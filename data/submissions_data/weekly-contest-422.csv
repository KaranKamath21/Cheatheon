username,userslug,contest_rank,question_id,language,code,submission_id
uwi,uwi,1,3627,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur] + 1, moveTime[nr][nc]+1);
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441290571
uwi,uwi,1,3628,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur], moveTime[nr][nc]) + (r+c)%2+1;
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441292405
uwi,uwi,1,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        long bal = 0;
        for(int i = 0;i < num.length();i++){
            bal = -bal + num.charAt(i) - '0';
        }
        return bal == 0;
    }
}",1441280931
uwi,uwi,1,3637,java,"	class Solution {
		public int countBalancedPermutations(String num) {
			int[] f = new int[10];
			int s = 0;
			for(char c : num.toCharArray()){
				f[c-'0']++;
				s += c-'0';
			}
			if(s % 2 != 0)return 0;
			final int mod = 1000000007;
			s /= 2;

			int n = num.length();
			long[][] dp = new long[n/2+1][s+1];
			int[][] fif = enumFIF(1000, mod);
			dp[0][0] = (long)fif[0][n/2] * fif[0][n-n/2] % mod;
			for(int i = 0;i <= 9;i++){
				long[][] ndp = new long[n/2+1][s+1];
				for(int j = n/2;j >= 0;j--){
					for(int k = s;k >= 0;k--){
						if(dp[j][k] == 0)continue;
						for(int t = 0;t <= f[i] && k+i*t <= s && j+t <= n/2;t++){
							ndp[j+t][k+i*t] += dp[j][k] * fif[1][t] % mod * fif[1][f[i]-t];
							ndp[j+t][k+i*t] %= mod;
						}
					}
				}
				dp = ndp;
			}
			return (int)dp[n/2][s];
		}

		public static int[][] enumFIF(int n, int mod) {
			int[] f = new int[n + 1];
			int[] invf = new int[n + 1];
			f[0] = 1;
			for (int i = 1; i <= n; i++) {
				f[i] = (int) ((long) f[i - 1] * i % mod);
			}
			long a = f[n];
			long b = mod;
			long p = 1, q = 0;
			while (b > 0) {
				long c = a / b;
				long d;
				d = a;
				a = b;
				b = d % b;
				d = p;
				p = q;
				q = d - c * q;
			}
			invf[n] = (int) (p < 0 ? p + mod : p);
			for (int i = n - 1; i >= 0; i--) {
				invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);
			}
			return new int[][]{f, invf};
		}

	}
",1441300564
green_pig,green_pig,2,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291673
green_pig,green_pig,2,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + k + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291255
green_pig,green_pig,2,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280737
green_pig,green_pig,2,3637,python3,"M = 10**9+7
F = [1] * 100
for i in range(1, len(F)):
    F[i] = F[i-1]*i%M
I = [pow(x, -1, M) for x in F]
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        a = [0] * 10
        for n in map(int, num):
            a[n] += 1
        s, t = len(num[::2]), len(num[1::2])
        @cache
        def f(i, d, m, n):
            if m > s or n > t: return 0
            if i == 10:
                return int(d == 0)
            r = 0
            for j in range(a[i]+1):
                k = a[i] - j
                r += I[j] * I[k] * f(i+1, d+i*(j-k), m+j, n+k) % M
            return r % M
        return F[s] * F[t] * f(0, 0, 0, 0) % M
",1441305429
Chris Ho,Chris_ho,3,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        pq = [(0, 0, 0)]
        
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            curr_time, row, col = heapq.heappop(pq)
            
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(moveTime[new_row][new_col] - curr_time, 0)
                    next_time = curr_time + 1 + wait_time
                    
                    if next_time < visited[new_row][new_col]:
                        visited[new_row][new_col] = next_time
                        heapq.heappush(pq, (next_time, new_row, new_col))
        
        return -1",1441299988
Chris Ho,Chris_ho,3,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        min_time = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        min_time[0][0][0] = 0
        heap = [(0, 0, 0, 0)]
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
        while heap:
            current_time, i, j, parity = heapq.heappop(heap)
            
            if current_time > min_time[i][j][parity]:
                continue
            
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < m:
                    move_duration = 1 if parity == 0 else 2
                    start_time = max(current_time, moveTime[ni][nj])
                    arrival_time = start_time + move_duration
                    new_parity = 1 - parity
                    if arrival_time < min_time[ni][nj][new_parity]:
                        min_time[ni][nj][new_parity] = arrival_time
                        heapq.heappush(heap, (arrival_time, ni, nj, new_parity))
                            
        return min(min_time[n - 1][m - 1][0], min_time[n - 1][m - 1][1])
",1441307226
Chris Ho,Chris_ho,3,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = sum(int(x) for x in num[0::2])
        y = sum(int(x) for x in num[1::2])
        return x==y
        
        ",1441280968
Chris Ho,Chris_ho,3,3637,python3,"MOD = 10**9 + 7
from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        cnt_d = [0] * 10
        total_sum = sum(map(int, num))
        for ch in num:
            cnt_d[int(ch)] += 1
        if total_sum % 2 != 0:
            return 0
        S = total_sum // 2
        NE = (N + 1) // 2
        NO = N // 2
        fac = [1] * (N + 1)
        for i in range(1, N + 1):
            fac[i] = fac[i - 1] * i % MOD
        inv_fac = [1] * (N + 1)
        inv_fac[N] = pow(fac[N], MOD - 2, MOD)
        for i in range(N, 0, -1):
            inv_fac[i - 1] = inv_fac[i] * i % MOD
        def C(n, k):
            if k < 0 or k > n:
                return 0
            return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD
        dp = defaultdict(int)
        dp[(0, 0)] = 1
        for d in range(10):
            cnt = cnt_d[d]
            if cnt == 0:
                continue
            dp_new = dp.copy()
            for (s1, c1), ways1 in dp.items():
                max_k = min(cnt, NE - c1)
                for k in range(1, max_k + 1):
                    s = s1 + k * d
                    c = c1 + k
                    ways = ways1 * C(cnt, k) % MOD
                    dp_new[(s, c)] = (dp_new.get((s, c), 0) + ways) % MOD
            dp = dp_new
        total_ways = 0
        for (s, c), ways in dp.items():
            if c == NE and s == S:
                total_ways = (total_ways + ways) % MOD
        total_permutations = total_ways * fac[NE] % MOD * fac[NO] % MOD
        for d in range(10):
            total_permutations = total_permutations * inv_fac[cnt_d[d]] % MOD
        return total_permutations
",1441302114
superfearless,superfearless,4,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        import heapq
        n, m = len(moveTime), len(moveTime[0])
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if t > dist[x][y]:
                continue
            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    t_move = max(t, moveTime[nx][ny])
                    t_neighbor = t_move + 1
                    if dist[nx][ny] > t_neighbor:
                        dist[nx][ny] = t_neighbor
                        heapq.heappush(heap, (t_neighbor, nx, ny))
        return dist[n-1][m-1]        ",1441288089
superfearless,superfearless,4,3628,python3,"class Solution:
	def minTimeToReach(S,moveTime):
		D=moveTime;E,F=len(D),len(D[0]);N=float('inf');A=[[[N]*2 for A in range(F)]for A in range(E)];G=[(0,0,0,0)];A[0][0][0]=0
		while G:
			K,L,M,H=heapq.heappop(G)
			if A[L][M][H]<K:continue
			for(O,P)in[(-1,0),(1,0),(0,-1),(0,1)]:
				B,C=L+O,M+P
				if 0<=B<E and 0<=C<F:
					Q=1 if H==0 else 2;R=max(K,D[B][C]);I=R+Q;J=(H+1)%2
					if I<A[B][C][J]:A[B][C][J]=I;heapq.heappush(G,(I,B,C,J))
		return min(A[E-1][F-1])      ",1441295837
superfearless,superfearless,4,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                even_sum += int(d)
            else:
                odd_sum += int(d)
        return even_sum == odd_sum       ",1441287048
superfearless,superfearless,4,3637,python3,"class Solution:
	def countBalancedPermutations(c,num):
		A=10**9+7;from math import comb;from collections import defaultdict as S;I=[0]*10;J=0;C=len(num);B=C//2;V=C-B
		for W in num:D=int(W);I[D]+=1;J+=D
		if J%2!=0:return 0
		X=J//2;Y=B*9;G=[S(int)for A in range(B+1)];G[0][0]=1;F=[1]*(C+1);K=[1]*(C+1)
		for E in range(1,C+1):F[E]=F[E-1]*E%A
		K[C]=pow(F[C],A-2,A)
		for E in range(C-1,-1,-1):K[E]=K[E+1]*(E+1)%A
		for D in range(10):
			L=I[D]
			if L==0:continue
			M=[S(int)for A in range(B+1)]
			for H in range(B+1):
				for T in G[H]:
					Z=G[H][T]
					for N in range(0,min(L,B-H)+1):
						O=H+N;P=T+N*D
						if O<=B and P<=Y:a=comb(L,N);M[O][P]=(M[O][P]+Z*a)%A
			G=M
		U=G[B].get(X,0)
		if U==0:return 0
		b=F[V]*F[B]%A;Q=1
		for D in range(10):Q=Q*F[I[D]]%A
		R=U*b%A;R=R*pow(Q,A-2,A)%A;return R        ",1441292392
LayCurse,LayCurse,5,3627,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441295459
LayCurse,LayCurse,5,3628,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1 + t;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1 + t;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441294873
LayCurse,LayCurse,5,3636,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  bool isBalanced(string A){
    int i;
    int N = A.size();
    int res = 0;
    for(i=(0);i<(N);i+=(2)){
      res += A[i] - '0';
    }
    for(i=(1);i<(N);i+=(2)){
      res -= A[i] - '0';
    }
    return res == 0;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   bool isBalanced(string A) {
//     int N = A.size(), res = 0;
//     rep(i,0,N,2) res += A[i] - '0';
//     rep(i,1,N,2) res -= A[i] - '0';
//     return res == 0;
//   }
// };
",1441281284
LayCurse,LayCurse,5,3637,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
template<class T> struct Comb{
  int mem_fact;
  T*factri;
  T*ifactri;
  int mem_dfact;
  T*dfactri;
  int mem_pw2;
  int mem_pw3;
  int mem_pw10;
  int mem_rep1;
  T*pw2c;
  T*pw3c;
  T*pw10c;
  T*rep1c;
  int mem_ipw2;
  int mem_ipw3;
  int mem_ipw10;
  T*ipw2c;
  T*ipw3c;
  T*ipw10c;
  Comb(){
    mem_fact = 0;
    mem_dfact = 0;
    mem_pw2 = mem_pw3 = mem_pw10 = mem_rep1 = 0;
    mem_ipw2 = mem_ipw3 = mem_ipw10 = 0;
  }
  inline void expand_fact(int k){
    int i;
    if(k <= mem_fact){
      return;
    }
    chmax(k, 2 * mem_fact);
    if(mem_fact == 0){
      factri = (T*)malloc(k * sizeof(T));
      ifactri = (T*)malloc(k * sizeof(T));
      factri[0] = 1;
      for(i=(1);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(0);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    else{
      factri = (T*)realloc(factri, k * sizeof(T));
      ifactri = (T*)realloc(ifactri, k * sizeof(T));
      for(i=(mem_fact);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(mem_fact);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    mem_fact = k;
  }
  inline T fac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return factri[k];
  }
  inline T ifac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return ifactri[k];
  }
  inline T C(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[b] * ifactri[a-b];
  }
  inline T P(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[a-b];
  }
  inline T H(int a, int b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    if(mem_fact < a+b){
      expand_fact(a+b);
    }
    return C(a+b-1, b);
  }
  inline T Multinomial(int sz, int a[]){
    int i;
    int s = 0;
    T res;
    for(i=(0);i<(sz);i++){
      s += a[i];
    }
    if(mem_fact < s+1){
      expand_fact(s+1);
    }
    res = factri[s];
    for(i=(0);i<(sz);i++){
      res *= ifactri[a[i]];
    }
    return res;
  }
  inline T Multinomial(int a){
    return 1;
  }
  inline T Multinomial(int a, int b){
    if(mem_fact < a+b+1){
      expand_fact(a+b+1);
    }
    return factri[a+b] * ifactri[a] * ifactri[b];
  }
  inline T Multinomial(int a, int b, int c){
    if(mem_fact < a+b+c+1){
      expand_fact(a+b+c+1);
    }
    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];
  }
  inline T Multinomial(int a, int b, int c, int d){
    if(mem_fact < a+b+c+d+1){
      expand_fact(a+b+c+d+1);
    }
    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];
  }
  inline T Catalan(int n){
    if(n < 0){
      return 0;
    }
    if(mem_fact < 2*n+1){
      expand_fact(2*n+1);
    }
    return factri[2*n] * ifactri[n] * ifactri[n+1];
  }
  inline T Catalan(int n, int m, int k){
    if(k <= 0){
      return C(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C(n+m, m) - C(n+m, k-1);
  }
  inline T Catalan_s(long long n, long long m, long long k){
    if(k <= 0){
      return C_s(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C_s(n+m, m) - C_s(n+m, k-1);
  }
  inline T C_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    if(b > a - b){
      b = a - b;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
      res /= i + 1;
    }
    return res;
  }
  inline T P_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
    }
    return res;
  }
  inline T H_s(long long a, long long b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    return C_s(a+b-1, b);
  }
  inline T per_s(long long n, long long k){
    T d;
    int m;
    if(n < 0 || k < 0){
      return 0;
    }
    if(n == k  &&  k == 0){
      return 1;
    }
    if(n == 0 || k == 0){
      return 0;
    }
    if(k==1){
      return 1;
    }
    if(k==2){
      d = n / 2;
      return d;
    }
    if(k==3){
      d = (n-1) / 6;
      m = (n-1) % 6;
      if(m==0){
        return 3 * d * d + d;
      }
      if(m==1){
        return 3 * d * d + 2 * d;
      }
      if(m==2){
        return 3 * d * d + 3 * d + 1;
      }
      if(m==3){
        return 3 * d * d + 4 * d + 1;
      }
      if(m==4){
        return 3 * d * d + 5 * d + 2;
      }
      if(m==5){
        return 3 * d * d + 6 * d + 3;
      }
    }
    assert(0 && ""per_s should be k <= 3"");
    return -1;
  }
  inline void expand_dfact(int k){
    int i;
    if(k <= mem_dfact){
      return;
    }
    chmax(k, 3);
    chmax(k, 2 * mem_dfact);
    if(mem_dfact==0){
      dfactri = (T*)malloc(k * sizeof(T));
      dfactri[0] = dfactri[1] = 1;
      for(i=(2);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    else{
      dfactri = (T*)realloc(dfactri, k * sizeof(T));
      for(i=(mem_dfact);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    mem_dfact = k;
  }
  inline void expand_pw2(int k){
    int i;
    if(k <= mem_pw2){
      return;
    }
    chmax(k, 2 * mem_pw2);
    if(mem_pw2==0){
      pw2c = (T*)malloc(k * sizeof(T));
      pw2c[0] = 1;
      for(i=(1);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    else{
      pw2c = (T*)realloc(pw2c, k * sizeof(T));
      for(i=(mem_pw2);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    mem_pw2 = k;
  }
  inline void expand_ipw2(int k){
    int i;
    if(k <= mem_ipw2){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw2);
    if(mem_ipw2==0){
      ipw2c = (T*)malloc(k * sizeof(T));
      ipw2c[0] = 1;
      ipw2c[1] = ipw2c[0] / 2;
      for(i=(1);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    else{
      ipw2c = (T*)realloc(ipw2c, k * sizeof(T));
      for(i=(mem_ipw2);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    mem_ipw2 = k;
  }
  inline void expand_pw3(int k){
    int i;
    if(k <= mem_pw3){
      return;
    }
    chmax(k, 2 * mem_pw3);
    if(mem_pw3==0){
      pw3c = (T*)malloc(k * sizeof(T));
      pw3c[0] = 1;
      for(i=(1);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    else{
      pw3c = (T*)realloc(pw3c, k * sizeof(T));
      for(i=(mem_pw3);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    mem_pw3 = k;
  }
  inline void expand_ipw3(int k){
    int i;
    if(k <= mem_ipw3){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw3);
    if(mem_ipw3==0){
      ipw3c = (T*)malloc(k * sizeof(T));
      ipw3c[0] = 1;
      ipw3c[1] = ipw3c[0] / 3;
      for(i=(1);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    else{
      ipw3c = (T*)realloc(ipw3c, k * sizeof(T));
      for(i=(mem_ipw3);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    mem_ipw3 = k;
  }
  inline void expand_pw10(int k){
    int i;
    if(k <= mem_pw10){
      return;
    }
    chmax(k, 2 * mem_pw10);
    if(mem_pw10==0){
      pw10c = (T*)malloc(k * sizeof(T));
      pw10c[0] = 1;
      for(i=(1);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    else{
      pw10c = (T*)realloc(pw10c, k * sizeof(T));
      for(i=(mem_pw10);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    mem_pw10 = k;
  }
  inline void expand_ipw10(int k){
    int i;
    if(k <= mem_ipw10){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw10);
    if(mem_ipw10==0){
      ipw10c = (T*)malloc(k * sizeof(T));
      ipw10c[0] = 1;
      ipw10c[1] = ipw10c[0] / 10;
      for(i=(1);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    else{
      ipw10c = (T*)realloc(ipw10c, k * sizeof(T));
      for(i=(mem_ipw10);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    mem_ipw10 = k;
  }
  inline void expand_rep1(int k){
    int i;
    if(k <= mem_rep1){
      return;
    }
    chmax(k, 2 * mem_rep1);
    if(mem_rep1==0){
      rep1c = (T*)malloc(k * sizeof(T));
      rep1c[0] = 0;
      for(i=(1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    else{
      rep1c = (T*)realloc(rep1c, k * sizeof(T));
      for(i=(mem_rep1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    mem_rep1 = k;
  }
  inline T dfac(int k){
    if(k >= 0){
      if(mem_dfact < k+1){
        expand_dfact(k+1);
      }
      return dfactri[k];
    }
    if(k==-1){
      return 1;
    }
    k = - k - 2;
    if(k % 4 == 1){
      return 1 / (-dfac(k));
    }
    return 1 / dfac(k);
  }
  inline T pw2(int k){
    if(k >= 0){
      if(mem_pw2 < k+1){
        expand_pw2(k+1);
      }
      return pw2c[k];
    }
    else{
      k = -k;
      if(mem_ipw2 < k+1){
        expand_ipw2(k+1);
      }
      return ipw2c[k];
    }
  }
  inline T pw3(int k){
    if(k >= 0){
      if(mem_pw3 < k+1){
        expand_pw3(k+1);
      }
      return pw3c[k];
    }
    else{
      k = -k;
      if(mem_ipw3 < k+1){
        expand_ipw3(k+1);
      }
      return ipw3c[k];
    }
  }
  inline T pw10(int k){
    if(k >= 0){
      if(mem_pw10 < k+1){
        expand_pw10(k+1);
      }
      return pw10c[k];
    }
    else{
      k = -k;
      if(mem_ipw10 < k+1){
        expand_ipw10(k+1);
      }
      return ipw10c[k];
    }
  }
  inline T repunit(int k){
    if(mem_rep1 < k+1){
      expand_rep1(k+1);
    }
    return rep1c[k];
  }
}
;
template<> inline Modint Comb<Modint>::C_s(long long a, long long b){
  long long i;
  Modint res;
  Modint d;
  if(b < 0 || b > a){
    return 0;
  }
  if(b > a - b){
    b = a - b;
  }
  res = d = 1;
  for(i=(0);i<(b);i++){
    res *= a - i;
    d *= i + 1;
  }
  return res / d;
}
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
Modint dp[50][2000];
Modint nx[50][2000];
Comb<Modint> comb;
class Solution{
  public:
  int countBalancedPermutations(string A){
    int i, k;
    int N = A.size();
    int x;
    int y;
    int mx;
    int g;
    int c;
    int u;
    int xx;
    int yy;
    x = N / 2;
    y = N - x;
    u = 0;
    g =max_L(x, y)* 9 + 4;
    mx = g * 2 + 1;
    int h[10] = {};
    for(i=(0);i<(N);i++){
      h[A[i]-'0']++;
    }
    for(i=(0);i<(x+1);i++){
      int j;
      for(j=(0);j<(mx);j++){
        dp[i][j] = 0;
      }
    }
    dp[x][g] = 1;
    for(k=(0);k<(10);k++){
      if(h[k]){
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            nx[i][j] = 0;
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            if(dp[i][j]){
              int m;
              for(m=(0);m<(h[k]+1);m++){
                xx = i;
                yy = N - u - i;
                if(xx < m || yy < h[k]-m){
                  continue;
                }
                nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
              }
            }
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            dp[i][j] = nx[i][j];
          }
        }
        u += h[k];
      }
    }
    return dp[0][g];
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// Modint dp[50][2000], nx[50][2000];
// Comb<Modint> comb;
// 
// class Solution {
// public:
//   int countBalancedPermutations(string A) {
//     int N = A.size();
//     int x, y, mx, g, c, u, xx, yy;
//     x = N / 2;
//     y = N - x;
//     u = 0;
//     g = max(x,y) * 9 + 4;
//     mx = g * 2 + 1;
// 
//     int h[10] = {};
//     rep(i,N) h[A[i]-'0']++;
// 
//     rep(i,x+1) rep(j,mx) dp[i][j] = 0;
//     dp[x][g] = 1;
// 
//     rep(k,10) if(h[k]){
//       rep(i,x+1) rep(j,mx) nx[i][j] = 0;
// 
//       rep(i,x+1) rep(j,mx) if(dp[i][j]) rep(m,h[k]+1){
//         xx = i;
//         yy = N - u - i;
//         if(xx < m || yy < h[k]-m) continue;
//         nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
//       }
// 
//       rep(i,x+1) rep(j,mx) dp[i][j] = nx[i][j];
//       u += h[k];
//     }
// 
//     return dp[0][g];
//   }
// };
",1441310437
Yiming Li,lympanda,7,3627,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295795
Yiming Li,lympanda,7,3628,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+z+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295250
Yiming Li,lympanda,7,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1,sum2,i;
        sum1=0;sum2=0;
        for (i=0;i<num.length();i++)
            {
                if (i%2==0) sum1+=num[i]-'0';
                else sum2+=num[i]-'0';
            }
        if (sum1==sum2) return true;
        else return false;
    }
};",1441281135
Yiming Li,lympanda,7,3637,cpp,"#define _int64 long long
#define mo 1000000007

int inited=0;

#define faclim 310000

_int64 fac[faclim];
_int64 invfac[faclim];

_int64 pow1(int x,int y)
{
	int i;
	_int64 ret;
	ret=1;
	for (i=30;i>=0;i--)
	{
		ret=ret*ret%mo;
		if (((1<<i)&y)!=0) ret=ret*x%mo;
	}
	return ret;
}
_int64 inv(int x)
{
	return pow1(x,mo-2);
}
_int64 c(int x,int y)
{
	return fac[x]*invfac[y]%mo*invfac[x-y]%mo;
}
void init()
{
	int i;
	fac[0]=1;
	for (i=1;i<faclim;i++)
		fac[i]=fac[i-1]*i%mo;
	invfac[faclim-1]=inv(fac[faclim-1]);
	for (i=faclim-1;i>0;i--)
		invfac[i-1]=invfac[i]*i%mo;
}

_int64 d[2][2100][50];

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (inited==0)
        {
            init();
            inited=1;
        }
        int cnt[10];
        int i,j,k,o,rem,nn,now,n1,n2;
        memset(cnt,0,sizeof(cnt));
        for (i=0;i<num.length();i++)
            cnt[num[i]-'0']++;
        memset(d[0],0,sizeof(d[0]));
        nn=(num.length()+1)/2;
        d[0][1000][nn]=1;
        rem=num.length();
        now=0;
        for (i=0;i<10;i++) {
            memset(d[1-now],0,sizeof(d[1-now]));
            for (j=0;j<2100;j++)
                for (k=0;k<=nn;k++) {
                    if (d[now][j][k]==0) continue;
                    //cout<<""i,j,k:""<<i<<"" ""<<j<<"" ""<<k<<"" ""<<d[now][j][k]<<endl;
                    n1=k;n2=rem-k;
                    for (o=0;o<=cnt[i];o++) {
                        if (o>n1) continue;
                        if (cnt[i]-o>n2) continue;
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]+=d[now][j][k]*c(n1,o)%mo*c(n2,cnt[i]-o);
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]%=mo;
                    }
                }
            rem-=cnt[i];
            now=1-now;
        }
        return d[now][1000][0];
    }
};",1441310647
Rakesh_Reddy7,Naruto_x,8,3627,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0: return -1
        m = len(moveTime[0])
        if m == 0: return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[float('inf')] * m for i in range(n)]
        t2[0][0] = 0
        pq = [(0, 0, 0)] 
        while pq:
            curt, x, y = heapq.heappop(pq)
            
            if x == n - 1 and y == m - 1:
                return int(curt)
            
            if curt > t2[x][y]:
                continue
            
            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    at = max(curt, moveTime[nx][ny]) + 1

                    if at < t2[nx][ny]:
                        t2[nx][ny] = at
                        heapq.heappush(pq, (at, nx, ny))
        
        return -1
",1441309684
Rakesh_Reddy7,Naruto_x,8,3628,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0:
            return -1
        m = len(moveTime[0])
        if m == 0:
            return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[[float('inf')] * 2 for i in range(m)] for j in range(n)]
        t2[0][0][0] = 0
        pq = [(0, 0, 0, 0)]  

        while pq:
            curt, x, y, z = heapq.heappop(pq)

            if x == n - 1 and y == m - 1:
                return int(curt)

            if curt > t2[x][y][z]:
                continue

            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    m1 = 1 if z == 0 else 2
                    t1 = max(curt, moveTime[nx][ny]) + m1
                    pp = 1 - z

                    if t1 < t2[nx][ny][pp]:
                        t2[nx][ny][pp] = t1
                        heapq.heappush(pq, (t1, nx, ny, pp))

        return -1
",1441310581
Rakesh_Reddy7,Naruto_x,8,3636,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        
        for i in range(len(num)):
            k = int(num[i])
            
            if i % 2 == 0:
                evens += k
            else:
                odds += k
                
        return evens == odds
",1441311289
Rakesh_Reddy7,Naruto_x,8,3637,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

mod = 10**9 + 7

def pow_mod(a, b):
    res = 1
    a %= mod
    while b > 0:
        if b & 1:
            res = res * a % mod
        a = a * a % mod
        b >>= 1
    return res

class Factorials:
    def __init__(self, n):
        self.fact = [1] * (n + 1)
        for i in range(1, n + 1):
            self.fact[i] = self.fact[i - 1] * i % mod
        self.invf = [1] * (n + 1)
        self.invf[n] = pow_mod(self.fact[n], mod - 2)
        for i in range(n - 1, -1, -1):
            self.invf[i] = self.invf[i + 1] * (i + 1) % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        tot = 0
        for ch in num:
            freq[int(ch)] += 1
            tot += int(ch)

        if tot % 2 != 0:
            return 0

        tsum = tot // 2
        k = (n + 1) // 2
        l = n // 2
        factorial = Factorials(n)
        fact = factorial.fact
        invf = factorial.invf

        dp = [[0] * (k + 1) for i in range(tsum + 1)]
        dp[0][0] = 1

        for d in range(10):
            if freq[d] == 0:
                continue
            for s in range(tsum, -1, -1):
                for c in range(k, -1, -1):
                    if dp[s][c] == 0:
                        continue
                    for t in range(1, freq[d] + 1):
                        if s + t * d > tsum or c + t > k:
                            break
                        dp[s + t * d][c + t] = (dp[s + t * d][c + t] + dp[s][c] * ((fact[freq[d]] * invf[t] % mod) * invf[freq[d] - t] % mod)) % mod

        validx = dp[tsum][k]
        if validx == 0:
            return 0

        ifreq = 1
        for d in range(10):
            if freq[d] > 0:
                ifreq = ifreq * invf[freq[d]] % mod

        ans = validx * fact[k] % mod
        ans = ans * fact[l] % mod
        ans = ans * ifreq % mod

        return ans
",1441308446
arignote,arignote,10,3627,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[3]);;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + 1, poll[1] - 1, poll[2] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + 1, poll[1], poll[2] - 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + 1, poll[1], poll[2] + 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + 1, poll[1] + 1, poll[2] });
            }
        }
    }
}",1441307297
arignote,arignote,10,3628,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[] { 0, 0, 0, 1 });;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + poll[3], poll[1] - 1, poll[2], 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + poll[3], poll[1], poll[2] - 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + poll[3], poll[1], poll[2] + 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + poll[3], poll[1] + 1, poll[2], 3 - poll[3] });
            }
        }
    }
}",1441307185
arignote,arignote,10,3636,java,"class Solution {

    public boolean isBalanced(String num) {
        int sum = 0;
        for (int i = 0; i < num.length(); i++) {
            sum += (i % 2 > 0 ? 1 : -1) * (num.charAt(i) - '0');
        }
        return sum == 0;
    }
}",1441307472
arignote,arignote,10,3637,java,"class Solution {

    public int countBalancedPermutations(String num) {
        int count[] = new int[10], sum = 0, f[][] = new int[num.length() + 1][num.length() + 1], dp[][][] = new int[11][num.length() / 2 + 1][361];
        for (char c : num.toCharArray()) {
            count[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 0) {
            for (int i = 0; i <= num.length(); i++) {
                for (int j = f[i][0] = f[i][i] = dp[0][0][0] = 1; j < i; j++) {
                    f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % 1000000007;
                }
            }
            for (int i = 0, s = 0, t = 0; i < 10; s += i * count[i], t += count[i++]) {
                for (int j = 0; j <= t && j <= num.length() / 2; j++) {
                    for (int k = 0; k <= s && k <= sum / 2; k++) {
                        for (int l = 0; dp[i][j][k] > 0 && l <= count[i] && l + j <= num.length() / 2 && l * i + k <= sum / 2; l++) {
                            dp[i + 1][j + l][l * i + k] = (int) ((dp[i + 1][j + l][l * i + k] + (long) dp[i][j][k] * f[num.length() / 2 - j][l] % 1000000007 * f[num.length() - num.length() / 2 - t + j][count[i] - l] % 1000000007) % 1000000007);
                        }
                    }
                }
            }
        }
        return dp[10][num.length() / 2][sum / 2];
    }
}",1441307111
Nguyen Quang Long,mbfibat,11,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 1), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441295120
Nguyen Quang Long,mbfibat,11,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 3 - t), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441294784
Nguyen Quang Long,mbfibat,11,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum_0 = 0, sum_1 = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = (num[i] - '0');
            if (i % 2) sum_1 += d;
            else sum_0 += d;
        }
        return (sum_0 == sum_1);
    }
};",1441280868
Nguyen Quang Long,mbfibat,11,3637,cpp,"const int mod = 1e9 + 7;

int fact[101], re_fact[101];

int qp(int a, int b) {
    if (b == 0) return 1;
    int tmp = qp(a, b / 2);
    if (b % 2 == 0) return 1LL * tmp * tmp % mod;
    return 1LL * a * tmp % mod * tmp % mod;
}

int f[11][81][721];
bool g[11][81][721];

class Solution {
private:
    int tot_cnt = 0;
    int occ[10];
    int tot_sum = 0;
    int sz1 = 0, sz2 = 0;
public:
    int dp(int pos, int cnt1, int sum1) {
        if (pos >= 10) {
            int sum2 = tot_sum - sum1;            
            int cnt2 = tot_cnt - cnt1;
            if (cnt1 == sz1 && cnt2 == sz2 && sum1 == sum2)
                return 1LL * fact[cnt1] * fact[cnt2] % mod;
            return 0;
        }

        if (g[pos][cnt1][sum1])
            return f[pos][cnt1][sum1];

        int ans = 0;
        for (int i = 0; i <= occ[pos]; i++) {
            int val = 1LL * dp(pos + 1, cnt1 + i, sum1 + pos * i) * re_fact[i] % mod * re_fact[occ[pos] - i] % mod;
            ans = (ans + val) % mod;
        }
        g[pos][cnt1][sum1] = true;
        return f[pos][cnt1][sum1] = ans;
    }

    int countBalancedPermutations(string num) {
        fact[0] = 1;
        for (int i = 1; i <= 100; i++)
            fact[i] = 1LL * fact[i - 1] * i % mod;
        re_fact[100] = qp(fact[100], mod - 2);
        for (int i = 100; i >= 1; i--)
            re_fact[i - 1] = 1LL * re_fact[i] * i % mod;

        for (int i = 0; i <= 9; i++) occ[i] = 0;
        
        for (char c : num) {
            occ[c - '0']++;
            tot_sum += (c - '0');
        }
        tot_cnt = num.size();
        sz1 = (tot_cnt + 1) / 2;
        sz2 = tot_cnt /2;
        
        for (int i = 0; i <= 9; i++)
            for (int j = 0; j <= tot_cnt; j++)
                for (int l = 0; l <= tot_sum; l++)
                    g[i][j][l] = false;
        return dp(0, 0, 0);
    }
};",1441314636
BERNARD BRAHIMCHA,BERNARB01,12,3627,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441315189
BERNARD BRAHIMCHA,BERNARB01,12,3628,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p ^ 1;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441314619
BERNARD BRAHIMCHA,BERNARB01,12,3636,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  bool isBalanced(string s) {
    int n = int(s.length());
    int se = 0, so = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        so += int(s[i] - '0');
      } else {
        se += int(s[i] - '0');
      }
    }
    return (se == so);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441307439
BERNARD BRAHIMCHA,BERNARB01,12,3637,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int N = 102;
const int md = int(1e9) + 7;

int iv[N], f1[N], f2[N], p2[N], ip2[N];

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

inline int C(int n, int k) {
  if (k < 0 || n < k) return 0;
  return mul(f1[n], mul(f2[k], f2[n - k]));
}

inline int nck(int n, int k) {
  int r = 1;
  for (int i = 1; i <= k; i++) {
    r = mul(r, mul(n - i + 1, inv(i)));
  }
  return r;
}

void bldmd() {
  iv[1] = 1;
  for (int i = 2; i < N; i++) {
    iv[i] = md - mul(md / i, iv[md % i]);
  }
  f1[0] = f2[0] = p2[0] = ip2[0] = 1;
  for (int i = 1; i < N; i++) {
    f1[i] = mul(f1[i - 1], i);
    f2[i] = mul(f2[i - 1], iv[i]);
    p2[i] = (p2[i - 1] << 1);
    if (p2[i] >= md) p2[i] -= md;
    ip2[i] = mul(ip2[i - 1], iv[2]);
  }
}

int ne, f;
int sum;
int cnt[10];
int dp[10][402][41];

int sol(int i, int j, int k) {
  if (i == 10) {
    if (j != sum || k != ne) {
      return 0;
    }
    return f;
  }
  int& ret = dp[i][j][k];
  if (ret != -1) {
    return ret;
  }
  ret = 0;
  for (int u = 0; u <= cnt[i]; u++) {
    if (j + u * i <= sum && k + u <= ne) {
      add(ret, mul(mul(f2[u], f2[cnt[i] - u]), sol(i + 1, j + u * i, k + u)));
    }
  }
  return ret;
}

class Solution {
 public:
  int countBalancedPermutations(string s) {
    bldmd();
    for (int i = 0; i < 10; i++) {
      cnt[i] = 0;
    }
    int n = int(s.length());
    sum = 0;
    for (char c : s) {
      sum += int(c - '0');
      ++cnt[int(c - '0')];
    }
    if (sum & 1) {
      return 0;
    }
    sum /= 2;
    ne = n / 2;
    int no = n - ne;
    f = mul(f1[ne], f1[no]);
    memset(dp, -1, sizeof dp);
    return sol(0, 0, 0);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441305879
LucasLyu,Lucas595,13,3627,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0) ]
    
        while heap:
            t, x, y = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 1
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny))
    
        return -1
        
        ",1441291623
LucasLyu,Lucas595,13,3628,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0, 1) ]
    
        while heap:
            t, x, y, odd = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 2 - odd
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny, 1 - odd))
    
        return -1
        
        ",1441307713
LucasLyu,Lucas595,13,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        diff = 0
        for i, k in enumerate(num):
            if i & 1:
                diff += int(k)
            else:
                diff -= int(k)
        return not diff
        ",1441282133
LucasLyu,Lucas595,13,3637,python3,"from math import comb
from collections import defaultdict


MOD = int(1e9 + 7)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        counts = [0] * 10
        N = len(num)
        for ch in num:
            counts[int(ch)] += 1

        total_sum = sum(d * counts[d] for d in range(10))
        if total_sum & 1:
            return 0

        target_sum = total_sum // 2
        N_even = (N + 1) // 2
        N_odd = N // 2

        max_N = N + 1
        factorials = [1] * max_N
        inv_factorials = [1] * max_N
        for i in range(1, max_N):
            factorials[i] = factorials[i - 1] * i % MOD

        inv_factorials[-1] = pow(factorials[-1], MOD - 2, MOD)
        for i in range(max_N - 2, -1, -1):
            inv_factorials[i] = inv_factorials[i + 1] * (i + 1) % MOD

        total_counts_fact = 1
        for c in counts:
            total_counts_fact = total_counts_fact * factorials[c] % MOD

        memo = {}

        def dp(d, s, c):
            key = (d, s, c)
            if key in memo:
                return memo[key]
            if s > target_sum or c > N_even:
                return 0
            if d == 10:
                if s == target_sum and c == N_even:
                    return 1
                else:
                    return 0
            res = 0
            for k in range(counts[d] + 1):
                s_new = s + k * d
                c_new = c + k
                if s_new > target_sum or c_new > N_even:
                    break
                ways = comb(counts[d], k)
                res = (res + dp(d + 1, s_new, c_new) * ways) % MOD
            memo[key] = res
            return res

        total_ways = dp(0, 0, 0) * factorials[N_even] % MOD
        total_ways = total_ways * factorials[N_odd] % MOD
        total_ways = total_ways * pow(total_counts_fact, MOD - 2, MOD) % MOD
        return total_ways
        ",1441315468
Ma Lin,Ma_Lin,14,3627,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f;
    int m, n, res, MAX = 2000000000;
    bool done[100][100];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d;
        set<pair<int, pair<int, int>>> S;
        f = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[i][j] = MAX;
                done[i][j] = false;
            }
                
        f[0][0] = 0;
        S.insert({0, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[i][j] || f[i][j] == MAX) continue;
            if (f[i][j] != d) continue;
            done[i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[nx][ny]){
                    v = max(a[nx][ny] + 1, f[i][j] + 1);
                    if (v < f[nx][ny]){
                        f[nx][ny] = v;
                        S.insert({v, {nx, ny}});
                    }
                }
            }
        }

        return f[m - 1][n - 1];
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441293809
Ma Lin,Ma_Lin,14,3628,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f[2];
    int m, n, res, MAX = 2000000000;
    bool done[2][800][800];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d, q;
        set<pair<pair<int, int>, pair<int, int> > > S;
        f[0] = a;
        f[1] = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[0][i][j] = f[1][i][j] = MAX;
                done[0][i][j] = done[1][i][j] = false;
            }
                
        f[0][0][0] = 0;
        S.insert({{0, 0}, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first.first;
            q = S.begin()->first.second;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[q][i][j] || f[q][i][j] == MAX) continue;
            if (f[q][i][j] != d) continue;
            done[q][i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[1 - q][nx][ny]){
                    v = max(a[nx][ny] + (q + 1), f[q][i][j] + (q + 1));
                    if (v < f[1 - q][nx][ny]){
                        f[1 - q][nx][ny] = v;
                        S.insert({{v, 1 - q}, {nx, ny}});
                    }
                }
            }
        }

        return min(f[0][m - 1][n - 1], f[1][m - 1][n - 1]);
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441299307
Ma Lin,Ma_Lin,14,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int x = 0, i;
        for (i = 0; i < s.size(); ++i)
            if (i % 2 == 0) x += s[i] - '0';
            else x -= s[i] - '0';
        
        return x == 0;
    }
};",1441280955
Ma Lin,Ma_Lin,14,3637,cpp,"class Solution {
public:
    int f[2][90][1600];
    int countBalancedPermutations(string s) {
        int mo = 1000000007;
        int C[100][100], n = s.size(), i, j, k, mid, yj, p[2], ge[10], old, now = 0, d, t, nk;
        C[0][0] = 1;
        for (i = 1; i <= n; ++i){
            C[i][0] = C[i][i] = 1;
            for (j = 1; j < i; ++j)
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mo;
        }
        
        p[0] = p[1] = 0;
        for (i = 0; i < 10; ++i) ge[i] = 0;
        for (i = 0; i < n; ++i){
            ++p[i % 2];
            ++ge[s[i] - '0'];
        }
        
        mid = n * 9;
        for (j = 0; j <= p[0]; ++j)
            for (k = 0; k <= mid + mid; ++k)
                f[now][j][k] = 0;
        f[now][0][mid] = 1;
        yj = 0;
        for (i = 0; i < 10; ++i){
            old = now;
            now = 1 - now;
            for (j = 0; j <= p[0]; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    f[now][j][k] = 0;
            for (j = 0; j <= p[0] && j <= yj; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    if (f[old][j][k] > 0){
                        for (d = 0; d <= ge[i]; ++d)
                            if (j + d <= p[0] && yj - j + (ge[i] - d) <= p[1]){
                                t = (1LL * C[p[0] - j][d] * C[p[1] - (yj - j)][ge[i] - d]) % mo;
                                t = (1LL * t * f[old][j][k]) % mo;
                                nk = k + d * i - (ge[i] - d) * i;
                                f[now][j + d][nk] = (f[now][j + d][nk] + t) % mo;
                            }
                    }
            yj += ge[i];
        }
        
        return f[now][p[0]][mid];
    }
};",1441316423
plevande,plevande,15,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time = [[float('inf') for j in range(m)] for i in range(n)]
        true_time[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0])
        while len(H) > 0:
            t, x, y = heapq.heappop(H)
            if true_time[x][y]==t:
                for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                    if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                        t2 = max(t+1, moveTime[x2][y2]+1)
                        if t2 < true_time[x2][y2]:
                            true_time[x2][y2] = t2 
                            heapq.heappush(H, [t2, x2, y2])
        return true_time[n-1][m-1]",1441290714
plevande,plevande,15,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time1 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0, 2])
        while len(H) > 0:
            t, x, y, my_case = heapq.heappop(H)
            if my_case==1:
                if true_time1[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+2, moveTime[x2][y2]+2)
                            if t2 < true_time2[x2][y2]:
                                true_time2[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 2])
            else:
                if true_time2[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+1, moveTime[x2][y2]+1)
                            if t2 < true_time1[x2][y2]:
                                true_time1[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 1])
        return min(true_time1[n-1][m-1], true_time2[n-1][m-1])",1441296393
plevande,plevande,15,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a1 = 0 
        a2 = 0 
        n = len(num)
        for i in range(n):
            if i % 2==0:
                a1+=int(num[i])
            else:
                a2+=int(num[i])
        return a1==a2",1441281094
plevande,plevande,15,3637,python3,"p = 10**9+7
binom = [[1], [1, 1]]
for i in range(81):
    row = binom[-1]
    new_row = [1]
    for j in range(len(row)-1):
        new_row.append((row[j]+row[j+1]) % p)
    new_row.append(1)
    binom.append(new_row)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int, num))
        if s % 2==1:
            return 0
        my_count = [0 for i in range(10)]
        for x in num:
            my_count[int(x)]+=1
        target = s//2
        poss = {(0, n//2, n-n//2): 1}
        for i in range(10):
            new_poss = {}
            c = my_count[i]
            for a, b, b2 in poss:
                for x in range(c+1):
                    if b2-(c-x) >=0 and b-x >= 0 and a+x*i <= target:
                        new_a = a+x*i
                        new_b = b-x
                        new_b2 = b2-(c-x)
                        new_ways = (poss[(a, b, b2)]*binom[b][x]*binom[b2][c-x]) % p
                        if (new_a, new_b, new_b2) not in new_poss:
                            new_poss[(new_a, new_b, new_b2)] = 0
                        new_poss[(new_a, new_b, new_b2)]+=new_ways 
                        new_poss[(new_a, new_b, new_b2)]%=p 
            poss = new_poss
        if (target, 0, 0) not in poss:
            return 0
        return poss[(target, 0, 0)]
        """"""
        how many ways are there
        to get target in n
        """"""",1441310112
BarryBondsOfLC,BarryBondsOfLC,19,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310608
BarryBondsOfLC,BarryBondsOfLC,19,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt == 1 ? 2 : 1});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310295
BarryBondsOfLC,BarryBondsOfLC,19,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for (int i = 0; i < num.size(); ++i) {
            (i % 2 ? o : e) += num[i] - '0';
        }
        return e == o;
    }
};",1441305906
BarryBondsOfLC,BarryBondsOfLC,19,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int MOD = 1e9 + 7;

ll mul(ll a, ll b) { return a * b % MOD; }

ll power(ll base, ll exp = MOD - 2) {
    ll res = 1, y = base;
    while (exp) {
        if (exp & 1)
            res = mul(res, y);
        y = mul(y, y);
        exp >>= 1;
    }
    return res;
}

struct Math {
    vector<ll> fact, inv;

    Math(int n = 1) {
        fact.resize(n + 1);
        inv.resize(n + 1);
        fact[0] = inv[0] = 1;
        for (int i = 1; i <= n; i++)
            fact[i] = mul(fact[i - 1], i);
        inv[n] = power(fact[n]);
        for (int i = n; i > 1; i--)
            inv[i - 1] = mul(inv[i], i);
    }

    ll comb(int n, int k) {
        if (n < k)
            return 0;
        return mul(mul(fact[n], inv[k]), inv[n - k]);
    }

    ll perm(int n, int k) {
        if (n < k)
            return 0;
        return mul(fact[n], inv[n - k]);
    }

    ll multi(vector<int> v) {
        ll res = fact[accumulate(v.begin(), v.end(), 0)];
        for (int i : v)
            res = mul(res, inv[i]);
        return res;
    }

} math(100005);

class Solution {
public:
    int countBalancedPermutations(string S) {
        int n = S.size();
        vector<int> fm(10);
        int total = 0;
        for (auto c : S) {
            ++fm[c - '0'];
            total += c - '0';
        }
        if (total % 2)
            return 0;
        int T = total / 2;
        int E = (n + 1) / 2, O = n - E;
        vector p_dp(T + 1, vector(E + 1, 0LL));
        p_dp[0][0] = 1;
        for (int d = 0; d < 10; ++d) {
            vector c_dp(T + 1, vector(E + 1, 0LL));
            for (int s = 0; s <= T; ++s) {
                for (int c = 0; c <= E; ++c) {
                    if (p_dp[s][c] == 0)
                        continue;
                    for (int k = 0; k <= fm[d] && k <= E - c && s + k * d <= T;  ++k) {
                        c_dp[s + k * d][c + k] += p_dp[s][c] * math.inv[k] % MOD * math.inv[fm[d] - k] % MOD % MOD;
                        c_dp[s + k * d][c + k] %= MOD;
                    }
                }
            }
            p_dp = move(c_dp);
        }
        return p_dp[T][E] * math.fact[E] % MOD * math.fact[O] % MOD;
    }
};",1441305590
dirigibility,dirigibility,20,3627,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,0,0)]
        visited = set()
        while True:
            t,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (i0,j0) in visited:
                continue
            visited.add((i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+1,i,j))",1441294813
dirigibility,dirigibility,20,3628,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,1,0,0)]
        visited = set()
        while True:
            t,dt,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (dt,i0,j0) in visited:
                continue
            visited.add((dt,i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (3-dt,i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+dt,3-dt,i,j))",1441296704
dirigibility,dirigibility,20,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])",1441281104
dirigibility,dirigibility,20,3637,python3,"mod = 10**9+7
@cache
def fac(n):
    return (n*fac(n-1))%mod if n else 1
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if (s := sum(map(int,num)))%2:
            return 0
        c = Counter(map(int,num))
        @cache
        def f(d,need,need_sum):
            if need < 0 or need_sum < 0:
                return 0
            if d == 10:
                return int(need == need_sum == 0)
            return sum(pow(fac(take)*fac(c[d]-take),-1,mod)*f(d+1,need-take,need_sum-d*take) for take in range(0,c[d]+1))%mod
        try:
            l = len(num)
            return (f(0,l//2,s//2)*fac(l//2)*fac(l-l//2))%mod
        finally:
            f.cache_clear()",1441317496
physics0523,physics0523,21,3627,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int clk=max(od.first,moveTime[nx][ny])+1;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441292885
physics0523,physics0523,21,3628,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int dlt;
                if((x+y)%2==0){dlt=1;}
                else{dlt=2;}
                int clk=max(od.first,moveTime[nx][ny])+dlt;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441295080
physics0523,physics0523,21,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int h=0;
        for(int i=0;i<num.size();i++){
            if(i%2){h+=(num[i]-'0');}
            else{h-=(num[i]-'0');}
        }
        return (h==0);
    }
};",1441281668
physics0523,physics0523,21,3637,cpp,"#define mod 1000000007

int md(int x){
    if(x>=mod){return x-mod;}
    return x;
}

int mul(long long x,long long y){
    return (x*y)%mod;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<vector<int>> nCr(105,vector<int>(105,0));
        nCr[0][0]=1;
        for(int i=1;i<105;i++){
            for(int j=0;j<=i;j++){
                if(j>0){nCr[i][j]+=nCr[i-1][j-1];}
                nCr[i][j]=md(nCr[i][j]);
                if(j<i){nCr[i][j]+=nCr[i-1][j];}
                nCr[i][j]=md(nCr[i][j]);
            }
        }
        // for(int i=0;i<5;i++){
        //     for(int j=0;j<5;j++){cout << nCr[i][j] << "" "";}
        //     cout << ""\n"";
        // }
        
        vector<int> bk(10,0);
        for(auto &nx : num){
            bk[nx-'0']++;
        }
        int rem=num.size();
        int ofs=400;
        int n=num.size();
        int x=(n+1)/2;
        int y=n/2;
        vector<vector<vector<int>>> dp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
        dp[x][y][ofs]=1;
        for(int tr=0;tr<10;tr++){
            vector<vector<vector<int>>> ndp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
            for(int cx=0;cx<=x;cx++){
                int cy=rem-cx;
                if(!(0<=cy && cy<=y)){continue;}
                for(int i=0;i<800;i++){
                    if(dp[cx][cy][i]==0){continue;}
                    for(int sx=0;sx<=bk[tr];sx++){
                        int sy=bk[tr]-sx;
                        int nx=cx-sx;
                        int ny=cy-sy;
                        if(!(0<=nx && nx<=x)){continue;}
                        if(!(0<=ny && ny<=y)){continue;}
                        int dlt=tr*(sx-sy);
                        int mv=dp[cx][cy][i];
                        // cout << x << "" "" << y << "" "" << i << "" -> "" << nx << "" "" << ny << "" "" << i+dlt << ""\n"";
                        // cout << mv << "" "" << nCr[cx][sx] << "" "" << nCr[cy][sy] << ""\n"";
                        mv=mul(mv,nCr[cx][sx]);
                        mv=mul(mv,nCr[cy][sy]);
                        ndp[nx][ny][i+dlt]=md(ndp[nx][ny][i+dlt]+mv);
                    }
                }
            }
            rem-=bk[tr];
            dp=ndp;
        }
        
        return dp[0][0][ofs]%mod;
    }
};",1441310947
ssk4988,ssk4988,22,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, i, j = heappop(heap)
            # print(i, j, t)
            if i == n-1 and j == m-1: return t
            if (i, j) in seen: continue
            seen.add((i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, (1 + max(moveTime[i1][j1], t), i1, j1))",1441295578
ssk4988,ssk4988,22,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, p, i, j = heappop(heap)
            # print(i, j, p, t)
            if i == n-1 and j == m-1: return t
            if (p, i, j) in seen: continue
            seen.add((p, i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, ((2 if p == 1 else 1) + max(moveTime[i1][j1], t), 1-p, i1, j1))",1441298603
ssk4988,ssk4988,22,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(v) for i,v in enumerate(num) if i % 2 == 0]) == sum([int(v) for i,v in enumerate(num) if i % 2 == 1])",1441281276
ssk4988,ssk4988,22,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        freq = [0] * 10
        for d in num:
            freq[int(d)] += 1
        mod = 1000000007
        @cache
        def combmod(n, k):
            return comb(n, k) % mod
        @cache
        def dp(dig, lefteven, leftodd, evmodd):
            if dig == 10:
                return 1 if evmodd == 0 and lefteven == 0 and leftodd == 0 else 0
            ans = 0
            for toeven in range(0, 1 + min(lefteven, freq[dig])):
                toodd = freq[dig] - toeven
                if toodd > leftodd: continue
                res = dp(dig+1, lefteven - toeven, leftodd - toodd, evmodd + (toeven - toodd) * dig)
                ways = (combmod(lefteven, toeven) * combmod(leftodd, toodd)) % mod
                ans = (ans + res * ways) % mod
            return ans
        n = len(num)
        return dp(0, n // 2, n - n // 2, 0)",1441311262
Balakrishnan Varadarajan,balakrishnan_v,23,3627,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> min_times(n,vector<int>(m,-1));
        vector<vector<bool>> done(n,vector<bool>(m,false));
        set<vector<int>> Q;
        Q.insert({0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j]) continue;
            done[i][j]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj]!=-1 && min_times[ni][nj]<=nt) continue;
                if (min_times[ni][nj]!=-1) {
                    Q.erase({min_times[ni][nj],ni,nj});
                }
                min_times[ni][nj]=nt;
                Q.insert({nt,ni,nj});
            }
        }
        return ans;
    }
};",1441317168
Balakrishnan Varadarajan,balakrishnan_v,23,3628,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<vector<int>>> min_times(n,vector<vector<int>>(m,vector<int>(2,-1)));
        vector<vector<vector<bool>>> done(n,vector<vector<bool>>(m,vector<bool>(2,false)));
        set<vector<int>> Q;
        Q.insert({0,0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            int p = it->at(3);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j][p]) continue;
            done[i][j][p]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+p+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj][1-p]!=-1 && min_times[ni][nj][1-p]<=nt) continue;
                if (min_times[ni][nj][1-p]!=-1) {
                    Q.erase({min_times[ni][nj][1-p],ni,nj,1-p});
                }
                min_times[ni][nj][1-p]=nt;
                Q.insert({nt,ni,nj,1-p});
            }
        }
        return ans;
    }
};",1441314130
Balakrishnan Varadarajan,balakrishnan_v,23,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0=0;
        int s1=0;
        int n=num.size();
        for(int i=0;i<n;i++) {
            int d=num[i]-'0';
            if (i%2==0) s0+=d;
            else s1+=d;
        }
        return s0==s1;
    }
};",1441318653
Balakrishnan Varadarajan,balakrishnan_v,23,3637,cpp,"#define MODD 1000000007
#define NUM_DIGS 10
#define MAXN 80
#define ll long long
class Solution {
public:
    
    ll fact[MAXN+2];
    ll factinv[MAXN+2];
    
    int dp[NUM_DIGS+1][MAXN+2][MAXN*9];
    
    int Solve(const vector<int>& counts, int d, int num_even_left, int sum_even_left) {
        if (d==NUM_DIGS) {
            return num_even_left==0 && sum_even_left==0;
        }
        
        if (dp[d][num_even_left][sum_even_left]!=-1) return dp[d][num_even_left][sum_even_left];
        
        ll ans = 0;
        for(int x=0;x<=min(num_even_left,counts[d]);x++) {
            if (sum_even_left-x*d<0) break;
            ans += Solve(counts, d+1, num_even_left-x,sum_even_left-x*d) * factinv[x]%MODD*factinv[counts[d]-x]%MODD;
            ans %= MODD;
        }
        return dp[d][num_even_left][sum_even_left]=ans;
    }
    
    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }

    

    int countBalancedPermutations(string num) {
        
        
        int n=num.size();
        fact[0]=factinv[0]=1;
        for(int i=1;i<=n;i++) {
            fact[i]=fact[i-1]*i%MODD;
            factinv[i]=modpow(fact[i],MODD-2);
        }
        vector<int> counts(10,0);
        int s=0;
        for(char c : num) {
            counts[c-'0']++;
            s += c-'0';
        }
        if (s&1) return 0;
        
        int num_odd_pos=0;
        int num_even_pos=0;
        for(int i=0;i<n;i++) {
            if (i%2) num_odd_pos++;
            else num_even_pos++;
        }
        
        for(int d=0;d<=NUM_DIGS;d++) {
            for(int num_even_left=0;num_even_left<=num_even_pos;num_even_left++) {
                for(int sum_even_left=0;sum_even_left<=s/2;sum_even_left++) {
                    dp[d][num_even_left][sum_even_left]=-1;
                }
            }
        }
        
        ll ans = Solve(counts, 0, num_even_pos, s/2);
        ans = ans*fact[num_odd_pos]%MODD*fact[num_even_pos]%MODD;
        
        // split each digit
        
        return ans;
        
    }
};",1441298327
leetgoat_dot_dev,leetgoat_dot_dev,26,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c to min time
        heap = [(0, 0, 0)] # time, r, c
        while heap:
            time, r, c = heapq.heappop(heap)
            if minDists[(r, c)] <= time:
                continue
            minDists[(r, c)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newTime = max(time + 1, moveTime[newR][newC] + 1)
                if newTime >= minDists[(newR, newC)]:
                    continue
                heapq.heappush(heap, (newTime, newR, newC))
        return minDists[(len(moveTime) - 1, len(moveTime[0]) - 1)]
            ",1441293052
leetgoat_dot_dev,leetgoat_dot_dev,26,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c, parity to min time
        heap = [(0, 0, 0, 0)] # time, r, c, parity
        while heap:
            time, r, c, parity = heapq.heappop(heap)
            if minDists[(r, c, parity)] <= time:
                continue
            minDists[(r, c, parity)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newDelta = 1 if parity == 0 else 2
                newTime = max(time + newDelta, moveTime[newR][newC] + newDelta)
                # if newTime >= minDists[(newR, newC)]:
                #     continue
                heapq.heappush(heap, (newTime, newR, newC, parity^1))
        return min(
            minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 0)],
             minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 1)],
        )
            ",1441295559
leetgoat_dot_dev,leetgoat_dot_dev,26,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i in range(len(num)):
            if i % 2 == 0:
                evens += int(num[i])
            else:
                odds += int(num[i])
        return evens == odds",1441280912
leetgoat_dot_dev,leetgoat_dot_dev,26,3637,python3,"# template by: https://github.com/agrawalishaan/leetcode

# n in the constructor is basically the biggest number we will operate on. So for instance finding n! % MOD. But also things like interleaving two sequences of length 500 and length 700 would require n=1200. To be safe, can always just put a big number like 1e5.
class ModCalc:
    def __init__(self, n, primeMod):
        self.n = n
        self.mod = primeMod # If this is not prime, anything using modInv may break (fermat's little theorem)
        # O(n) time to build a factorial mod array
        self.factorialsWithMod = self._buildFactorialsWithMod()
        # O(n) time to build an inverse factorial mod array
        self.inverseFactorialsWithMod = self._buildInverseFactorialsWithMod()

    # ********** STUFF WITH FACTORIALS **********

    # O(n) time to build a factorial mod array
    def _buildFactorialsWithMod(self):
        factorialsWithMod = [1] # 0 factorial is 1
        for factorial in range(1, self.n + 1):
            factorialsWithMod.append(factorialsWithMod[-1] * factorial % self.mod)
        return factorialsWithMod

    # O(n) time to build an inverse factorial mod array
    def _buildInverseFactorialsWithMod(self):
        inverseFactorialsWithMod = [1] * (self.n + 1)
        inverseFactorialsWithMod[self.n] = self.modInv(self.factorialsWithMod[self.n])
        for i in range(self.n - 1, 0, -1):
            inverseFactorialsWithMod[i] = inverseFactorialsWithMod[i + 1] * (i + 1) % self.mod
        return inverseFactorialsWithMod

    # Gets (x! % MOD)
    # O(1) time
    def getFactorialWithMod(self, factorial):
        return self.factorialsWithMod[factorial]

    # Gets (1/x! % MOD)
    # O(1) time
    def getInverseFactorialWithMod(self, inverseFactorial):
        return self.inverseFactorialsWithMod[inverseFactorial]

    # Given two sequences of length X and Y, such as ""123"" and ""4567"", find the # of ways to interleave them.  Note we don't care about the actual items in each sequence, we just care about the # of ways we can interleave the two. We don't even get the actual sequences themselves, just their lengths.
    # O(1) time
    def interleaveTwoSequencesWithMod(self, length1, length2):
        # Interleaving a sequence of length 3 and 4 would be like 7!/(3!4!), which is 7! * (1/3!) * (1/4!)
        combinedLength = length1 + length2
        if combinedLength >= len(self.factorialsWithMod):
            raise ValueError(f""To interleave {length1} and {length2} items, we need at least {combinedLength + 1} items in the factorial array."")
        numerator = self.getFactorialWithMod(combinedLength)
        denominator1 = self.getInverseFactorialWithMod(length1)
        denominator2 = self.getInverseFactorialWithMod(length2)
        return self.modMultiply(numerator, denominator1, denominator2)


    # Calculates the # of ways to select k items from n unique items. Order does not matter.
    # Formula for C(n, k) = n! / (k!(n-k)!)
    # Denominator is 1/k! * 1/(n-k)!
    # O(1) time
    def nChooseKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator1 = self.getInverseFactorialWithMod(k)
        denominator2 = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator1, denominator2)

    # Calculates the # of ways to select k items from n unique items. Order matters.
    # Formula for P(n, k) = n! / (n-k)!
    # Denominator is 1/(n-k)!
    # O(1) time
    def nPermuteKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator)

    # Calculate the # of ways to distribute n identical items into k distinct buckets (relates to stars and bars)
    # Formula for allowing empty buckets is C(n+k-1, k-1), which is: (n+k-1)! * 1/(n-1)! * 1/k!
    # Formula for NOT allowing empty buckets is C(n-1, k-1), which is: (n-1)! * 1/(n-k)! * 1/k!
    # O(1) time
    def waysToPutIdenticalItemsIntoDistinctBucketsWithMod(self, items, buckets, allowEmptyBuckets=True):
        if allowEmptyBuckets:
            return self.nChooseKWithMod(items + buckets - 1, buckets - 1)
        return self.nChooseKWithMod(items - 1, buckets - 1)

    # Putting n distinct items into k distinct buckets is just k options for the first item, k for the second, etc, so k^n. This is if we allow empty buckets. If we don't allow empty buckets, we need Stirling numbers of the second kind.
    # O(log items) time due to modPow, but modPow can be cached
    def waysToPutDistinctItemsIntoDistinctBucketsAllowingEmptyWithMod(self, items, buckets):
        return self.modPow(buckets, items)

    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        # need to figure out how to do this in O(1) if it is possible lol
        pass

    # ********** NO FACTORIALS NEEDED **********

    # Multiples k numbers together
    # O(k) time
    def modMultiply(self, *args):
        result = 1
        for num in args:
            result = (result * num) % self.mod
        return result

    # Calculates base^exponent % MOD
    # Can add caching if we are using the same base a lot. But if we are using one instance of the ModCalc class across all test cases, maybe that would MLE? I think no cache by default is better, since it is very fast already.
    # O(log exponent) time (even without caching)
    # @cache # uncomment to cache
    def modPow(self, base, exponent):
        return pow(base, exponent, self.mod)

    # Gets 1/x % MOD
    # Could cache this, if we are calling the same range of numbers a lot. If this class is created once across all test cases, could maybe MLE? Also num needs to be coprime to MOD.
    # O(log MOD) time
    # @cache # uncomment to cache
    def modInv(self, num):
        return self.modPow(num, self.mod - 2)


class MoreAdvancedStirlingStuff:
    def __init__(self, maxPossibleDistinctItemCount, maxPossibleBucketCount, mod):
        self.maxPossibleDistinctItemCount = maxPossibleDistinctItemCount
        self.maxPossibleBucketCount = maxPossibleBucketCount
        self.mod = mod

        # # Build a basic modCalc so we can get factorial mods
        self.modCalc = ModCalc(maxPossibleBucketCount, mod)

        # O(maxPossibleDistinctItemCount * maxPossibleBucketCount) build time
        self.stirling2Dp = self._buildStirling2Dp()

    def _buildStirling2Dp(self):
        dp = [[0] * (self.maxPossibleBucketCount + 1) for _ in range(self.maxPossibleDistinctItemCount + 1)]
        dp[0][0] = 1
        for i in range(1, self.maxPossibleDistinctItemCount + 1):
            for j in range(1, self.maxPossibleBucketCount + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % self.mod
        return dp

    # Calculate the # of ways to distribute n distinct items into k identical non-empty buckets. For instance with items 'A' and 'B' and 2 buckets, there's only one way, since the buckets are identical.
    # This is stirling2 numbers.
    # O(1) time
    def waysToPutDistinctItemsIntoIdenticalNonemptyBucketsWithMod(self, items, buckets):
        return self.stirling2Dp[items][buckets]

    # Calculate the # of ways to distribute n distinct items into k distinct non-empty buckets.
    # O(1) time
    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        waysAssumingIdenticalBuckets = self.stirling2Dp[items][buckets]
        bucketOrderings = self.modCalc.getFactorialWithMod(buckets)
        return self.modCalc.modMultiply(waysAssumingIdenticalBuckets, bucketOrderings)

    
calc = ModCalc(10000, 10**9 + 7)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        c = Counter(int(l) for l in num)
        
        evens = len(num) // 2
        odds = len(num) - evens
        
        M = 10**9 + 7
        
        @cache
        def dp(digit, evenSurplus, evensUsed, oddsUsed):
            if digit == 10:
                return 1 if not evenSurplus else 0
            
            resHere = 0
            for distributeToOdds in range(c[digit] + 1):
                newOdds = oddsUsed + distributeToOdds
                if newOdds > odds:
                    break
                distributeToEvens = c[digit] - distributeToOdds
                newEvens = evensUsed + distributeToEvens
                if newEvens > evens:
                    continue
                oddGain = distributeToOdds * digit
                evenGain = distributeToEvens * digit
                evenNet = evenGain - oddGain
                
                oddSpotsLeft = odds - oddsUsed
                evenSpotsLeft = evens - evensUsed
                
                waysToDistributeOdds = calc.nChooseKWithMod(oddSpotsLeft, distributeToOdds)
                waysToDistEvens = calc.nChooseKWithMod(evenSpotsLeft, distributeToEvens)
                resHere += calc.modMultiply(dp(digit + 1, evenSurplus + evenNet, newEvens, newOdds), waysToDistributeOdds, waysToDistEvens)
            return resHere % M
        
        a = dp(0,0,0,0)
        dp.cache_clear()
        return a
            
            
            ",1441306558
Chinnu,chinnu11,27,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&t){
        int n=t.size(),m=t[0].size();
        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};
        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));
        dist[0][0]=0;
        
        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<>>q;
        q.emplace(0,0,0);
        
        while(!q.empty()){
            auto[ct,i,j]=q.top();q.pop();
            if(i==n-1&&j==m-1)return ct;
            if(ct>dist[i][j])continue;
            
            for(auto[di,dj]:d){
                int ni=i+di,nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m){
                    int ns=max(ct,t[ni][nj]);
                    int at=ns+1;
                    if(at<dist[ni][nj]){
                        dist[ni][nj]=at;
                        q.emplace(at,ni,nj);
                    }
                }
            }
        }
        return -1;
    }
};",1441287083
Chinnu,chinnu11,27,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n=t.size(), m=t[0].size();
        vector<pair<int,int>> d={{-1,0},{1,0},{0,-1},{0,1}};
        const int inf=INT_MAX;
        vector<int> dist(n*m*2,inf);
        dist[0]=0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;
        q.emplace(0,0);
        
        while(!q.empty()) {
            auto [c,s]=q.top(); q.pop();
            int p=s%2, pos=s/2, i=pos/m, j=pos%m;
            if(i==n-1&&j==m-1) return c;
            if(c>dist[s]) continue;
            
            for(auto &[di,dj]:d) {
                int ni=i+di, nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m) {
                    int st=max(c,t[ni][nj]), dur=p==0?1:2, nt=st+dur, np=1-p;
                    int ns=(ni*m+nj)*2+np;
                    if(nt<dist[ns]) {
                        dist[ns]=nt;
                        q.emplace(nt,ns);
                    }
                }
            }
        }
        return -1;
    }
};",1441290452
Chinnu,chinnu11,27,3636,cpp,"class Solution{
public:
    bool isBalanced(string n){
        int e=0,o=0;
        for(int i=0;i<n.size();++i){
            int d=n[i]-'0';
            if(i%2==0)e+=d;
            else o+=d;
        }
        return e==o;
    }
};
",1441281159
Chinnu,chinnu11,27,3637,cpp,"typedef long long ll;
const int M=1'000'000'007;

ll pmod(ll x,ll y,ll m){
    ll r=1;
    x%=m;
    while(y>0){
        if(y&1)r=r*x%m;
        x=x*x%m;
        y>>=1;
    }
    return r;
}

ll inv(ll x,ll m){
    return pmod(x,m-2,m);
}

int cBalPerms(string num){
    int n=num.size();
    vector<ll>f(n+1,1),invf(n+1,1);
    for(int i=1;i<=n;i++)f[i]=f[i-1]*i%M;
    invf[n]=inv(f[n],M);
    for(int i=n-1;i>=0;i--)invf[i]=invf[i+1]*(i+1)%M;

    int fr[10]={0};
    ll ts=0;
    for(char c:num)fr[c-'0']++,ts+=(c-'0');
    if(ts%2!=0)return 0;
    ll tgt=ts/2;
    int k=(n+1)/2,m=n-k;

    vector<vector<ll>>dp(tgt+1,vector<ll>(k+1,0));
    dp[0][0]=1;

    for(int d=0;d<=9;d++){
        if(fr[d]==0)continue;
        vector<vector<ll>>d2(tgt+1,vector<ll>(k+1,0));
        for(int s=0;s<=tgt;s++){
            for(int c=0;c<=k;c++){
                if(dp[s][c]==0)continue;
                for(int a=0;a<=fr[d]&&a+c<=k;a++){
                    if(s+d*a>tgt)break;
                    ll comb=f[fr[d]]*invf[a]%M*invf[fr[d]-a]%M;
                    d2[s+d*a][c+a]=(d2[s+d*a][c+a]+dp[s][c]*comb)%M;
                }
            }
        }
        dp=d2;
    }

    ll assign=dp[tgt][k];
    if(assign==0)return 0;

    ll prod_f=1;
    for(int d=0;d<=9;d++)prod_f=prod_f*f[fr[d]]%M;

    ll fk=f[k],fm=f[m],invp=inv(prod_f,M);
    ll tot=assign*fk%M*fm%M*invp%M;

    return (int)tot;
}

class Solution{
public:
    int countBalancedPermutations(string num){
        return cBalPerms(num);
    }
};
",1441313189
Larry,LarryNY,28,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + 1:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + 1
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441290449
Larry,LarryNY,28,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                p = 2 - ((nx + ny) % 2)
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + p:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + p
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441293459
Larry,LarryNY,28,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        N = len(num)
        
        a = [0] * 2
        for i in range(N):
            a[i % 2] += int(num[i])
            
        return a[0] == a[1]",1441280862
Larry,LarryNY,28,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        arr = [int(x) for x in num]
        N = len(arr)
        f = [0] * 10
        for x in arr:
            f[x] += 1

        fact = [1]
        ifact = [pow(1, -1, MOD)]
        for i in range(1, N + 1):
            fact.append((fact[-1] * i) % MOD)
            ifact.append(pow(fact[-1], -1, MOD))

        numer = 1
        if N % 2 == 0:
            numer = (fact[(N // 2)] * fact[(N // 2)]) % MOD
        else:
            numer = (fact[((N + 1) // 2)] * fact[(N // 2)]) % MOD
            
        @cache
        def go(index, delta_count, delta_sum):
            if index == len(f):
                if delta_sum != 0:
                    return 0

                if N % 2 == 0:
                    if delta_count != 0:
                        return 0
                    return 1
                else:
                    if delta_count == 1:
                        return 1
                    return 0
        
            total = 0
            for i in range(f[index] + 1):
                left = i
                right = f[index] - i
                total += go(index + 1, delta_count + (left - right), delta_sum + (left - right) * index) * ifact[left] * ifact[right]
                total %= MOD
            return total % MOD
        
        return (go(0, 0, 0) * numer) % MOD",1441320693
Nguyn Tho,nguyenquocthao00,30,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + 1, i2,j2))
            
        ",1441292016
Nguyn Tho,nguyenquocthao00,30,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            added = 1 if (i+j)%2==0 else 2
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + added, i2,j2))
            
        
        ",1441294941
Nguyn Tho,nguyenquocthao00,30,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x,y = 0,0
        for i,ch in enumerate(num):
            if i%2==0: x+=int(ch)
            else: y+=int(ch)
        return x==y
        ",1441281098
Nguyn Tho,nguyenquocthao00,30,3637,python3,"MOD = 10**9 + 7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        count=[0]*10
        for ch in num: count[int(ch)]+=1
        s= sum(i*v for i,v in enumerate(count))
        if s%2==1: return 0
        # target=s//2
        @lru_cache(None)
        def dp(v,n,t):
            if v<0: return 0 if (n!=0 or t!=0) else 1
            if count[v]==0: return dp(v-1,n,t)
            n2,s2 = len(num)-n, s-t
            for v2 in range(9, v,-1):
                n2-=count[v2]
                s2-=count[v2]*v2
            if n<0 or t<0 or n2<0 or s2<0: return 0
            res=0
            for i in range(count[v]+1):
                res += math.comb(n, i) * math.comb(n2, count[v]-i) * dp(v-1, n-i, t-i*v)
            return res%MOD
        return dp(9, len(num)//2, s//2)
            
        ",1441321719
hxu10,hxu10,31,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                newt = max(t, moveTime[newi][newj]) + 1
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]
            
        
        
        ",1441293045
hxu10,hxu10,31,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                    
                
                newt = max(t, moveTime[newi][newj]) + 2 - (i+j+1) % 2 
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]",1441298013
hxu10,hxu10,31,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s1 = num[::2]
        s2 = num[1::2]
        
        tot1 = 0
        for c in s1:
            tot1 += int(c)
            
        tot2 = 0
        for c in s2:
            tot2 += int(c)
            
        return tot1==tot2
    ",1441281054
hxu10,hxu10,31,3637,python,"

M = 10**9 + 7

def fastfrac(a,b):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M


factor = [1]
invfactor = [1]

for _ in range(100):
    factor.append(factor[-1]*len(factor)%M)
    invfactor.append(fastfrac(1,factor[-1])%M)
    

                     
    
    
    
    
    
    

class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        
        
        fre = [0]*10
        
        s = 0
        
        for c in num:
            fre[int(c)] += 1
            s += int(c) 
            
            
        if s%2==1:
            return 0
        
        

        
        
        
            
            
            
        target = len(num) // 2
        
        tsum = s // 2
        
        
    
        
        
        dic = {}
        
        def getnext(index,totc,totnum):
            
            
            if index==10:
                if totc==target and totnum==tsum:
                    return 1
                return 0
            
            if totc > target or totnum > tsum:
                return 0
            
            
            #print(index,totc,totnum)
            
            if (index,totc,totnum) in dic:  
                return dic[(index,totc,totnum)]
            
            
            res = 0
            for d in range(fre[index]+1):
                xi = invfactor[d] * invfactor[fre[index]-d] 
                res += getnext(index+1, totc+d, totnum+d*index) * xi % M
                res %= M
                
            dic[(index,totc,totnum)] = res
            return res
        
        ans = getnext(0,0,0) * factor[target] * factor[len(num)-target] % M
        
        
        

        
        return ans 
                
            
             
            
            
        
                
            
            
            ",1441322214
kzyKT,kzyKT,32,3627,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<ll,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m];
    rep(i,n)rep(j,m) d[i][j]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(0,P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F;
      if(d[x][y]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+1;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1);
          if(d[xx][yy]>cc) {
            d[xx][yy]=cc;
            que.push(PP(cc,P(xx,yy)));
          }
        }
      }
    }
    return d[n-1][m-1];
  }
};
",1441291418
kzyKT,kzyKT,32,3628,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<P,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m][2];
    rep(i,n)rep(j,m)rep(k,2) d[i][j][k]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(P(0,0),P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F.F,k=p.F.S;
      if(d[x][y][k]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+k+1,kk=(k+1)%2;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1+k);
          if(d[xx][yy][kk]>cc) {
            d[xx][yy][kk]=cc;
            que.push(PP(P(cc,kk),P(xx,yy)));
          }
        }
      }
    }
    return min(d[n-1][m-1][0],d[n-1][m-1][1]);
  }
};
",1441293902
kzyKT,kzyKT,32,3636,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  bool isBalanced(string s) {
    ll c[2];mem(c);
    rep(i,s.size()) c[i%2]+=s[i]-'0';
    return c[0]==c[1];
  }
};
",1441281289
kzyKT,kzyKT,32,3637,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;


void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;
  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}
  *c=r0;*a=a0;*b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll fact[2100],fact_inv[2100];

void init() {
  fact[0]=1;
  REP(i,1,2100) fact[i]=fact[i-1]*i%MAX;
  fact_inv[2050]=get_inv(fact[2050],MAX);
  rrep(i,2050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;
}

ll nCr(ll N,ll K){
  if(K<0||K>N)return 0;
  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;
}

ll dp[11][44][444];
class Solution {
public:
  int countBalancedPermutations(string s) {
    init();
    ll n=s.size();
    ll c[26],sum=0;
    mem(c);
    rep(i,n) c[s[i]-'0']++;
    rep(i,10) sum+=i*c[i];
    if(sum%2) return 0;
    ll n1=n/2+n%2,n2=n/2,e=0;
    rep(i,11)rep(j,n1+1)rep(k,400) dp[i][j][k]=0;
    dp[0][0][0]=1;
    rep(i,10) {
      rep(j,n1+1) {
        rep(k,400) {
          rep(l,c[i]+1) {
            if(j+l>n1||k+l*i>400) break;
            ll nn=e-j;
            if(n2-nn<0) continue;
            dp[i+1][j+l][k+l*i]+=dp[i][j][k]*nCr(n1-j,l)%MAX*nCr(n2-nn,c[i]-l);
            dp[i+1][j+l][k+l*i]%=MAX;
          }
        }
      }
      e+=c[i];
    }
    return dp[10][n1][sum/2];
  }
};",1441309238
nimish7866,nimish7866,33,3627,cpp,"
    
    class Solution {
public:


int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = moveTime.size();
        int m = moveTime[0].size();
        

        vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        

        vector<vector<long long>> arrival(n, vector<long long>(m, LLONG_MAX));
        arrival[0][0] = 0; 
        

        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>, 
                      greater<>> pq;
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            auto [currentTime, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            

            if (currentTime > arrival[row][col]) continue;
            

            for (const auto& [dx, dy] : directions) {
                int newRow = row + dx;
                int newCol = col + dy;
                

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {

                    long long nextTime = max(currentTime, (long long)moveTime[newRow][newCol]);
                    nextTime += 1;  
                    

                    if (nextTime < arrival[newRow][newCol]) {
                        arrival[newRow][newCol] = nextTime;
                        pq.push({nextTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return (int)arrival[n-1][m-1];
}
    };
        
    
",1441297861
nimish7866,nimish7866,33,3628,cpp,"class Solution {
public:
    typedef pair<long long, pair<int, int>> P;

    long long minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        vector<pair<int, int>> dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(m, vector<long long>(2, LLONG_MAX)));

        dp[0][0][0] = 0;

        priority_queue<pair<long long, tuple<int, int, int>>, vector<pair<long long, tuple<int, int, int>>>, greater<>> pq;
        pq.push({0, {0, 0, 0}});

        while (!pq.empty()) {
            auto [curT, state] = pq.top();
            auto [r, c, mv] = state;
            pq.pop();

            if (curT > dp[r][c][mv % 2]) continue;

            for (const auto& [dx, dy] : dir) {
                int nr = r + dx;
                int nc = c + dy;

                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int mvTime = (mv % 2 == 0) ? 1 : 2;
                    long long nextT = max(curT, (long long)mt[nr][nc]);
                    nextT += mvTime;

                    if (nextT < dp[nr][nc][(mv + 1) % 2]) {
                        dp[nr][nc][(mv + 1) % 2] = nextT;
                        pq.push({nextT, {nr, nc, (mv + 1) % 2}});
                    }
                }
            }
        }

        return (int)min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441300894
nimish7866,nimish7866,33,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

    for (size_t i = 0; i < num.length(); ++i) {
        int digit = num[i] - '0';  
        if (i % 2 == 0) {
            es += digit;  
        } else {
            os += digit;  
        }
    }

    return es == os;
    }
};",1441281030
nimish7866,nimish7866,33,3637,cpp,"using ll = long long;
using vll = vector<ll>;
using vvll = vector<vll>; 

class Solution {
public:
    const int MOD = 1'000'000'007; 

    int countBalancedPermutations(string n) {
        int L = n.size();
        int E = (L + 1) / 2;
        int O = L / 2;

        string v = n;
        int cnt[10] = {0};
        countDigits(n, cnt);

        ll total = calcTotal(cnt);
        if (total % 2 != 0) return 0;

        ll target = total / 2;

        vll fact = preFact();
        vll invFact = preInvFact(fact);

        vvll dp = initDP(E, target); 
        fillDP(dp, cnt, fact, invFact, E, target); 

        return calcAns(dp, E, target, cnt, L); 
    }

private:
    void countDigits(const string& n, int* cnt) {
        for (char ch : n) cnt[ch - '0']++;
    }

    ll calcTotal(int* cnt) {
        ll sum = 0;
        for (int d = 0; d < 10; d++) {
            sum += (ll)d * cnt[d];
        }
        return sum;
    }

    vll preFact() {
        const int MAX = 80;
        vll fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    vll preInvFact(const vll& fact) {
        const int MAX = 80;
        vll invFact(MAX + 1, 1);
        invFact[MAX] = power(fact[MAX], MOD - 2, MOD);
        for (int i = MAX - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
        return invFact;
    }

    ll comb(int a, int b, const vll& fact, const vll& invFact) {
        if (b > a) return 0;
        return fact[a] * invFact[b] % MOD * invFact[a - b] % MOD;
    }

    vvll initDP(int E, ll target) {
        vvll dp(E + 1, vll(target + 1, 0));
        dp[0][0] = 1;
        return dp;
    }

    void fillDP(vvll& dp, int* cnt, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            updateDP(dp, cnt[d], d, fact, invFact, E, target); 
        }
    }

    void updateDP(vvll& dp, int digitCount, int digit, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int t = E; t >= 0; t--) {
            for (ll s = target; s >= 0; s--) {
                if (dp[t][s] == 0) continue;
                for (int k = 1; k <= digitCount && t + k <= E && s + (ll)digit * k <= target; k++) {
                    dp[t + k][s + (ll)digit * k] = (dp[t + k][s + (ll)digit * k] + dp[t][s] * comb(digitCount, k, fact, invFact)) % MOD;
                }
            }
        }
    }

    int calcAns(const vvll& dp, int E, ll target, int* cnt, int L) { 
        ll valid = dp[E][target];
        ll prodFact = calcProductFact(cnt);
        ll ans = (valid * preFact()[E] % MOD * preFact()[L / 2] % MOD) * power(prodFact, MOD - 2, MOD) % MOD;
        return (int)ans;
    }

    ll calcProductFact(int* cnt) {
        ll prodFact = 1;
        for (int d = 0; d < 10; d++) {
            prodFact = prodFact * preFact()[cnt[d]] % MOD;
        }
        return prodFact;
    }

    ll power(ll b, ll e, ll m) {
        ll r = 1; 
        b %= m;
        while (e > 0) {
            if (e & 1) r = r * b % m;
            b = b * b % m; 
            e >>= 1;
        }
        return r;
    }
};",1441316156
Zejun Wu,watashi,34,3627,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 1;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441293776
Zejun Wu,watashi,34,3628,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 2 - (xx + yy) % 2;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441298622
Zejun Wu,watashi,34,3636,cpp,"class Solution {
public:
  bool isBalanced(string num) {
    int s = 0, f = 1;
    for (char c : num) {
      s += (c - '0') * f;
      f *= -1;
    }
    return s == 0;
  }
};",1441281479
Zejun Wu,watashi,34,3637,cpp,"class Solution {
  static constexpr int64_t MOD = 1000000007;

  // a * x + b * y = gcd(a, b) >= 0
  long long extGcd(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
      x = a >= 0 ? 1 : -1;
      y = 0;
      return abs(a);
    }
    else {
      int g = extGcd(b, a % b, y, x);
      y -= a / b * x;
      return g;
    }
  }

  // ASSUME: gcd(a, m) == 1
  long long modInv(long long a, long long m) {
    long long x, y;
    extGcd(a, m, x, y);
    return (x % m + m) % m;
  }

public:
  int countBalancedPermutations(string num) {
    vector<int64_t> fac(800), inv(800);
    fac[0] = inv[0] = 1;
    for (int i = 1; i < inv.size(); ++i) {
      fac[i] = fac[i - 1] * i % MOD;
      inv[i] = modInv(fac[i], MOD);
    }

    int s = 0;
    vector<int> c(10, 0);
    for (char ch : num) {
      ++c[ch - '0'];
      s += ch - '0';
    }
    if (s % 2 != 0) {
      return 0;
    }

    int n = num.length();
    int m = n / 2;
    int z = 0;
    s /= 2;
    vector<vector<int64_t>> dp(m + 1, vector<int64_t>(s + 1, 0));
    dp[0][0] = 1;
    for (int x = 0; x < 10; ++x) {
      vector<vector<int64_t>> pre(m + 1, vector<int64_t>(s + 1, 0));
      pre.swap(dp);
      for (int y = 0; y <= c[x]; ++y) { // 80
        for (int i = y; i <= m; ++i) {
          for (int j = x * y; j <= s; ++j) {
            dp[i][j] += pre[i - y][j - x * y] * inv[y] % MOD * inv[c[x] - y] % MOD;
          }
        }
      }
      for (auto& i : dp) {
        for (auto& j : i) {
          j %= MOD;
        }
      }
    }

    int64_t ret = dp[m][s];
    for (int i = 1; i <= m; ++i) {
      ret = ret * i % MOD;
    }
    for (int i = 1; i <= n - m; ++i) {
      ret = ret * i % MOD;
    }
    return (int)ret;
  }
};",1441316290
SayA,usaya,36,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        dist = [[float('inf') for _ in range(m)] for _ in range(n)]
        dist[0][0] = 0
        
        hp = [(0, 0, 0)] # (time, x, y)
        while hp:
            t, x, y = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(hp, (nt, nx, ny))
        return -1",1441293531
SayA,usaya,36,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        
        dp = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        hp = [(0, 0, 0, 0)] # (time, x, y, z)
        
        while hp:
            t, x, y, z = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dp[x][y][z]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + (1 if z == 0 else 2)
                    nz = 1 - z
                    if nt < dp[nx][ny][nz]:
                        dp[nx][ny][nz] = nt
                        heappush(hp, (nt, nx, ny, nz))
        return -1",1441301029
SayA,usaya,36,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = s2 = 0
        for idx, d in enumerate(num):
            if idx % 2 == 0:
                s1 += ord(d) - ord('0')
            else:
                s2 += ord(d) - ord('0')
        return s1 == s2",1441288801
SayA,usaya,36,3637,python3,"MOD = 10**9 + 7
MAXN = 85

fact = [1] * (MAXN + 1)
for i in range(1, MAXN + 1):
    fact[i] = fact[i-1] * i % MOD

inv = [1] * (MAXN + 1)
inv[MAXN] = pow(fact[MAXN], MOD-2, MOD)
for i in range(MAXN, 0, -1):
    inv[i-1] = inv[i] * i % MOD

comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for i in range(MAXN + 1):
    comb[i][0] = 1
    for j in range(1, i + 1):
        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for d in num:
            cnt[int(d)] += 1
        cnt_e, cnt_o = (n + 1) // 2, n // 2

        s = sum(int(ch) for ch in num)
        if s & 1:
            return 0
        hs = s // 2

        @cache
        def dfs(d, r_e, r_s):
            if d == 10:
                if r_e ==0 and r_s ==0:
                    return 1
                else:
                    return 0
            res = 0
            for t in range(0, min(cnt[d], r_e) + 1):
                if t * d > r_s:
                    continue
                res = (res + dfs(d + 1, r_e - t, r_s - t * d) * comb[cnt[d]][t]) % MOD
            return res

        ans = dfs(0, cnt_e, hs) * fact[cnt_e] * fact[cnt_o] % MOD
        for d in range(10):
            ans = ans * inv[cnt[d]] % MOD
        return ans",1441323871
funsquared,funsquared,37,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))
        
            ",1441323726
funsquared,funsquared,37,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1 + (r + c) % 2
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))",1441323530
funsquared,funsquared,37,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))",1441323951
funsquared,funsquared,37,3637,python3,"MAX = 80
MOD = 10 ** 9 + 7

fact = [1]
for x in range(1, MAX + 1):
    fact.append(fact[-1] * x % MOD)
inv_fact = [None] * (MAX + 1)
inv_fact[MAX] = pow(fact[MAX], -1, MOD)
for x in range(MAX - 1, -1, -1):
    inv_fact[x] = inv_fact[x + 1] * (x + 1) % MOD

def choose(n, k):
    if n < k:
        return 0
    return fact[n] * inv_fact[n - k] % MOD * inv_fact[k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        S = sum(map(int, num))
        if S % 2 == 1:
            return 0
        cnt = [0] * 10
        for d in map(int, num):
            cnt[d] += 1
        target = S // 2
        @cache
        def count(d, o, e, s):
            if d == 10:
                return int(s == target)
            res = 0
            for c in range(min(cnt[d], o) + 1):
                if cnt[d] - c > e:
                    continue
                res = (res + choose(o, c) * choose(e, cnt[d] - c) % MOD * count(d + 1, o - c, e - (cnt[d] - c), s + c * d) % MOD) % MOD
            return res
        return count(0, n // 2, (n + 1) // 2, 0)",1441323285
Ethan,ethanrao,38,3627,cpp,"#include<bits/stdc++.h>>
using namespace std;

class Solution {
public:
    int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    queue<tuple<int, int, int>> q;
    
    int bfs(vector<vector<int>>& cost) {
        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 1e9+3000));
        dp[0][0] = 0;
        
        while (!q.empty()) {
            auto [x, y, t] = q.front();
            q.pop();
            for (int i=0;i<4;i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
                    int tt = max(cost[xx][yy], t);
                    if (tt + 1 < dp[xx][yy]) {
                        q.push({xx, yy, tt + 1});
                        dp[xx][yy] = tt + 1;
                    }
                    else continue;
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        q.push({0, 0, 0});
        return bfs(moveTime);
    }
};
",1441315400
Ethan,ethanrao,38,3628,cpp,"class Solution {
public:
    int a[755][755], n, m, dis[755][755][2];
    struct node{
        int x, y, z, d;
    };
    struct cmp{
        bool operator()(node x, node y){
            return x.d > y.d;      
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        m = moveTime[0].size();
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                a[i][j] = moveTime[i - 1][j - 1];
        priority_queue <node, std::vector <node>, cmp> q;
        q.push((node){1, 1, 0, 0});
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                dis[i][j][0] = dis[i][j][1] = 1.5e9;
        dis[1][1][0] = 0;
        while(q.size()){
            node u = q.top(); q.pop();
            if(u.d > dis[u.x][u.y][u.z]) continue;
            if(u.x > 1){
                int d = std::max(u.d, a[u.x - 1][u.y]) + u.z + 1;
                if(d < dis[u.x - 1][u.y][u.z ^ 1]){
                    dis[u.x - 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x - 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.x < n){
                int d = std::max(u.d, a[u.x + 1][u.y]) + u.z + 1;
                if(d < dis[u.x + 1][u.y][u.z ^ 1]){
                    dis[u.x + 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x + 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.y > 1){
                int d = std::max(u.d, a[u.x][u.y - 1]) + u.z + 1;
                if(d < dis[u.x][u.y - 1][u.z ^ 1]){
                    dis[u.x][u.y - 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y - 1, u.z ^ 1, d});
                }
            }
            if(u.y < m){
                int d = std::max(u.d, a[u.x][u.y + 1]) + u.z + 1;
                if(d < dis[u.x][u.y + 1][u.z ^ 1]){
                    dis[u.x][u.y + 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y + 1, u.z ^ 1, d});
                }
            }
        }
        return std::min(dis[n][m][0], dis[n][m][1]);
    }
};",1441324125
Ethan,ethanrao,38,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ct1 = 0, ct2 = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                ct1 += digit;
            } else {
                ct2 += digit;
            }
        }
        
        return ct1 == ct2;
    }
};
",1441310208
Ethan,ethanrao,38,3637,cpp,"class Solution {
public:
    int n, n1, n2;
    const int mod = 1e9 + 7;
    int c[10];
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    int C[85][85], f[11][85][361];
    int countBalancedPermutations(string num) {
        n = num.size();
        n1 = n2 = 0;
        int S = 0;
        for(int i = 0; i < n; ++i){
            if(i % 2 == 0) ++n1;
            else ++n2;
            ++c[num[i] - '0'];
            S += num[i] - '0';
        }
        if(S % 2){
            return 0;
        }
        C[0][0] = 1;
        for(int i = 1; i <= n; ++i)
            for(int j = 0; j <= i; ++j){
                if(j == 0) C[i][j] = 1;
                else C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
            }
        f[0][0][0] = 1;
        int s = 0;
        for(int i = 1; i <= 10; ++i){
            int t = c[i - 1];
            for(int sum = 0; sum <= 360; ++sum){
                for(int j = 0; j <= n1; ++j){
                    for(int k = 0; k <= j && k <= t; ++k){
                        int pn1 = j - k, pn2 = s - pn1, sa = k * (i - 1);
                        if(pn2 < 0 || pn2 > n2 || sa > sum) continue;
                        f[i][j][sum] = add(f[i][j][sum], mul(f[i - 1][pn1][sum - sa], mul(C[n1 - pn1][k], C[n2 - pn2][t - k])));
                    } 
                }
            }
            s += t;
        }
        return f[10][n1][S / 2];
    }
};",1441309618
zaneyu2005,zaneyu2005,41,3627,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int x=z/m,y=z%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[a*m+b]<=max(arr[a][b],dist[z])+1){
                    continue;
                }
                dist[a*m+b]=max(arr[a][b],dist[z])+1;
                pq.push({dist[a*m+b],a*m+b});
            }
        }
        return dist[n*m-1];
    }
    
};",1441292757
zaneyu2005,zaneyu2005,41,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(2*n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int st=z%2;
            int x=(z/2)/m,y=(z/2)%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[(a*m+b)*2+1-st]<=max(arr[a][b],dist[z])+(st+1)){
                    continue;
                }
                dist[(a*m+b)*2+1-st]=max(arr[a][b],dist[z])+st+1;
                pq.push({dist[(a*m+b)*2+1-st],(a*m+b)*2+1-st});
            }
        }
        return min(dist[2*(n*m-1)],dist[2*n*m-1]);
    }
    
};",1441296463
zaneyu2005,zaneyu2005,41,3636,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
class Solution {
public:
    bool isBalanced(string s) {
        int n=sz(s);
        int sum=0;
        REP(i,n){
            if(i%2) sum+=s[i]-'0';
            else sum-=s[i]-'0';
        }
        return (sum==0);
    }
};",1441280925
zaneyu2005,zaneyu2005,41,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dp[100][1000],ndp[100][1000];
int c[100][100];
class Solution {
public:
    int countBalancedPermutations(string num) {
        REP(i,50) REP(j,1000) dp[i][j]=ndp[i][j]=0;
        REP(i,100){
            c[i][0]=1;
            REP1(j,i){
                c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;
            }
        }
        dp[0][0]=1;
        int cnt[10];
        REP(i,10) cnt[i]=0;
        int s=0;
        for(auto x:num){
            cnt[x-'0']++;
            s+=(x-'0');
        }
        if(s%2){
            return 0;
        }
        s/=2;
        int o=sz(num)/2;
        int e=sz(num)-o;
        int pf=0;
        REP(i,10){
            REP(a,o+1) REP(b,s+1) ndp[a][b]=0;
            REP(a,o+1){
                REP(b,s+1){
                    if(!dp[a][b]) continue;
                    REP(j,cnt[i]+1){
                        if(a+j>o or b+j*i>s) continue;
                        ndp[a+j][b+j*i]+=1LL*dp[a][b]*c[o-a][j]%MOD*c[e-(pf-a)][cnt[i]-j]%MOD;
                        if(ndp[a+j][b+j*i]>=MOD) ndp[a+j][b+j*i]-=MOD;
                    }
                }
            }
            pf+=cnt[i];
            REP(a,o+1) REP(b,s+1) dp[a][b]=ndp[a][b];
        }
        return dp[o][s];
    }
};",1441312046
Ayush,as_313,42,3627,python3,"import heapq

class Solution:
    def is_valid(self, i, j, n, m):
        return 0 <= i < n and 0 <= j < m
    
    def get_neighbors(self, r, c, n, m):
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if self.is_valid(nr, nc, n, m):
                yield nr, nc
    
    def init_distance(self, n, m):
        return [[float('inf')]*m for _ in range(n)]
    
    def process_node(self, t, r, c, g, d, q):
        if t > d[r][c]:
            return
        
        n, m = len(g), len(g[0])
        for nr, nc in self.get_neighbors(r, c, n, m):
            new_time = max(t, g[nr][nc]) + 1
            if new_time < d[nr][nc]:
                d[nr][nc] = new_time
                heapq.heappush(q, (new_time, nr, nc))
    
    def minTimeToReach(self, g):
        n, m = len(g), len(g[0])
        d = self.init_distance(n, m)
        q = [(0, 0, 0)]
        d[0][0] = 0
        
        while q:
            t, r, c = heapq.heappop(q)
            self.process_node(t, r, c, g, d, q)
            
        return d[n-1][m-1]",1441325790
Ayush,as_313,42,3628,python3,"class Solution:
    def minTimeToReach(self, t: List[List[int]]) -> int:
        n, m = len(t), len(t[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        q = [(0, 0, 0, 2)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def is_within_bounds(a, b): return 0 <= a < n and 0 <= b < m
        
        def calculate_next_time(x, a, b, nv): return max(x, t[a][b]) + nv
        
        def explore_neighbors(x, r, c, v):
            for i, j in dirs:
                a, b = r + i, c + j
                if is_within_bounds(a, b):
                    nv = 1 if v == 2 else 2
                    y = calculate_next_time(x, a, b, nv)
                    if y < d[a][b]: 
                        d[a][b] = y
                        heappush(q, (y, a, b, nv))
        
        while q:
            x, r, c, v = heappop(q)
            if r == n - 1 and c == m - 1: return x
            if x > d[r][c]: continue
            explore_neighbors(x, r, c, v)
        
        return d[n-1][m-1]
",1441301088
Ayush,as_313,42,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i, d in enumerate(num):
            if i % 2 == 0: e += int(d)
            else: o += int(d)
        return e == o
",1441284192
Ayush,as_313,42,3637,python3,"class Solution:
    def countBalancedPermutations(self, s):
        MOD = 10**9 + 7
        
        def power_mod(x, y):
            r, x = 1, x % MOD
            while y:
                if y & 1: r = r * x % MOD
                x, y = x * x % MOD, y >> 1
            return r
        
        n = len(s)
        f = [1] + [0] * n
        v = [1] + [0] * n
        for i in range(1, n + 1): f[i] = f[i-1] * i % MOD
        v[n] = power_mod(f[n], MOD - 2)
        for i in range(n-1, -1, -1): v[i] = v[i+1] * (i+1) % MOD
        
        c = [s.count(str(i)) for i in range(10)]
        total = sum(int(ch) for ch in s)
        if total % 2: return 0
        
        k, target = (n + 1) // 2, total // 2
        dp = [[0] * (target + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d, cnt in enumerate(c):
            new_dp = [[0] * (target + 1) for _ in range(k + 1)]
            for i in range(k + 1):
                for j in range(target + 1):
                    if dp[i][j]:
                        for x in range(min(cnt, k - i) + 1):
                            if j + d * x <= target:
                                new_dp[i + x][j + d * x] = (
                                    new_dp[i + x][j + d * x] + 
                                    dp[i][j] * v[x] % MOD * v[cnt - x]
                                ) % MOD
            dp = new_dp
        
        return f[k] * f[n-k] % MOD * dp[k][target] % MOD
",1441319728
scanhex,scanhex,45,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441295664
scanhex,scanhex,45,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + t + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441294951
scanhex,scanhex,45,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(i) for i in str(num)[::2]]) == sum([int(i) for i in str(num)[1::2]])",1441296619
scanhex,scanhex,45,3637,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int countBalancedPermutations(string num) {
    int ceven = num.size() / 2, codd = num.size() - ceven;
    int n = num.size();
    vector<vector<int>> c(n + 1, vector<int>(n + 1));
    c[0][0] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 0; j <= i; ++j)
        c[i][j] = ((j == 0 ? 0 : c[i - 1][j - 1]) + c[i - 1][j]) % mod;
    const int MX = 2 * 100 * 9;
    const int ZERO = MX / 2;
    vector<vector<int>> dp(ceven + 1, vector<int>(MX));
    dp[0][ZERO] = 1;
    int totcnt = 0;
    for (int i = 0; i < 10; ++i) {
      int cnt = 0;
      for (char ch : num)
        if (ch - '0' == i)
          ++cnt;
      auto dpp = vector<vector<int>>(ceven + 1, vector<int>(MX));
      for (int j = ceven; j >= 0; --j) {
        for (int k = ceven; k >= 0; --k) {
          if (j + k > ceven || k > cnt)
            continue;
          for (int l = 0; l < MX; ++l) {
            if (dp[j][l] == 0)
              continue;
            int nodd = cnt - k;
            int totodd = totcnt - j;
            int nl = l + (k - nodd) * i;
            if (nl < 0 || nl >= MX)
              continue;
            dpp[j + k][nl] += 1LL * dp[j][l] * c[j + k][k] % mod *
                             c[totodd + nodd][nodd] % mod;
            if (dpp[j + k][nl] >= mod)
              dpp[j + k][nl] -= mod;
          }
        }
      }
      dp = dpp;
      totcnt += cnt;
    }
    return dp[ceven][ZERO];
  }
};
",1441314395
Shuqi Shang,sshang,46,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        seen = set()
        
        while q:
            t, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1, ni, nj))",1441291881
Shuqi Shang,sshang,46,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0, 0)]
        seen = set()
        
        while q:
            t, state, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1 + state, 1 - state, ni, nj))",1441294899
Shuqi Shang,sshang,46,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        odd, even = 0, 0
        for i, c in enumerate(num):
            if i % 2:
                odd += int(c)
            else:
                even += int(c)
        return odd == even",1441281285
Shuqi Shang,sshang,46,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        mod = 10 ** 9 + 7
        
        n = len(num)
        size = n // 2
        
        total = 0
        cnter = {}
        l = []
        for c in num:
            digit = int(c)
            total += digit
            
            if digit in cnter:
                cnter[digit] += 1
            else:
                cnter[digit] = 1
                bisect.insort(l, digit)
                
        l.reverse()
        presum = [0]
        precnt = [0]
        for num in l:
            cnt = cnter[num]
            precnt.append(precnt[-1] + cnt)
            presum.append(presum[-1] + num * cnt)
            
        if total % 2:
            return 0
        
        target = total // 2
        
        @lru_cache(None)
        def dfs(i, cur_size, cur):
            if i == len(l):
                if cur_size == size and cur == target:
                    return 1
                else:
                    return 0
                
            op_size = precnt[i] - cur_size
                
            num = l[i]
            cnt = cnter[num]
            res = 0
            for j in range(cnt + 1):
                ncur_size = cur_size + j
                ncur = cur + j * num
                nop_size = precnt[i+1] - ncur_size
                nop_sum = presum[i+1] - ncur
                
                if ncur_size <= size and nop_size <= n - size and ncur <= target and nop_sum <= target:
                    mul = (math.comb(size - cur_size, j) % mod) * (math.comb(n - size - op_size, cnt - j) % mod) % mod
                    res += dfs(i+1, ncur_size, ncur) * mul % mod
            return res % mod
            
        return dfs(0, 0, 0)",1441327864
Milind Gupta,milind0110,48,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + 1;
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny});
                }
            }
        }
        return -1;
    }
};",1441298834
Milind Gupta,milind0110,48,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,4>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y,turn] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + (turn == 0 ? 1 : 2);
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny,turn ^ 1});
                }
            }
        }
        return -1;
    }
};",1441297775
Milind Gupta,milind0110,48,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int ans = 0;
        int n = (int)s.size();
        for(int i = 0; i < n; i++){
            if(i & 1){
                ans += s[i] - '0';
            } else {
                ans -= s[i] - '0';
            }
        }
        return (ans == 0);
    }
};",1441281507
Milind Gupta,milind0110,48,3637,cpp,"const int N = 100;
const int mod = 1e9 + 7;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }
template <class T> using V = vector<T>;
template <class T> using VV = V<V<T>>;

template <uint MD> struct ModInt {
    using M = ModInt;
    const static M G;
    uint v;
    ModInt(ll _v = 0) { set_v(_v % MD + MD); }
    M& set_v(uint _v) {
        v = (_v < MD) ? _v : _v - MD;
        return *this;
    }
    explicit operator bool() const { return v != 0; }
    M operator-() const { return M() - *this; }
    M operator+(const M& r) const { return M().set_v(v + r.v); }
    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }
    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }
    M operator/(const M& r) const { return *this * r.inv(); }
    M& operator+=(const M& r) { return *this = *this + r; }
    M& operator-=(const M& r) { return *this = *this - r; }
    M& operator*=(const M& r) { return *this = *this * r; }
    M& operator/=(const M& r) { return *this = *this / r; }
    bool operator==(const M& r) const { return v == r.v; }
    M pow(ll n) const {
        M x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    M inv() const { return pow(MD - 2); }
    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }
};
using Mint = ModInt<mod>;
template<> const Mint Mint::G = Mint(3);

// template <class Mint> void nft(bool type, V<Mint>& a) {
//     int n = int(a.size()), s = 0;
//     while ((1 << s) < n) s++;
//     assert(1 << s == n);

//     static V<Mint> ep, iep;
//     while (int(ep.size()) <= s) {
//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));
//         iep.push_back(ep.back().inv());
//     }
//     V<Mint> b(n);
//     for (int i = 1; i <= s; i++) {
//         int w = 1 << (s - i);
//         Mint base = type ? iep[i] : ep[i], now = 1;
//         for (int y = 0; y < n / 2; y += w) {
//             for (int x = 0; x < w; x++) {
//                 auto l = a[y << 1 | x];
//                 auto r = now * a[y << 1 | x | w];
//                 b[y | x] = l + r;
//                 b[y | x | n >> 1] = l - r;
//             }
//             now *= base;
//         }
//         swap(a, b);
//     }
// }

// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {
//     assert(false);
//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer
//     int n = int(a.size()), m = int(b.size());
//     if (!n || !m) return {};
//     int lg = 0;
//     while ((1 << lg) < n + m - 1) lg++;
//     int z = 1 << lg;
//     auto a2 = a, b2 = b;
//     a2.resize(z);
//     b2.resize(z);
//     nft(false, a2);
//     nft(false, b2);
//     for (int i = 0; i < z; i++) a2[i] *= b2[i];
//     nft(true, a2);
//     a2.resize(n + m - 1);
//     Mint iz = Mint(z).inv();
//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;
//     return a2;
// }

Mint fact[N];
Mint inv[N];
void precalc(){
    fact[0] = 1;
    for(int i = 1; i < N; i++){
        fact[i] = fact[i - 1];
        fact[i] *= i;
    }
    for(int i = 0; i < N; i++){
        inv[i] = 1;
        inv[i] /= fact[i];
    }
}
Mint ncrmodp(int n,int r){
    if(n < 0 || n < r)
        return 0;
    return fact[n]*inv[n-r]*inv[r];
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        precalc();
        int n = (int)s.length();
        const int mx = 10;
        vector<int> cnt(mx);
        int sum = 0;
        for(auto i : s){
            cnt[i - '0']++;
            sum += (i - '0');
        }
        if(sum & 1) return 0;
        sum /= 2;
        int len = n / 2;
        vector<vector<Mint>> dp(len + 1,vector<Mint>(sum + 1));
        dp[0][0] = fact[len] * fact[n - len];
        for(int i = 0; i < mx; i++){
            vector<vector<Mint>> ndp(len + 1,vector<Mint>(sum + 1));
            for(int clen = 0; clen <= len; clen++){
                for(int csum = 0; csum <= sum; csum++){
                    for(int take = 0; take <= cnt[i]; take++){
                        if(take + clen > len) break;
                        int nsum = csum + take * i;
                        if(nsum > sum) break;
                        ndp[clen + take][nsum] += dp[clen][csum] * inv[take] * inv[cnt[i] - take];
                    }
                }
            }
            swap(dp,ndp);
        }
        // for(int i = 0; i <= len; i++){
        //     for(int j = 0; j <= sum; j++){
        //         cout << i << "" "" << j << "" "" << dp[i][j].v << ""\n"";
        //     }
        // }
        return dp[len][sum].v;

    }
};",1441328324
07dishwasherbob8,07dishwasherbob8,50,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1, moveTime[tx][ty] + 1), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441328119
07dishwasherbob8,07dishwasherbob8,50,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1 + ((x + y) & 1), moveTime[tx][ty] + 1 + ((x + y) & 1)), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441327239
07dishwasherbob8,07dishwasherbob8,50,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for(int i = 1; i < num.size(); i+=2) {
            s0 += num[i] - '0';
        }
        for(int i = 0; i < num.size(); i+=2) {
            s1 += num[i] - '0';
        }
        return s0 == s1;
    }
};",1441329956
07dishwasherbob8,07dishwasherbob8,50,3637,cpp,"typedef long long ll;
typedef long double ld;

template<class T>
constexpr T power(T a, ll b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

//Modular Division currently uses Little Fermat's Theorem, so won't work for nonprime p. 
template<int P>
struct Mint {
    int x;
    constexpr Mint(): x{} {}
    constexpr Mint(ll x): x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if(P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if(x < 0) {
            x += getMod();
        }
        if(x >= getMod()) { //not sure why this is needed
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    constexpr Mint operator-() const {
        Mint res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr Mint inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr Mint &operator*=(Mint rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr Mint &operator+=(Mint rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr Mint &operator-=(Mint rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr Mint &operator/=(Mint rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr Mint operator*(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr Mint operator+(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr Mint operator-(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr Mint operator/(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, Mint &a) {
        ll v;
        is >> v;
        a = Mint(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const Mint &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(Mint lhs, Mint rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(Mint lhs, Mint rhs) {
        return lhs.val() != rhs.val();
    }
};

constexpr int P = 1000000007;
using Z = Mint<P>;

class Solution {

public:
    int countBalancedPermutations(string num) {
        vector<Z> factorials(800);
        vector<Z> ifactorials(800);
        factorials[0] = 1;
        ifactorials[0] = 1;
        for(int i = 1; i < 800; i++) {
            factorials[i] = factorials[i-1] * i;
            ifactorials[i] = 1 / factorials[i];
        }

        vector<int> cnts(10);
        int sum = 0;
        for(char c : num) {
            cnts[c - '0']++;
            sum += c - '0';
        }

        
        if(sum & 1) {
            return 0;
        }
        
        // cout << ""sum : "" << sum << '\n';

        vector<vector<Z>> dp(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));
        vector<vector<Z>> next(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));

        dp[0][0] = 1;

        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    next[j][k] = 0;
                }
            }
            
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    for(int l = 0; l + j <= num.size() / 2 && k + (i * l) <= sum / 2 && l <= cnts[i]; l++) {
                        next[l+j][k + i * l] += dp[j][k] * ifactorials[l] * ifactorials[cnts[i] - l];
                    }
                }
            }
            // cout << ""i : "" << i << '\n';
            // for(int j = 0; j <= num.size() / 2; j++) {
            //     for(int k = 0; k <= sum / 2; k++) {
            //         // cout << ""i : "" << i << "" j : "" << j << "" k : "" << k << "" val : "" << dp[j][k] << '\n';
            //         cout << next[j][k] << "" "";
            //     }
            //     cout << '\n';
            // }
            swap(dp,next);
        }
        return (dp[num.size() / 2][sum / 2] * factorials[num.size() / 2] * factorials[(num.size() + 1) / 2]).x;
    }
};",1441315453
wuaws,wuaws,51,3627,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int>,vector<tuple<ll,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        vpi dirs={{-1,0},{1,0},{0,-1},{0,1}};
        const ll INF=1e18;
        mll d(n,vll(m,INF));
        d[0][0]=0;
        pq pq;
        pq.emplace(0,0,0);
        
        while(!pq.empty()){
            auto[t,i,j]=pq.top();
            pq.pop();
            
            if(i==n-1&&j==m-1)return(int)t;
            
            if(t>d[i][j])continue;
            
            for(auto&[di,dj]:dirs){
                int ni=i+di,nj=j+dj;
                
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                
                ll at=max(t,(ll)mt[ni][nj])+1;
                if(at<d[ni][nj]){
                    d[ni][nj]=at;
                    pq.emplace(at,ni,nj);
                }
            }
        }
        return -1;
    }
};",1441329816
wuaws,wuaws,51,3628,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int,int>,vector<tuple<ll,int,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        mll d0(n,vll(m,1e18)),d1(n,vll(m,1e18));
        d0[0][0]=0;
        pq pq;
        pq.emplace(0,0,0,0);
        vector<pair<int,int>> dirs={{-1,0},{1,0},{0,-1},{0,1}};
        
        while(!pq.empty()){
            auto[t,i,j,p]=pq.top(); pq.pop();
            if(i==n-1&&j==m-1)return t;
            if((p==0&&t>d0[i][j])||(p==1&&t>d1[i][j]))continue;

            for(auto& d:dirs){
                int ni=i+d.first,nj=j+d.second;
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                ll ts=max((ll)t,(ll)mt[ni][nj]),at=ts+(p==0?1:2);
                int np=1-p;
                if((np==0&&at<d0[ni][nj])||(np==1&&at<d1[ni][nj])){
                    (np==0?d0[ni][nj]:d1[ni][nj])=at;
                    pq.emplace(at,ni,nj,np);
                }
            }
        }
        return -1;
    }
};",1441329602
wuaws,wuaws,51,3636,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

class Solution {
public:
    bool isBalanced(string num) {
        int e=0,o=0;
        FOR(i,0,num.length()){
            int d=num[i]-'0';
            if(i%2==0) e+=d;
            else o+=d;
        }
        return e==o;
    }
};",1441330062
wuaws,wuaws,51,3637,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

const int MOD=1e9+7;

ll fast_power(ll x,ll y,ll mod){
    ll r=1; x%=mod;
    while(y>0){
        if(y&1)r=r*x%mod;
        x=x*x%mod; y>>=1;
    }
    return r;
}

class Solution {
public:
    int countBalancedPermutations(string n){
        int c[10]={0}; ll s=0;
        for(char d:n){c[d-'0']++; s+=d-'0';}
        if(s&1)return 0;
        ll t=s/2; int sz=n.size(),e=(sz+1)/2,o=sz/2;
        
        vector<ll> f(sz+1,1),ivf(sz+1,1);
        FOR(i,1,sz+1)f[i]=f[i-1]*i%MOD;
        ivf[sz]=fast_power(f[sz],MOD-2,MOD);
        FORD(i,sz,0)ivf[i]=ivf[i+1]*(i+1)%MOD;
        
        vector<pair<int,int>>d;
        FOR(dg,0,10)if(c[dg])d.PB({dg,c[dg]});
        
        mll dp(t+1,vector<ll>(e+1,0));
        dp[0][0]=1;
        
        FORE(dg,d){
            mll ndp(t+1,vector<ll>(e+1,0));
            FOR(k,0,t+1)FOR(m,0,e+1)if(dp[k][m]){
                int mx=min(dg.S,e-m);
                FOR(x,0,mx+1){
                    ll nk=k+x*dg.F; if(nk>t)continue;
                    int nm=m+x;
                    ndp[nk][nm]=(ndp[nk][nm]+dp[k][m]*ivf[x]%MOD*ivf[dg.S-x]%MOD)%MOD;
                }
            }
            dp=ndp;
        }
        
        ll a=(t<=t&&e<=e)?dp[t][e]:0;
        
        return (int)(f[e]*f[o]%MOD*a%MOD);
    }
};",1441329386
Meng-Hsuan Wu,meng-hsuan,55,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + 1, tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441305853
Meng-Hsuan Wu,meng-hsuan,55,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + (1 if (tr + tc) % 2 else 2), tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441307123
Meng-Hsuan Wu,meng-hsuan,55,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) * (1 if i % 2 else -1) for i in range(n)) == 0",1441282661
Meng-Hsuan Wu,meng-hsuan,55,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(ch) for ch in num) % 2:
            return 0
        
        MODULI = 10 ** 9 + 7
        n = len(num)
        no = n >> 1
        ne = n - no
        C = Counter(num)
        
        choose = [[1]]
        for n_ in range(1, n + 1):
            choose.append([1])
            for r in range(1, n_):
                choose[-1].append((choose[-2][r - 1] + choose[-2][r]) % MODULI)
            choose[-1].append(1)
        #for i in choose:
        #    print(i)
        
        curr = {(ne, no, 0): 1}
        for i in range(10):
            prev = curr
            curr = collections.defaultdict(int)
            qty = C[str(i)]
            
            for ce in range(qty + 1):
                co = qty - ce
                dbal = (ce - co) * i
                
                for pe, po, pbal in prev:
                    if pe >= ce and po >= co:
                        curr[key := (pe - ce, po - co, pbal + dbal)] += prev[(pe, po, pbal)] * choose[pe][ce] % MODULI * choose[po][co] % MODULI
                        curr[key] %= MODULI
        
        return curr[(0, 0, 0)]
    ",1441331806
haohao,cchao,56,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 3>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        vector<vector<int>> d(n, vector<int>(m, inf));
        d[0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2];
            if (dis != d[x][y]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir];
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + 1;
                if (nd < d[tx][ty]) {
                    d[tx][ty] = nd;
                    q.push({nd, tx, ty});
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441295427
haohao,cchao,56,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 4>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0, 0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        int d[n][m][2];
        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {
            d[i][j][0] = d[i][j][1] = inf;
        }
        d[0][0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2], z = t[3];
            if (dis != d[x][y][z]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir], tz = z ^ 1;
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + (z + 1);
                if (nd < d[tx][ty][tz]) {
                    d[tx][ty][tz] = nd;
                    q.push({nd, tx, ty, tz});
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441301451
haohao,cchao,56,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        return sum(int(x) for x in num[0::2]) == sum(int(x) for x in num[1::2])",1441283080
haohao,cchao,56,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for c in num:
            cnt[ord(c) - ord('0')] += 1

        mod = 10 ** 9 + 7
        inv = lambda x : pow(x, mod - 2, mod)
        fac = [1] * 100
        ifac = [1] * 100
        for i in range(1, len(fac)):
            fac[i] = fac[i-1] * i % mod
            ifac[i] = inv(fac[i])
        
        @cache
        def f(cap1, cap2, diff, index):
            if cap1 < 0 or cap2 < 0:
                return 0
            if cap1 == 0 and cap2 == 0:
                return diff == 0
            ans = 0
            for i in range(cnt[index] + 1):
                j = cnt[index] - i
                if cap1 >= i and cap2 >= j:
                    m1 = fac[cap1] * ifac[i] * ifac[cap1 - i]
                    m2 = fac[cap2] * ifac[j] * ifac[cap2 - j]
                    r = f(cap1 - i, cap2 - j, diff + index * (i - j), index + 1)
                    r = r * m1 % mod
                    r = r * m2 % mod
                    ans = (ans + r) % mod
            return ans % mod
        return f(n//2, n-n//2, 0, 0)",1441332143
Ernest Lu,ernestlu,57,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 1);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441318385
Ernest Lu,ernestlu,57,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 2);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441317334
Ernest Lu,ernestlu,57,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = (int)num.size();
        vector<int> a(n);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
            if (i % 2 == 0)
                sum += a[i];
        }
        const int sum_2 = accumulate(a.begin(), a.end(), 0);
        if (sum + sum == sum_2)
            return true;
        return false;
    }
};",1441319837
Ernest Lu,ernestlu,57,3637,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        // * even! * odd!
        // divide by how many we choose at each level?
        // maintain sum

        int n = (int)num.size();
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
        }

        const int tot = accumulate(a.begin(), a.end(), 0);
        if (tot % 2 == 1) {
            return 0;
        }
        const int target = tot / 2;

 

        vector<int> f(10);
        for (auto u : a)
            f[u]++;

        const int B = n + 101;
        vector<mint> fac(B, 1), inv(B, 1);
        for (int i = 1; i < B; i++)
            fac[i] = fac[i - 1] * i;
        inv[B - 1] = fac[B - 1].pow();
        for (int i = B - 2; i >= 0; i--)
            inv[i] = inv[i + 1] * (i + 1);

        const int even = n / 2, odd = n - even;
        vector dp(even + 1, vector<mint>(target + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            vector new_dp(even + 1, vector<mint>(target + 1, 0));
            for (int num_vals = 0; num_vals <= even; num_vals++) {
                for (int val = 0; val <= target; val++) {
                    for (int fc = 0; fc <= f[i]; fc++) {
                        mint ways_t = inv[fc] * inv[f[i] - fc];
                        const int new_val = val + fc * i;
                        if (num_vals + fc <= even and new_val <= target) {
                            new_dp[num_vals + fc][new_val] += dp[num_vals][val] * ways_t;
                        }
                    }
                }
            }
            swap(dp, new_dp);
        }
        
        const mint ans = dp[even][target] * fac[even] * fac[odd];
        return ans.x;
    }
};",1441299220
Xiaomeng Yang,yangxm,58,3627,cpp,"#define X first
#define Y second

constexpr int MAX = 64;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti3 = tuple<int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX];
priority_queue<Ti3, vector<Ti3>, greater<Ti3>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y] = 0;
  que.emplace(0, src.X, src.Y);
  while (!que.empty()) {
    auto [d, x, y] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y];
    }
    if (d > dis[dst.X][dst.Y]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y]) + 1;
      if (dis[xx][yy] > dis[x][y] + w) {
        dis[xx][yy] = dis[x][y] + w;
        que.emplace(dis[xx][yy], xx, yy);
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441295829
Xiaomeng Yang,yangxm,58,3628,cpp,"#define X first
#define Y second

constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti4 = tuple<int, int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX][2];
priority_queue<Ti4, vector<Ti4>, greater<Ti4>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y][0] = 0;
  que.emplace(0, src.X, src.Y, 0);
  while (!que.empty()) {
    auto [d, x, y, k] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y][k];
    }
    if (d > dis[dst.X][dst.Y][k]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y][k]) + k + 1;
      if (dis[xx][yy][k ^ 1] > dis[x][y][k] + w) {
        dis[xx][yy][k ^ 1] = dis[x][y][k] + w;
        que.emplace(dis[xx][yy][k ^ 1], xx, yy, (k ^ 1));
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441299693
Xiaomeng Yang,yangxm,58,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      int n = num.length(), x = 0, y = 0;
      for (int i = 0; i < n; ++i) {
        int v = num[i] - '0';
        if (i & 1) {
          x += v;
        } else {
          y += v;
        }
      }
      return x == y;
    }
};",1441281670
Xiaomeng Yang,yangxm,58,3637,cpp,"constexpr int MAXM = 128;
constexpr int MAXN = 1024;
constexpr int MOD = 1000000007;

using i64 = long long;

int cnt[16];
i64 c[MAXM][MAXM], dp[MAXM][MAXN];

void Init() {
  memset(c, 0, sizeof(c));
  for (int i = 0; i < MAXM; ++i) {
    c[i][0] = 1;
    for (int j = 1; j <= i; ++j) {
      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
    }
  }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
      static bool init = []() {
        Init();
        return true;
      }();
      
      int n = num.length(), m = 0;
      memset(cnt, 0, sizeof(cnt));
      for (char ch : num) {
        int x = ch - '0';
        m += x;
        ++cnt[x];
      }
      
      if (m & 1) {
        return false;
      }
      
      memset(dp, 0, sizeof(dp));
      for (int i = 0; i <= cnt[0]; ++i) {
        dp[i][0] = 1;
      }
      int v = cnt[0], w = 0;
      for (int i = 1; i < 10; ++i) {
        if (cnt[i] == 0) {
          continue;
        }
        v += cnt[i];
        w += cnt[i] * i;
        for (int j = v; j >= 0; --j) {
          for (int k = w; k >= 0; --k) {
            i64 sum = 0;
            for (int d = 0; d <= j && d <= cnt[i] && d * i <= k; ++d) {
              int p = j, q = v - j;
              i64 cur = c[p][d] * c[q][cnt[i] - d] % MOD;
              sum = (sum + dp[j - d][k - d * i] * cur) % MOD;
            }
            dp[j][k] = sum;
          }
        }
      }
      return dp[(n + 1) / 2][m / 2];
    }
};",1441327081
raincoat911,raincoat911,60,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<int>> dp(r, vector<int>(c, INT_MAX));
        dp[0][0] = 0;
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq;
        pq.push({0,0,0});
        vector<vector<bool>> seen(r, vector<bool>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2];
            if (seen[i][j]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j] = true;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y]) continue;
                int nt = max(t, moveTime[x][y]) + 1;
                if (dp[x][y] > nt) {
                    dp[x][y] = nt;
                    pq.push({nt, x, y});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441294180
raincoat911,raincoat911,60,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<array<int, 2>>> dp(r, vector<array<int, 2>>(c, {INT_MAX, INT_MAX}));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> pq;
        pq.push({0,0,0,0});
        vector<vector<array<bool, 2>>> seen(r, vector<array<bool, 2>>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2], z = p[3];
            if (seen[i][j][z]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j][z] = true;
            int nz = z ^ 1;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y][nz]) continue;
                int nt = max(t, moveTime[x][y]) + (z == 0 ? 1 : 2);
                if (dp[x][y][nz] > nt) {
                    dp[x][y][nz] = nt;
                    pq.push({nt, x, y, nz});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441298517
raincoat911,raincoat911,60,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0,  e = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return o == e;
    }
};",1441281089
raincoat911,raincoat911,60,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int l = num.size(), o = (l + 1) / 2, e = l - o, s = 0;
        vector<int> arr(10);
        for (char c : num) {
            arr[c - '0']++;
            s += c - '0';
        }
        if (s & 1) return 0;
        int n = 0;
        vector<vector<int>> dp(s / 2 + 1, vector<int>(o + 1));
        arr2.resize(o + 1, vector<int>(o + 1));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            // cout << i << endl;
            if (arr[i] == 0) continue;
            vector<vector<int>> dp2(s / 2 + 1, vector<int>(o + 1));
            for (int j = 0; j < dp.size(); j++) {
                for (int d = 0; d <= o; d++) {
                    if (dp[j][d] == 0) continue;
                    for (int k = 0; k <= arr[i] && d + k <= o && j + k * i < dp.size(); k++) {
                        if (e - (n - d) < arr[i] - k) continue;
                        // cout << i << "" "" << j << "" "" << k << "" "" << d << endl;
                        // cout << j + k * i << "" "" << d + k << "" "" << o - d << "" "" << k << "" "" << e - (n - d) << "" "" << arr[i] - k << endl;
                        dp2[j + k * i][d + k] += (((long)dp[j][d] * cnk(o - d, k)) % M * cnk(e - (n - d), arr[i] - k)) % M;
                        dp2[j + k * i][d + k] %= M;
                        // cout << ""done"" << endl;
                    }
                }
            }
            swap(dp, dp2);
            n += arr[i];
        }
        // cout << ""aaa"" << endl;
        return dp.back().back();
    }
    
private:
    int M = 1e9 + 7;
    vector<vector<int>> arr2;
    
    int cnk(int n, int k) {
        // cout << n << "" "" << k << endl;
        if (n == k || k == 0) return 1;
        if (arr2[n][k]) return arr2[n][k];
        return arr2[n][k] = (cnk(n - 1, k - 1) + cnk(n - 1, k)) % M;
    }
};",1441328822
OTTFF,OTTFF,62,3627,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

class Solution {
public:
typedef array<int, 3> A3;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        vector<vector<int>> dis(n, vector<int>(m, INF));
        vector<vector<int>> vis(n, vector<int>(m, 0));

        priority_queue<A3, vector<A3>, greater<A3>> qu;
        dis[0][0] = 0;
        qu.push({0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny] = qu.top(); qu.pop();
            if (vis[nx][ny]) continue;
            vis[nx][ny] = 1;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny]) + 1;
                if (dis[x][y] <= nd) {
                    continue;
                }
                dis[x][y] = nd;
                qu.push({nd, x, y});
            }
        }

        return dis[n - 1][m - 1];
    }
};",1441298205
OTTFF,OTTFF,62,3628,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

const int M = 755;
int dis[M][M][2];
int vis[M][M][2];

class Solution {
public:
typedef array<int, 4> A4;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        // vector<vector<int>> dis(n, vector<int>(m, INF));
        // vector<vector<int>> vis(n, vector<int>(m, 0));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dis[i][j][0] = dis[i][j][1] = INF;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }

        priority_queue<A4, vector<A4>, greater<A4>> qu;
        dis[0][0][0] = 0;
        qu.push({0, 0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny, nt] = qu.top(); qu.pop();
            if (vis[nx][ny][nt]) continue;
            vis[nx][ny][nt] = 1;

            // cout << nx << ' ' << ny << ' ' << nt << ' ' << dis[nx][ny][nt] << endl;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y][nt]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny][nt]) + (nt ? 2 : 1);
                if (dis[x][y][nt ^ 1] <= nd) {
                    continue;
                }
                dis[x][y][nt ^ 1] = nd;
                qu.push({nd, x, y, nt ^ 1});
            }
        }

        return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441304611
OTTFF,OTTFF,62,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int i = 0;
        for (char c : num) {
            if (i & 1) {
                sum += c - '0';
            } else {
                sum -= c - '0';
            }
            i++;
        }
        return sum == 0;
    }
};",1441281671
OTTFF,OTTFF,62,3637,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

vector<Mint> inv, fa, ifa;
void init_mod(int n) {
    inv.assign(n + 1, Mint(1));
    fa.assign(n + 1, Mint(1));
    ifa.assign(n + 1, Mint(1));
    for(int i = 2; i <= n; i++) {
        fa[i] = fa[i-1] * i;
        inv[i] = Mint(Mint::MO - Mint::MO / i) * inv[Mint::MO % i];
        ifa[i] = inv[i] * ifa[i-1];
    }
}
inline Mint C(int n,int m) {
  return (m<0 || n<m) ? Mint(0) : fa[n]*ifa[m]*ifa[n-m]; }
inline Mint A(int n,int m) { return fa[n]*ifa[n-m]; }

const int M = 85;
int f = 0;
void init() {
    if (f) return;
    f = 1;
    init_mod(M);
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        
        int n = s.length();
        int sum = 0;
        vector<int> cnt(10);
        for (int i = 0; i < n; i++) {
            sum += s[i] - '0';
            cnt[s[i] - '0']++;
        }
        if (sum & 1) {
            return 0;
        } 

        int m = n / 2;
        int tar = sum / 2;

        vector<vector<Mint>> dp(m + 1, vector<Mint>(tar + 1)), tmp(m + 1, vector<Mint>(tar + 1));
        dp[0][0] = 1;

        int tot = 0;
        for (int v = 0; v < 10; v++) {
            swap(dp, tmp);
            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= tar; j++) {
                    dp[i][j] = 0;
                }
            }

            for (int sel = 0; sel <= cnt[v]; sel++) {
                for (int i = 0; i + sel <= m; i++) {
                    for (int j = 0; j + v * sel <= tar; j++) {
                        dp[i + sel][j + v * sel] += tmp[i][j] * C(m - i, sel) * C(n - m - (tot - i), cnt[v] - sel);
                    }
                }
            }

            tot += cnt[v];
        }

        return dp[m][tar].x;
    }
};",1441322604
Wanjun Li,wjli,63,3627,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					tt = max(moveTime[xx][yy] + 1, t + 1);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};",1441291066
Wanjun Li,wjli,63,3628,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt, dt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					if ((xx + yy) & 1) dt = 1;
					else dt = 2;
					tt = max(moveTime[xx][yy] + dt, t + dt);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};

",1441292925
Wanjun Li,wjli,63,3636,cpp,"


// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	bool isBalanced(string num) {
		int n = num.size(), i, j, k;
		VI s(2, 0);
		FOR(i, n) s[i & 1] += num[i] - '0';
		return s[0] == s[1];
	}
};
",1441281367
Wanjun Li,wjli,63,3637,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class factorial {
public:
    LL MAXX, MOD;
    VL f, ff;

    factorial(LL maxx = 200010, LL mod = 998244353) {
        MAXX = maxx;
        MOD = mod;

        f.RSZ(MAXX);
        ff.RSZ(MAXX);

        f[0] = 1;
        for (int i = 1; i < MAXX; i++) f[i] = (f[i - 1] * i) % MOD;
        for (int i = 0; i < MAXX; i++) ff[i] = mul_inv(f[i], MOD);
    }

    long long mul_inv(long long a, long long b)
    {
        long long b0 = b, t, q;
        long long x0 = 0, x1 = 1;
        if (b == 1) return 1;
        while (a > 1) {
            q = a / b;
            t = b, b = a % b, a = t;
            t = x0, x0 = x1 - q * x0, x1 = t;
        }
        if (x1 < 0) x1 += b0;
        return x1;
    }

    long long division(long long a, long long b) {		// (a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p
        long long ans, inv;
        inv = mul_inv(b, MOD);
        ans = ((a % MOD) * inv) % MOD;
        return ans;
    }

    LL calcc(LL n, LL a) {
        if (n == a) return 1;
        if (n == 0) return 0;
        if (n < a) return 0;
        LL ans = (f[n] * ff[a]) % MOD;
        ans = (ans * ff[n - a]) % MOD;
        return ans;
    }

    LL calcp(LL n, LL a) {
        LL ans = (f[n] * ff[n - a]) % MOD;
        return ans;
    }

    LL ball_in_box(LL box, LL ball) {    // # of ways of putting k balls to n boxes; boxes can be empty
        if (box == 0) return (ball == 0);
        LL ans = calcc(ball + box - 1, ball);
        return ans;
    }


    LL exp(LL base, LL n, LL MODD = -1) {
        LL mod;
        if (MODD == -1) mod = MOD;
        else mod = MODD;

        base %= mod;
        LL ans = 1, x = base, MAXLEVEL = 60, i;

        for (i = 0; i < MAXLEVEL; i++) {
            if ((1LL << i) > n) break;
            if ((1LL << i) & n) ans = (ans * x) % mod;
            x = (x * x) % mod;
        }
        return ans;
    }

    LL exp_abc(LL a, LL b, LL c) {  // a ^ (b ^ c) $ MOD where b and c can be very big
        // https://www.geeksforgeeks.org/find-power-power-mod-prime/#
        // Fermat's Little: a ^ (MOD - 1) = 1 % MOD
        // a ^ (b ^ c) % MOD = a ^ (b ^ c % (MOD - 1)) % MOD

        LL bc = exp(b, c, MOD - 1);
        LL ans = exp(a, bc);
        return ans;
    }


    LL sum_arithmetic_sequence(LL first_item, LL difference, LL n) {
        LL ans, last = (first_item + difference * (n - 1)) % MOD;
        ans = ((first_item + last) * n / 2) % MOD;

        return ans;
    }

    LL sum_geometry_sequence(LL first_item, LL ratio, LL n) {
        LL ans;

        if (ratio == 1) ans = (first_item * n) % MOD;
        else if (n == 1) ans = first_item;
        else {
        https://www.mathsisfun.com/algebra/sequences-sums-geometric.html
            LL rn = exp(ratio, n);
            ans = (first_item * (1 - rn + MOD)) % MOD;
            ans = division(ans, 1 - ratio + MOD) % MOD;
        }
        return ans;
    }
};

class Solution {
public:
	int countBalancedPermutations(string num) {
		LL n = num.length(), i, j, k, ans = 0, MOD = 1000000007, s, m, ss, sss, cc;
		VL ct(10, 0);
		s = 0;
		FOR(i, n) {
			ct[num[i] - '0']++;
			s += num[i] - '0';
		}
        factorial f(n + 100, MOD);

		if (s & 1) return 0;
        ss = s / 2;

		m = n / 2;

		// dp[digit][ct][sum] = # of ways
        VVL dp(m + 1, VL(ss + 1, 0)), dp2 = dp; 
        cc = 0;
        dp[0][0] = 1;
        FOR(i, 10) {
            if (ct[i] == 0) continue;
            cc += ct[i];
            swap(dp, dp2);
            dp.assign(m + 1, VL(ss + 1, 0));

            FOR(j, m + 1) {
                FOR(k, ss + 1) {
                    if (dp2[j][k] == 0) continue;

                    sss = k;
                    FOR(v, ct[i] + 1) {
                        if ((v + j > m) || (sss > ss)) break;
                        
                        LL x = (f.calcc(j + v, v) * f.calcc(cc - (j + v), (ct[i] - v))) % MOD;
						dp[j + v][sss] = (dp[j + v][sss] + dp2[j][k] * x) % MOD;
                        sss += i;
                    }
                }
            }

            k = 0;
        }

        ans = dp[m][ss];

		ans %= MOD;
		return ans;
	}
};

",1441316234
Kishan Jaiswal,kishan_jaiswal,64,3627,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) { return {dx, dy}; }

    vector<pair<int, int>> getDirections() {
        return {addDirection(-1, 0), addDirection(1, 0), addDirection(0, -1),
                addDirection(0, 1)};
    }

    int maxSum(int a, int b) { return max(a, b) + 1; }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();

        vector<vector<int>> minTime(
            rows, vector<int>(cols, numeric_limits<int>::max()));
        minTime[0][0] = 0;

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            queue;
        queue.push({0, 0, 0});

        auto directions = getDirections();

        while (!queue.empty()) {
            auto [currentTime, x, y] = queue.top();
            queue.pop();

            if (x == rows - 1 && y == cols - 1) {
                return currentTime;
            }

            if (currentTime > minTime[x][y]) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int newX = x + dx;
                int newY = y + dy;

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int newTime = maxSum(currentTime, moveTime[newX][newY]);

                    if (newTime < minTime[newX][newY]) {
                        minTime[newX][newY] = newTime;
                        queue.push({newTime, newX, newY});
                    }
                }
            }
        }

        return -1;
    }
};",1441321018
Kishan Jaiswal,kishan_jaiswal,64,3628,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) {
    return {dx, dy};
}

vector<pair<int, int>> getDirections() {
    return {addDirection(1, 0), addDirection(-1, 0), addDirection(0, 1), addDirection(0, -1)};
}

int calculateNextTime(int time, int moveTime, int moveDuration) {
    return max(time, moveTime) + moveDuration;
}

int minTimeToReach(vector<vector<int>>& moveGrid) {
    int rows = moveGrid.size(), cols = moveGrid[0].size();
    vector<vector<array<int, 2>>> minDist(rows, vector<array<int, 2>>(cols, {numeric_limits<int>::max(), numeric_limits<int>::max()}));
    
    minDist[0][0][0] = 0;
    
    priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> queue;
    queue.push({0, 0, 0, 0});

    auto directions = getDirections();

    while (!queue.empty()) {
        auto [time, x, y, parity] = queue.top();
        queue.pop();

        if (x == rows - 1 && y == cols - 1) {
            return time;
        }

        if (time > minDist[x][y][parity]) {
            continue;
        }

        int moveDuration = (parity == 0) ? 1 : 2;

        for (auto [dx, dy] : directions) {
            int newX = x + dx;
            int newY = y + dy;

            if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                int nextTime = calculateNextTime(time, moveGrid[newX][newY], moveDuration);
                int nextParity = 1 - parity;

                if (nextTime < minDist[newX][newY][nextParity]) {
                    minDist[newX][newY][nextParity] = nextTime;
                    queue.push({nextTime, newX, newY, nextParity});
                }
            }
        }
    }

    return -1;
}
};",1441322853
Kishan Jaiswal,kishan_jaiswal,64,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long  cnt=1;
        int n=num.size();
        long long  sum1=0;
        long long  sum2=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                sum1+=(num[i]-'0')%10;
            }else{
                sum2+=(num[i]-'0')%10;
            }
        }
        return sum1==sum2?true:false;
    }
};",1441301786
Kishan Jaiswal,kishan_jaiswal,64,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

using namespace std;

class Solution {
public:
    int countBalancedPermutations(string n) {
        const int MOD = 1000000007;
        int length = n.length();
        int totalSum = 0;
        vector<int> digitCount(10, 0);
        
        for (char digit : n) {
            digitCount[digit - '0']++;
            totalSum += (digit - '0');
        }
        if (totalSum % 2 != 0) return 0;
        
        int halfSum = totalSum / 2;
        int halfLength = (length + 1) / 2;
        vector<long> factorials(length + 1);
        factorials[0] = 1;
        
        for (int i = 1; i <= length; i++) 
            factorials[i] = multiply(factorials[i - 1], i, MOD);
        
        vector<long> inverseFactorials(length + 1);
        inverseFactorials[length] = calculateModInverse(factorials[length], MOD);
        
        for (int i = length - 1; i >= 0; i--) 
            inverseFactorials[i] = multiply(inverseFactorials[i + 1], (i + 1), MOD);
        
        vector<vector<long>> dpTable(halfLength + 1, vector<long>(halfSum + 1, 0));
        dpTable[0][0] = 1;

        for (int digit = 0; digit <= 9; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int k = halfLength; k >= 0; k--) {
                for (int s = halfSum; s >= 0; s--) {
                    if (dpTable[k][s] == 0) continue;
                    for (int t = 1; t <= digitCount[digit] && k + t <= halfLength && s + digit * t <= halfSum; t++) {
                        dpTable[k + t][s + digit * t] = add(dpTable[k + t][s + digit * t], multiply(dpTable[k][s], computeCombination(digitCount[digit], t, factorials, inverseFactorials, MOD), MOD), MOD);
                    }
                }
            }
        }

        long ways = dpTable[halfLength][halfSum];
        long result = multiply(factorials[halfLength], factorials[length - halfLength], MOD);
        
        for (int digit = 0; digit <= 9; digit++) {
            result = multiply(result, inverseFactorials[digitCount[digit]], MOD);
        }
        
        result = multiply(result, ways, MOD);
        return static_cast<int>(result);
    }

private:
    long add(long a, long b, int mod) {
        return (a + b) % mod;
    }

    long multiply(long a, long b, int mod) {
        return (a * b) % mod;
    }

    long calculateModInverse(long a, int mod) {
        long result = 1;
        long exponent = mod - 2;
        long base = a;
        while (exponent > 0) {
            if ((exponent & 1) == 1) {
                result = multiply(result, base, mod);
            }
            base = multiply(base, base, mod);
            exponent >>= 1;
        }
        return result;
    }

    long computeCombination(int n, int k, const vector<long>& factorials, const vector<long>& invFactorials, int mod) {
        if (k > n) return 0;
        return multiply(factorials[n], multiply(invFactorials[k], invFactorials[n - k], mod), mod);
    }
};
",1441329757
SheenYangYun,SheenYangYun,65,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vvi dp = init(n, m);
        dp[0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(stateStart(0, 0, 0));
        vector<int> directions = { -1, 0, 1, 0, -1 };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (ff(current, n, m)) return current.time;
            if (fff(current, dp)) continue;
            children(current, moveTime, dp, pq, directions, n, m);
        }
        return -1;
    }

private:
    vvi init(int n, int m) {
        return vvi(n, vector<int>(m, INT32_MAX));
    }

    State stateStart(int time, int x, int y) {
        return State{ time, x, y };
    }

    bool ff(const State& state, int n, int m) {
        return state.x == n - 1 && state.y == m - 1;
    }

    bool fff(const State& state, const vvi& dp) {
        return state.time > dp[state.x][state.y];
    }

    bool chek(int x, int y, int n, int m) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    void children(const State& current, const vvi& moveTime, 
                         vvi& dp, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vector<int>& directions, int n, int m) {
        for(int k = 0; k < 4; ++k){
            int newX = current.x + directions[k];
            int newY = current.y + directions[k + 1];
            if(chek(newX, newY, n, m)){
                int newTime = max(current.time, moveTime[newX][newY]) + 1;
                if(newTime < dp[newX][newY]){
                    dp[newX][newY] = newTime;
                    pq.push(stateStart(newTime, newX, newY));
                }
            }
        }
    }
};

",1441321118
SheenYangYun,SheenYangYun,65,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
    int p;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vvi> dist = init(n, m);
        dist[0][0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(start(0, 0, 0, 0));
        vvi dirs = { {1,0},{-1,0},{0,1},{0,-1} };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (solved(current, n, m)) return current.time;
            if (possible(current, dist)) continue;
            chuildren(current, moveTime, dist, pq, dirs, n, m);
        }
        return -1;
    }

private:
    vector<vvi> init(int n, int m) {
        return vector<vvi>(n, vvi(m, vector<int>(2, INT32_MAX)));
    }

    State start(int time, int x, int y, int p) {
        return State{ time, x, y, p };
    }

    bool solved(const State& state, int n, int m) {
        return state.x == n -1 && state.y == m -1;
    }

    bool possible(const State& state, const vector<vvi>& dist) {
        return state.time > dist[state.x][state.y][state.p];
    }

    bool check(int x, int y, int n, int m) {
        return x >=0 && x <n && y >=0 && y <m;
    }

    void chuildren(const State& current, const vvi& moveTime, 
                         vector<vvi>& dist, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vvi& dirs, int n, int m) {
        int moveDuration = current.p == 0 ? 1 : 2;
        for(auto &d : dirs){
            int nx = current.x + d[0];
            int ny = current.y + d[1];
            if(check(nx, ny, n, m)){
                int nextTime = max(current.time, moveTime[nx][ny]) + moveDuration;
                int nextP = current.p == 0 ? 1 : 0;
                if(nextTime < dist[nx][ny][nextP]){
                    dist[nx][ny][nextP] = nextTime;
                    pq.push(start(nextTime, nx, ny, nextP));
                }
            }
        }
    }
};
",1441314554
SheenYangYun,SheenYangYun,65,3636,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    bool isBalanced(const string &num)
    {
        int cnt1 = 0;
        int cnt2 = 0;

        for (int i = 0; i < num.size(); ++i)
        {
            int digit = num[i] - '0';
            if (i & 1)
            {
                cnt2 += digit;
                continue;
            }

            cnt1 += digit;
        }

        return cnt1 == cnt2;
    }
};
",1441323172
SheenYangYun,SheenYangYun,65,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int freq[10] = {0};
        for (char c : num)
        {
            freq[c - '0']++;
        }

        int n = num.size();
        int nEven = (n + 1) / 2;
        int nOdd = n / 2;

        ll sum = 0;
        for (int d = 0; d < 10; d++)
        {
            sum += (ll)d * freq[d];
        }

        if (sum & 1)
        {
            return 0;
        }

        ll des = sum / 2;

        vector<vector<ll>> dp(nEven + 1, vector<ll>(des + 1, 0));
        dp[0][0] = 1;

        vector<ll> fact(n + 1, 1);
        for (int i = 1; i <= n; i++)
        {
            fact[i] = fact[i - 1] * i % MOD;
        }

        auto pow_mod = [&](ll a, ll b) -> ll
        {
            ll res = 1;
            a %= MOD;
            while (b > 0)
            {
                if (b & 1)
                {
                    res = res * a % MOD;
                }
                a = a * a % MOD;
                b >>= 1;
            }
            return res;
        };

        vector<ll> invFact(n + 1, 1);
        invFact[n] = pow_mod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
        {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }

        ll inFact = 1;
        for (int d = 0; d < 10; d++)
        {
            inFact = inFact * invFact[freq[d]] % MOD;
        }

        for (int d = 0; d < 10; d++)
        {
            int c = freq[d];
            if (c == 0)
                continue;

            for (int k = nEven; k >= 0; k--)
            {
                for (ll s = des; s >= 0; s--)
                {
                    if (dp[k][s] == 0)
                    {
                        continue;
                    }

                    int max_m = min(c, nEven - k);
                    for (int m = 1; m <= max_m; m++)
                    {
                        ll newK = k + m;
                        ll newS = s + (ll)d * m;
                        if (newS > des)
                        {
                            break;
                        }

                        ll comb_val = fact[c] * invFact[m] % MOD;
                        comb_val = comb_val * invFact[c - m] % MOD;

                        dp[newK][newS] = (dp[newK][newS] + dp[k][s] * comb_val) % MOD;
                    }
                }
            }
        }

        ll ans = dp[nEven][des];
        if (ans != 0)
        {

            ans = ans * fact[nEven] % MOD;
            ans = ans * fact[nOdd] % MOD;
            ans = ans * inFact % MOD;

            return (int)(ans);
        }

        return 0;
    }
};
",1441307925
Tin,tin_le,67,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, std::greater<array<ll, 3>>> minHeap;
        minHeap.push({0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<ll>> dp(n, vector<ll>(m, INF));
        dp[0][0] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)(cost + 1), (ll)moveTime[row][col] + 1);
                if(newCost < dp[row][col]) {
                    dp[row][col] = newCost;
                    minHeap.push({newCost, row, col});
                }
            }
        }
        return -1;
    }
};",1441296900
Tin,tin_le,67,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, std::greater<array<ll, 4>>> minHeap;
        minHeap.push({0, 0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        dp[0][0][0] = dp[0][0][1] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j, k] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j][k]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)cost, (ll)moveTime[row][col]) + (k == 0 ? 1 : 2);
                if(newCost < dp[row][col][!k]) {
                    dp[row][col][!k] = newCost;
                    minHeap.push({newCost, row, col, !k});
                }
            }
        }
        return -1;
    }
};",1441301018
Tin,tin_le,67,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        int n = num.size();
        for(int i = 0; i < n; i++) {
            if(i & 1) odd += num[i] - '0';
            else even += num[i] - '0';
        }
        return odd == even;
    }
};",1441280985
Tin,tin_le,67,3637,cpp,"//
//
//
//
//
//
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vvpll vt<vpll>
#define vvvll vt<vvll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
class Combinatoric {    
    public: 
    int n;  
    vll fact, inv;   
    Combinatoric(int n) {   
        this->n = n;    
        fact.rsz(n + 1), inv.rsz(n + 1);
        init();
    }
        
    void init() {   
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {   
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        inv[n] = modExpo(fact[n], MOD - 2, MOD);
        for(int i = n - 1; i >= 0; i--) {   
            inv[i] = (inv[i + 1] * (i + 1)) % MOD;
        }
    }
    
    ll choose(ll a, ll b) {  
		if(a < b) return 0;
        return fact[a] * inv[b] % MOD * inv[a - b] % MOD;
    }
};
class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        int freq[10] = {};
        for(auto& x : s) {
            freq[x - '0']++;
        }
        ll sm = 0;
        for(int i = 0; i <= 9; i++) {
            sm += (ll)i * freq[i];
        }
        if(sm % 2) return 0;
        ll target = sm / 2;
        int k = (n + 1) / 2, l = n / 2;
        Combinatoric comb(n + 1);
        vector<vector<ll>> dp(k + 1, vector<ll>(target + 1));
        dp[0][0] = 1;
        for(int d = 0; d <= 9; d++) {
            if(freq[d] == 0) continue;
            for(int c = k; c >= 0; c--) {
                for(ll S = target; S >= 0; S--) {
                    if(dp[c][S] == 0) continue;
                    for(int cnt = 1; cnt <= freq[d] && cnt <= k - c; cnt++) {
                        if(S + d * cnt > target) break;
                        auto& A = dp[c + cnt][S + d * cnt];
                        A = (A + dp[c][S] * comb.choose(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        ll prod = 1;
        for(int d = 0; d <= 9; d++) {
            prod = prod * comb.fact[freq[d]] % MOD;
        }
        return (dp[k][target]) * comb.fact[k] % MOD * comb.fact[l] % MOD * modExpo(prod, MOD - 2, MOD) % MOD;
    }
};",1441323448
despair of athkatla,nibbas,68,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        vis = [[math.inf] * m for _ in range(n)]
        heap = [(0, 0, 0)]
        vis[0][0] = 0
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if x == n-1 and y == m-1:
                return t
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(heap, (nt, nx, ny))",1441292174
despair of athkatla,nibbas,68,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        INF = math.inf
        dist = [[INF]*m for _ in range(n)]
        dist[0][0] = 0
        heap = []
        heappush(heap, (0, 0, 0, 0))
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y, p = heappop(heap)
            if x == n-1 and y == m-1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0<=nx<n and 0<=ny<m:
                    d = 1 if p ==0 else 2
                    nt = max(t, moveTime[nx][ny]) + d
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(heap, (nt, nx, ny, 1 - p))
        return -1",1441298863
despair of athkatla,nibbas,68,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441282709
despair of athkatla,nibbas,68,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
  
  const long long INF = 9223372036854775807;

  #ifndef ONLINE_JUDGE
  #define WATCH(key, val)                                                        \
    printf(""Watched %s ->  %s \n"", key, std::to_string(val).c_str());
  #define WATCH_CONTAINER(key, val)                                              \
    printf(""Watched %s : "", key);                                                \
    for (auto e : val)                                                           \
      printf("" %s"", std::to_string(e).c_str());                                  \
    printf(""\n"");
  #define WATCH_MAP(map)                                                         \
    printf(""Watching Map\n"");                                                    \
    for (auto e : map)                                                           \
      printf(""%s -> %s\n"", std::to_string(e.first).c_str(),                      \
            std::to_string(e.second).c_str());                                  \
    printf(""\n"");
  #else
  #define WATCH(key, val)                                                        \
    do {                                                                         \
    } while (false);
  #define WATCH_CONTAINER(key, val)                                              \
    do {                                                                         \
    } while (false);
  #define WATCH_MAP(map)                                                         \
    do {                                                                         \
    } while (false);
  #endif

  #ifdef FAST_EXECUTION
  #pragma GCC optimize(""O3"")
  #pragma comment(linker, ""/stack:247474112"")
  #endif

  #define REP(n) for(int t=0; t<n; t++)
  #define FOR(i, n) for (i = 0; i < n; i++)
  #define FFOR(i, j, n) for(i = j; j < n; j++)
  #define FOR_S(i, n, k) for (i = 0; i < n; i += k)
  #define RFOR(i, n) for (i = n - 1; i >= 0; i--)
  #define RFOR_S(i, n, k) for (i = n - 1; i >= 0; i -= k)
  #define MAX_OF(x, y) ((x > y) ? x : y)
  #define MIN_OF(x, y) ((x > y) ? y : x)
  #define MIN_IN(A) *(std::min_element(A.begin(), A.end()));
  #define MAX_IN(A) *(std::max_element(A.begin(), A.end()));
  #define MAX_AT(A) (std::max_element(A.begin(), A.end()) - A.begin());
  #define MIN_AT(A) (std::min_element(A.begin(), A.end()) - A.begin());
  #define TESTCASE                                                              \
    int testcase;                                                               \
    std::cin>>testcase;                                                         \
    while(testcase--)
  #define GCD(a,b) std::__gcd(a,b);
  #define LCM(a,b) (a)*((b)/std::__gcd(a,b));
  #define SORT(A) std::sort(A.begin(), A.end());
  #define RSORT(A) std::sort(A.rbegin(), A.rend());
  #define REVERSE(A) std::reverse(A.begin(), A.end());
  #define ANY(container, result, condition)                                      \
    result = false;                                                              \
    for (const auto &e : container)                                              \
      if (condition(e)) {                                                        \
        result = true;                                                           \
        break;                                                                   \
      }
  #define ALL(container, result, condition)                                      \
    result = true;                                                               \
    for (const auto &e : container)                                              \
      if (!condition(e)) {                                                       \
        result = false;                                                          \
        break;                                                                   \
      }
  #ifdef INTERACTIVE_MODE
  #define iprint(...)                                                            \
    printf(__VA_ARGS__);                                                         \
    fflush(stdout);
  #else
  #define iprint(...) printf(__VA_ARGS__);
  #endif

  #define LL long long
  #define L long
  #define ULL unsigned long long
  #define I int
  #define D double
  #define UI unsigned int
  #define VEC(i) std::vector<i>
  #define MAP(a, b) std::map<a, b>
  #define UMAP(a, b) std::unordered_map<a, b>
  #define SET(a) std::set<a>
  #define USET(a) std::unordered_set<a>
  #define MSET(a) std::multiset<a>
  #define STR std::string
  #define PAIR(a,b) std::pair<a,b>
  #define PAIRI std::pair<int, int>
  #define READ_INT(var) scanf(""%d"", &var)
  #define READ_STR(var) std::cin >> var
  #define READ_LONG(var) scanf(""%lld"", &var)
  #define WRITE_INT(var) printf(""%d"", var)
  #define WRITE_LONG(var) printf(""%lld"", var)
  #define WRITE_STR(var) std::cout << var
  #define WRITE_VEC_LL(val)                                                      \
    for (auto e : val)                                                           \
      printf(""%lld "", e);
  #define WRITE_VEC_I(val)                                                       \
    for (auto e : val)                                                           \
      printf(""%d "", e);
      
  #define pb push_back
  #define eb emplace_back


class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> cnt(10, 0);
        int S = 0;
        for (char ch : s) {
            cnt[ch - '0']++;
            S += (ch - '0');
        }
        
        if (S % 2 != 0) return 0;
        
        int T = S / 2;
        int K = (n + 1) / 2;
    
        vector<long long> F(n + 1, 1), IF(n + 1, 1);
        for (int i = 1; i <= n; i++) F[i] = F[i - 1] * i % MOD;

        auto pw = [&](ll a, ll b) -> ll {
            ll R = 1;
            a %= MOD;
            while (b > 0) {
                if (b & 1) R = R * a % MOD;
                a = a * a % MOD;
                b >>= 1;
            }
            return R;
        };
        
        IF[n] = pw(F[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) IF[i] = IF[i + 1] * (i + 1) % MOD;
        
        vector<vector<long long>> dp(K + 1, vector<long long>(T + 1, 0));
        dp[0][0] = 1;
        
        for (int d = 0; d <= 9; d++) {
            if (cnt[d] == 0) continue;
            for (int t = K; t >= 0; t--) {
                for (int s = T; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int x = 1; x <= min(cnt[d], K - t) && s + x * d <= T; x++) {
                        dp[t + x][s + x * d] = (dp[t + x][s + x * d] + dp[t][s] * F[cnt[d]] % MOD * IF[x] % MOD * IF[cnt[d] - x] % MOD) % MOD;
                    }
                }
            }
        }
        
        ll R = dp[K][T] * F[K] % MOD * F[n - K] % MOD;
        for (int d = 0; d <= 9; d++) {
            R = R * IF[cnt[d]] % MOD;
        }
        
        return (int)R;
    }
};
",1441316716
Lucky Orb,megurine,69,3627,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + 1, xx, yy))
        # print(f)
        return f[n - 1][m - 1]
        ",1441300238
Lucky Orb,megurine,69,3628,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + (x + y) % 2 + 1, xx, yy))
        print(f)
        return f[n - 1][m - 1]
""""""
[[0,58],[27,69]]
71
""""""",1441304557
Lucky Orb,megurine,69,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        return sum(map(int, s[::2])) == sum(map(int, s[1::2]))",1441281574
Lucky Orb,megurine,69,3637,cpp,"#include <bits/stdc++.h>

#ifdef MEGURINE
#include ""algo/debug.h""
#include ""algo/debug_lc.h""
#else
#define debug(...) 42
#endif

using namespace std;

auto __fast_io__ = [] {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

#define itr(it) begin(it), end(it)

// @formatter:off
template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a;
        swap(a, m);
        u -= t * v;
        swap(u, v);
    }
    assert(m == 1);
    return u;
}

template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() :
        value() {}

    template <typename U>
    Modular(const U &x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U &x) {
        Type v;
        if (-mod() <= x && x < mod())
            v = static_cast<Type>(x);
        else
            v = static_cast<Type>(x % mod());
        if (v < 0)
            v += mod();
        return v;
    }

    const Type &operator()() const { return value; }

    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }

    constexpr static Type mod() { return T::value; }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= mod())
            value -= mod();
        return *this;
    }

    Modular &operator-=(const Modular &other) {
        if ((value -= other.value) < 0)
            value += mod();
        return *this;
    }

    template <typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template <typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }
    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(
        const Modular &rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }

    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type &abs(const Modular &x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename U>
    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename V, typename U>
    friend V &operator>>(V &stream, Modular<U> &number);

    template <typename V>
    operator V() { return (V)value; }

private:
    Type value;
};

template <typename T>
bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }

template <typename T, typename U>
bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }

template <typename T, typename U>
bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }

template <typename T>
bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T>
bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }

template <typename T>
Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T>
Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T>
Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T>
Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> power(const Modular<T> &a, const U &b) {
    if (b < 0)
        return 1 / power(a, -b);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1)
            res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}

template <typename T>
bool IsZero(const Modular<T> &number) {
    return number() == 0;
}

template <typename T>
string to_string(const Modular<T> &number) {
    return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U &operator<<(U &stream, const Modular<T> &number) {
    return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U &operator>>(U &stream, Modular<T> &number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}

//using ModType = int;
//
//struct VarMod { static ModType value; };
//ModType VarMod::value;
//ModType &md = VarMod::value;
//using Mint = Modular<VarMod>;

// constexpr int md = 998244353;
constexpr int md = 1e9 + 7;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
// @formatter:on

vector<Mint> fact;
vector<Mint> inv_fact;

Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int)fact.size() < n + 1) {
        if (fact.empty()) {
            fact = inv_fact = {1};
            continue;
        }
        fact.push_back(fact.back() * (int)fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        int m = 0, k1 = (s.size() + 1) / 2, k2 = s.size() - k1;
        vector<int> cnt(10);
        for (char x : s)
            m += x - '0', cnt[x - '0']++;
        if (m % 2)
            return 0;
        m /= 2;
        if (m == 0)
            return 1;
        vector f(k2 + 1, vector<Mint>(m + 1));
        f[0][0] = 1;
        int p = 0, q = 0;
        for (int x = 0; x < 10; ++x) {
            if (!cnt[x]) continue;
            vector h(k2 + 1, vector<Mint>(m + 1));
            p += cnt[x], q += cnt[x] * x;
            for (int i = 0; i <= k2 && i + cnt[x] <= p; ++i) {
                for (int j = 0; j <= m; ++j) {
                    for (int k = 0; k <= cnt[x]; ++k) {
                        int ii = i + k, jj = j + x * k;
                        if (ii <= k2 && jj <= m && p - ii <= k1 && q - jj <= m) {
                            h[ii][jj] += f[i][j] * C(k2 - i, k) * C(k1 - (p - cnt[x] - i), cnt[x] - k);
                        }
                    }
                }
            }
            h.swap(f);
        }
        return f[k2][m];
    }
};

#ifdef MEGURINE

int main() {
    freopen(""../input.txt"", ""r"", stdin);
    freopen(""../output.txt"", ""w"", stdout);
    clock_t start_time = clock();
    int T;
    cin >> T;
    getchar();
    while (T--) {
        Solution sol;
        test<string>(sol, &Solution::countBalancedPermutations);
    }
    cout << ""\nExecution Time: "" << static_cast<double>(clock() - start_time) / CLOCKS_PER_SEC * 1000 << ""ms"" << endl;
    return 0;
}

#endif
",1441330841
4dalols,4dalols,70,3627,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441317045
4dalols,4dalols,70,3628,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1+(cx+cy)%2; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441316390
4dalols,4dalols,70,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int t=0,i=1;
        for (auto r:s) {
            t+=i*(r-'0');
            i=-i;
        }
        return t==0;
    }
};",1441318720
4dalols,4dalols,70,3637,cpp,"class Solution {
public:
    const int MX = 100;
    long long F[101], Fi[101], mod=1e9+7;
     
    long long pw(long long b, long long e) {
    	int x=1;
    	while (e) {
    		if (e%2) x=x*b%mod; 
    		b=b*b%mod; 
    		e/=2; 
    	}
    	return x;
    }
     
    long long nCk(int n, int k) {
        if (k>n||k<0) return 0;
        return F[n]*Fi[k]%mod*Fi[n-k]%mod;
    }
     
    void initC() {
    	F[0]=1;
    	for (int i = 1; i <= MX; i++) F[i]=F[i-1]*i%mod;
        Fi[MX]=pw(F[MX],mod-2);
    	for (int i = MX; i; i--) Fi[i-1]=Fi[i]*i%mod;
    }
     
    int countBalancedPermutations(string s) {
        int n= s.size(); 
        initC();
        int t=0;
        map<int,int> m; 
        for (auto r:s) {
            m[r-'0']++;
            t+=r-'0'; 
        }
        if (t%2) return 0;
        vector<vector<long long>> dp(n+1,vector<long long>(t+1)); dp[0][0]=1; 
        int x=0;
        for (auto [a,b]:m) {
            x+=b;
        vector<vector<long long>> dp2(n+1,vector<long long>(t+1));
            // cout << a << "" "" << b << endl; 
            for (int i = 0; i <= b; i++) {
                for (int j = n; j>=i; j--) {
                    for (int k=t;k>=a*i;k--) {
                        (dp2[j][k]+=dp[j-i][k-a*i]*nCk(j,i)%mod*nCk(x-j,b-i))%=mod;
                    }
                }
            }
            dp=dp2;
        // for (auto r:dp) {
        //     for (int j:r) cout << j << "" ""; cout << ""\n"";
        // } cout << ""\n"";
        }
        return dp[(n+1)/2][t/2]; 
    }
};",1441307470
Brijesh Siwach,Dhongee,71,3627,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 1 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};",1441337879
Brijesh Siwach,Dhongee,71,3628,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 2 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};
",1441336728
Brijesh Siwach,Dhongee,71,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int s1 = 0,s2=0;
        for(int i = 0 ; i < n; i++){
            if(i%2) s1+=(s[i]-'0');
            else s2+=(s[i]-'0');
        }
        return s1==s2;
    }
};",1441339150
Brijesh Siwach,Dhongee,71,3637,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:

    ll binpow(ll a,ll b,const int mod){
        ll res=1;
        while(b>0) {
            if(b&1) res=res*a%mod;
            b>>=1;
            a=a*a%mod;
        }
        return res;
    }

    int countBalancedPermutations(string s) {
        int n = s.size();
        const int mod=1e9+7;
        vector<ll> fact(n+1,1);
        vector<ll> inv(n+1);
        for(int i = 1; i <= n; i++){
            fact[i] = fact[i-1] * i % mod;
        }
        for(int i = 0; i <= n; i++){
            inv[i] = binpow(fact[i], mod-2, mod);
        }   

        auto mul = [&](ll x,ll y)->ll{
            return (x%mod * y%mod)%mod;
        };
        auto add = [&](ll x,ll y)->ll{
            return (x%mod + y%mod)%mod;
        };

        vector<ll>f(10);
        int sum = 0;
        for(auto x: s) {
            f[x-'0']++;
            sum += (x-'0');
        }
        const int M = 8e2;
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (n+1, vector<ll> (M, -1)));

        function<ll(int,int,int)>go=[&](int pos,int ot, int ost) -> ll{
            if(pos==10) {
                if(ot != (n+1)/2) return 0;
                if(ost != sum - ost) return 0;
                return mul(fact[ot], fact[n-ot]);
            }

            if(dp[pos][ot][ost] == -1) {
                ll ans = 0;
                for(int i = 0; i <= f[pos]; i++){
                    ll val = mul(inv[i], inv[f[pos]-i]);

                    ans = add(ans, mul(go(pos+1,ot+i,ost+i*pos),val));
                }
                dp[pos][ot][ost]=ans;
            }
            return dp[pos][ot][ost];
        };

        ll ans = go(0, 0, 0);

        return ans;

    }
};
",1441315427
Rastsislau Matusevich,rastsislau,72,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int move_time = max(t, moveTime[new_x][new_y]) + 1;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441301173
Rastsislau Matusevich,rastsislau,72,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int cost = (x + y) % 2 + 1;
                        int move_time = max(t, moveTime[new_x][new_y]) + cost;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441305087
Rastsislau Matusevich,rastsislau,72,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector <int> sum(2,0);
        int i=0;
        for (auto x: num)
            {
                sum[i%2]+=(x-'0');
                i++;
            }
        return sum[0] == sum[1];
    }
};",1441281746
Rastsislau Matusevich,rastsislau,72,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10**9 + 7
        counts = [0] * 10
        total_sum = 0
    
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total_sum += d
    
        if total_sum % 2 != 0:
            return 0
    
        n_even = (n + 1) // 2 
        n_odd = n // 2 
    
        max_s = n_even * 9
    
        max_fact = n + 1
        fact = [1] * (max_fact)
        inv_fact = [1] * (max_fact)
        for i in range(1, max_fact):
            fact[i] = (fact[i - 1] * i) % MOD
        inv_fact[max_fact - 1] = pow(fact[max_fact - 1], MOD - 2, MOD)
        for i in range(max_fact - 2, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
    
        comb_cache = {}
        def nCk(n, k):
            if k < 0 or k > n:
                return 0
            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD
    
        dp = [ [0] * (n_even + 1) for _ in range(total_sum // 2 + 1) ]
        dp[0][0] = 1
    
        for d in range(10):
            c_d = counts[d]
            if c_d == 0:
                continue
            dp_new = [row[:] for row in dp]
            for c in range(1, c_d + 1):
                comb_cd_c = nCk(c_d, c)
                delta_s = c * d
                for s in range(total_sum // 2 - delta_s + 1):
                    for k in range(n_even - c +1):
                        dp_new[s + delta_s][k + c] = (dp_new[s + delta_s][k + c] + dp[s][k] * comb_cd_c) % MOD
            dp = dp_new
    
        total_ways = dp[total_sum // 2][n_even]
        if total_ways == 0:
            return 0
    
        numerator = (total_ways * fact[n_even] % MOD) * fact[n_odd] % MOD
        denom = 1
        for c in counts:
            denom = (denom * fact[c]) % MOD
    
        answer = numerator * pow(denom, MOD - 2, MOD) % MOD
        return answer
        ",1441332810
PyIsTheBestLang,PyIsTheBestLang,76,3627,python3,"
def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        dis = [[math.inf] * n for _ in range(m)]
        dis[0][0] = 0
        stack = [(0, 0, 0)]
        while stack:
            d, i, j = heappop(stack)
            
            if dis[i][j] < d:
                continue
            
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0<=a+i<m and 0<=b+j<n:
                    dj = max(d + 1, moveTime[i+a][j+b]+1)
                    if dj < dis[a+i][b+j]:
                        dis[a+i][b+j] = dj
                        heappush(stack, (dj, a+i, j+b))
        ans = dis[-1][-1]
        return ans ",1441302684
PyIsTheBestLang,PyIsTheBestLang,76,3628,python3,"
def max(a, b):
    return a if a > b else b




class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        k = 2
        dis = [[[math.inf] * k for _ in range(n)] for _ in range(m)]
        dis[0][0][0] = 0
        stack = [(0, 0, 0, 0)]
        while stack:
            d, s, i, j = heappop(stack)

            if dis[i][j][s] < d:
                continue
   
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0 <= a + i < m and 0 <= b + j < n:
                    if s == 0:
                        dj = max(d+s+1, moveTime[i + a][j + b]+1)
                    else:
                        dj = max(d+ s + 1, moveTime[i + a][j + b]+2)  
                        
                    if dj < dis[a + i][b + j][(s+1)%2]:
                        dis[a + i][b + j][(s+1)%2] = dj
                        heappush(stack, (dj, (s+1)%2, a + i, j + b))
        ans = min(dis[-1][-1])
        return ans ",1441309881
PyIsTheBestLang,PyIsTheBestLang,76,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) for i in range(1, n, 2)) ==  sum(int(num[i]) for i in range(0, n, 2))",1441302566
PyIsTheBestLang,PyIsTheBestLang,76,3637,python3,"import math
from functools import lru_cache
from itertools import accumulate


# from sortedcontainers import SortedList
# sys.set_int_max_str_digits(0)  # for big number in leet code


def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


mod = 10 ** 9 + 7


class Combinatorics:
    def __init__(self, n, mod):
        assert mod > n
        self.n = n + 10
        self.mod = mod

        self.perm = [1]
        self.rev = [1]
        self.inv = [0]
        self.fault = [0]

        self.build_perm()
        self.build_rev()
        self.build_inv()
        self.build_fault()
        return

    def build_perm(self):
        self.perm = [1] * (self.n + 1)  # (i!) % mod
        for i in range(1, self.n + 1):
            self.perm[i] = self.perm[i - 1] * i % self.mod
        return

    def build_rev(self):
        self.rev = [1] * (self.n + 1)  # pow(i!, -1, mod)
        self.rev[-1] = pow(self.perm[-1], -1, self.mod)  # GcdLike().mod_reverse(self.perm[-1], self.mod)
        for i in range(self.n - 1, 0, -1):
            self.rev[i] = (self.rev[i + 1] * (i + 1) % self.mod)  # pow(i!, -1, mod)
        return

    def build_inv(self):
        self.inv = [0] * (self.n + 1)  # pow(i, -1, mod)
        self.inv[1] = 1
        for i in range(2, self.n + 1):
            self.inv[i] = (self.mod - self.mod // i) * self.inv[self.mod % i] % self.mod
        return

    def build_fault(self):
        self.fault = [0] * (self.n + 1)  # fault permutation
        self.fault[0] = 1
        self.fault[2] = 1
        for i in range(3, self.n + 1):
            self.fault[i] = (i - 1) * (self.fault[i - 1] + self.fault[i - 2])
            self.fault[i] %= self.mod
        return

    def comb(self, a, b):
        if a < b:
            return 0
        res = self.perm[a] * self.rev[b] * self.rev[a - b]  # comb(a, b) % mod = (a!/(b!(a-b)!)) % mod
        return res % self.mod

    def factorial(self, a):
        res = self.perm[a]  # (a!) % mod
        return res % self.mod

    def inverse(self, n):
        res = self.perm[n - 1] * self.rev[n] % self.mod  # pow(n, -1, mod)
        return res

    def catalan(self, n):
        res = (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod
        return res


cb = Combinatorics(200, mod)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        @lru_cache(None)
        def dfs(i, k, pre):
            if k > odd or (m - odd) > even:
                return 0
            if i == 10:
                return pre == 0
            
            
            res = 0
            rest_odd = odd-k
            rest_even = post[-1] - post[i]-rest_odd
            for xx in range(cnt[i] + 1):
                res += dfs(i + 1, k + xx, pre + xx * i - (cnt[i] - xx) * i)*cb.comb(rest_odd, xx)*cb.comb(rest_even, cnt[i]-xx)
            return res % mod

        num = sorted(num)
        m = len(num)
  
        cnt = [0] * 10
        odd = m // 2 + m % 2
        even = m - odd
        for x in num:
            cnt[int(x)] += 1
        post = list(accumulate(cnt, initial=0))
        ans = dfs(0, 0, 0)
        return ans
",1441320219
Xiong_Jiangkai,xlyy,77,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y = q[0]
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n and visited[x_new][y_new] == -1:
                    t_max = max(t, moveTime[x_new][y_new]) + 1
                    visited[x_new][y_new] = t_max
                    heapq.heappush(q, (t_max, x_new, y_new))
        return visited[-1][-1] ",1441316739
Xiong_Jiangkai,xlyy,77,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0, 1)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y, dt = q[0]
            dt_new = 2 if dt == 1 else 1
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n:
                    t_max = max(t, moveTime[x_new][y_new])
                    if (visited[x_new][y_new] == -1 or visited[x_new][y_new] > t_max + dt):
                        visited[x_new][y_new] = t_max + dt
                        heapq.heappush(q, (t_max + dt, x_new, y_new, dt_new))
        return visited[-1][-1] ",1441313622
Xiong_Jiangkai,xlyy,77,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        n = len(num)
        sum1 = sum2 = 0
        for i in range(0, n, 2):
            sum1 += int(num[i])
        for i in range(1, n, 2):
            sum2 += int(num[i])
        return sum1 == sum2",1441281965
Xiong_Jiangkai,xlyy,77,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = int(1e9)+ 7
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
    
        counts = [0] * 10
        total = 0
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total += d
    
        if total %2 != 0:
            return 0
        S = total // 2
    
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] *i % MOD
    
        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


        
        dp_prev = [[0] * (n_even + 1) for _ in range(S + 1)]
        dp_prev[0][0] = 1
        for d in range(10):
            c_d = counts[d]
            if c_d ==0:
                dp_curr = [row[:] for row in dp_prev]
            else:
                dp_curr = [[0] * (n_even + 1) for _ in range(S + 1)]
                k_min = max(0, c_d - n_odd)
                for s in range(S + 1):
                    for c in range(n_even + 1):
                        val = dp_prev[s][c]
                        if val == 0:
                            continue
                        for k in range(k_min, min(c_d, n_even - c) + 1):
                            new_s = s + d * k
                            if new_s > S:
                                continue
                            new_c = c + k
                            if new_c > n_even:
                                continue
                            add_val = val * inv_fact[k] % MOD
                            add_val = add_val * inv_fact[c_d - k] % MOD
                            dp_curr[new_s][new_c] = (dp_curr[new_s][new_c] + add_val) % MOD
                dp_prev = dp_curr
    
        dp_final = dp_prev[S][n_even]
        res = fact[n_even] * fact[n_odd] % MOD
        res = res * dp_final % MOD
        return res",1441334143
Meet Brahmbhatt,MeetBrahmbhatt,78,3627,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 1;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334615
Meet Brahmbhatt,MeetBrahmbhatt,78,3628,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 2;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334276
Meet Brahmbhatt,MeetBrahmbhatt,78,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < (int) s.size(); i++) {
            sum += (s[i] - '0') * (i & 1 ? -1 : 1);
        }
        return !sum;
    }
};",1441322261
Meet Brahmbhatt,MeetBrahmbhatt,78,3637,cpp,"constexpr int32_t MOD = 1e9 + 7;
// constexpr int32_t MOD = 998244353;

struct Mint {
    int val;
    Mint(long long v = 0) {
        if (v < 0) {
            v = v % MOD + MOD;
        }
        if (v >= MOD) {
            v %= MOD;
        }
        val = v;
    }
    static int mod_inv(int a, int m = MOD) {
        int g = m, r = a, x = 0, y = 1;
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
        return x < 0 ? x + m : x;
    }
    explicit operator int() const {
        return val;
    }
    Mint& operator+=(const Mint &other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    Mint& operator-=(const Mint &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    typedef unsigned long long ull;
    ull fast_mod(ull a, ull b, ull M = MOD) {
        long long ret = a * b - M * ull(1.L / M * a * b);
        return ret + M * (ret < 0) - M * (ret >= (long long)M);
    }
    Mint& operator*=(const Mint &other) {
        val = fast_mod((ull) val, other.val);
        return *this;
    }
    Mint& operator/=(const Mint &other) {
        return *this *= other.inv();
    }
    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }
    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }
    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }
    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }
    Mint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
    Mint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }
    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }
    Mint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
    bool operator==(const Mint &other) const { return val == other.val; }
    bool operator!=(const Mint &other) const { return val != other.val; }
    Mint inv() const {
        return mod_inv(val);
    }
    Mint pow(long long p) const {
        assert(p >= 0);
        Mint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            a *= a;
            p >>= 1;
        }
        return result;
    }
    friend ostream& operator<<(ostream &stream, const Mint &m) {
        return stream << m.val;
    }
    friend istream& operator >> (istream &stream, Mint &m) {
        return stream >> m.val;
    }
};

const int32_t N = 100;
bool done = false;
Mint FAC[N + 1], INV[N + 1];

void calc() {
    if (done) {
        return;
    }
    done = true;
    FAC[0] = 1;
    for (int i = 1; i <= N; i++) {
        FAC[i] = (FAC[i - 1] * i);
    }
    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);
    for (int i = N - 1; i >= 0; i--) {
        INV[i] = (INV[i + 1] * (i + 1));
    }
}
Mint ncr(int n, int r) {
    if (r < 0) return 0;
    if (n < r) return 0;
    if (r == 0) return 1;
    Mint a = FAC[n] * INV[r] * INV[n - r];
    return a;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        calc();
        int n = (int) s.size();
        
        vector<int> freq(10);
        for (auto i : s) {
            freq[i - '0']++;
        }
        
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += freq[i] * i;
        }
        
        if (sum & 1) {
            return 0;
        }
        
        sum /= 2;
        vector<vector<Mint>> dp((n / 2) + 1, vector<Mint>(sum + 1));
        dp[0][0] = 1;
        
        for (int i = 0; i < 10; i++) {
            vector<vector<Mint>> ndp(n / 2 + 1, vector<Mint>(sum + 1));
            for (int prev_take = 0; prev_take <= n / 2; prev_take++) {
                for (int take = 0; take <= freq[i] && prev_take + take <= n / 2; take++) {
                    for (int prev_sum = 0; prev_sum + take * i <= sum; prev_sum++) {
                        int new_sum = prev_sum + take * i;
                        int new_take = prev_take + take;
                        ndp[new_take][new_sum] += dp[prev_take][prev_sum] * INV[take] * INV[freq[i] - take];
                    }
                }
            }
            
            dp = ndp;
        }
        
        Mint ans = dp[n / 2][sum] * FAC[n / 2] * FAC[(n + 1) / 2];
        return ans.val;
    }
};",1441321938
Dylan Smith,DylanSmith,79,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + 1;
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441293304
Dylan Smith,DylanSmith,79,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + ((r + c) % 2 == 0 ? 1 : 2);
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441294311
Dylan Smith,DylanSmith,79,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0, o = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2 == 0) {
                e += num[i] - '0';
            } else {
                o += num[i] - '0';
            }
        }
        return e == o;
    }
};",1441281042
Dylan Smith,DylanSmith,79,3637,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

int mod = 1000000007;

ll exGCD(ll a, ll b, ll &x, ll &y) {
    if (a == 0) { x = 0; y = 1; return b; }
    ll g = exGCD(b % a, a, x, y);
    ll t = x; x = y - b / a * x; y = t;
    return g;
}

int mInv(int n) {
    ll x, y, g = exGCD(n, mod, x, y);
    if (g != 1) return 0;
    return (x % mod + mod) % mod;
}

vector<int> factArr = {1}, factInvArr = {1};
int fact(int n) {
    while (sz(factArr) <= n)
        factArr.pb((int)((ll)factArr[sz(factArr) - 1] * sz(factArr) % mod));
    return factArr[n];
}

int factInv(int n) {
    fact(n);
    while (sz(factInvArr) <= n)
        factInvArr.pb(mInv(factArr[sz(factInvArr)]));
    return factInvArr[n];
}

int choose(int n, int k) {
    if (k < 0 || k > n) return 0;
    return (int)((ll)fact(n) * factInv(k) % mod * factInv(n - k) % mod);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int sum = 0;
        for (char c : num) sum += c - '0';
        if (sum % 2 == 1) return 0;
        vector<vector<ll>> dp((int)num.size() / 2 + 1, vector<ll>(sum / 2 + 1, 0)), nxt = dp;
        dp[0][0] = 1;
        vector<int> freq(10, 0);
        for (char c : num) freq[c - '0']++;
        int pre = 0;
        for (int k = 0; k < 10; k++) {
            for (int i = 0; i <= num.size() / 2; i++) fill(all(nxt[i]), 0);
            for (int l = 0; l <= freq[k]; l++) {
                for (int i = 0; i + l <= (int)num.size() / 2; i++) {
                    int n = (ll)choose(i + l, l) * choose(pre - i + freq[k] - l, freq[k] - l) % mod;
                    for (int j = 0; j + k * l <= sum / 2; j++) {
                        nxt[i + l][j + k * l] += (ll)dp[i][j] * n % mod;
                    }
                }
            }
            for (int i = 0; i <= num.size() / 2; i++) {
                for (int j = 0; j <= sum / 2; j++) {
                    nxt[i][j] %= mod;
                }
            }
            pre += freq[k];
            swap(dp, nxt);
        }
        return dp[(int)num.size() / 2][sum / 2];
    }
};",1441327844
Liwei Cai,cai_lw,80,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m);
        pq.push({0,0,0});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=it.i*m+it.j;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it2.t,moveTime[it2.i][it2.j])+1;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441295706
Liwei Cai,cai_lw,80,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool p;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m*2);
        pq.push({0,0,0,false});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=(it.i*m+it.j)*2+it.p;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it.t,moveTime[it2.i][it2.j])+(it.p?2:1);
                it2.p=!it.p;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441297773
Liwei Cai,cai_lw,80,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s[2]{0,0};
        for(int i=0;i<num.size();i++)
            s[i%2]+=num[i]-'0';
        return s[0]==s[1];
    }
};",1441280960
Liwei Cai,cai_lw,80,3637,cpp,"class Solution {
    static constexpr int P=1'000'000'007;
    struct State{
        int n1,n2,step,diff;
        bool operator<(const State& rhs)const{
            return tuple(n1,n2,step,diff)<tuple(rhs.n1,rhs.n2,rhs.step,rhs.diff);
        }
    };
    int solve(const State& st,const int (&cnt)[10],const int (&rem)[10],const vector<vector<int>>& binom,map<State,int>& mem){
        if(st.step==10)
            return st.diff==0;
        if(abs(st.diff)>rem[st.step])
            return 0;
        auto [it,inserted]=mem.emplace(st,0);
        if(!inserted)
            return it->second;
        int& ans=it->second;
        for(int c1=0;c1<=cnt[st.step];c1++){
            int c2=cnt[st.step]-c1;
            if(c1>st.n1||c2>st.n2)
                continue;
            int coef=1ll*binom[st.n1][c1]*binom[st.n2][c2]%P;
            State nxt=st;
            nxt.n1-=c1;
            nxt.n2-=c2;
            nxt.step++;
            nxt.diff+=st.step*(c2-c1);
            ans+=1ll*coef*solve(nxt,cnt,rem,binom,mem)%P;
            if(ans>=P)
                ans-=P;
        }
        return ans;
    }
public:
    int countBalancedPermutations(string num) {
        int cnt[10]{};
        for(char c:num)
            cnt[c-'0']++;
        int rem[10];
        rem[9]=cnt[9]*9;
        for(int i=8;i>=0;i--)
            rem[i]=rem[i+1]+cnt[i]*i;
        int n=num.size();
        int n1=n/2,n2=n-n1;
        vector<vector<int>> binom(n2+1,vector<int>(n2+1));
        for(int i=0;i<=n2;i++){
            binom[i][0]=binom[i][i]=1;
            for(int j=1;j<i;j++){
                binom[i][j]=binom[i-1][j-1]+binom[i-1][j];
                if(binom[i][j]>=P)
                    binom[i][j]-=P;
            }
        }
        map<State,int> mem;
        return solve(State{n1,n2,0,0},cnt,rem,binom,mem);
    }
};",1441335423
ocavue,ocavue,81,3627,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        result = [[MAX_TIME] * n for _ in range(m)]

        result[0][0] = 0

        heap = [(0, 0, 0)]

        while heap:
            time, i, j = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    new_time = start_time + 1
                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        heapq.heappush(heap, (new_time, ii, jj))

        return result[m - 1][n - 1]
 ",1441296531
ocavue,ocavue,81,3628,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        # print(""m"", m, ""n"", n)
        result1 = [[MAX_TIME] * n for _ in range(m)]
        result2 = [[MAX_TIME] * n for _ in range(m)]

        result2[0][0] = 0

        heap = [(0, 0, 0, 1)]

        while heap:
            time, i, j, next_move = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    # assert next_move in [1, 2]
                    new_time = start_time + next_move

                    result = result1 if next_move == 1 else result2

                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        # print(f""result {ii} {jj} {new_time} -> {(next_move) % 2 + 1}"")
                        heapq.heappush(heap, (new_time, ii, jj, (next_move) % 2 + 1))

        # print(""result1"", result1)
        # print(""result2"", result2)

        return min(result1[m - 1][n - 1], result2[m - 1][n - 1])

 ",1441316045
ocavue,ocavue,81,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = 0
        o = 0
        for i, char in enumerate(num):
            dig = int(char)
            if i % 2 == 0:
                e += dig 
            else:
                o += dig 
        return e == o",1441281980
ocavue,ocavue,81,3637,python3,"from functools import cache
import math

MOD = 10**9 + 7


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        total_sum = sum(int(c) for c in num)
        if total_sum % 2 != 0:
            return 0

        counter = [0] * 10
        for c in num:
            d = int(c)
            counter[d] += 1

        assert sum(counter) == len(num)

        n = len(num)
        e = n // 2
        o = n - e

        @cache
        def dp(i: int, e_available: int, o_available: int, diff: int) -> int:
            if i == 10:
                assert e_available == 0 and o_available == 0, f""e_available: {e_available}, o_available: {o_available}""
                return 1 if diff == 0 else 0

            total_result = 0
            for e_pick in range(0, e_available + 1):
                o_pick = counter[i] - e_pick
                if 0 <= e_pick <= e_available and 0 <= o_pick <= o_available:
                    result = 1
                    result *= math.comb(e_available, e_pick)
                    result %= MOD
                    result *= math.comb(o_available, o_pick)
                    result %= MOD
                    result *= dp(i + 1, e_available - e_pick, o_available - o_pick, diff + (o_pick - e_pick) * i)
                    result %= MOD
                    total_result += result
            return total_result % MOD

        return dp(0, e, o, 0)

 ",1441342495
nemokwy,nemokwy,82,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        ret = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0))
        ret[0][0] = 0
        while h:
            t, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m and ret[u][v] > max(moveTime[u][v]+1, t+1):
                    ret[u][v] = max(moveTime[u][v]+1, t+1)
                    heappush(h, (ret[u][v], u, v))
        return ret[-1][-1]",1441292753
nemokwy,nemokwy,82,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        r0 = [[inf] * m for _ in range(n)]
        r1 = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0, 0))
        r0[0][0] = 0
        while h:
            t, p, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m:
                    if p == 0:
                        if r1[u][v] > max(moveTime[u][v]+1, t+1):
                            r1[u][v] = max(moveTime[u][v]+1, t+1)
                            heappush(h, (r1[u][v], 1, u, v))
                    else:
                        if r0[u][v] > max(moveTime[u][v]+2, t+2):
                            r0[u][v] = max(moveTime[u][v]+2, t+2)
                            heappush(h, (r0[u][v], 0, u, v))
        if r0[-1][-1] == inf:
            return r1[-1][-1]
        if r1[-1][-1] == inf:
            return r0[-1][-1]
        return max(r0[-1][-1], r1[-1][-1])",1441309614
nemokwy,nemokwy,82,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a, b = 0, 0
        for i,c in enumerate(num):
            if i & 1:
                a += int(c)
            else:
                b += int(c)
        return a == b",1441281344
nemokwy,nemokwy,82,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        ret = 0
        d = [0] * 10
        s = 0
        for i, c in enumerate(num):
            d[int(c)] += 1
            s += int(c)
        if s & 1:
            return 0
        v = s // 2
        @lru_cache(None)
        def C(n, m):
            a = 1
            for i in range(m):
                a = a * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD
            return a

        @lru_cache(None)
        def chk(tp, tq, p, q, t):
            if t == 0:
                if tp or tq:
                    return 0
                return 1
            ret = 0
            for i in range(d[t]+1):
                if tp < i * t or tq < (d[t]-i) * t:
                    continue
                ret += C(p, i) * C(q, d[t]-i) * chk(tp - i * t, tq - (d[t]-i) * t, p - i, q - (d[t]-i), t - 1) % MOD
            # print(tp, tq, p, q, t, ret)
            return ret % MOD
        return chk(v, s - v, len(num) // 2,len(num) - len(num) // 2, 9)",1441336421
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0):0}
        h = [(0,0,0)]
        while h:
            c,x,y = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and (nx,ny) not in dist:
                    dist[nx,ny] = max(1 + moveTime[nx][ny], 1 + c)
                    heapq.heappush(h, (dist[nx,ny], nx, ny))
                ",1441290546
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0,0):0}
        h = [(0,0,0,0)]
        while h:
            c,x,y,p = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            if dist[(x,y,p)] != c:
                continue
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and dist.get((nx,ny,1-p), inf) > p + 1 + max(moveTime[nx][ny], c):
                    dist[nx,ny,1-p] = p + 1 + max(moveTime[nx][ny], c)
                    heapq.heappush(h, (dist[nx,ny,1-p], nx, ny, 1-p))
                ",1441294236
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ret = 0
        for i in range(len(num)):
            x = int(num[i])
            if i % 2:
                ret += x
            else:
                ret -= x
        return ret == 0",1441280896
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3637,python3,"MOD = 10**9+7

@cache
def comb(x, y):
    if y == 0 or y == x:
        return 1
    return (comb(x-1, y-1) + comb(x-1, y)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        SM = 0
        l = [0] * 10
        tot = [0] * 10
        tc = [0] * 10
        for x in num:
            l[int(x)] += 1
            SM += int(x)
        if SM % 2:
            return 0
        for i in range(10):
            tot[i] = (0 if i == 0 else tot[i-1]) + l[i] * i
            tc[i] = (0 if i == 0 else tc[i-1]) + l[i]
        # print(tot)
        # print(tc)
        # print(l)
        
        @cache
        def dp(idx, ct, sm):
            # print(idx, ct, sm)
            if idx == -1:
                # print(idx, ct, sm)
                return int(ct == 0 and sm == 0)
            ct2 = tc[idx] - ct
            sm2 = tot[idx] - sm
            # print(idx, ct, sm, ct2, sm2)
            ret = 0
            for t in range(l[idx] + 1):
                # print(t, l[idx] - t > ct2, sm > (idx) * t, sm2 > (idx) * (l[idx] - t))
                if t > ct or l[idx] - t > ct2 or sm < (idx) * t or sm2 < (idx) * (l[idx] - t):
                    continue
                v = dp(idx-1, ct - t, sm - (idx) * t)
                ret += comb(ct, t) * comb(ct2, l[idx] - t) * v % MOD
                ret %= MOD
                # print(idx, ct, sm, ret)
            return ret

        return dp(9, (len(num)+1)//2, SM//2)
                
                ",1441343521
thedude7181,thedude7181,85,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, row, col = heappop(q)
            if (row, col) in vis:
                continue
            vis.add((row, col))
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1, moveTime[nrow][ncol] + 1), nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441297537
thedude7181,thedude7181,85,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, movecost, row, col = heappop(q)
            if (row, col, movecost) in vis:
                continue
            vis.add((row, col, movecost))
            new_movecost = (movecost + 1) % 2 
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1 + movecost, moveTime[nrow][ncol] + 1 + movecost), new_movecost, nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441305265
thedude7181,thedude7181,85,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0 
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return odd == even",1441287722
thedude7181,thedude7181,85,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def helper(d, s, ecnt, ocnt):
            if s < 0:
                return 0
            if ecnt < 0:
                return 0
            if ocnt < 0:
                return 0
            if d > 9:
                return s == 0
            res = 0
            for i in range(digit_cnts[d] + 1):
                res += comb(ecnt, i) * helper(d + 1, s - (d * i), ecnt - i, ocnt - (digit_cnts[d] - i)) * comb(ocnt, digit_cnts[d] - i)
            return res % mod

        target_cnt = len(num) // 2
        mod = 1_000_000_007
        num = [int(n) for n in num]
        sum_ = sum(num)
        if sum_ % 2 != 0:
            return 0
        target_s = sum_ // 2
        digit_cnts = Counter(num)
        res = helper(0, target_s, (len(num) + 1) // 2, len(num) // 2)
        helper.cache_clear()
        return res",1441343532
Ethan,Ethan038,86,3627,cpp,"
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    int minTimeToReach(vector<vi>& mvtm) {
        return [](vector<vi>& mvtm) -> int {
            int n = mvtm.size();
            int m = mvtm[0].size();
            
            vector<vll> dis(n, vll(m, LLONG_MAX));
            dis[0][0] = 0;
            
            priority_queue<pair<ll, pi>, 
                          vector<pair<long long, pair<int, int>>>, 
                          greater<>> pq;
            pq.push({0, {0, 0}});
            
            vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            
            while (!pq.empty()) {
                auto [currtm, cor] = pq.top();
                auto [x, y] = cor;
                pq.pop();
                
                if (currtm > dis[x][y]) continue;
                
                for (auto [dx, dy] : dirs) {
                    int nex = x + dx;
                    int ny = y + dy;
                    
                    if (nex >= 0 && nex < n && ny >= 0 && ny < m) {
                        long long waitTime = max(0LL, mvtm[nex][ny] - currtm);
                        long long ntm = currtm + waitTime + 1;
                        
                        if (ntm < dis[nex][ny]) {
                            dis[nex][ny] = ntm;
                            pq.push({ntm, {nex, ny}});
                        }
                    }
                }
            }
            
            return dis[n-1][m-1];
        }(mvtm);
    }
};",1441292430
Ethan,Ethan038,86,3628,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;
int a[N]; 
bool c[N]; 

class Solution {
public:
   int minTimeToReach(vector<vi>& mt) {
       int n = mt.size();
       int m = mt[0].size();
       
       vector<vll> ans(n, vll(m, LLONG_MAX));
       ans[0][0] = 0;
       
       priority_queue<pair<ll, vi>, vector<pair<ll, vi>>, greater<>> pq;
       pq.push({0, {0, 0, 0}});
       
       auto chk = mt;
       
       vector<pi> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
       
       auto isValid = [&](int x, int y) -> bool {
           return x >= 0 && x < n && y >= 0 && y < m;
       };
       
       auto nxtmv = [](int mvtyp) -> int {
           return 1 - mvtyp; 
       };
       
       auto gcst = [](int mvtyp) -> int {
           return (mvtyp == 0) ? 1 : 2;
       };
       
       auto getm = [](long long xrrtm, int tartime, int mvcst) -> long long {
           return max((long long)tartime, xrrtm) + mvcst;
       };
       
       while(!pq.empty()) {
           auto [time, pos] = pq.top();
           auto x = pos[0], y = pos[1], mvtyp = pos[2];
           pq.pop();
           
           if(time > ans[x][y]) continue;
           
           for(auto [dx, dy] : dirs) {
               int nx = x + dx;
               int ny = y + dy;
               
               if(isValid(nx, ny)) {
                   int mvcst = gcst(mvtyp);
                   ll ntm = getm(time, chk[nx][ny], mvcst);
                   
                   if(ntm < ans[nx][ny]) {
                       ans[nx][ny] = ntm;
                       pq.push({ntm, {nx, ny, nxtmv(mvtyp)}});
                   }
               }
           }
       }
       
       return ans[n-1][m-1];
   }
};
",1441302877
Ethan,Ethan038,86,3636,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    bool isBalanced(string num) {
        return [](string num) -> bool {
            int evenSum = 0, oddSum = 0;
            rep(i, 0, num.length()) {
                (i % 2 == 0) ? evenSum += num[i] - '0' : oddSum += num[i] - '0';
            }
            return evenSum == oddSum;
        }(num);
    }
};",1441288482
Ethan,Ethan038,86,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;

class Solution { 
public: 
   const int MOD = 1e9 + 7;

   ll countBalancedPermutations(string num) {
       auto solv4 = [](ll x, ll y, ll mod) -> ll {
           ll res = 1;
           x %= mod;
           while(y > 0) {
               if(y & 1) res = res * x % mod;  x = x * x % mod;   y >>= 1;
           }
           return res;
       };
       
       auto solv2 = [&](vll& fc, vll& kp, int maxN) {
           fc.resize(maxN + 1, 1);
           rep(i,1,maxN+1) fc[i] = fc[i-1] * i % MOD;
           kp.resize(maxN + 1, 1);
           kp[maxN] = solv4(fc[maxN], MOD - 2, MOD);
           for(int i = maxN-1; i >= 0; --i) kp[i] = kp[i+1] * (i+1) % MOD; };auto km = num; auto sp = num;
       
       auto solv3 = [](const string& s) -> pair<array<int,10>, ll> {
           array<int,10> cnt{};
           ll sum = 0;
           for(char c : s) {
               cnt[c-'0']++;
               sum += (c-'0');
           }
           return {cnt, sum};
       };
       
       int L = num.length();
       auto [cnts, tsum] = solv3(num);
       
       if(tsum % 2) return 0;
       
       ll smevn = tsum / 2;
       int k = (L + 1) / 2;
       
       vll fc, kp;
       solv2(fc, kp, L);
       
       auto solvdp = [&](int d, const vector<vll>& pdp, int cntd) -> vector<vll> {
           vector<vll> tmdp(k + 1, vll(smevn + 1, 0));
           rep(c,0,k+1) {
               rep(s,0,smevn+1) {
                   if(pdp[c][s] == 0) continue;
                   int maxA = min(cntd, k - c);
                   rep(aD,0,maxA+1) {
                       ll nec = c + aD;   ll nws = s + (ll)d * aD;    if(nws > smevn) continue;
                       tmdp[nec][nws] = (tmdp[nec][nws] + 
                           pdp[c][s] * kp[aD] % MOD *   kp[cntd - aD] % MOD) % MOD;
                   }
               }
           }
           return tmdp;
       };

       vector<vll> pdp(k + 1, vll(smevn + 1, 0));  pdp[0][0] = 1;
       
       rep(d,0,10) {
           pdp = solvdp(d, pdp, cnts[d]);
       }
       
       ll vlid = pdp[k][smevn];
       ll anas = fc[k] * fc[L - k] % MOD;
       anas = anas * vlid % MOD;
       
       return (int)anas;
   }
};
",1441343539
Only My Railgun,Quar,89,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0)] # t, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1
                    yield tt, rr, cc
        
        while heap:
            t, ir, ic = heappop(heap)
            
            for tt, rr, cc in get_neighbor(t, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]

            ",1441293619
Only My Railgun,Quar,89,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0, 0)] # t, additional_time, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, dt, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1 + dt
                    yield tt, 1 - dt, rr, cc
        
        while heap:
            t, d, ir, ic = heappop(heap)
            
            for tt, dd, rr, cc in get_neighbor(t, d, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, dd, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]
",1441296911
Only My Railgun,Quar,89,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = str(num)
        even = sum(int(s[i]) for i in range(0, len(s), 2))
        odd = sum(int(s[i]) for i in range(1, len(s), 2))
        return even == odd
",1441281831
Only My Railgun,Quar,89,3637,python3,"from math import comb
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        cnt = [0] * 10
        for c in num:
            cnt[int(c)] += 1
            
        total_sum = sum(x * c for x, c in enumerate(cnt))
        
        if total_sum % 2 == 1:
            return 0
        
        target_sum = total_sum // 2
        
        MODULO = 10**9 + 7
        
        @cache
        def dp(i, rem_even, rem_odd, rem_even_sum):
            if rem_even == 0:
                if rem_even_sum != 0:
                    return 0
                ret = 1
                for j in range(i, 10):
                    ret = ret * comb(rem_odd, cnt[j]) % MODULO
                    rem_odd -= cnt[j]
                return ret
            
            if rem_even_sum > 0 and rem_even == 0:
                return 0
            
            if 0 < rem_even_sum < i:
                return 0
            
            ret = 0
            max_even_take = cnt[i] if i == 0 else min(cnt[i], rem_even_sum // i)
            max_even_take = min(max_even_take, rem_even)
            
            for even_take in range(0, max_even_take + 1):
                odd_take = cnt[i] - even_take
                if odd_take > rem_odd:
                    continue
                coeff = (comb(rem_even, even_take) % MODULO) * (comb(rem_odd, odd_take) % MODULO) % MODULO
                rest = dp(i + 1, rem_even - even_take, rem_odd - odd_take, rem_even_sum - i * even_take)
                ret += coeff * rest % MODULO
            
            return ret % MODULO
        
        n_odd = len(num) // 2
        n_even = len(num) - n_odd
        
        return dp(0, n_even, n_odd, target_sum)
                
            
                
        ",1441338510
carlostagosaku,carlostagosaku,90,3627,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 1
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441300648
carlostagosaku,carlostagosaku,90,3628,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 2
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441299342
carlostagosaku,carlostagosaku,90,3636,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

class Solution:
    def isBalanced(self, num: str) -> bool:
        X = list(num)
        X = [int(x) for x in X]
        if sum(x for x in X[1::2])==sum(x for x in X[0::2]):
            return True
        else:
            return False  ",1441302147
carlostagosaku,carlostagosaku,90,3637,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

mod = 10**9 + 7
CC = combination(10**6,mod)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        S = list(num)
        S = [int(x) for x in S]
        W = sum(S)
        if W%2==1:
            return 0
        n = len(S)
        target = W//2
        m = n//2
        dp = [[0]*(target+2) for _ in range(m+1)]
        dp[0][0] = 1
        for s in S:
            for i in range(target,-1,-1):
                for j in range(m-1,-1,-1):
                    dp[j+1][min(i+s,target+1)] = (
                        dp[j+1][min(i+s,target+1)]
                        + dp[j][i]
                    )%mod
        ans = 1
        C = Counter(S)
        
        ans = dp[m][target]*CC.fact[m]*CC.fact[n-m]%mod
        # print(dp,C)
        for v in C.values():
            ans = (ans * CC.factinv[v])%mod

        return ans",1441325130
aqxa2k,aqxa2k,91,3627,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<int>> d(n, vector<int>(m, -1)); 
        d[0][0] = 0; 

        set<array<int, 3>> st; 
        st.insert({d[0][0], 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny] == -1) {
                        d[nx][ny] = max(t + 1, a[nx][ny] + 1); 
                        st.insert({d[nx][ny], nx, ny}); 
                    }
                }
            }
        }

        return d[n - 1][m - 1]; 
        
    }
};",1441296110
aqxa2k,aqxa2k,91,3628,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2000000000))); 
        d[0][0][0] = 0; 

        set<array<int, 4>> st; 
        st.insert({0, 0, 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0], z = c[3]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny][z ^ 1] == 2000000000) {
                        d[nx][ny][z ^ 1] = max(t + 1 + z, a[nx][ny] + 1 + z); 
                        st.insert({d[nx][ny][z ^ 1], nx, ny, z ^ 1}); 
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]); 
        
    }
};",1441300647
aqxa2k,aqxa2k,91,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> c(2, 0); 
        for (int i = 0; i < num.size(); ++i) {
            c[i % 2] += (num[i] - '0'); 
        }
        return c[0] == c[1]; 
    }
};",1441281197
aqxa2k,aqxa2k,91,3637,cpp,"template <typename T>
T inverse(T a, T m) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = m / a;
		m -= t * a; swap(a, m);
		u -= t * v; swap(u, v);
	}
	assert(m == 1);
	return u;
}

template<class T>
T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

template <typename T>
class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {

    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));

        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
            long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
            value = normalize(value * rhs.value - q * mod());
            return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
            value = normalize(value * rhs.value);
            return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
};
template <typename T> bool operator>(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value > rhs.value; }
template <typename T, typename U> bool operator>(const Modular<T>& lhs, U rhs) { return lhs > Modular<T>(rhs); }
template <typename T, typename U> bool operator>(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) > rhs; }

template <typename T> bool operator>=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value >= rhs.value; }
template <typename T, typename U> bool operator>=(const Modular<T>& lhs, U rhs) { return lhs >= Modular<T>(rhs); }
template <typename T, typename U> bool operator>=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) >= rhs; }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
template <typename T, typename U> bool operator<(const Modular<T>& lhs, U rhs) { return lhs < Modular<T>(rhs); }
template <typename T, typename U> bool operator<(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) < rhs; }

template <typename T> bool operator<=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value <= rhs.value; }
template <typename T, typename U> bool operator<=(const Modular<T>& lhs, U rhs) { return lhs <= Modular<T>(rhs); }
template <typename T, typename U> bool operator<=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) <= rhs; }

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string ss) {
        vector<int> a; 
        for (char c: ss) a.push_back(c - '0'); 

        int s = accumulate(a.begin(), a.end(), 0); 
        if (s % 2) return 0; 

        int n = a.size(); 
        vector<int> f(10, 0); 
        for (int i = 0; i < n; ++i) f[a[i]]++; 

        s /= 2;  
        
        vector<vector<Mint>> dp(n + 1, vector<Mint>(s + 1, Mint(0))); 
        dp[0][0] = 1; 

        int hv = 0; 
        for (int v = 0; v < 10; ++v) {
            vector<vector<Mint>> dp2(n + 1, vector<Mint>(s + 1, Mint(0))); 
            
            for (int c = 0; c <= f[v]; ++c) {
                for (int i = 0; i + c <= n; ++i) {
                    for (int j = 0; j + (c * v) <= s; ++j) {
                        dp2[i + c][j + (c * v)] += dp[i][j] * C(i + c, c) * C(hv - i + f[v] - c, f[v] - c); 
                    }
                }
            }

            hv += f[v]; 
            dp = dp2; 
        }

        int ans = (int)dp[n / 2][s]; 
        return ans; 
        // return (dp[n / 2][s]) % md; 
    }
};",1441333231
user5860c,user5860c,92,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 1;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441345728
user5860c,user5860c,92,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 2;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441344214
user5860c,user5860c,92,3636,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
class Solution {
public:
    bool isBalanced(string v) {
        int o1 = 0;
        int o2 = 0;
        FOR(i, sz(v)) {
            if (i%2) {
                o1 += v[i] - '0';
            } else {
                o2 += v[i] - '0';
            }
        }
        return o1 == o2;
    }
};",1441346769
user5860c,user5860c,92,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;


// N ~ 10^6
class Combinations {
public:
  vector<mint> inv, fact, ifact;

  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};

Combinations comb(1000);

mint best[11][82*10][82];

class Solution {
public:
    int countBalancedPermutations(string v) {
        int sum = 0;
        vi cnt(10);
        for (auto x : v) {
            sum += (x-'0');
            cnt[x-'0']++;
        }
        if (sum%2) return 0;
        for (int i=0;i<=10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    best[i][s][k] = 0;
                }
            }
        }
        best[0][0][0] = 1;
        int placed = 0;
        for (int i=0;i<10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    for (int j=0;j<=cnt[i] && s + j * i <= sum/2;++j) {
                        if (best[i][s][k].x == 0) continue;
                        //cout << i << "" "" << k << "" "" << j << "" "" << s << "" "" << endl;
                        //cout << i+1 << "" "" << s + j * (i) << "" "" << k + j << endl;
                        best[i+1][s + j * (i)][k+j] += 
                            best[i][s][k] * ( comb.comb(k+j,j) * comb.comb(placed-k+cnt[i]-j, cnt[i]-j));
                        //cout << best[i][s][k] * ( comb.comb(k+j,j) + comb.comb(placed-k+cnt[i]-j, cnt[i]-j)) << endl;
                    }
                }
            }
            placed += cnt[i];
        }
        mint ret = best[10][sum/2][(sz(v)+1)/2];
        return ret.x;
    }
};",1441318305
Abhishek Choudhary,theabbie,94,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441294424
Abhishek Choudhary,theabbie,94,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1 if even else 2
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441293690
Abhishek Choudhary,theabbie,94,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = [0, 0]
        for i in range(len(num)):
            s[i % 2] += int(num[i])
        return s[0] == s[1]",1441295519
Abhishek Choudhary,theabbie,94,3637,python3,"M = 10 ** 9 + 7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        f = [1] * (n + 1)
        rf = [1] * (n + 1)
        for i in range(1, n + 1):
            f[i] = i * f[i - 1]
            f[i] %= M
            rf[i] = pow(f[i], M - 2, M)
        ctr = [0] * 10
        s = 0
        for c in num:
            s += int(c)
            ctr[int(c)] += 1
        if s & 1:
            return 0
        cache = [[[-1] * ((s // 2) + 1) for _ in range(n + 1)] for _ in range(10)]
        def dp(d, l, rem):
            if d > 9:
                return int(l == 0 and rem == 0)
            if cache[d][l][rem] != -1:
                return cache[d][l][rem]
            res = 0
            for take in range(ctr[d] + 1):
                if take > l or d * take > rem:
                    continue
                res += rf[take] * rf[ctr[d] - take] * dp(d + 1, l - take, rem - d * take)
                res %= M
            cache[d][l][rem] = res
            return res
        return (f[n // 2] * f[n - (n // 2)] * dp(0, n // 2, s // 2)) % M",1441348952
furuyarei,furuyarei,95,3627,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            d, x, y = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny) not in dist or max(d, a[nx][ny]) + 1 < dist[(nx, ny)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + 1, nx, ny))
                        dist[(nx, ny)] = max(d, a[nx][ny]) + 1
        return dist[(m - 1, n - 1)]
        ",1441293432
furuyarei,furuyarei,95,3628,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0, 1)]
        dist = {(0, 0, 1): 0}
        while q:
            d, x, y, cost = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny, 3 - cost) not in dist or max(d, a[nx][ny]) + cost < dist[(nx, ny, 3 - cost)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + cost, nx, ny, 3 - cost))
                        dist[(nx, ny, 3 - cost)] = max(d, a[nx][ny]) + cost
        return min(dist.get((m - 1, n - 1, 1), inf), dist.get((m - 1, n - 1, 2), inf))",1441297122
furuyarei,furuyarei,95,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        p = q = 0
        for i, ch in enumerate(num):
            if i % 2 == 0:
                p += int(ch)
            else:
                q += int(ch)
        return p == q",1441286385
furuyarei,furuyarei,95,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        
        @cache
        def C(n, k):
            if n < k:
                return 0
            if k == 0:
                return 1
            return (C(n - 1, k - 1) + C(n - 1, k)) % MOD

        @cache
        def S2(n, k):
            # print(n + k - 1, k - 1)
            return C(n + k - 1, k - 1)

        c = Counter(int(d) for d in num)
        # print(c)
        
        @cache
        def f(x, p1, p2, diff):
            if x == 10:
                return int(p1 == p2 == diff == 0)

            alloc = c.get(x, 0)
            ans = 0
            for q1 in range(alloc + 1):
                q2 = alloc - q1
                if q1 > p1 or q2 > p2:
                    continue
                coef = S2(q1, p1 - q1 + 1) * S2(q2, p2 - q2 + 1) % MOD
                ans += coef * f(x + 1, p1 - q1, p2 - q2, diff + (q1 - q2) * x) % MOD
            #     print(f""coef = {q1} {p1 - q1 + 1} {q2} {p2 - q2 + 1} = {S2(q1, p1 - q1 + 1)} {S2(q2, p2 - q2 + 1)}"")
            #     print(f""from = {x + 1} {p1 - q1} {p2 - q2} {diff + (q1 - q2) * x}"")
            # print(f""{x} {p1} {p2} {diff} = {ans}"")
            return ans % MOD

        l = len(num)
        ans = f(0, (l + 1) // 2, l // 2, 0)
        C.cache_clear()
        S2.cache_clear()
        f.cache_clear()
        return ans",1441349069
Nicholas,nicholask_17,97,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
using pii=pair <int,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m];
        bool visited[n][m];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                dist[i][j]=2e9;
                visited[i][j]=0;
            }
        }
        priority_queue <pair <int,pii>,vector <pair <int,pii> >,greater <pair <int,pii> > > pq;
        dist[0][0]=0; pq.push({0,{0,0}});
        while (!pq.empty()){
            pair <int,pii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first][tp.second.second]) continue;
            visited[tp.second.first][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first+dx[dir],ny=tp.second.second+dy[dir];
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny]) continue;
                if (max(tp.first,moveTime[nx][ny])+1<dist[nx][ny]){
                    dist[nx][ny]=max(tp.first,moveTime[nx][ny])+1;
                    pq.push({dist[nx][ny],{nx,ny}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441298407
Nicholas,nicholask_17,97,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using pii=pair <int,int>;
        using tii=pair <pii,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m][2];
        bool visited[n][m][2];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                for (int k=0; k<2; k++){
                    dist[i][j][k]=2e9;
                    visited[i][j][k]=0;
                }
            }
        }
        priority_queue <pair <int,tii>,vector <pair <int,tii> >,greater <pair <int,tii> > > pq;
        dist[0][0][0]=0; pq.push({0,{{0,0},0}});
        while (!pq.empty()){
            pair <int,tii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first.first][tp.second.first.second][tp.second.second]) continue;
            visited[tp.second.first.first][tp.second.first.second][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first.first+dx[dir],ny=tp.second.first.second+dy[dir],nz=1-tp.second.second;
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny][nz]) continue;
                if (max(tp.first,moveTime[nx][ny])+(nz==1?1:2)<dist[nx][ny][nz]){
                    dist[nx][ny][nz]=max(tp.first,moveTime[nx][ny])+(nz==1?1:2);
                    pq.push({dist[nx][ny][nz],{{nx,ny},nz}});
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441303421
Nicholas,nicholask_17,97,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0,sum2=0;
        for (int i=0; i<num.size(); i++){
            if (i%2==0) sum1+=num[i]-'0';
            else sum2+=num[i]-'0';
        }
        return sum1==sum2;
    }
};",1441281077
Nicholas,nicholask_17,97,3637,cpp,"class Solution {
public:
    const long long mod=1e9+7LL;
    long long f[100],inv[100],finv[100];
    void init(){
        f[0]=f[1]=inv[0]=inv[1]=finv[0]=finv[1]=1;
        for (int i=2; i<100; i++){
            f[i]=f[i-1]*i%mod;
            inv[i]=inv[mod%i]*(mod-mod/i)%mod;
            finv[i]=finv[i-1]*inv[i]%mod;
        }
    }
    long long ncr(int n,int r){
        if (n<r||r<0) return 0;
        return f[n]*finv[n-r]%mod*finv[r]%mod;
    }
    int countBalancedPermutations(string num) {
        init();
        int n=num.size();
        int sum=0;
        for (char i:num) sum+=i-'0';
        if (sum%2) return 0;
        int cnt[10];
        for (int i=0; i<10; i++) cnt[i]=0;
        for (char i:num) cnt[(i-'0')]++;
        int dp[11][41][1500];
        for (int i=0; i<11; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++) dp[i][j][k]=0;
            }
        }
        dp[0][0][750]=1;
        int done=0;
        for (int i=0; i<10; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++){
                    if (!dp[i][j][k]) continue;
                    for (int l=0; l<=cnt[i]&&j+l<41; l++){
                        long long way=ncr((n+1)/2-j,l)*ncr(n/2-(done-j),cnt[i]-l)%mod;
                        if (k+i*l-(cnt[i]-l)*i>=0&&k+i*l-(cnt[i]-l)*i<1500){
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]+=way*dp[i][j][k]%mod;
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]%=mod;
                        }
                    }
                }
            }
            done+=cnt[i];
        }
        int ans=0;
        for (int i=0; i<41; i++) ans=(ans+dp[10][i][750])%mod;
        return ans;
    }
};",1441322955
Dhruv Pasricha,pasricha_dhruv,99,3627,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441317612
Dhruv Pasricha,pasricha_dhruv,99,3628,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = h == 1 ? 2 : 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441316521
Dhruv Pasricha,pasricha_dhruv,99,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i = 0; i < n; ++i)
        {
            num[i] -= '0';
            if(i % 2 == 0) sum1 += num[i];
            else sum2 += num[i];
        }
        return sum1 == sum2;
    }
};",1441281493
Dhruv Pasricha,pasricha_dhruv,99,3637,cpp,"#define int long long

const int N = 1e2 + 10, MOD = 1e9 + 7, mod = 1e9 + 7;
 
int fact[N + 1], invFact[N + 1];
 
// x^n % MOD
int power(int x, int n)
{
    if(n == 0)
    {
        return 1;
    }
 
    if(n % 2 == 0)
    {
        int ans = power(x, n / 2);
        ans = (ans * ans) % MOD;
        return ans;
    }
 
    return (x * power(x, n - 1)) % MOD;
}
 
// mod inverse
int modInverse(int x)
{
    return power(x, MOD - 2);
}
 
void pre()
{
    fact[0] = 1;
    for(int i = 1; i <= N; ++i)
    {
        fact[i] = (i * fact[i - 1]) % MOD;
    }
 
    for(int i = 0; i <= N; ++i)
    {
        invFact[i] = modInverse(fact[i]);
    }
}
 
int Binomial(int n, int r)
{
    if(r > n or n < 0 or r < 0) return 0;

    int ans = fact[n];
    ans *= invFact[n - r];
    ans %= MOD;
    ans *= invFact[r];
    ans %= MOD;
    return ans;
}
 
int freq[10], dp[10][42][410];

int solve(int cur, int remOddPlaces, int remEvenPlaces, int remOddSum, int remEvenSum)
{
    if(remOddPlaces < 0 or remEvenPlaces < 0 or remOddSum < 0 or remEvenSum < 0)
        return 0;
    
    if(cur == -1)
    {
        return 1;
    }

    if(dp[cur][remOddPlaces][remOddSum] != -1) return dp[cur][remOddPlaces][remOddSum]; 

    int ans = 0;
    for(int even = 0; even <= freq[cur]; ++even)
    {
        int odd = freq[cur] - even;

        int curAns = (Binomial(remOddPlaces, odd) * Binomial(remEvenPlaces, even)) % mod;
        curAns *= solve(cur - 1, remOddPlaces - odd, remEvenPlaces - even, remOddSum - odd * cur, remEvenSum - even * cur);
        curAns %= mod;

        ans += curAns;
        ans %= mod;
    }

    return dp[cur][remOddPlaces][remOddSum] = ans;
}

class Solution {
public:
    int countBalancedPermutations(string num) {

        pre();
        memset(freq, 0, sizeof(freq));
        memset(dp, -1, sizeof(dp));
    
        int sum = 0;
        for(auto it : num)
        {
            sum += it - '0';
            freq[it - '0']++;
        }
    
        if(sum % 2 == 1)
        {
            return 0;
        }

        int n = num.size();

        return solve(9, (n + 1) / 2, n / 2, sum / 2, sum / 2);
    }
};

#undef int",1441343833
Behrooz Sepehry,sepehry,100,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj

        node0 = (0, 0)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))

        return visited_dist[(n - 1, m - 1)]
",1441295828
Behrooz Sepehry,sepehry,100,3628,python3,"
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j, odd = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj, not odd

        node0 = (0, 0, True)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (node2[2] + max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))
        sol = float('inf')

        if (n - 1, m - 1, False) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, False)])
        if (n - 1, m - 1, True) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, True)])

        return sol
",1441311181
Behrooz Sepehry,sepehry,100,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])
",1441281738
Behrooz Sepehry,sepehry,100,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cc = collections.Counter(num)
        F = [cc[str(ii)] for ii in range(10)]

        mod = ((10 ** 9) + 7)

        @functools.lru_cache(None)
        def dp(d, rem_odd, rem_even, balance):
            if d == -1:
                return rem_odd == 0 and rem_even == 0 and balance == 0
            f = F[d]
            min_f_odd = max(0, f - rem_even)
            max_f_odd = min(rem_odd, f)
            vvv = 0
            for f_odd in range(min_f_odd, max_f_odd + 1):
                f_even = f - f_odd
                vvv += ((math.comb(rem_odd, f_odd) % mod) * (math.comb(rem_even, f_even) % mod) * dp(d - 1,
                                                                                                     rem_odd - f_odd,
                                                                                                     rem_even - f_even,
                                                                                                     balance + (
                                                                                                                 f_odd - f_even) * d)) % mod
                vvv %= mod

            return vvv

        n2 = n // 2
        sol = dp(9, n2, n - n2, 0)
        dp.cache_clear()
        return sol % mod
",1441343869
Aryan470,Aryan470,102,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, i, j = heapq.heappop(q)
            if i == n-1 and j == m-1:
                return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                # check the time at which we can reach this guy
                this_reach = max(curr_time + 1, moveTime[u][v] + 1)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, u, v))
    
                ",1441291107
Aryan470,Aryan470,102,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, True, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, first_move, i, j = heapq.heappop(q)
            # if i == n-1 and j == m-1:
                # return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                delta_time = 1 if first_move else 2
                # check the time at which we can reach this guy
                this_reach = max(curr_time + delta_time, moveTime[u][v] + delta_time)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, not first_move, u, v))
        
        return reach_time[(n-1,m-1)]
    
                ",1441294437
Aryan470,Aryan470,102,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            dig = int(num[i])
            if i % 2 == 0:
                es += dig
            else:
                os += dig
        return es == os",1441280972
Aryan470,Aryan470,102,3637,python3,"from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # sum of digs has to be 2k
        # how many ways can we choose n//2 digs with sum k
        # then how many ways can we permute those
        sum_digs = sum(int(c) for c in num)
        if sum_digs % 2 != 0:
            return 0
        
        target_sum = sum_digs // 2
        num_to_choose = len(num) // 2
        # first n digits with sum k
        # choose z digits with sum k
        # sum can be up to 80 * 9 and num digs can be up to 80
        # dp[i][k] = num sets of i digits with sum k

        max_sum = target_sum
        dp = [[0 for j in range(max_sum+1)] for i in range(num_to_choose + 1)]
        dp[0][0] = 1

        for i in range(len(num)):
            dig = int(num[i])
            for num_dig in range(num_to_choose, 0, -1):
                for k in range(dig, max_sum+1):
                    if k - dig >= 0:
                        dp[num_dig][k] += dp[num_dig - 1][k - dig]
        num_partitions = dp[num_to_choose][target_sum]
        # if 2 * num_to_choose == len(num):
            # num_partitions //= 2
        # print(dp)
        # print(num_partitions)
        # now given this, for each partition we can make some permutations
        # how many ways can we permute num_to_choose numbers * (n - num_to_choose) // (num 0! * num 1! * num 2!)
        def fact(x):
            prod = 1
            for u in range(2,x+1):
                prod *= u
            return prod
            
        ans = num_partitions * fact(num_to_choose) * fact(len(num) - num_to_choose)
        # print(ans)
        digcnt = Counter(int(c) for c in num)
        for dig, cnt in digcnt.items():
            if cnt > 1:
                ans //= fact(cnt)
        return ans % (10**9 + 7)",1441338715
Remineva,Remineva,103,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= di < m and 0 <= dj < n:
                    new = max(t, moveTime[di][dj]) + 1
                    if new < time[di][dj]:
                        time[di][dj] = new
                        heappush(h, (new, di, dj))

",1441301058
Remineva,Remineva,103,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0, True)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j, flag = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            if flag:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 1
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, False))
            else:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 2
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, True))
",1441309971
Remineva,Remineva,103,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        flag = True
        for c in num:
            if flag:
                s += int(c)
            else:
                s -= int(c)
            flag = not flag
        return s == 0",1441280982
Remineva,Remineva,103,3637,python3,"M = 10 ** 9 + 7
def ncr(n, r, p):
    num = den = 1 
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p
m = 100 + 1
fac = [1] * m
for i in range(2, m):
    fac[i] = fac[i-1] * i % M

inv = [1] * m
inv[-1] = pow(fac[-1], M - 2, M)
for i in range(m - 2, 1, -1):
    inv[i] = inv[i+1] * (i + 1) % M
    
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        s = 0
        cnt = [0] * 10
        for c in num:
            curr = int(c)
            s += curr
            cnt[curr] += 1
        if s & 1:
            return 0
        s //= 2
        n = len(num)
        m = (n + 1) // 2
        
        dp = [[0] * (s + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        for digit in range(10):
            temp = cnt[digit]
            if temp == 0:
                continue
            
            for i in range(m, -1, -1):
                for j in range(s, -1, -1):
                    if dp[i][j] == 0:
                        continue
                    for di in range(1, min(temp, m - i) + 1):
                        dj = di * digit
                        if j + dj > s:
                            break
                        dp[i + di][j + dj] += dp[i][j] * ncr(temp, di, M)
                        dp[i + di][j + dj] %= M
        res = dp[-1][-1]
        f = 1
        for digit in range(10):
            f = f * fac[cnt[digit]] % M
        inv_f = pow(f, M - 2, M)
        
        res *= fac[m] * fac[n - m]
        res %= M
        res *= inv_f
        res %= M
        return res

        ",1441345758
M Kawa,mkawa222,107,3627,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            nd=max(d+1,mt[ni][nj]+1)
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441297946
M Kawa,mkawa222,107,3628,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            cost=((i^j)&1)+1
            nd=max(d,mt[ni][nj])+cost
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441315942
M Kawa,mkawa222,107,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s=0
        p=1
        for c in num:
            s+=int(c)*p
            p=-p
        return s==0

",1441285811
M Kawa,mkawa222,107,3637,python3,"def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

md = 10**9+7
n_max = 200
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        aa = list(map(int, num))
        s = sum(aa)
        if s & 1: return 0
        s >>= 1
        n = len(aa)
        m = n//2
        em = n-m
        cnt = [0]*10
        for a in aa: cnt[a] += 1
        dp = [[0]*(s+1) for _ in range(m+1)]
        dp[0][0] = 1
        si = sj = 0
        for a in range(10):
            if cnt[a] == 0: continue
            ndp = [[0]*(s+1) for _ in range(m+1)]
            for i in range(m+1)[::-1]:
                ei = si-i
                for j in range(s+1):
                    pre = dp[i][j]
                    if pre == 0: continue
                    ej = sj-j
                    for c in range(cnt[a]+1):
                        ec = cnt[a]-c
                        if i+c > m or ei+ec > em or j+a*c > s or ej+a*ec > s: continue
                        ndp[i+c][j+a*c] += pre*nCr(m-i, c)%md*nCr(em-ei, ec)%md
                        ndp[i+c][j+a*c] %= md
            dp = ndp
            si += cnt[a]
            sj += cnt[a]*a
        return dp[-1][-1]%md
",1441353918
PankajGhodla,PankajGhodla,108,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c))

        return -1",1441291398
PankajGhodla,PankajGhodla,108,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c, move = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + move + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + move + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c, (move+1)%2 ))

        return -1",1441293810
PankajGhodla,PankajGhodla,108,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even = odd = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281353
PankajGhodla,PankajGhodla,108,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        counter = Counter()
        
        totalSum = 0
        for digit in num: 
            totalSum += int(digit)
            counter[int(digit)] += 1
        prefix = [0]*10
        prefix[0] = counter[0]
        for i in range(1, 10):
            prefix[i] = prefix[i-1] + counter[i] 
        # print(prefix)
        n = len(num)
        @cache
        def solve(digit, count, total):
            # print(digit, count, total)
            if digit == 10:
                # print(digit, count, total)
                return (count == n//2) and total*2 == totalSum
            ans = solve(digit+1, count, total) * math.comb(prefix[digit] - count, counter[digit])
            # print(math.comb(prefix[digit], counter[digit]), (prefix[digit], counter[digit]), digit)
            for i in range(counter[digit]):
                remaining = prefix[digit] - (count + i + 1)
                ans += solve(digit+1, count+i+1, total + digit*(i+1)) * math.comb(count+i+1, i+1) * math.comb(remaining, counter[digit] - (i+1))
                # print(math.comb(remaining, counter[digit] - (i+1)), math.comb(count+i+1, i+1), (count+i+1, i+1))
            return ans % MOD
        return solve(0, 0, 0)
            
            
            ",1441347745
cm_fast,cm_fast,109,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441297393
cm_fast,cm_fast,109,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    steps++;
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441296687
cm_fast,cm_fast,109,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0;
        int sum2=0;
        for(int i=0;i<(int)(num.size());i++)
        {
            if(i%2)
            {
                sum1+=(int)(num[i]-'0');
            }
            else
                
            {
                sum2+=(int)(num[i]-'0');
            }
            
        }
        return (sum1==sum2);
    }
};",1441282765
cm_fast,cm_fast,109,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
const int MAX_N = 80; // Maximum possible n as per constraints

ll gcd_custom(ll a, ll b)
{
    if (b == 0)
        return a;
    return gcd_custom(b, a % b);
}

ll add(ll x, ll y)
{
    x += y;
    while (x >= MOD)
        x -= MOD;
    while (x < 0)
        x += MOD;
    return x;
}

ll mul(ll x, ll y)
{
    return (x * y) % MOD;
}

ll binpow(ll x, ll y)
{
    ll z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

ll inv(ll x)
{
    return binpow(x, MOD - 2);
}

ll divide(ll x, ll y)
{
    return mul(x, inv(y));
}

ll fact_arr[81];
ll inv_fact_arr[81];

void precalc()
{
    fact_arr[0] = 1;
    for (ll i = 1; i <= 80; i++)
    {
        fact_arr[i] = mul(fact_arr[i - 1], i);
    }
    // Precompute inverse factorials
    inv_fact_arr[80] = divide(1, fact_arr[80]);
    for (ll i = 79; i >= 0; i--)
    {
        inv_fact_arr[i] = mul(inv_fact_arr[i + 1], i + 1);
    }
}

ll C(ll n, ll k)
{
    if (k > n || k < 0)
        return 0;
    return mul(fact_arr[n], mul(inv_fact_arr[k], inv_fact_arr[n - k]));
}

class Solution
{
public:
    
    ll memo_table[11][81][801]; 

    Solution()
    {
        for(int i=0;i<11;i++)
        {
            for(int j=0;j<81;j++)
            {
                 for(int k=0;k<801;k++)
                 {
                     memo_table[i][j][k] = -1;
                 }
            }
                
                    
        }
            
    }

    ll helper(int digit, int remaining_count, ll remaining_sum, const vector<ll> &original_freq)
    {
        if (remaining_count == 0 && remaining_sum == 0)
            return 1;
        if (digit > 9 || remaining_count < 0 || remaining_sum < 0)
            return 0;
        if (memo_table[digit][remaining_count][remaining_sum] != -1)
            return memo_table[digit][remaining_count][remaining_sum];
        ll total = 0;
        for (ll k = 0; k <= original_freq[digit] && k <= remaining_count && (ll)digit * k <= remaining_sum; k++)
        {
            total = add(total, mul(C(original_freq[digit], k), helper(digit + 1, remaining_count - k, remaining_sum - (ll)digit * k, original_freq)));
            total %= MOD;
        }
        return memo_table[digit][remaining_count][remaining_sum] = total;
    }

    ll countBalancedPermutations(string s)
    {
        precalc();
        ll n = s.size();
        if (n < 2)
            return 0;
        vector<ll> original_freq(10, 0);
        ll total_sum = 0;
        for (char c : s)
        {
            original_freq[c - '0']++;
            total_sum += (ll)(c - '0');
        }
        if (total_sum % 2 != 0)
            return 0;
        ll sum_p = total_sum / 2;
        int p = (n + 1) / 2;
        int q = n / 2;
        memset(memo_table, -1, sizeof(memo_table));
        ll ways = helper(0, p, sum_p, original_freq);
        if (ways == 0)
            return 0;
        ll fact_p = fact_arr[p];
        ll fact_q = fact_arr[q];
        ll denom = 1;
        for (int d = 0; d <= 9; d++)
        {
            denom = mul(denom, fact_arr[original_freq[d]]);
        }
        ll numerator = mul(mul(ways, fact_p), fact_q);
        ll denom_inv = inv(denom);
        ll result = mul(numerator, denom_inv);
        return result;
    }
};
",1441347789
Anupam Shah,user9218i,110,3627,cpp,"class Solution {
public:
    typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    vector<ll> dijkstra(vector<vector<pair<ll, ll>>> &G, ll v)
    {
        vector<ll> ans(G.size(), INF);
        ans[v] = 0;
        priority_queue<pair<ll, ll>> que;
        que.push({0, v});
        while (!que.empty())
        {
            auto [x, u] = que.top();
            que.pop();
            if (-x > ans[u])
                continue;
            for (auto [v, w] : G[u])
                if (ans[u] + w < ans[v])
                    ans[v] = ans[u] + w, que.push({-ans[v], v});
        }
        return ans;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        
        priority_queue<pair<ll, pair<ll,ll>>> que;
        que.push({0, {0, 0}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, ux = it.second.first, uy = it.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, {xx,yy}});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441301349
Anupam Shah,user9218i,110,3628,cpp,"class Solution {
public:
        typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<ll, pair<ll, pair<ll, ll>>>> que;
        que.push({0, {1, {0, 0}}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, p = it.second.first, ux = it.second.second.first, uy = it.second.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + p;
                    ll np = 1;
                    
                    if(p == 1)  np = 2;  
                    else np = 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, { np, {xx,yy} }});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441310479
Anupam Shah,user9218i,110,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for(int i = 0; i < num.length(); i ++)
            if(i % 2)   o += num[i] - '0';
            else e += num[i] - '0';
        return o == e;
    }
};",1441281198
Anupam Shah,user9218i,110,3637,cpp,"class Solution {
public:
    typedef long long ll;
    ll MOD = 1000000007;
    
    ll power(ll a, ll b, ll m) {
        ll ans = 1;
        while(b) {
            if(b & 1)
                ans = (ans * a) % m;
            b /= 2;
            a = (a * a) % m;
        }
        return ans;
    }
    
    ll go(ll ind, ll tk, ll csum, ll& sum, ll& req, ll& n, vector<ll>& f, vector<ll>& ff, vector<ll>& iff, vector<vector<vector<ll>>>& dp) {
        //cout << ind << "" "" << ind << "" ""<< tk << "" ""<< csum << endl;
        if(ind == 10) {
            if(tk == req and csum == sum) {
                //cout << ""YY"" << endl;
                return (ff[req] * ff[n-req]) % MOD;
            }
            return 0;
        }
        if(tk > req)    return 0;
        if(csum > sum)    return 0;
        
        if(dp[ind][tk][csum] != -1)     return dp[ind][tk][csum];
        
        ll ans = 0;
        for(ll i = 0; i <= f[ind]; i ++) {
            if(tk + i <= req and (csum + ( i * ind )) <= sum) {
                ll curr = (iff[i] * iff[f[ind] - i]) % MOD; 
                ans += curr * go(ind + 1, tk + i, csum + (i*ind), sum, req, n, f, ff, iff, dp);
                ans %= MOD;
            }
        }
        
        return dp[ind][tk][csum] = ans;
    }
    int countBalancedPermutations(string num) {
        ll sum = 0;
        vector<ll> f(10, 0);
        for(auto it : num) {
            //cout << it-'0' << endl;
            sum += (it - '0');
            f[it - '0'] ++;
        }
        if(sum % 2)     return 0;
        sum /= 2;
        
        vector<ll> ff(100, 1);
        vector<ll> iff(100, 1);
        
        for(int i = 0; i < 100; i ++)  {
            if(i)   ff[i] = ff[i-1] * i;
            ff[i] %= MOD;
            
            iff[i] = power(ff[i], MOD-2, MOD);
        }
        
        ll n = num.length();
        ll req = n/2;
        
        //cout << sum << "" -> "" << req << endl;
        
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (req+1, vector<ll> (sum+1, -1)));
        
        ll ans = go(0, 0, 0, sum, req, n, f, ff, iff, dp);
        return ans%MOD;
    }
};",1441354520
user5976fh,user5976fh,111,3627,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + 1, moveTime[newB][newC] + 1);
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC});
                        }
                }
            }
            
        }
        return -1;
    }
};",1441293815
user5976fh,user5976fh,111,3628,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,4>> q;
        q.push({0,0,0,1});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        vector<vector<int>> maxD2 = maxD;
        // let q[3] represent if move takes 1 or move takes 2
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c,d] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + d, moveTime[newB][newC] + d);
                    // based on D check which table to use
                    if (d == 1){
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                    else{
                        if (newT < maxD2[newB][newC]){
                            maxD2[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                        
                }
            }
            
        }
        return -1;
    }
};",1441297442
user5976fh,user5976fh,111,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); ++i){
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
            
        }

        return sum == 0;
    }
};",1441281034
user5976fh,user5976fh,111,3637,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;

    long long powerMod(long long x, long long y, long long modVal) {
        long long res = 1;
        x %= modVal;
        while (y > 0) {
            if (y & 1) res = res * x % modVal;
            x = x * x % modVal;
            y >>= 1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size();
        int freq[10] = {0};
        long long totalSum = 0;

        for (char c : num) {
            freq[c - '0']++;
            totalSum += (c - '0');
        }

        if (totalSum % 2 != 0) return 0;
        long long sumEven = totalSum / 2;
        int halfN = (n + 1) / 2;
        int maxLimit = 160;

        vector<long long> fact(maxLimit + 1, 1);
        for (int i = 1; i <= maxLimit; i++) fact[i] = fact[i - 1] * i % mod;

        vector<long long> invFact(maxLimit + 1, 1);
        invFact[maxLimit] = powerMod(fact[maxLimit], mod - 2, mod);
        for (int i = maxLimit - 1; i >= 0; i--) invFact[i] = invFact[i + 1] * (i + 1) % mod;

        vector<vector<long long>> comb(10, vector<long long>());
        for (int d = 0; d < 10; d++) {
            comb[d].resize(freq[d] + 1, 0);
            for (int x = 0; x <= freq[d]; x++) {
                comb[d][x] = (fact[freq[d]] * invFact[x] % mod) * invFact[freq[d] - x] % mod;
            }
        }

        long long productFreqFact = 1;
        for (int d = 0; d < 10; d++) {
            productFreqFact = productFreqFact * fact[freq[d]] % mod;
        }

        vector<vector<long long>> dpPrev(sumEven + 1, vector<long long>(halfN + 1, 0));
        dpPrev[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            vector<vector<long long>> dpNext(sumEven + 1, vector<long long>(halfN + 1, 0));
            for (long long s = 0; s <= sumEven; s++) {
                for (int c = 0; c <= halfN; c++) {
                    if (dpPrev[s][c] == 0) continue;
                    for (int x = 0; x <= freq[d]; x++) {
                        if (s + (long long)x * d > sumEven) break;
                        if (c + x > halfN) continue;
                        dpNext[s + x * d][c + x] = (dpNext[s + x * d][c + x] + dpPrev[s][c] * comb[d][x]) % mod;
                    }
                }
            }
            dpPrev = dpNext;
        }

        long long F = dpPrev[sumEven][halfN];
        long long invProductFreqFact = powerMod(productFreqFact, mod - 2, mod);
        long long totalPerms = fact[n] * invProductFreqFact % mod;
        long long answer = F * fact[halfN] % mod;
        answer = answer * fact[n - halfN] % mod;
        answer = answer * invProductFreqFact % mod;

        return (int)answer;
    }
};",1441356070
Harttle,harttle,112,3627,javascript,"/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(Infinity))
    while (heap.size()) {
        const [t, x, y] = heap.pop()
        if (dist[x][y] !== Infinity) continue
        dist[x][y] = t
        for (const [nx, ny] of [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]) {
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny] !== Infinity) continue
            const nt = Math.max(t + 1, moveTime[nx][ny] + 1)
            heap.push([nt, nx, ny])
        }
    }
    return dist[N - 1][M - 1]
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441297717
Harttle,harttle,112,3628,javascript,"const diffs = [0, 1, 0, -1, 0]
/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    const saw = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    while (heap.size()) {
        const [t, x, y, alt] = heap.pop()
        if (dist[x][y][alt] !== Infinity) continue
        dist[x][y][alt] = t
        const nalt = 1 - alt
        for (let i = 0; i < 4; i++) {
            const nx = x + diffs[i], ny = y + diffs[i + 1]
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny][nalt] !== Infinity) continue
            const nt = Math.max(t + 1 + alt, moveTime[nx][ny] + 1 + alt)
            if (nt < saw[nx][ny][nalt]) {
                saw[nx][ny][nalt] = nt
                heap.push([nt, nx, ny, nalt])
            }
        }
    }
    return Math.min(...dist[N - 1][M - 1])
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441315111
Harttle,harttle,112,3636,javascript,"/**
 * @param {string} num
 * @return {boolean}
 */
var isBalanced = function(nums) {
    const sums = [0, 0]
    for (let i = 0; i < nums.length; i++) sums[i % 2] += +nums[i]
    // console.log(sums)
    return sums[0] === sums[1]
};",1441284175
Harttle,harttle,112,3637,javascript,"const MOD = 1e9 + 7
var MODn = BigInt(MOD);
var _Ann = [1n];
/**
 * @param {string} num
 * @return {number}
 */
var countBalancedPermutations = function(num) {
    const digits = [...num].map(x => +x)
    const N = digits.length
    const EVEN = Math.ceil(N / 2)
    const ODD = N - EVEN
    const sum = digits.reduce((sum, d) => sum + d, 0)
    if (sum % 2) return 0
    const counts = Array(10).fill(0)
    for (const d of digits) counts[d]++
    const halfSum = sum / 2
    const memo = new Map()
    const comb = dfs(halfSum, 0, ODD)
    let ans = prod(comb, factorial(EVEN), factorial(ODD))
    // console.log('comb', comb, `fact(${EVEN})`, factorial(EVEN), `fact(${ODD})`, factorial(ODD))
    for (const count of counts) {
        if (count < 2) continue
        const fact = factorial(count)
        ans = prod(ans, modInverse(fact))
    }
    return ans
    function dfs(sum, begin, count) {
        if (sum < 0 || count < 0) return 0
        if (begin === N) return sum === 0 && count === 0 ? 1 : 0
        const key = sum * 10000 + begin * 100 + count
        if (memo.has(key)) return memo.get(key)
        let ans = 0
        ans += dfs(sum - digits[begin], begin + 1, count - 1)
        ans += dfs(sum, begin + 1, count)
        ans %= MOD
        memo.set(key, ans)
        return ans
    }
};
function prod(a, ...args) {
    if (!args.length) return a
    const prev = prod(...args)
    return Number(BigInt(a) * BigInt(prev) % MODn)
}
// src/euclidean.ts
function gcdExtended(a, b) {
  if (b === 0)
    return [a, 1, 0];
  const [gcd, x1, y1] = gcdExtended(b, a % b);
  return [gcd, y1, x1 - Math.floor(a / b) * y1];
}
function modInverse(a, M = MOD) {
  const [gcd, x] = gcdExtended(a, M);
  if (gcd !== 1)
    throw new Error(""inverse not exist"");
  return (x % M + M) % M;
}

// src/binomial.ts
function factorial(N) {
  const Nn = BigInt(N);
  for (let n = BigInt(_Ann.length); n <= Nn; n++)
    _Ann.push(_Ann[_Ann.length - 1] * n % MODn);
  return Number(_Ann[Number(N)]);
}
function factorialSeq(N) {
  factorial(N);
  return _Ann.slice(0, N + 1).map((x) => Number(x));
}
function pascalsTriangle(N) {
  const C = [[1n]];
  for (let n = 1; n <= N; ++n) {
    C.push(Array(n + 1));
    C[n][0] = C[n][n] = 1n;
    for (let k = 1; k < n; ++k) {
      C[n][k] = (C[n - 1][k - 1] + C[n - 1][k]) % MODn;
    }
  }
  for (let n = 0; n <= N; n++)
    for (let k = 0; k <= n; k++)
      C[n][k] = Number(C[n][k]);
  return C;
}
function combination(n, k) {
  const deno = modMultiply(factorial(k), factorial(n - k));
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function arrangement(n, k) {
  const deno = factorial(n - k);
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function modMultiply(a, b) {
  return Number(BigInt(a) * BigInt(b) % MODn);
}",1441343449
Dhruva N L,dhruva05,113,3627,cpp,"class Solution {
public:
     int n, m;
    const long long INF = 1e18;
    vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    
    void initArrival(vector<vector<long long>>& arr) {
        for (int i = 0; i < n; i++) {
            fill(arr[i].begin(), arr[i].end(), INF);
        }
        arr[0][0] = 0;
    }
    
    bool isValid(int x, int y) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return 0;
        m = moveTime[0].size();
        vector<vector<long long>> arr(n, vector<long long>(m));
        initArrival(arr);
        
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        while (!pq.empty()) {
            auto [curTime, x, y] = pq.top();
            pq.pop();
            
            if (x == n - 1 && y == m - 1) return (int)curTime;
            if (curTime > arr[x][y]) continue;

            for (auto &[dx, dy] : dirs) {
                int nx = x + dx, ny = y + dy;
                if (isValid(nx, ny)) {
                    long long newTime = max(curTime, (long long)moveTime[nx][ny]) + 1;
                    if (newTime < arr[nx][ny]) {
                        arr[nx][ny] = newTime;
                        pq.emplace(newTime, nx, ny);
                    }
                }
            }
        }
        return -1;
    }
};",1441318569
Dhruva N L,dhruva05,113,3628,cpp,"class Solution {
    typedef long long ll;
    const ll INF = 1e18;
    
    int n, m;

    int encode(int i, int j, int parity) {
        return (i * m + j) * 2 + parity;
    }

    tuple<int, int, int> decode(int id) {
        int p = id % 2;
        int temp = id / 2;
        int j = temp % m;
        int i = temp / m;
        return {i, j, p};
    }

    void updateTime(priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> &pq,
                    vector<vector<vector<ll>>> &arrTimes, int i, int j, int p, ll arr) {
        if (arr < arrTimes[i][j][p]) {
            arrTimes[i][j][p] = arr;
            pq.push({arr, encode(i, j, p)});
        }
    }

public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return -1;
        m = moveTime[0].size();
        if (m == 0) return -1;

        vector<vector<vector<ll>>> arrTimes(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;

        arrTimes[0][0][0] = 0;
        pq.push({0, encode(0, 0, 0)});
        
        vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!pq.empty()) {
            auto [currTime, id] = pq.top(); pq.pop();
            auto [i, j, p] = decode(id);
            
            if (i == n - 1 && j == m - 1) return (int)currTime;
            if (currTime > arrTimes[i][j][p]) continue;

            for (auto &[di, dj] : dirs) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    ll moveDur = (p == 0) ? 1 : 2;
                    ll startTime = max(currTime, (ll)moveTime[ni][nj]);
                    ll arr = startTime + moveDur;
                    int np = 1 - p;
                    updateTime(pq, arrTimes, ni, nj, np, arr);
                }
            }
        }
        
        return -1;
    }
};",1441335644
Dhruva N L,dhruva05,113,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

        for (int i = 0; i < num.length(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0)
                es += d;
            else
                os += d;
        }

        return es == os;
    }
};",1441291195
Dhruva N L,dhruva05,113,3637,java,"class Solution {
    private static final int MOD = 1_000_000_007;

    private long powerMod(long x, long y, long mod) {
        long res = 1;
        x %= mod;
        while (y > 0) {
            if ((y & 1) == 1) {
                res = res * x % mod;
            }
            x = x * x % mod;
            y >>= 1;
        }
        return res;
    }

    private void computeFactAndInvFact(long[] fact, long[] invFact, int maxN) {
        fact[0] = 1;
        for (int i = 1; i <= maxN; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[maxN] = powerMod(fact[maxN], MOD - 2, MOD);
        for (int i = maxN - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    private long calculateDigitCountsAndSum(String num, int[] digitCount) {
        long totalSum = 0;
        for (char ch : num.toCharArray()) {
            digitCount[ch - '0']++;
            totalSum += (ch - '0');
        }
        return totalSum;
    }

    private long[][] initializeDpArray(int halfLen, int halfSum) {
        long[][] dp = new long[halfLen + 1][halfSum + 1];
        dp[0][0] = 1;
        return dp;
    }

    private long processDp(int halfLen, int halfSum, int[] digitCount, long[] invFact, long[][] dp) {
        for (int d = 0; d < 10; d++) {
            int countD = digitCount[d];
            long[][] tempDp = new long[halfLen + 1][halfSum + 1];

            for (int c = 0; c <= halfLen; c++) {
                for (int s = 0; s <= halfSum; s++) {
                    if (dp[c][s] == 0) continue;
                    int maxA = Math.min(countD, halfLen - c);

                    for (int aD = 0; aD <= maxA; aD++) {
                        int newC = c + aD;
                        long newS = s + (long) d * aD;
                        if (newS > halfSum) continue;
                        tempDp[newC][(int) newS] = (tempDp[newC][(int) newS] + dp[c][s] * invFact[aD] % MOD * invFact[countD - aD] % MOD) % MOD;
                    }
                }
            }
            dp = tempDp;
        }
        return dp[halfLen][halfSum];
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] digitCount = new int[10];
        long totalSum = calculateDigitCountsAndSum(num, digitCount);

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int halfLen = (n + 1) / 2;

        long[] fact = new long[n + 1];
        long[] invFact = new long[n + 1];
        computeFactAndInvFact(fact, invFact, n);

        long[][] dp = initializeDpArray(halfLen, (int) halfSum);
        long validAssignments = processDp(halfLen, (int) halfSum, digitCount, invFact, dp);

        long answer = fact[halfLen] * fact[n - halfLen] % MOD;
        answer = answer * validAssignments % MOD;

        return (int) answer;
    }
}",1441356821
rarelytested,rarelytested,114,3627,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = 1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441356900
rarelytested,rarelytested,114,3628,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = (x+y)%2+1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441355901
rarelytested,rarelytested,114,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s0 += num[i] - '0';
            } else {
                s1 += num[i] - '0';
            }
        }
        return s0 == s1;
    }
};",1441282560
rarelytested,rarelytested,114,3637,cpp,"class Solution {
   public:
#define MOD 1000000007
    long long C[100][100];
    void init() {
        C[0][0] = 1;
        for (int i = 1; i < 100; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        vector<int> cnt(10, 0);
        for (int i = 0; i < num.size(); i++) {
            sum += num[i] - '0';
            cnt[num[i] - '0']++;
        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        init();

        int n0 = (num.size() + 1) / 2;
        int n1 = num.size() - n0;
        vector<vector<vector<long long>>> dp(
            10,
            vector<vector<long long>>(sum + 1, vector<long long>(n0 + 1, 0)));
        int tot = 0;
        for (int i = 0; i < 10; i++) {
            if (i == 0) {
                for (int j = 0; j <= cnt[i]; j++) {
                    if (j > n0) {
                        break;
                    }
                    dp[i][0][j] = C[n0][j] * C[n1][cnt[i] - j] % MOD;
                }
                tot += cnt[i];
                continue;
            }
            for (int j = 0; j <= sum; j++) {
                for (int k = 0; k <= n0; k++) {
                    if (dp[i - 1][j][k] == 0) {
                        continue;
                    }
                    for (int l = 0; l <= cnt[i]; l++) {
                        if (j + l * i > sum || k + l > n0) {
                            break;
                        }
                        if (n1 - (tot-k) < 0) {
                            continue;
                        }
                        if (tot < k) {
                            continue;
                        }
                        // if (i == 3) {
                        //     std::cout << i << "" "" << j << "" "" << k << "" "" << l
                        //               << "" "" << dp[i - 1][j][k] << "" ""
                        //               << C[n0 - k][l] << "" ""
                        //               << C[n1 - (tot-k)][cnt[i] - l]
                        //               << std::endl;
                        // }
                        dp[i][j + l * i][k + l] +=
                            dp[i - 1][j][k] * C[n0 - k][l] % MOD *
                            C[n1 - (tot-k)][cnt[i] - l] % MOD;
                        dp[i][j + l * i][k + l] %= MOD;
                    }
                }
            }
            tot += cnt[i];
        }
        // std::cout << dp[2][3][2] << std::endl;
        return dp[9][sum][n0];
    }
};",1441338543
Yucheng Dai,Rainingcity,115,3627,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(0, make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [d, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + 1;
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(-nt, make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441293574
Yucheng Dai,Rainingcity,115,3628,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(make_pair(0, 1), make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [dd, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            auto [d, step] = dd;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + (step ? 1 : 2);
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(make_pair(-nt, !step), make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441297044
Yucheng Dai,Rainingcity,115,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < num.length(); i++) {
            if (i & 1) {
                r += num[i] - '0';
            } else {
                l += num[i] - '0';
            }
        }
        return l == r;
    }
};",1441281589
Yucheng Dai,Rainingcity,115,3637,cpp,"typedef long long ll;
const ll MOD = 1000000007;
vector<ll> buildFact(ll n) {
    vector<ll> fact(n + 1, 0);
    fact[0] = fact[1] = 1;
    for(ll i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    return fact;
}
vector<vector<ll>> buildC(ll n) {
    vector<vector<ll>> C(n + 1, vector<ll>(n + 1, 0));
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(ll i = 2; i <= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(ll j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
    return C;
}
ll gcdExtended(ll a, ll b, ll& x, ll& y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    ll d = gcdExtended(b % a, a, x, y);
    ll t = x;
    x = y - (b / a) * x;
    y = t;
    return d;
}
ll modInverse(ll a) {
    ll x, y;
    ll g = gcdExtended(a, MOD, x, y);
    return (x % MOD + MOD) % MOD;
}
vector<ll> buildInv(vector<ll>& l) {
    vector<ll> res{};
    for(ll x: l) {
        res.push_back(modInverse(x));
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        int sum = 0;
        int cnt[10];
        memset(cnt, 0, sizeof(cnt));
        for(char c: num) {
            sum += c - '0';
            cnt[c - '0']++;
        }
        if (sum & 1) return 0;
        vector<vector<ll>> C = buildC(n);
        vector<ll> fact = buildFact(n);
        vector<ll> factInv = buildInv(fact);
        int m = (n + 1) / 2;
        sum /= 2;
        // cur_digit, left #digit, left sum
        vector<vector<vector<ll>>> dp(11, vector<vector<ll>>(m + 1, vector<ll>(sum + 1, 0)));
        dp[0][0][0] = 1;
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= m; j++) {
                for(int k = 0; k <= sum; k++) {
                    for(int t = 0; t <= cnt[i] && t <= j && i * t <= k; t++) {
                        dp[i + 1][j][k] = (dp[i + 1][j][k] + ((dp[i][j - t][k - i * t] * factInv[t]) % MOD) * factInv[cnt[i] - t]) % MOD;
                        // cout << i << "" "" << j << "" "" << k << "" "" << dp[i + 1][j][k] << endl;
                    }
                }
            }
        }
        return (((dp[10][m][sum] * fact[m]) % MOD) * fact[n - m]) % MOD;
    }
};",1441357030
Shashwat Tripathi,Fkaiser7,117,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,
            greater<pair<int,pair<int,int>>>>pq;
        pq.push({0,{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({t1,{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({t1,{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({t1,{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({t1,{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441296836
Shashwat Tripathi,Fkaiser7,117,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<pair<int,int>,pair<int,int>>,vector<pair<pair<int,int>,pair<int,int>>>,
            greater<pair<pair<int,int>,pair<int,int>>>>pq;
        pq.push({{0,0},{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first.first;
            int turn=it.first.second;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+turn+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+turn+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({{t1,1-turn},{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1+turn;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1+turn;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({{t1,1-turn},{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1+turn;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1+turn;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({{t1,1-turn},{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1+turn;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1+turn;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({{t1,1-turn},{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441304766
Shashwat Tripathi,Fkaiser7,117,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int a=0,b=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        return a==b;
    }
};",1441281257
Shashwat Tripathi,Fkaiser7,117,3637,cpp,"#define lli long long
lli mod=1e9+7;
vector<lli>fact(81);
void calc(){
    lli p=1;
    fact[0]=fact[1]=1;
    for(lli i=2;i<=80;i++){
        p=(p%mod*i%mod)%mod;
        fact[i]=p;
    }
}
long long power(long long i, int j) { return j ? j & 1 ? power(i * i % mod, j >> 1) * i % mod : power(i * i % mod, j >> 1) : 1; }
lli comb(lli n,lli r){
    lli t=fact[n];
    lli t1=(fact[r]%mod*fact[n-r]%mod)%mod;
    t1=power(t1,mod-2);
    t=(t%mod*t1%mod)%mod;
    return t;
}
class Solution {
public:
    lli fuc(lli i,lli o,lli sum,vector<lli>&freq,vector<vector<vector<lli>>>&dp
,lli &n){
        if(i==10){
            if(sum==0){
                return 1;
            }
            return 0;
        }
        if(dp[i][o][sum]!=-1){
            return dp[i][o][sum];
        }
        lli o1=n/2;
        if(n%2){
            o1++;
        }
        lli e=0;
        if(i!=0){
            e=freq[i-1]-o1+o;
        }
        e=n/2-e;
        lli t=freq[i];
        if(i!=0){
            t-=freq[i-1];
        }
        //cout<<i<<"" ""<<o<<"" ""<<e<<"" ""<<t<<"" ""<<sum<<endl;
        //cout<<i<<"" ""<<o<<"" ""<<e<<endl;
        lli ans=0;
            for(lli j=0;j<=t;j++){
                if(t-j>e||j>o||j*i>sum){
                    continue;
                }
                lli ans1=(comb(o,j)%mod*comb(e,t-j)%mod)%mod;
                ans1=(ans1%mod*fuc(i+1,o-j,sum-j*i,freq,dp,n)%mod)%mod;
                ans+=ans1;
                ans%=mod;
            }
        //cout<<i<<"" ""<<o<<"" ""<<t<<"" ""<<sum<<"" ""<<ans<<endl;
        return dp[i][o][sum]=ans;
    }
    int countBalancedPermutations(string num) {
        calc();
        //cout<<comb(4,2)<<endl;
        lli n=num.length();
        lli o=n/2,e=n/2;
        if(n%2){
            o++;
        }
        vector<lli>freq(10);
        lli sum=0;
        for(lli i=0;i<n;i++){
            freq[num[i]-'0']++;
            sum+=num[i]-'0';
        }
        if(sum%2){
            return 0;
        }
        vector<vector<vector<lli>>>dp(10,vector<vector<lli>>(n+1,
        vector<lli>(sum/2+1,-1)));
        vector<lli>freq1(10);
        for(lli i=0;i<10;i++){
            if(i==0){
                freq1[i]=freq[i];
            }
            else{
                freq1[i]=freq1[i-1]+freq[i];
            }
        }
        //cout<<sum<<endl;
        return (int)(fuc(0,o,sum/2,freq1,dp,n));
    }
};",1441358541
lilPeep,stupidRR,118,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<int>> dp(n,vector<int>(m,2e9));
        dp[0][0]=0;
        
        set< array<int,3> > dij;
        dij.insert( {0,0,0} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y]=*dij.begin();
            dij.erase( dij.begin() );
            
            cout << X << "" "" << Y << "" "" << tim << endl;
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim+1,ar[x][y]+1);
                    if( dp[x][y] > reach )
                    {
                        dij.erase( {dp[x][y],x,y} );
                        dp[x][y]=reach;
                        dij.insert( {dp[x][y],x,y} );
                    }
                }
            }
        }
        cout << endl;
        return dp[n-1][m-1];
    }
};",1441298381
lilPeep,stupidRR,118,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(2,2e9)));
        dp[0][0][1]=0;
        
        set< array<int,4> > dij;
        dij.insert( {0,0,0,1} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y,type]=*dij.begin();
            dij.erase( dij.begin() );
            
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim,ar[x][y])+2-type%2;
                    if( dp[x][y][1-type] > reach )
                    {
                        dij.erase( {dp[x][y][1-type],x,y,1-type} );
                        dp[x][y][1-type]=reach;
                        dij.insert( {dp[x][y][1-type],x,y,1-type} );
                    }
                }
            }
        }
        return std::min(dp[n-1][m-1][0],dp[n-1][m-1][1]);
    }
};",1441303245
lilPeep,stupidRR,118,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum=0;
        for(int i=0;i<num.size();i++)
        {
            if(i%2)
                sum+=(num[i]-'0');
            else
                sum=sum-(num[i]-'0');
        }
        return !sum;
    }
};",1441282957
lilPeep,stupidRR,118,3637,cpp,"typedef long long ll;
class Solution {
    ll factorial[101];
    ll inverse[101];
       
    ll binpow(ll base,ll ex)
    {
        if(ex<0)
          return 0ll;
        ll ans=1;
        while(ex>0)
        {
            if(ex%2==1)
                    ans=(ans*base)%mod;
            base=(base*base)%mod;
            ex=ex/2;
        }
        return ans;
    }
     
    void pre()
    {
       factorial[0]=1;
       inverse[0]=1;
       for(int i=1;i<=100;i++)
           factorial[i]=(factorial[i-1]*i)%mod;
       
       inverse[100]=binpow(factorial[100],mod-2);
       for(int i=99;i>=0;i--)
          inverse[i]=(inverse[i+1]*(i+1ll))%mod;
    }
     
    ll nCr(int n , int r)
    {
        if(n<0 || r<0 || n<r)
                return 0;
        ll ans=1;
        ans=factorial[n];
        ans=(ans*inverse[n-r])%mod;
        ans=(ans*inverse[r])%mod;
        return ans;
    }
    const int mod=1e9+7;
public:
    int countBalancedPermutations(string num) {
        int n=num.size();
        pre();
        int odd=(n)/2;

        vector<int> freq(10);
        for(auto ele : num)
            freq[ele-'0']++;

        vector<vector<long long>> dp(odd+1,vector<long long>(1001,0));
        dp[ odd ][ 500 ]=1ll;
        int placedTillNow=0;
        int even=n-odd;

        for(int i=0;i<10;i++) // 10* 41*41*1000 = 16000*2000 
        {
            int val=freq[i];
            if(val==0)
                continue;

            vector<vector<long long>> ndp(odd+1,vector<long long>(1001,0));

            for(int oddHave=0;oddHave<=odd;oddHave++)
            {
                for(int j=oddHave;j<=odd;j++)
                {

                    int oddUsed=j-oddHave;
                    if(oddUsed>val)
                        break;
                    int evenUsed=val-oddUsed;
                    
                    int oddPlacedTillNow=odd-j;
                    int evenPlaced=placedTillNow-oddPlacedTillNow;

                    if(evenPlaced+evenUsed > even)
                        continue;
                    
                    int delta=oddUsed*i-evenUsed*i;

                    for(int sum=0;sum<=1000;sum++)
                    {
                        if(sum+delta <=1000 && sum+delta>=0 && dp[j][sum])
                            ndp[oddHave][sum+delta]=(ndp[oddHave][sum+delta]+ dp[j][sum]* ((nCr(odd-oddPlacedTillNow,oddUsed)*nCr(even-evenPlaced,evenUsed))%mod) )%mod;
                    }
                }
            }
            placedTillNow+=val;
            swap(dp,ndp);
        }

        return dp[0][500];
    }
};

",1441339362
Srujan_Teja_Rayella,Srujan_code_code,119,3627,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        int[][] distance = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        priorityQueue.offer(new int[]{0, 0, 0}); // {time, row, col}
        distance[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!priorityQueue.isEmpty()) {
            int[] current = priorityQueue.poll();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > distance[currentRow][currentCol]) continue;

            for (int[] direction : directions) {
                int newRow = currentRow + direction[0];
                int newCol = currentCol + direction[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int newTime = Math.max(currentTime, moveTime[newRow][newCol]) + 1;

                    if (newTime < distance[newRow][newCol]) {
                        distance[newRow][newCol] = newTime;
                        priorityQueue.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }

        return distance[rows - 1][cols - 1];
    }
}


",1441321285
Srujan_Teja_Rayella,Srujan_code_code,119,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] dp = new int[n][m][2];
        for (int[][] arr : dp) {
            for (int[] subArr : arr) {
                Arrays.fill(subArr, Integer.MAX_VALUE);
            }
        }
        dp[0][0][0] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int time = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];

            if (time > dp[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);

                    if (newTime < dp[newRow][newCol][1 - parity]) {
                        dp[newRow][newCol][1 - parity] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol, 1 - parity});
                    }
                }
            }
        }

        return Math.min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
}



",1441326648
Srujan_Teja_Rayella,Srujan_code_code,119,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumEvenPositions = 0;
        int sumOddPositions = 0;
        
        for (int index = 0; index < num.length(); index++) {
            int digitValue = num.charAt(index) - '0'; 
            
            if (index % 2 == 0) {
                sumEvenPositions += digitValue; 
            } else {
                sumOddPositions += digitValue; 
            }
        }
        
        return sumEvenPositions == sumOddPositions;
    }
}
",1441297850
Srujan_Teja_Rayella,Srujan_code_code,119,3637,java,"class Solution {
    private static final int MOD = 1000000007;

    public int countBalancedPermutations(String num) {
        int length = num.length();
        long totalSum = 0;
        int[] counts = new int[10];

        for (char digit : num.toCharArray()) {
            int d = digit - '0';
            totalSum += d;
            counts[d]++;
        }

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int m = (length + 1) / 2;
        long[] factorial = new long[length + 1];
        long[] invFactorial = new long[length + 1];
        factorial[0] = 1;

        for (int i = 1; i <= length; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        invFactorial[length] = modInverse(factorial[length], MOD);

        for (int i = length - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        long[][] dp = new long[m + 1][(int) (halfSum + 1)];
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (counts[d] == 0) {
                continue;
            }

            for (int k = m; k >= 0; k--) {
                for (int s = (int) halfSum; s >= 0; s--) {
                    if (dp[k][s] == 0) {
                        continue;
                    }

                    for (int t = 1; t <= counts[d]; t++) {
                        if (k + t > m || s + d * t > halfSum) {
                            break;
                        }
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(counts[d], t, factorial, invFactorial, MOD)) % MOD;
                    }
                }
            }
        }

        long w = dp[m][(int) halfSum];
        long result = factorial[m] * factorial[length - m] % MOD;

        for (int d = 0; d < 10; d++) {
            result = result * invFactorial[counts[d]] % MOD;
        }

        result = result * w % MOD;
        return (int) result;
    }

    private long modInverse(long a, int m) {
        long result = 1;
        long base = a;
        int p = m - 2;

        while (p > 0) {
            if ((p & 1) == 1) {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        return result;
    }

    private long comb(int n, int k, long[] factorial, long[] invFactorial, int m) {
        if (k > n) {
            return 0;
        }
        return factorial[n] * invFactorial[k] % m * invFactorial[n - k] % m;
    }
}

",1441353506
sveng101,sveng101,120,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0))]
        while heap:
            t, pos = heapq.heappop(heap)
            if pos in seen: continue
            seen.add(pos)
            for pos2 in move(pos):
                if pos2 in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1
                if pos2 == target:
                    return t2
                heapq.heappush(heap, (t2, pos2))
        return -1",1441300706
sveng101,sveng101,120,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0), False)]
        while heap:
            t, pos, even = heapq.heappop(heap)
            #print(pos, even, t)
            if (pos, even) in seen: continue
            elif pos == target:
                return t
            seen.add((pos, even))
            for pos2 in move(pos):
                if (pos2, not even) in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1 + even
                heapq.heappush(heap, (t2, pos2, not even))
        return -1",1441308855
sveng101,sveng101,120,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res = 0
        n = len(num)
        for i in range(0, n, 2):
            res += int(num[i])
        for i in range(1, n, 2):
            res -= int(num[i])
        return not res
        """"""
        while num:
            num, d = divmod(num, 10)
            res += d if d & 1 else -d
        return not res
        """"""",1441289145
sveng101,sveng101,120,3637,python3,"import math
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        md = 10 ** 9 + 7

        n = len(num)
        
        cnts = {}
        tot = 0
        for d in num:
            d2 = int(d)
            cnts[d2] = cnts.get(d2, 0) + 1
            tot += d2
        if tot & 1: return 0
        tot_target = tot >> 1
        res = 0
        cnts2 = sorted([(y, x) for x, y in cnts.items()])
        m = len(cnts2)
        cnt_target = n >> 1
        #print(cnts2)
        memo = {}
        def backtrack(idx: int, cnt_rem: int=cnt_target, tot_rem: int=tot_target) -> int:
            f_tot, num = cnts2[idx]
            if idx == m - 1:
                f = cnt_rem
                if f > f_tot or f * num != tot_rem: return 0
                return (math.factorial(cnt_target) * math.factorial(n - cnt_target)) // (math.factorial(f) * math.factorial(f_tot - f))
            args = (idx, cnt_rem, tot_rem)
            if args in memo.keys(): return memo[args]
            res = 0
            cnt_rem2 = cnt_rem
            tot_rem2 = tot_rem
            for f in range(min(f_tot, cnt_rem) + 1):
                res += backtrack(idx + 1, cnt_rem=cnt_rem2, tot_rem=tot_rem2) // (math.factorial(f) * math.factorial(f_tot - f))
                cnt_rem2 -= 1
                tot_rem2 -= num
                if tot_rem2 < 0: break
            memo[args] = res
            return res
        res =(backtrack(0)) % md
        #print(memo)
        return res",1441359877
Pankaj Ananda Bhosale,pankaj_777,121,3627,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dist(n, vector<ll> (m, inf));
        dist[0][0] = 0;
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, greater<array<ll, 3>>> pq;
        pq.push({0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 : moveTime[nrow][ncol] + 1);
                    if (dist[nrow][ncol] > ntime) {
                        dist[nrow][ncol] = ntime;
                        pq.push({ntime, nrow, ncol});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441315132
Pankaj Ananda Bhosale,pankaj_777,121,3628,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        ll dist[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }
        
        dist[0][0][0] = 0;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, greater<array<ll, 4>>> pq;
        pq.push({0, 0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0], parity = pq.top()[3];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 + parity : moveTime[nrow][ncol] + 1 + parity);
                    if (dist[nrow][ncol][1 - parity] > ntime) {
                        dist[nrow][ncol][1 - parity] = ntime;
                        pq.push({ntime, nrow, ncol, 1 - parity});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441320881
Pankaj Ananda Bhosale,pankaj_777,121,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int cntEven = 0, cntOdd = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2) cntEven += num[i] - '0';
            else cntOdd += num[i] - '0';
        }
        
        return cntOdd == cntEven;
    }
};",1441281857
Pankaj Ananda Bhosale,pankaj_777,121,3637,cpp,"#define ll long long int
const int mod = 1e9 + 7;

int mulm(ll a, ll b) {
    return (a * b) % mod;
}

int addm(ll a, ll b) {
    return (a + b) % mod;
}

ll powr(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = mulm(res, a);
        a = mulm(a, a);
        b = b >> 1;
    }
    return res;
}

ll inv(ll x) {
    if (x <= 1) return 1;
    return powr(x, mod - 2);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        
        int tot_sum = 0;
        vector<int> cnt(10, 0), fact(n + 1, 1);
        for (int i = 0; i < n; i++) {
            tot_sum += (num[i] - '0');
            cnt[num[i] - '0']++;
        }
        
        if (tot_sum % 2) return 0;
        
        for (int i = 2; i <= n; i++) {
            fact[i] = mulm(i, fact[i - 1]);
        }
        
        vector<vector<vector<int>>> dp(10, vector<vector<int>> (400, vector<int> (n + 1, -1)));
        auto fun = [&] (int idx, int sum_even, int cntEven, auto&& fun) -> int {
            if (idx == 10) {
                return (sum_even == tot_sum / 2 and cntEven == n / 2) * mulm(fact[n / 2], fact[(n + 1) / 2]);
            }
            
            if (dp[idx][sum_even][cntEven] != -1) return dp[idx][sum_even][cntEven];
            
            int res = 0;
            for (int c = 0; c <= cnt[idx]; c++) {
                res = addm(res, mulm(fun(idx + 1, sum_even + c * idx, cntEven + c, fun), mulm(inv(fact[c]), inv(fact[cnt[idx] - c]))));
            }

            return dp[idx][sum_even][cntEven] = res;
        };
        
        return fun(0, 0, 0, fun);
    }
};",1441359987
i_will_beat_my_iq,i_will_beat_my_iq,122,3627,cpp,"class Solution {
public:
#define ll long long
void f1(int x, int y, int curr_t, vector<vector<int>>& t, vector<vector<int>>& d, 
                           priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>>& q,
                           int dirs[][2], ll r, ll c) {
        ll i = 0;
        while (i < 4) {
            int nx = x + dirs[i][0], ny = y + dirs[i][1];
            if (f2(nx, ny, r, c)) {
                int new_t = f3(curr_t, t[nx][ny]);
                if (new_t < d[nx][ny]) {
                    d[nx][ny] = new_t;
                    q.push({new_t, {nx, ny}});
                }
            }
            i++;
        }
    }

    bool f2(int x, int y, ll r, ll c) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }

    int f3(int curr_t, int move_t) {
        return max(curr_t, move_t) + 1;
    }
    int minTimeToReach(vector<vector<int>>& t) {
        ll r = t.size();
        ll c = t[0].size();
        vector<vector<int>> d(r, vector<int>(c, INT32_MAX));
        d[0][0] = 0;

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> q;
        q.push({0, {0, 0}});

        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!q.empty()) {
            auto [curr_t, pos] = q.top();
            int x = pos.first, y = pos.second;
            q.pop();

            if (x == r - 1 && y == c - 1) return curr_t;
            if (curr_t > d[x][y]) continue;

            f1(x, y, curr_t, t, d, q, dirs, r, c);
        }
        return -1;
    }
};",1441314147
i_will_beat_my_iq,i_will_beat_my_iq,122,3628,cpp,"class Solution {
public:
struct S {
    long long a;
    int b;
    int c;
    int d;
    bool operator<(const S& o) const {
        return a > o.a;
    }
};

 priority_queue<S> f1() {
        priority_queue<S> a;
        return a;
    }

    vector<pair<int, int>> f2() {
        vector<pair<int, int>> a = { {1,0}, {-1,0}, {0,1}, {0,-1} };
        return a;
    }

    S f3(priority_queue<S>& a) {
        S b = a.top();
        a.pop();
        return b;
    }

    bool f4(int a, int b, int c, int d) {
        return (a >= 0 && a < c && b >= 0 && b < d);
    }

    int f5(int a) {
        return (a == 0) ? 1 : 2;
    }

    long long f6(long long a, vector<vector<int>>& b, int c, int d) {
        return max(a, (long long)b[c][d]);
    }

    S f7(long long a, int b, int c, int d) {
        S e;
        e.a = a;
        e.b = b;
        e.c = c;
        e.d = d;
        return e;
    }
    int minTimeToReach(vector<vector<int>>& a) {
        vector<vector<int>> b = a;
        int c = b.size();
        if(c == 0) return -1;
        int d = b[0].size();
        if(d == 0) return -1;
        long long e = 1000000000000000000;
        vector<vector<long long>> f(c, vector<long long>(d, e));
        vector<vector<long long>> g(c, vector<long long>(d, e));
        priority_queue<S> h = f1();
        S i;
        i.a = 0;
        i.b = 0;
        i.c = 0;
        i.d = 0;
        f[0][0] = 0;
        h.push(i);
        vector<pair<int, int>> j = f2();
        while(!h.empty()) {
            S k = f3(h);
            if(k.b == c-1 && k.c == d-1){
                return (int)k.a;
            }
            if((k.d == 0 && k.a > f[k.b][k.c]) || 
               (k.d == 1 && k.a > g[k.b][k.c])) {
                continue;
            }
            for(int l = 0; l < j.size(); l++) {
                pair<int, int> m = j[l];
                int n = k.b + m.first;
                int o = k.c + m.second;
                if(!f4(n, o, c, d)) continue;
                int p = f5(k.d);
                long long q = f6(k.a, b, n, o);
                long long r = q + p;
                int s = 1 - k.d;
                if(s == 0){
                    if(r < f[n][o]){
                        f[n][o] = r;
                        S t = f7(r, n, o, s);
                        h.push(t);
                    }
                }
                else{
                    if(r < g[n][o]){
                        g[n][o] = r;
                        S u = f7(r, n, o, s);
                        h.push(u);
                    }
                }
            }
        }
        return -1;
    }
};",1441342852
i_will_beat_my_iq,i_will_beat_my_iq,122,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int se = 0, so = 0, i = 0;
        while (i < s.size()) {
            int d = s[i] - '0';
            (i % 2 == 0) ? se += d : so += d;
            i++;
        }
        return se == so;
    }
};",1441308665
i_will_beat_my_iq,i_will_beat_my_iq,122,3637,cpp,"class Solution {
public:
typedef long long ll;
static const int mx = 80;
ll mod_val = 1000000007;
ll f[mx + 1], inv_f[mx + 1];

ll f1(ll x, ll y, ll mod) {
    ll r = 1;
    x %= mod;
    while (y > 0) {
        if (y & 1) {
            r = r * x % mod;
        }
        x = x * x % mod;
        y >>= 1;
    }
    return r;
}
void f2() {
    f[0] = 1;
    for (int i = 1; i <= mx; i++) {
        f[i] = f[i - 1] * i % mod_val;
    }
    inv_f[mx] = f1(f[mx], mod_val - 2, mod_val);
    for (int i = mx - 1; i >= 0; i--) {
        inv_f[i] = inv_f[i + 1] * (i + 1) % mod_val;
    }
}
void f4(string &s, int freq[]) {
        for (char c : s) {
            freq[c - '0']++;
        }
    }

    ll f5(int freq[]) {
        ll total = 0;
        for (int d = 0; d <= 9; d++) {
            total += (ll)d * freq[d];
        }
        return total;
    }

    void f6(int freq[], ll grp_size, ll half, vector<vector<ll>> &dp_prev, vector<vector<ll>> &dp_curr) {
        for (int d = 0; d <= 9; d++) {
            for (int j = 0; j <= grp_size; j++) {
                fill(dp_curr[j].begin(), dp_curr[j].end(), 0LL);
            }

            for (int j = 0; j <= grp_size; j++) {
                for (int k = 0; k <= half; k++) {
                    if (dp_prev[j][k] == 0) continue;
                    f8(dp_curr, dp_prev, freq[d], j, k, d, grp_size, half);
                }
            }
            swap(dp_prev, dp_curr);
        }
    }

    ll f7(int freq[]) {
        ll denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * inv_f[freq[d]] % mod_val;
        }
        return denom;
    }

    void f8(vector<vector<ll>> &dp_curr, vector<vector<ll>> &dp_prev, int freq_d, int j, int k, int d, int grp_size, ll half) {
        for (int c = 0; c <= freq_d && j + c <= grp_size && k + c * d <= half; c++) {
            ll comb = f[freq_d] * inv_f[c] % mod_val * inv_f[freq_d - c] % mod_val;
            dp_curr[j + c][k + c * d] = (dp_curr[j + c][k + c * d] + dp_prev[j][k] * comb) % mod_val;
        }
    }
    int countBalancedPermutations(string s) {
        bool init = false;
        if (!init) {
            f2();
            init = true;
        }

        int freq[10] = {0};
        f4(s, freq);

        ll total = f5(freq);

        if (total % 2 != 0) return 0;

        ll half = total / 2;
        ll grp_size = (s.size() + 1) / 2;
        ll odd_grp_size = s.size() - grp_size;

        vector<vector<ll>> dp_prev(grp_size + 1, vector<ll>(half + 1, 0));
        vector<vector<ll>> dp_curr(grp_size + 1, vector<ll>(half + 1, 0));
        dp_prev[0][0] = 1;

        f6(freq, grp_size, half, dp_prev, dp_curr);

        ll total_comb = dp_prev[grp_size][half];
        ll denom = f7(freq);

        ll res = f[grp_size] * f[odd_grp_size] % mod_val;
        res = (res * total_comb) % mod_val;
        res = (res * denom) % mod_val;

        return res;
    }
};",1441353944
virinci,virinci,124,3627,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307496
virinci,virinci,124,3628,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, 3 - incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307148
virinci,virinci,124,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281046
virinci,virinci,124,3637,python3,"from collections import Counter

M = 10**9 + 7

fact = [1] * 81
for x in range(1, len(fact)):
    fact[x] = (fact[x - 1] * x) % M


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digit_sum = sum(map(int, num))
        if digit_sum % 2:
            return 0

        n, m = len(num), digit_sum // 2 + 1

        dp = [[0] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 1

        for d in map(int, num):
            for i in range(n, 0, -1):
                for j in range(m, d - 1, -1):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % M

        even_count = (n + 1) // 2
        ways = dp[even_count][digit_sum // 2]

        counter = Counter(num)
        inv = 1
        for c in counter.values():
            inv *= pow(fact[c], -1, M)
            inv %= M

        return ways * fact[even_count] * fact[n - even_count] * inv % M",1441342013
Samadeep,rbssmtkr,125,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int n = moveTime.size();
        int m = moveTime[0].size();

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            pq;

        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));

        pq.push({0, 0, 0});
        dist[0][0] = 0;

        while (!pq.empty()) {

            auto [time, x, y] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (time > dist[x][y])
                continue;

            for (auto& [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int wait_time = max(0, moveTime[nx][ny] - time);
                    int new_time = time + 1 + wait_time;

                    if (new_time < dist[nx][ny]) {
                        dist[nx][ny] = new_time;
                        pq.push({new_time, nx, ny});
                    }
                }
            }
        }

        return -1;
    }
};",1441296109
Samadeep,rbssmtkr,125,3628,cpp,"int64_t dist1[850][850], dist0[850][850];
const int64_t INF = 1e18;
class Solution {
public:
    struct node_state {
    int64_t time;
        int x, y;    
        bool parity;
        bool operator<(const node_state& other) const {
            return time > other.time;
        }
    };

    Solution() {

        for (int i = 0; i <= 800; i++) {
            for (int j = 0; j <= 800; j++) {
                dist1[i][j] = INF;
                dist0[i][j] = INF;
            }
        }
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        auto inside = [&](int x, int y) {
            return !(x < 0 || x >= n || y < 0 || y >= m);
        };

        auto cmp = [](const node_state a, const node_state b) {
            return a.time > b.time;
        };

        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<node_state> pq;
        dist0[0][0] = 0;

        pq.push(node_state{0, 0, 0, false});

        while (!pq.empty()) {

            auto [curr_time,x, y, parity] = pq.top();
            pq.pop();

            if ((curr_time > dist0[x][y] && !parity) ||
                (curr_time > dist1[x][y]) && parity) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int nx = x + dx;
                int ny = y + dy;

                if (!inside(nx, ny))
                    continue;

                int64_t start = max(curr_time, (int64_t)moveTime[nx][ny]);
                int dur = (parity) ? 2 : 1;
                int64_t arrival_time = start + dur;

                bool next = !parity;

                if (next == 0 and arrival_time < dist0[nx][ny]) {
                    dist0[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                } else if (arrival_time < dist1[nx][ny]) {
                    dist1[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                }
            }
        }

        int64_t answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return static_cast<int>(answer);
    }
};",1441340411
Samadeep,rbssmtkr,125,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for( int i = 0 ; i < num.size(); i++ ){
            if( i&1 ) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }

        return sum == 0;
    }
};",1441286169
Samadeep,rbssmtkr,125,3637,cpp,"
const int64_t mod = 1e9 + 7;
int64_t inv(int64_t i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
int64_t mod_mul(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}
int64_t mod_add(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}
int64_t gcd(int64_t a, int64_t b) { if (b == 0) return a; return gcd(b, a % b);}
int64_t ceil_div(int64_t a, int64_t b) {return a % b == 0 ? a / b : a / b + 1;}


const int SIZE = 200;
const int MOD = 1e9 + 7;
int64_t mypow(int64_t x, int64_t y) {
    x %= MOD;
    int64_t res = 1 % MOD;
    while (y) {
        if (y & 1)
            res = res * x % MOD;
        y >>= 1;
        x = x * x % MOD;
    }
    return res;
}

int64_t power(int64_t base, int64_t exp, int64_t mod) {
    int64_t res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1)
            res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

int64_t fac[SIZE];
int64_t inv_fac[SIZE];
void pre() {
    fac[0] = 1;
    for (int i = 1; i < SIZE; i++) {
        fac[i] = fac[i - 1] * i % MOD;
    }
    inv_fac[SIZE - 1] = mypow(fac[SIZE - 1], MOD - 2);
    for (int i = SIZE - 2; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD;
    }
}

int64_t NCR(int64_t n, int64_t m) {
    if (m < 0 || m > n) {
        return 0;
    }
    return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;
}

bool precompute = false;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (not precompute) {
            pre();
            precompute = true;
        }

        int N = num.size();
        int E = (N + 1) / 2;
        int O = N / 2;

        int64_t cnt[10] = {0};
        for (char ch : num) {
            cnt[ch - '0']++;
        }

        int64_t total_sum = 0;
        for (int64_t d = 0; d < 10; d++) {
            total_sum += d * cnt[d];
        }

        if (total_sum % 2 != 0)
            return 0;

        const int64_t TARGET = total_sum / 2;

        vector<vector<int64_t>> dp(E + 1,
                                     vector<int64_t>(TARGET + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (!cnt[d])
                continue;
            
            for (int t = E; t >= 0; t--) {
                for (int64_t s = TARGET; s >= 0; s--) {
                    if (!dp[t][s])
                        continue;
                    
                    for (int k = 1; k <= cnt[d] && t + k <= E &&
                                    s + (int64_t)d * k <= TARGET;
                         k++) {
                        dp[t + k][s + (int64_t)d * k] =
                            mod_add(dp[t + k][s + (int64_t)d * k] , dp[t][s] * NCR(cnt[d], k));
                    }
                }
            }
        }

        int64_t prod_ans = 1;
        for (int d = 0; d < 10; d++) {
            prod_ans = mod_mul(prod_ans , fac[cnt[d]]);
        }

        int64_t answer = dp[E][TARGET] * fac[E] % MOD;
        answer = answer * fac[O] % MOD;
        return (int)mod_mul(answer , power(prod_ans, MOD - 2, MOD));
    }
};",1441361820
Huzaifa Khilawala,RedHeadphone,127,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+1,(nx,ny)))
                    visited.add((nx,ny))",1441295652
Huzaifa Khilawala,RedHeadphone,127,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,1,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time,addi, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+addi,1 if addi==2 else 2,(nx,ny)))
                    visited.add((nx,ny))",1441299635
Huzaifa Khilawala,RedHeadphone,127,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ev = 0
        for i in range(0,len(num),2):
            ev += int(num[i])
        od = 0
        for i in range(1,len(num),2):
            od += int(num[i])
        return ev == od",1441281765
Huzaifa Khilawala,RedHeadphone,127,3637,python3,"
MOD = 10**9 + 7

class Combinatorics:
    def __init__(self, pre_compute_limit=0):
        self.fact = [1] * pre_compute_limit
        self.invfact = [1] * pre_compute_limit
        for i in range(1, pre_compute_limit):
            self.fact[i] = (self.fact[i - 1] * i) % MOD
            self.invfact[i] = (self.invfact[i - 1] * pow(i, MOD - 2, MOD)) % MOD

    def ncr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[r] * self.invfact[n - r]) % MOD

    def npr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[n - r]) % MOD

    def ncr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = den = 1
        for i in range(r):
            num = (num * (n - i)) % MOD
            den = (den * (i + 1)) % MOD
        return (num * pow(den, MOD - 2, MOD)) % MOD

    def npr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = 1
        for i in range(n, n - r, -1):
            num = (num * i) % MOD
        return num

comb = Combinatorics(100)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(num)
        num = [int(i) for i in num]

        summ = sum(num)
        if summ%2 != 0:
            return 0
        
        target = summ//2
        n = len(num)
        length_req = n//2

        inv_mul = True if n-length_req == length_req else False

        combi = (comb.fact[length_req]*comb.fact[n-length_req])%MOD

        c = Counter(num)

        @cache
        def dp(i, curr, length):
            if curr > target:
                return 0
            
            if i==10:
                if curr==target and length==length_req:
                    return combi
                else:
                    return 0
            
            ans = 0
            for j in range(c[i]+1):
                ans+= dp(i+1, curr+i*j, length+j)*comb.invfact[j]*comb.invfact[c[i]-j]
                ans%= MOD
            return ans

        ans = dp(0,0,0)
        return ans",1441351613
Saijayavinoth T V S,saijayavinoth,128,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0))]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+1
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny)))
        # print(T)
        return -1",1441295122
Saijayavinoth T V S,saijayavinoth,128,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0), True)]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell, step = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+(1 if step else 2)
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny), not step))
        # print(T)
        return -1",1441297746
Saijayavinoth T V S,saijayavinoth,128,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = 0
        flag = True
        for ch in num:
            ch = int(ch)
            if flag: ch *= -1
            x += ch
            flag = not flag
        return x == 0",1441282486
Saijayavinoth T V S,saijayavinoth,128,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = list(map(int, list(num)))
        count = Counter(nums)
        nums = list(set(nums))
        nums.sort()
        MOD = 10**9+7
        n = len(num)
        O = n//2
        E = n-O
        @cache
        def ncr(n, r):
            if n == 0 and r == 0:
                return 1
            if n == 0:
                return 0
            return ncr(n-1,r) + ncr(n-1,r-1)
        @cache
        def solve(ind, evenPos, oddPos, x):
            if ind == len(nums):
                return 1 if x == 0 else 0
            num = nums[ind]
            ans = 0
            for even in range(count[num]+1):
                if even > evenPos:
                    break
                odd = count[num] - even
                if odd > oddPos: continue
                ans += ncr(evenPos, even) * ncr(oddPos, odd) * solve(ind+1, evenPos-even, oddPos-odd, x+(even-odd)*num)
                ans %= MOD
            return ans
        return solve(0, E, O, 0)
        ",1441364426
MvKaio,MvKaio,129,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, (long long)(1e11)));
        dist[0][0] = 0;
        
        using T = pair<long long, pair<int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, pair(0, 0));
        
        vector vis(n, vector(m, false));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = v.first;
            int j = v.second;
            if (vis[i][j]) continue;
            vis[i][j] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1] > dist[i][j] + 1) {
                    dist[i1][j1] = dist[i][j] + 1;
                    dist[i1][j1] = max<long long>(dist[i1][j1], g[i1][j1] + 1);
                    q.emplace(dist[i1][j1], pair(i1, j1));
                }
            }
        }
        
        

        return dist[n - 1][m - 1];
    }
};",1441303773
MvKaio,MvKaio,129,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, vector(2, (long long)(1e11))));
        dist[0][0][0] = 0;
        
        using T = pair<long long, tuple<int, int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, make_tuple(0, 0, 0));
        
        vector vis(n, vector(m, vector(2, false)));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = get<0>(v);
            int j = get<1>(v);
            int x = get<2>(v);
            if (vis[i][j][x]) continue;
            vis[i][j][x] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1][!x] > dist[i][j][x] + 1 + x) {
                    dist[i1][j1][!x] = dist[i][j][x] + 1 + x;
                    dist[i1][j1][!x] = max<long long>(dist[i1][j1][!x], g[i1][j1] + 1 + x);
                    q.emplace(dist[i1][j1][1-x], make_tuple(i1, j1, 1 - x));
                }
            }
        }
        
        

        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441309686
MvKaio,MvKaio,129,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2) s += num[i] - '0';
            else s -= num[i] - '0';
        }
        return s == 0;
    }
};",1441281184
MvKaio,MvKaio,129,3637,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> v(n);
        for (int i = 0; i < n; i++)
            v[i] = s[i] - '0';
        
        vector cnt(10, 0);
        for (int i : v) cnt[i]++;
        
        int S = accumulate(v.begin(), v.end(), 0);
        if (S % 2) return 0;
        
        auto add = [&] (long long& a, long long b) {
            a += b;
            if (a >= MOD) a -= MOD;
        };
        
        vector fact(n + 1, 1ll);
        for (int i = 2; i <= n; i++)
            fact[i] = i * fact[i - 1] % MOD;
        
        auto fexp = [&] (long long a, long long b) {
            long long ans = 1;
            while (b) {
                if (b & 1) ans = ans * a % MOD;
                a = a * a % MOD;
                b /= 2;
            }
            return ans;
        };
        
        vector ifact(n + 1, 1ll);
        for (int i = 0; i <= n; i++)
            ifact[i] = fexp(fact[i], MOD - 2);
        
        vector dp(11, vector(n + 1, vector(S + 1, 0LL)));
        dp[0][0][0] = fact[n/2] * fact[(n+1)/2] % MOD;
        for (int d = 0; d < 10; d++) {
            for (int i = 0; i <= n; i++) {
                for (int s = 0; s <= S; s++) {
                    for (int qt = 0; qt <= cnt[d]; qt++) if (s + qt * d <= S && i + qt <= n) {
                        add(dp[d + 1][i + qt][s + qt * d], 
                            dp[d][i][s] 
                            * ifact[qt] % MOD
                            * ifact[cnt[d] - qt] % MOD
                       );
                    }
                }
            }
        }

        
        //cout << dp[10][n/2][S/2] << endl;
        return dp[10][n/2][S/2];
    }
};",1441338870
Arnab Mondal,arnab_97,131,3627,java," class Solution {
     public int minTimeToReach(int[][] moveTime) {
         int n = moveTime.length;
         int m = moveTime[0].length;
         int[][] dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
         int[][] minArrive = new int[n][m];
         for(int[] row : minArrive){
             Arrays.fill(row, Integer.MAX_VALUE);
         }
         minArrive[0][0] = 0;
         PriorityQueue<Cell> pq = new PriorityQueue<>();
         pq.offer(new Cell(0, 0, 0));
         while(!pq.isEmpty()){
             Cell current = pq.poll();
             int r = current.row;
             int c = current.col;
             int t = current.time;
             if(r == n-1 && c == m-1){
                 return t;
             }
             if(t > minArrive[r][c]){
                 continue;
             }
             for(int[] dir : dirs){
                 int nr = r + dir[0];
                 int nc = c + dir[1];
                 if(nr >=0 && nr < n && nc >=0 && nc < m){
                     int arriveTime = Math.max(t, moveTime[nr][nc]) +1;
                     if(arriveTime < minArrive[nr][nc]){
                         minArrive[nr][nc] = arriveTime;
                         pq.offer(new Cell(nr, nc, arriveTime));
                     }
                 }
             }
         }
         return -1;
     }

     class Cell implements Comparable<Cell>{
         int row;
         int col;
         int time;
         Cell(int row, int col, int time){
             this.row = row;
             this.col = col;
             this.time = time;
         }
         public int compareTo(Cell other){
             return Integer.compare(this.time, other.time);
         }
     }
 }",1441294066
Arnab Mondal,arnab_97,131,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        long INF = Long.MAX_VALUE;
        long[][][] dist = new long[n][m][2];
        for(int i=0;i<n;i++) {
            for(int j=0; j<m; j++) {
                dist[i][j][0] = INF;
                dist[i][j][1] = INF;
            }
        }
        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> Long.compare(a.time, b.time));
        dist[0][0][0] = 0;
        pq.add(new State(0, 0, 0, 0));
        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
        while(!pq.isEmpty()) {
            State current = pq.poll();
            if(current.x == n-1 && current.y == m-1){
                return (int)current.time;
            }
            if(current.time > dist[current.x][current.y][current.p]){
                continue;
            }
            for(int[] dir : directions){
                int nx = current.x + dir[0];
                int ny = current.y + dir[1];
                if(nx >=0 && nx <n && ny >=0 && ny <m){
                    long start_move_time = Math.max(current.time, (long)moveTime[nx][ny]);
                    long move_duration = current.p == 0 ? 1 : 2;
                    long arrival_time = start_move_time + move_duration;
                    int next_p = 1 - current.p;
                    if(arrival_time < dist[nx][ny][next_p]){
                        dist[nx][ny][next_p] = arrival_time;
                        pq.add(new State(nx, ny, next_p, arrival_time));
                    }
                }
            }
        }
        return -1;
    }
    class State {
        int x, y, p;
        long time;
        State(int x, int y, int p, long time){
            this.x = x;
            this.y = y;
            this.p = p;
            this.time = time;
        }
    }
}
",1441293520
Arnab Mondal,arnab_97,131,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';

            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}",1441283689
Arnab Mondal,arnab_97,131,3637,java,"class Solution {
    static final int MOD = 1_000_000_007;

     public int countBalancedPermutations(String num) {
         int[] freq = new int[10];
         int N = num.length();
         long sumTotal = 0;
         for(char c : num.toCharArray()) {
             freq[c - '0']++;
             sumTotal += (c - '0');
         }
         if(sumTotal % 2 != 0) return 0;
         long sumTarget = sumTotal / 2;
         int half1 = (N + 1) / 2;
         int half2 = N / 2;

         long[] fact = new long[N + 1];
         fact[0] = 1;
         for(int i=1;i<=N;i++) {
             fact[i] = fact[i-1] * i % MOD;
         }

         long[] invFact = new long[N +1];
         invFact[N] = powMod(fact[N], MOD-2);
         for(int i=N-1;i>=0;i--){
             invFact[i] = invFact[i+1] * (i+1) % MOD;
         }

         
         long[][] dp = new long[half1 +1][(int)(sumTarget) +1];
         dp[0][0] = 1;

         for(int d=0; d<=9; d++) {
             int f = freq[d];
             if(f ==0) continue;
             long[][] next = new long[half1 +1][(int)(sumTarget) +1];
             for(int j=0; j<=half1; j++) {
                 for(int k=0; k<=sumTarget; k++) {
                     if(dp[j][k] ==0) continue;
                     for(int c=0; c<=f; c++) {
                         if(j + c > half1) break;
                         long newSum = k + (long)d * c;
                         if(newSum > sumTarget) break;
                         next[j + c][(int)newSum] = (next[j + c][(int)newSum] + dp[j][k] * invFact[c] % MOD * invFact[f - c] % MOD ) % MOD;
                     }
             }}
             dp = next;
         }

         if(sumTotal %2 !=0){
             return 0;
         }

         if(half1 <0 || half1 >N || sumTarget <0){
             return 0;
         }

         long dpVal = dp[half1][(int)sumTarget];
         if(dpVal ==0){
             return 0;
         }

         long answer = fact[half1] * fact[half2] % MOD;
         answer = answer * dpVal % MOD;
         return (int)answer;
     }

     long powMod(long a, long b){
         long res =1;
         a %= MOD;
         while(b >0){
             if( (b&1) !=0){
                 res = res * a % MOD;
             }
             a = a * a % MOD;
             b >>=1;
         }
         return res;
    }
}",1441359079
Nutty Professor,varkatkl,132,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        BIG = 1 << 30
        best = [[BIG] * W for _ in range(H)]
        bfs = collections.deque()
        def visit(y, x, t):
            if best[y][x] > t and (t > moveTime[y][x] or (y == 0 and x == 0)):
                best[y][x] = t
                bfs.append((y, x))

        visit(0, 0, 0)
        while bfs:
            y, x = bfs.popleft()
            t_cur = best[y][x]
            for dy, dx in ADJACENT:
                y2, x2 = y + dy, x + dx
                if y2 >= 0 and x2 >= 0 and y2 < H and x2 < W:
                    t_move = max(moveTime[y2][x2], t_cur)
                    visit(y2, x2, t_move + 1)

        return best[H - 1][W - 1]
",1441295956
Nutty Professor,varkatkl,132,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)] 
        BIG = 1 << 30

        best = [[[BIG, BIG] for _ in range(W)] for _ in range(H)]
        bfs = []
        def visit(y, x, par, t):
            if best[y][x][par] > t:
                best[y][x][par] = t
                heapq.heappush(bfs, (t, y, x, par))

        visit(0, 0, 0, 0)

        while bfs:
            t_cur, y, x, par = heapq.heappop(bfs)
            if y == H - 1 and x == W - 1:
                return t_cur
            for dy, dx in ADJACENT:
                y2, x2, par2 = y + dy, x + dx, 1 - par
                if y2 < 0 or x2 < 0 or y2 >= H or x2 >= W:
                    continue
                t_start = max(t_cur, moveTime[y2][x2])
                visit(y2, x2, par2, t_start + par + 1)

        return min(best[H - 1][W - 1])
",1441309476
Nutty Professor,varkatkl,132,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e, o = 0, 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                e += int(d)
            else:
                o += int(d)
        return e == o
",1441282473
Nutty Professor,varkatkl,132,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = (10 ** 9) + 7
        counts = [0] * 10
        total = 0
        N = len(num)
        for d in num:
            counts[int(d)] += 1
            total += int(d)

        if total % 2 != 0:
            return 0

        inv_fact = [1] * 81
        fact = 1
        for i in range(2, 81):
            fact = fact * i % MOD
            inv_fact[i] = pow(fact, MOD - 2, MOD)

        @functools.lru_cache(maxsize=None)
        def f(i, odds_used, osum):
            if i == 10:
                if odds_used != N // 2 or osum * 2 != total:
                    return 0
                return 1

            ret = 0
            for ei in range(counts[i] + 1):
                oi = counts[i] - ei
                ret += inv_fact[ei] * inv_fact[oi] * f(i + 1, oi + odds_used, oi * i + osum) % MOD
                ret %= MOD
            return ret

        ret = f(0, 0, 0)
        ret *= pow(inv_fact[(N + 1) // 2], MOD - 2, MOD) * pow(inv_fact[N // 2], MOD - 2, MOD)
        ret %= MOD
        return ret
",1441359390
Yatin Kwatra,yatin_kwatra,134,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

int vis[55][55];

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:

	// bool possible(int k, vvii &v) {
	// 	fo(i, 0, n - 1) {
	// 		fo(j, 0, m - 1) vis[i][j] = 1e9;
	// 	}
	// 	queue<ar<int, 2>> q;

	// 	q.push({0, 0});
	// 	vis[0][0] = 1;

	// 	while (sz(q)) {
	// 		auto t = q.front();
	// 		q.pop();

	// 		int a = t[0], b = t[1];

	// 		fo(dir, 0, 3) {
	// 			int x = a + dx[dir];
	// 			int y = b + dy[dir];

	// 			if (valid(x, y, k, vis[a][b])) {
	// 				vis[x][y] = max(v[x][y], vis[a][b] + 1);
	// 				q.push({x, y});
	// 			}
	// 		}
	// 	}

	// 	return vis[n - 1][m - 1];

	// }

	int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vvii dp(n, vii(m, INT_MAX));

		set<ar<int, 3>> s;
		s.insert({0, 0, 0});
		dp[0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[1] + dx[dir];
				int y = t[2] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1, t[0] + 1);
				if (spend < dp[x][y]) {
					auto it = s.find({dp[x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[x][y] = spend;
					s.insert({dp[x][y], x, y});
				}
			}
		}

		return dp[n - 1][m - 1];
	}
};


















",1441306051
Yatin Kwatra,yatin_kwatra,134,3628,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vector<vector<vector<int>>>  dp(2, vvii(n, vii(m, INT_MAX)));

		set<ar<int, 4>> s;
		s.insert({0, 0, 0, 0});
		dp[0][0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[2] + dx[dir];
				int y = t[3] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1 + t[0], t[1] + 1 + t[0]);
				if (spend < dp[!t[0]][x][y]) {
					auto it = s.find({dp[!t[0]][x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[!t[0]][x][y] = spend;
					s.insert({!t[0], dp[!t[0]][x][y], x, y});
				}
			}
		}

		return min(dp[0][n - 1][m - 1], dp[1][n - 1][m - 1]);
	}
};


















",1441315344
Yatin Kwatra,yatin_kwatra,134,3636,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	bool isBalanced(string s) {
		int n = sz(s);
		int a[2] = {0};
		fo(i, 0, n - 1) {
			a[i % 2] += s[i] - '0';
		}
		return a[0] == a[1];
	}
};




















",1441281153
Yatin Kwatra,yatin_kwatra,134,3637,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

const int N = 81;
ll f[N];

ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}

ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}

ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}

ll nCr(ll n, ll r) {
	if (n < r) return 0;
	ll num = f[n];
	ll deno = mulmod(f[r], f[n - r]);
	return divmod(num, deno);
}


int cnt[10];

int dp[10][42][802], sum;

class Solution {
public:

	int gino(int pos, int odd, int even, int dx) {
		if (pos == 10) {
			return (dx == 0);
		}
		int &ans = dp[pos][odd][sum + dx];
		if (ans != -1) return ans;
		ans = 0;

		fo(placeAtOdd, 0, min(odd, cnt[pos])) {
			int atOdd = placeAtOdd;
			int atEven = cnt[pos] - placeAtOdd;
			if (atEven > even) continue;

			int updDx = dx + atOdd * pos - atEven * pos;

			ans = addmod(ans, mulmod(mulmod(nCr(odd, atOdd), nCr(even, atEven)), gino(pos + 1, odd - atOdd, even - atEven,  updDx)));

			// pr(pos, atOdd, atEven, odd, even,  updDx, ans);
		}

		// pr(pos, odd, even, dx, ans);

		return ans;
	}

	int countBalancedPermutations(string s) {
		if (!f[0]) {
			f[0] = 1;
			fo(i, 1, N - 1) {
				f[i] = mulmod(f[i - 1], i);
			}
		}

		fo(i, 0, 9) {
			cnt[i] = 0;
		}
		for (auto &i : s) cnt[i - '0']++;
		int n = sz(s);

		sum = 0;
		sort(all(s));
		reverse(all(s));
		fo(i, 0, ((n + 1) / 2) - 1) sum += s[i] - '0';

		fo(i, 0, 9) {
			fo(j, 0, (n + 1) / 2) {
				fo(k, 0, 2 * sum) dp[i][j][k] = -1;
			}
		}


		return gino(0, (n + 1) / 2, n / 2, 0);
	}
};





















",1441359762
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3627,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        using Triple = tuple<int64_t,int,int>;
        PQ(Triple, greater) pq;
        pq.emplace(0, 0, 0);
        vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        vector<vector<bool>> vis(R, vector<bool>(C, false));
        dp[0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x] = pq.top(); pq.pop();
            if(vis[y][x]) continue;
            vis[y][x] = true;
            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1, 
                    1ll * stat[ny][nx] + 1
                );
                if(next_time >= dp[ny][nx])
                    continue;
                dp[ny][nx] = next_time;
                pq.emplace(next_time, ny, nx);
            }
        }

        return dp[R - 1][C - 1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441360335
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3628,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

const int nax = 751;
int64_t dp[nax][nax][2];
bool vis[nax][nax][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        // vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        //dp[row][col][flag] = best
        //min(...dp[R - 1][C - 1])
        for(int row = 0; row < R; row++)
            for(int col = 0; col < C; col++)
                for(int flag = 0; flag <= 1; flag++)
                    dp[row][col][flag] = INF, vis[row][col][flag] = false;

        using Quad = tuple<int64_t,int,int,int>;
        PQ(Quad, greater) pq;
        pq.emplace(0, 0, 0, 0);
        dp[0][0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x, flag] = pq.top(); pq.pop();
            if(vis[y][x][flag]) continue;
            vis[y][x][flag] = true;

            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1 + flag, 
                    1ll * stat[ny][nx] + 1 + flag
                );
                if(next_time >= dp[ny][nx][flag ^ 1])
                    continue;
                dp[ny][nx][flag ^ 1] = next_time;
                pq.emplace(next_time, ny, nx, flag ^ 1);
            }
        }

        return min(dp[R - 1][C - 1][0], dp[R - 1][C - 1][1]);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441367413
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3636,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    bool isBalanced(string num) {
        int ans[2] = {0, 0};
        const int n = num.size();
        for(int i = 0; i < n; i++)
            ans[i % 2] += num[i] - '0';

        return ans[0] == ans[1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441346394
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3637,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

template <uint64_t mod = 1'000'000'007>
struct Mint {
    uint64_t val;
    Mint() : val(0) {}
    Mint(int64_t _val) {
        _val %= mod;
        if (_val < 0) _val += mod;
        val = _val;
    }
    Mint& operator += (const Mint& other){ val += other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator -= (const Mint& other){ val += mod - other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator *= (const Mint& other){ val = (uint64_t)val * other.val % mod; return *this; }
    Mint& operator /= (const Mint& other){ return *this *= other.inv(); }
    Mint operator + (const Mint& other) const { return Mint(*this) += other; }
    Mint operator - (const Mint& other) const { return Mint(*this) -= other; }
    Mint operator * (const Mint& other) const { return Mint(*this) *= other; }
    Mint operator / (const Mint& other) const { return Mint(*this) /= other; }
    Mint pwr(int64_t expo) const {
        Mint res = 1;
        Mint cur = *this;
        while(expo){
            if(expo & 1) res *= cur;
            cur *= cur; expo >>= 1;
        }
        return res;
    }
    Mint inv() const { return pwr(mod - 2); }
    friend ostream& operator << (ostream& os, const Mint& m) { os << m.val; return os; }
    bool operator == (const Mint& other) const { return val == other.val; }
};

constexpr uint64_t MODS[] = {
    1'000'000'007,       // 1e9 + 7
    1'000'000'009,       // 1e9 + 9
    1'000'000'003,       // 1e9 + 3
    1'000'000'019,       // 1e9 + 19
    1'000'000'037,       // 1e9 + 37
    1'000'000'061,       // 1e9 + 61
    1'000'000'077,       // 1e9 + 77
    1'000'000'123,       // 1e9 + 123
    5'330'004'01, 
    7'356'327'91, 
    7'765'314'19,
    7'970'034'13
};

using mint = Mint<MODS[0]>;
mint fact[100];
mint ifact[100];
int dp[10][42][42][730];
int vfreq[10];
int even_max;
int odd_max;
//729 is the max
//370(offset) is the 0

int init = []{
    fact[0] = 1;
    ifact[0] = 1;
    for(int i = 1; i < 100; i++){
        fact[i] = fact[i - 1] * i;
        ifact[i] = fact[i].inv();
    }
    return 0;
}();

mint ncr(int take, int has) {
    assert(take <= has);
    assert(take >= 0 && has >= 0);
    return fact[has] * ifact[take] * ifact[has - take];
}

int dfs(int val, int even, int odd, int sum) {
    if(val < 0)
        return sum == 370 && even == even_max && odd == odd_max;
    if(dp[val][even][odd][sum] != -1)
        return dp[val][even][odd][sum];

    const int left_slot = even_max - even;
    const int right_slot = odd_max - odd;
    mint got = 0;
    for(int left = 0; left <= vfreq[val]; left++){
        if(left_slot < left) continue;
        const int right = vfreq[val] - left;
        if(right_slot < right) continue;
        const int next_sum = sum + (left * val) - (right * val);
        if(next_sum < 0 || next_sum > 729) 
            continue;
        got += 
        ncr(left, left_slot) * 
        ncr(right, right_slot) * 
        dfs(val - 1, even + left, odd + right, next_sum);
    }

    return dp[val][even][odd][sum] = got.val;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        const int n = s.size();
        even_max = n / 2 + (n & 1);
        odd_max = n / 2;
        for(int i = 0; i <= 9; i++)
            for(int even = 0; even <= even_max; even++)
                for(int odd = 0; odd <= odd_max; odd++)
                    for(int sum = 0; sum < 730; sum++)
                        dp[i][even][odd][sum] = -1;

        fill(vfreq, vfreq + 10, 0);
        for(auto ch : s)
            vfreq[ch - '0']++;

        return dfs(9, 0, 0, 370);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441343915
VILLANOVA_ECON,VILLANOVA_ECON,138,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0))
            best_dist = [[math.inf]*(M) for _ in range(N)]
            best_dist[0][0] = 0
            while heap_list:
                dist, i,j = heapq.heappop(heap_list)
                if dist == best_dist[i][j]:
                    best_dist[i][j] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+1,moveTime[a][b]+1)
                        if new_max < best_dist[a][b]:
                            best_dist[a][b] = new_max
                            heapq.heappush(heap_list,(new_max,a,b))
            return best_dist[-1][-1]
        
        return djikstra(graph)",1441294489
VILLANOVA_ECON,VILLANOVA_ECON,138,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0,0))
            best_dist = [[[math.inf]*2 for _ in range(M)] for _ in range(N)]
            best_dist[0][0][0] = 0
            while heap_list:
                dist, seq,i,j = heapq.heappop(heap_list)
                jump_cost = 1 if seq == 0 else 2
                if dist == best_dist[i][j][seq]:
                    best_dist[i][j][seq] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+jump_cost,moveTime[a][b]+jump_cost)
                        if new_max < best_dist[a][b][seq^1]:
                            best_dist[a][b][seq^1] = new_max
                            heapq.heappush(heap_list,(new_max,seq^1,a,b))
            return min(best_dist[-1][-1])
        
        return djikstra(graph)",1441299087
VILLANOVA_ECON,VILLANOVA_ECON,138,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        dp = [0,0]
        
        for i in range(len(list(num))):
            x = int(num[i])
            dp[i%2] += x
        return dp[0] == dp[1]",1441281131
VILLANOVA_ECON,VILLANOVA_ECON,138,3637,python3,"# class Solution:
#     def countBalancedPermutations(self, num: str) -> int:
#         def check(num):
#             dp = [0,0]  
#             for i in range(len(list(num))):
#                 x = int(num[i])
#                 dp[i%2] += x
#             return dp[0] == dp[1]

#         def brute(arr):
#             seen = set()
#             for zeb in itertools.permutations(arr):
#                 if check(list(zeb)):
#                     seen.add("""".join(list(zeb)))
#             return len(seen)
        
#         return brute(num)
    
    
MOD = 10 ** 9 + 7
MX = 1000

fac = [1] * MX
for i in range(1, MX):
    fac[i] = fac[i-1] * i % MOD
ifac = [pow(fac[MX - 1], MOD-2, MOD)] * MX
for i in range(MX - 1, 0, -1):
    ifac[i-1] = ifac[i] * i % MOD




class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        modulo = 10**9 + 7

        total_sum = sum([int(x) for x in num])
        
        target_count = len(num)//2
        
        remain_count = len(num)-target_count
        

        if total_sum%2 != 0:
            return 0
        
        target_sum = total_sum//2

        digit_len = len(list(num))//2
        

                    
                    
        num_count = [0]*10
        
        for x in num:
            num_count[int(x)] += 1
            
            
        ans = 0
        
        
        dp = [[0]*(target_sum+1) for _ in range(target_count+1)]
        dp[0][0] = 1

        for i in range(len(num_count)):
            
            new_dp = [[0]*(target_sum+1) for _ in range(target_count+1)] #[0]*(target_sum+1)
            for x in range(num_count[i]+1):
                take = x
                remain = num_count[i]-take
                new_take_sum = x * i
                #print(i,take,remain,new_take_sum)
                for j in range(len(dp)-1,-1,-1):
                    if j-take < 0:
                        break
                    for z in range(len(dp[0])-1,-1,-1):
                        if z-new_take_sum < 0:
                            break
                        if dp[j-take][z-new_take_sum] >= 0:
                            new_dp[j][z] += dp[j-take][z-new_take_sum] * ifac[take] * ifac[remain]
                            if new_dp[j][z] >= modulo:
                                new_dp[j][z] %= modulo
            

                        
            dp = list([list(row) for row in new_dp]) #[0]*(target_sum+1)

        return (dp[-1][-1] * fac[target_count]  * fac[len(num)-target_count]     )%modulo
                    
        
        
        
        
        

                    
            
",1441367947
parthDOOM,parthDOOM,139,3627,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
#define ptpll priority_queue<tuple<ll,ll,ll>, vector<tuple<ll,ll,ll>>, greater<tuple<ll,ll,ll>>>

class Solution {
public:
   int minTimeToReach(vector<vector<int>>& mt) {
       ll n = sz(mt);
       if(n == 0) rt 0;
       ll m = sz(mt[0]);
       
       vl dx = {-1, 1, 0, 0};
       vl dy = {0, 0, -1, 1};
       
       vlll0(arr, n, m);
       
       arr[0][0] = 0;
       
       ptpll pq;
       pq.emplace(0ll, 0ll, 0ll);
       
       while(!pq.empty()){
           auto [ct, x, y] = pq.top();
           pq.pop();
           
           if(x == n-1 && y == m-1){
               rt (int)ct;
           }
           if(ct > arr[x][y]) cnt;
           rep(i, 0, 4){
               ll nx = x + dx[i],ny = y + dy[i];
               if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                   ll nt = max(ct, (ll)mt[nx][ny]) + 1;
                   if(nt < arr[nx][ny]) {
                       arr[nx][ny] = nt;
                       pq.emplace(nt, nx, ny); 
                   }
               }
           }
       }
       rt -1;
   }
};
 ",1441319399
parthDOOM,parthDOOM,139,3628,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = sz(moveTime),m = sz(moveTime[0]); 
        vl dx = {0, 0, 1, -1},dy = {1, -1, 0, 0};
        vlll0(dist, n, m);
        vlll0(moves, n, m); 
        priority_queue<pair<ll, pair<pll, ll>>, 
                      vector<pair<ll, pair<pll, ll>>>, 
                      greater<pair<ll, pair<pll, ll>>>> pq;
        
        dist[0][0] = 0;
        moves[0][0] = 0;
        pq.push({0, {{0, 0}, 0}});
        
        while(!pq.empty()) {
            ll currTime = pq.top().fst;
            ll x = pq.top().sec.fst.fst,y = pq.top().sec.fst.sec;
            ll moveCount = pq.top().sec.sec;
            pq.pop();
            if(currTime > dist[x][y]) cnt;
            rep(i, 0, 4) {
                ll newX = x + dx[i],newY = y + dy[i];
                if(newX >= 0 && newX < n && newY >= 0 && newY < m) {
                    ll waitTime = max(0ll, moveTime[newX][newY] - currTime);
                    ll moveTime = (moveCount % 2 == 0) ? 1 : 2;
                    ll newTime = currTime + waitTime + moveTime;
                    if(newTime < dist[newX][newY]) {
                        dist[newX][newY] = newTime;
                        moves[newX][newY] = moveCount + 1;
                        pq.push({newTime, {{newX, newY}, moveCount + 1}});
                    }
                }
            }
        }
        rt dist[n-1][m-1];        
    }
};",1441299919
parthDOOM,parthDOOM,139,3636,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return

class Solution {
public:
    bool isBalanced(string num) {
        ll ctE = 0,ctO = 0;
        rep(i, 0, sz(num)){
            if(!(i%2)) ctE += (num[i] - '0');
            else ctO += (num[i] - '0');
        }
        rt ctE == ctO;        
    }
};",1441285157
parthDOOM,parthDOOM,139,3637,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int countBalancedPermutations(string s) {
        ll n = sz(s),e = (n+1)>>1,o = n>>1,sum = 0;
        vll0(ct,10)
        loop(c,s) ct[c-'0']++;
        rep(d,0,10) sum += d * ct[d];
        if(sum&1) rt 0;
        sum >>= 1;
        const ll mx = 80;
        vll(f,mx+1)
        f[0] = 1;
        rep(i,1,mx+1) f[i] = f[i-1]*i%modulo;
        vll(inv,mx+1)
        inv[mx] = [&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(f[mx],modulo-2);
        per(i,mx-1,-1) inv[i] = inv[i+1]*(i+1)%modulo;
        auto C = [&](ll n,ll k) -> ll{
            if(k > n) rt 0;
            rt f[n]*inv[k]%modulo*inv[n-k]%modulo;
        };
        vlll dp(e+1,vl(sum+1,0));
        dp[0][0] = 1;
        rep(d,0,10){
            if(!ct[d]) cnt;
            per(t,e,-1){
                per(s,sum,-1){
                    if(!dp[t][s]) cnt;
                    rep(k,1,ct[d] + 1){
                        if(!(t+k <= e) || !(s+d*k <= sum)) brk;
                        ll ns = s+d*k;
                        dp[t+k][ns] = (dp[t+k][ns]+dp[t][s]*C(ct[d],k))%modulo;
                    }
                }
            }
        }
        ll ans = dp[e][sum],pf = 1;
        rep(d, 0, 10) pf = pf*f[ct[d]]%modulo;
        ans = ans*f[e]%modulo;ans = ans*f[o]%modulo;
        ans = ans*[&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(pf,modulo-2)%modulo;
        rt (int)ans;
    }
};",1441355501
wei zhang,l1l2,141,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;


class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> time(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.emplace(moveTime[0][0], make_pair(0, 0));
        time[0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};

        while (!pq.empty()) {
            auto [t, p] = pq.top(); pq.pop();
            int i = p.first, j = p.second;
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    
                    int nt = max({t, moveTime[i][j], moveTime[ni][nj]}) + 1;
                    if (nt < time[ni][nj]) {
                        time[ni][nj] = nt;
                        pq.emplace(nt, make_pair(ni, nj));
                    }
                }
            }
        }
        return -1;
    }
};
",1441349376
wei zhang,l1l2,141,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<vector<int>>> time(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(moveTime[0][0], 0, 0, 0);
        time[0][0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

        while (!pq.empty()) {
            auto [t, i, j, k] = pq.top(); pq.pop();
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j][k]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int c = (k == 0) ? 1 : 2;
                    int t_start = max({t, moveTime[i][j], moveTime[ni][nj]});
                    int arrival_time = t_start + c;
                    int nk = 1 - k;
                    if (arrival_time < time[ni][nj][nk]) {
                        time[ni][nj][nk] = arrival_time;
                        pq.emplace(arrival_time, ni, nj, nk);
                    }
                }
            }
        }
        return -1;
    }
};
",1441355653
wei zhang,l1l2,141,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long se = 0;
        long long so = 0;

        for(int i = 0; i < num.size(); i += 2) {
            se += (num[i] - '0');
        }

        for(int i = 1; i < num.size(); i += 2) {
            so += (num[i] - '0');
        }

        return se == so;
    }
};",1441287354
wei zhang,l1l2,141,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

ll power_mod(ll a, ll b, ll mod_val){
    ll res=1;a%=mod_val;
    while(b>0){
        if(b&1) res=res*a%mod_val;
        a=a*a%mod_val; b>>=1;
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int f[10] = {0};
        ll total =0;
        for(char c: num) {f[c-'0']++; total += (c-'0');}
        if(total%2) return 0;
        ll tgt = total/2;
        int ne = (n+1)/2, no = n/2;
        vector<ll> fact(n+1,1), invf(n+1,1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1]*i%MOD;
        invf[n] = power_mod(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--) invf[i] = invf[i+1]*(i+1)%MOD;
        vector<vector<ll>> dp(ne+1, vector<ll>(tgt+1,0));
        dp[0][0]=1;
        for(int d=0;d<10;d++) {
            if(f[d]==0) continue;
            vector<vector<ll>> ndp(ne+1, vector<ll>(tgt+1,0));
            for(int k=0;k<=ne;k++) {
                for(ll s=0;s<=tgt;s++) {
                    if(dp[k][s]==0) continue;
                    for(int c=0;c<=min(f[d], ne -k);c++) {
                        ll ns = s + (ll)c*d;
                        if(ns > tgt) continue;
                        ll comb = fact[f[d]] * invf[c] % MOD;
                        comb = comb * invf[f[d]-c] % MOD;
                        ndp[k+c][ns] = (ndp[k+c][ns] + dp[k][s]*comb)%MOD;
                    }
                }
            }
            dp = move(ndp);
        }
        ll sa = dp[ne][tgt];
        ll ipf =1;
        for(int d=0;d<10;d++) if(f[d]>0) ipf = ipf * invf[f[d]] % MOD;
        ll fe = fact[ne], fo = fact[no];
        ll ans = fe * fo % MOD;
        ans = ans * sa % MOD;
        ans = ans * ipf % MOD;
        return ans;
    }
};
",1441307596
delphih,delphih,142,3627,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0
        que = [(0, 0, 0)]  # d, r, c
        while que:
            d, r, c = heappop(que)
            if d != D[r][c][0]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                d2 = max(d, A[r2][c2]) + 1
                if d2 < D[r2][c2][0]:
                    D[r2][c2][0] = d2
                    heappush(que, (d2, r2, c2))
        # print(D)
        return D[-1][-1][0]",1441294936
delphih,delphih,142,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf, inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0 # (next 1, next 2)
        que = [(0, 0, 0, 0)]  # d, r, c, t
        while que:
            d, r, c, t = heappop(que)
            if d != D[r][c][t]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                t2 = 1 - t
                d2 = max(d, A[r2][c2]) + t + 1
                if d2 < D[r2][c2][t2]:
                    D[r2][c2][t2] = d2
                    heappush(que, (d2, r2, c2, t2))
        # print(D)
        return min(D[-1][-1])",1441296845
delphih,delphih,142,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = sum(int(c) for c in num[::2])
        s2 = sum(int(c) for c in num[1::2])
        return s1 == s2",1441281691
delphih,delphih,142,3637,python3,"M = 10**9+7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
        tot = sum(int(d) for d in num)
        if tot % 2 != 0: return 0
            
        freq = Counter(num)
        
        dp = [[Counter() for _ in range(n_odd+1)] for _ in range(n_even+1)]  # dp[even][odd][even - odd]
        dp[0][0][0] = 1
        cur = 0
        for d, cnt in freq.items():
            d = int(d)
            for i0 in range(cur-n_odd, min(cur, n_even)+1):
                i1 = cur - i0
                # if i1 > n_odd: continue
                # print(i0, i1)
                for diff0, ways0 in dp[i0][i1].items():
                    for j0 in range(cnt+1):
                        j1 = cnt - j0
                        if i0+j0 > n_even or i1+j1 > n_odd: continue
                        diff = diff0 + (j0-j1) * d
                        ways = ways0 * comb(i0+j0, j0) * comb(i1+j1, j1) % M
                        dp[i0+j0][i1+j1][diff] = (dp[i0+j0][i1+j1][diff] + ways) % M
            cur += cnt
        return dp[n_even][n_odd][0]",1441356652
Syed Ali Aatif,mafailure,143,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; 
        pq.push(make_pair(0,0)); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<int>> d(n, vector<int>(m,inf)); 
        d[0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second;
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y]>max(moveTime[x][y]+1, _d+1)) {
                    d[x][y] = max(moveTime[x][y]+1, _d+1); 
                    pq.push(make_pair(d[x][y], x*m+y)); 
                }
            }
        }
        return d[n-1][m-1]; 
    }
};",1441297641
Syed Ali Aatif,mafailure,143,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; 
        pq.push(make_pair(0,make_pair(0,0))); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m,vector<int>(2,inf))); 
        d[0][0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second.first;
            auto _ = pq.top().second.second; 
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y][1-_]>max(moveTime[x][y], _d)+1+_) {
                    d[x][y][1-_] = max(moveTime[x][y], _d)+1+_; 
                    pq.push(make_pair(d[x][y][1-_], make_pair(x*m+y,1-_))); 
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]); 
    }
};",1441302882
Syed Ali Aatif,mafailure,143,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> cnt(2); 
        for(int i=0;i<num.size();i++){
            cnt[i%2]+=num[i]-'0'; 
        }
        return cnt.front() == cnt.back(); 
    }
};",1441285747
Syed Ali Aatif,mafailure,143,3637,cpp,"const int mod = 1e9+7; 
class Solution {
public:
#define int long long 
    int add (int a,int b ) { return (a+b)%mod;}
    int mul (int a,int b) {return a*b%mod;}
    int sub(int a,int b) { return (a-b+mod)%mod;}
    int power(int a,int b,int mod) {
        if(b==0)return 1; 
        int u = power(a,b>>1,mod); 
        u = mul(u,u);
        if(b%2)u = mul(u,a); 
        return u; 
    }


    int32_t countBalancedPermutations(string num) {
        int dp[num.size()+1][9*num.size()+1];
        memset(dp,0,sizeof(dp)); 
        vector<int> cnt(10);
        for(auto it:num)cnt[it-'0']++; 
        vector<int> fact(81);
        fact[0] = 1; 
        for(int i=1;i<fact.size();i++)fact[i] = mul(i,fact[i-1]); 
        vector<int> ifact(81,1); 
        ifact[80] = power(fact[80], mod-2, mod); 
        for(int i=79;i>=0;i--)ifact[i]=mul(i+1, ifact[i+1]); 
        int tot = 0; 
        for(auto it:num)tot+=it-'0'; 
        if(tot%2)return 0; 
        auto getAns = [&](vector<int> & c,int t) {
            int dp[11][81][81*9]; 
            memset(dp,0,sizeof(dp)); 
            dp[0][0][0] = 1; 
            for(int i=0;i<10;i++){
                for(int j=0;j<=t;j++){
                    for(int p = 0;p<81*9;p++){
                    if(dp[i][j][p] == 0)continue; 
                    for(int k=0;k<=c[i] && k+j<=t;k++){
                         //cout<<i<<"" ""<<j<<"" ""<<p<<"" ""<<k<<"" ""<<t<<endl; 
                        dp[i+1][j+k][p+k*i] = add(dp[i+1][j+k][p+k*i], mul(dp[i][j][p], mul(ifact[k], ifact[c[i]-k])));
                    }
                    }
                }
            }
            return dp[10][t][tot/2]; 
        };
        int n = num.size();
        int o = (n+1)/2;
        int e = n-o; 
        int ans = mul(mul(fact[o], fact[e]), getAns(cnt, o)); 
    
        return ans;
    }

#undef int
};",1441350773
Shubham Maheshwari,sm_27,144,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0))]
        visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+1,(x,y)))
                        visited.add((x,y))
                        
                        
            ",1441298499
Shubham Maheshwari,sm_27,144,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0),0)]
        times = [[[float(""inf""), float(""inf"")] for _ in range(m)] for _ in range(n)]
        # visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node,move = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            # visited.add(node)
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if max(curr,moveTime[x][y]) + move < times[x][y][(move+1)%2]:
                    # if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+move+1,(x,y),(move+1)%2))
                        times[x][y][(move+1)%2] = max(curr,moveTime[x][y]) + move                        
                        
            ",1441313266
Shubham Maheshwari,sm_27,144,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(n):
            if i&1:
                odd += int(num[i])
            else:
                even += int(num[i])
        return odd == even",1441281409
Shubham Maheshwari,sm_27,144,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        def C(n,r):
            return math.comb(n,r)
        n = len(num)
        nums = dict()
        for i in range(10):
            nums[i] = 0
        s = 0
        for c in num:
            nums[int(c)] += 1
            s += int(c)
        if s %2 != 0:
            return 0
        odd = n//2
        if n&1:
            odd += 1
        MOD = 10**9+7
        @lru_cache(None)
        def dfs(num, odd,even, rem):
            nonlocal MOD
            # print(num,odd,even,rem)
            if rem == 0 and num == 10:
                if odd == 0 and even == 0:
                    return 1
                return 0
            if num >= 10:
                return 0
            if odd < 0 or even < 0:
                return 0
            if rem < 0:
                return 0
            ans = 0
            for count in range(nums[num]+1):
                # we select count num in odd side
                if rem < count*num and count <= odd and nums[num]-count <= even:
                    continue
                # count in odd and nums[num]-count in even
                facts = (C(odd,count)*C(even,nums[num]-count))% MOD
                ans += (dfs(num+1,odd-count,even-nums[num]+count,rem-count*num) * facts)
                ans %= MOD
            # if num == 1:
                # print(ans)
            return ans
            
            
        return dfs(0,odd,n-odd,s//2)
            ",1441363442
Umesh Kumar,icosa,145,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<ii, vector<ii>, greater<ii>> pq;
        pq.push({0, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] == inf){
                        dp[ni][nj] = 1 + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441299654
Umesh Kumar,icosa,145,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;
        typedef tuple<ll, ll, ll> iii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<iii, vector<iii>, greater<iii>> pq;
        pq.push({0, 1, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, mt, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;

            if(dp[i][j] < t) continue;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] > mt + max(t, (ll)moveTime[ni][nj])){
                        dp[ni][nj] = mt + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], mt == 1? 2: 1, v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441309882
Umesh Kumar,icosa,145,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i=0; i<num.size(); i++){
            (i & 1 ? odd: even) += (num[i] - '0');
        }
        return even == odd;
    }
};",1441311751
Umesh Kumar,icosa,145,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define FOR(i, l, r) for (ll i = l; i < r; i++)
#define For(i, r, l) for (ll i = r - 1; i >= l; i--)
#define sz(x) x.size()
#define all(x) x.begin(), x.end()
#define pb push_back
#define eb emplace_back
#define ITER(itr, x) for (auto &itr : x)
#define LSOne(S) ((S) & (-S))

using namespace std;
#define debug(args...)                                                         \
  {                                                                            \
    string _s = #args;                                                         \
    replace(_s.begin(), _s.end(), ',', ' ');                                   \
    stringstream _ss(_s);                                                      \
    istream_iterator<string> _it(_ss);                                         \
    err(_it, args);                                                            \
  }
template <typename... Args>
void err(istream_iterator<string> it, Args... args) {
  ((cerr << *it << "" = "" << args << "" "", it++), ...);
  cerr << endl;
}

typedef pair<int, int> ii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<ii> vii;
typedef vector<vi> vvi;
typedef vector<vll> vvll;

/**
 * Description: modular arithmetic operations
 * Source:
 * KACTL
 * https://codeforces.com/blog/entry/63903
 * https://codeforces.com/contest/1261/submission/65632855 (tourist)
 * https://codeforces.com/contest/1264/submission/66344993 (ksun)
 * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp
 * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic
 */

template <int MOD, int RT> struct mint {
  static const int mod = MOD;
  static constexpr mint rt() { return RT; } // primitive root for FFT
  int v;
  explicit operator int() const {
    return v;
  } // explicit -> don't silently convert to int
  mint() : v(0) {}
  mint(ll _v) {
    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
    if (v < 0)
      v += MOD;
  }
  bool operator==(const mint &o) const { return v == o.v; }
  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
  friend void re(mint &a) {
    ll x;
    cin >> x;
    a = mint(x);
  }
  // friend str ts(mint a) { return ts(a.v); }

  mint &operator+=(const mint &o) {
    if ((v += o.v) >= MOD)
      v -= MOD;
    return *this;
  }
  mint &operator-=(const mint &o) {
    if ((v -= o.v) < 0)
      v += MOD;
    return *this;
  }
  mint &operator*=(const mint &o) {
    v = int((ll)v * o.v % MOD);
    return *this;
  }
  mint &operator/=(const mint &o) { return (*this) *= inv(o); }
  friend mint pow(mint a, ll p) {
    mint ans = 1;
    assert(p >= 0);
    for (; p; p /= 2, a *= a)
      if (p & 1)
        ans *= a;
    return ans;
  }
  friend mint inv(const mint &a) {
    assert(a.v != 0);
    return pow(a, MOD - 2);
  }

  mint operator-() const { return mint(-v); }
  mint &operator++() { return *this += 1; }
  mint &operator--() { return *this -= 1; }
  friend mint operator+(mint a, const mint &b) { return a += b; }
  friend mint operator-(mint a, const mint &b) { return a -= b; }
  friend mint operator*(mint a, const mint &b) { return a *= b; }
  friend mint operator/(mint a, const mint &b) { return a /= b; }
};

const ll MOD = 1e9 + 7;
using mi = mint<MOD, 5>; // 5 is primitive root for both common mods
using vmi = vector<mi>;
using pmi = pair<mi, mi>;
using vpmi = vector<pmi>;

vector<vmi> scmb; // small combinations
void genComb(int SZ) {
  scmb.assign(SZ, vmi(SZ));
  scmb[0][0] = 1;
  FOR(i, 1, SZ)
  FOR(j, 0, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);
}

/**
 * Description: pre-compute factorial mod inverses,
 * assumes MOD$ is prime and SZ < MOD$.
 * Time: O(SZ)
 * Source: KACTL
 * Verification: https://dmoj.ca/problem/tle17c4p5
 */

vmi invs, fac, ifac;
void genFac(int SZ) {
  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);
  invs[1] = fac[0] = ifac[0] = 1;
  FOR(i, 2, SZ) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);
  FOR(i, 1, SZ) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];
}
mi comb(int a, int b) {
  if (a < b || b < 0)
    return 0;
  return fac[a] * ifac[b] * ifac[a - b];
}

const int MAX_E = 41;
const int MAX_SE = MAX_E * 9;
mi dp[11][MAX_E][MAX_SE]; // count even, sum even

class Solution {
public:
  int countBalancedPermutations(string num) {
    genFac(1001);
    vi count(10, 0);
    for (auto c : num)
      count[c - '0']++;

    memset(dp, 0, sizeof(dp));
    dp[0][0][0] = 1;

    int n = num.size(), digs = 0, sum_digs = 0;
    for (int i = 0; i < 10; i++) {
      for (int e = 0; e < min(MAX_E, digs + 1); e++) {
        int odd = digs - e;
        for (int c = 0; c <= min(count[i], MAX_E - e - 1); c++) {
          for (int se = 0; se < min(sum_digs + 1, MAX_SE - c * i); se++) {
            int sum_odd = sum_digs - se;
            // put c in even places
            dp[i + 1][c + e][se + c * i] +=
                (dp[i][e][se] * comb((n + 1) / 2 - e, c) *
                 comb(n - (n + 1) / 2 - odd, count[i] - c));
          }
        }
      }

      digs += count[i];
      sum_digs += count[i] * i;
    }

    mi ans = 0;
    ans += dp[10][(n + 1) / 2][sum_digs / 2];

    if (sum_digs & 1)
      return 0;
    return (int)ans;
  }
};",1441363622
g129512,g129512,146,3627,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,1)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=1
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359512
g129512,g129512,146,3628,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,2)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=(1 if nt==2 else 2)
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359413
g129512,g129512,146,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n=len(num)
        s1=sum(int(num[i]) for i in range(n) if i%2==0)
        s2=sum(int(num[i]) for i in range(n) if i%2==1)
        return s1==s2
        ",1441359720
g129512,g129512,146,3637,python3,"from functools import cache
from typing import Counter

class Comb:
    def __init__(self, n, mod) -> None:
        p,pi=[0]*(n+1),[0]*(n+1)
        self.p,self.pi=p,pi
        self.mod=mod
        p[0]=1
        pi[0]=1
        for i in range(1,n+1):
            p[i]=p[i-1]*i%mod
        pi[n]=pow(p[n],mod-2,mod)
        for i in range(n-1,0,-1):
            pi[i]=pi[i+1]*(i+1)%mod
    
    def comb(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[r]*self.pi[n-r]%self.mod
    
    def perm(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[n-r]%self.mod

M=10**9+7
comb=Comb(80, M)

@cache
def cb(n,k):
    return comb.comb(n,k)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n=len(num)
        s=sum(int(v) for v in num)
        if s%2==1:return 0
        ct=Counter(num)
        dp=[[0]*361 for _ in range(41)]
        dp[0][0]=1
        prec=0
        for kk,v in ct.items():
            kk=int(kk)
            ndp=[[0]*361 for _ in range(41)]
            for i in range(n//2+1):
                for j in range(s//2+1):
                    for k in range(v+1):
                        if i+k>n//2 or j+k*kk>s//2:break
                        ndp[i+k][j+k*kk]+=dp[i][j]*cb(i+k,k)*cb(prec-i+v-k,v-k)
                        ndp[i+k][j+k*kk]%=M
            dp=ndp
            prec+=v
        return dp[n//2][s//2]",1441363810
Rahul Gupta,guts_berserker718,147,3627,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0}); 
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 1) : time + (k == 0 ? 1 : 1);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301916
Rahul Gupta,guts_berserker718,147,3628,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});  
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 2) : time + (k == 0 ? 1 : 2);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301323
Rahul Gupta,guts_berserker718,147,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0,b=0;
        for(int i=0;i<num.length();i++){
            if(i%2==0){
                a+=(num[i]-'0');
            }else b+=(num[i]-'0');
        }
    return a==b;
    }

};",1441281567
Rahul Gupta,guts_berserker718,147,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution {
public:
    ll nCr(int n, int r, const vector<ll>& fact, const vector<ll>& invFact) {
        if (r > n) return 0;
        return fact[n]* invFact[n - r] % MOD * invFact[r] % MOD ;
    }
    ll modPow(ll base, ll exp) {
        ll res = 1;
        while (exp) {
            if (exp & 1) res = res * base % MOD;
            base = base * base % MOD;
            exp >>= 1;
        }
        return res;
    }
    

    
    int countBalancedPermutations(string num) {
        int i = 0;
        int len = num.size();
         int half2 = len / 2;
        int half1 = (len + 1) / 2;
       
        
        vector<int> freq(12, 0);
       
        
        ll sum = 0;
       
        
        
        
        vector<ll>invFact(len + 5, 1), fact(len + 5, 1);
        i = 1;
        while (i <= len) {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        i=0;
        while (i < len) {
            freq[num[i] - '0']++;
            i++;
        }
        invFact[len] = modPow(fact[len], MOD - 2);
        i = len - 1;
        while (i >= 0) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
            i--;
        }
        
        i = 0;
        while (i < 10) {
            sum += 1LL * i * freq[i];
            i++;
        }
        if (sum % 2 != 0) return 0;
        ll target = sum / 2;

        
        

       vector<vector<ll>> dp(target + 5, vector<ll>(half1 + 5, 0));
dp[0][0] = 1;

int d = 0;
while (d < 10) {
    // if(freq[d]==0)continue;
    if (freq[d] != 0) {
        int j = half1;
        while (j >= 0) {
            int k = target;
            while (k >= 0) {
                if (dp[k][j] != 0) {
                    int c = 1;
                    while (c <= min(freq[d], half1 - j)) {
                        if (k + d * c > target) break;
                        ll ways = nCr(freq[d], c, fact, invFact);
                        dp[k + d * c][j + c] = (dp[k + d * c][j + c] % MOD + dp[k][j] * ways) % MOD;
                        c++;
                    }
                }
                k--;
            }
            j--;
        }
    }
    d++;
}

ll dpVal = dp[target][half1];
if (dpVal == 0) return 0;


ll factProd = 1;
d = 0;
while (d < 10) {
    factProd = (fact[freq[d]] % MOD * factProd % MOD) % MOD;
    d++;
}
ll result = (dpVal * fact[half1] % MOD * fact[half2] % MOD) % MOD;
result = result * modPow(factProd, MOD - 2) % MOD;
return result % MOD;

    }
};
",1441357919
xpycc,xpycc,148,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        pq.emplace(0, 0, 0);
        mt[0][0] = -1;
        while (!pq.empty()) {
            auto [t, x, y] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d];
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (mt[nx][ny] < 0) continue;
                const int nt = max(t + 1, mt[nx][ny] + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny);
                mt[nx][ny] = -1;
            }
        }
        return -1;
    }
};",1441305505
xpycc,xpycc,148,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        vector<int8_t> mem(n * m * 2);
        auto vis = [&](int x, int y, int b) -> int8_t& {
            return mem[x * m * 2 + y * 2 + b];
        };
        pq.emplace(0, 0, 0, 0);
        vis(0, 0, 0) = true;
        while (!pq.empty()) {
            auto [t, x, y, b] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y, b);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d], nb = !b;
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (vis(nx, ny, nb)) continue;
                const int nt = max(t + b + 1, mt[nx][ny] + b + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny, nb);
                vis(nx, ny, nb) = true;
            }
        }
        return -1;
    }
};",1441317271
xpycc,xpycc,148,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int diff = 0, f = 1;
        for (char c : num) {
            diff += f * (c - '0');
            f = -f;
        }
        return diff == 0;
    }
};",1441282241
xpycc,xpycc,148,3637,cpp,"class Solution {
    static constexpr int mod = 1'000'000'007;
    static int inv(int x) {
        int p = mod - 2;
        int a = 1;
        while (p > 0) {
            if (p & 1) a = a * 1LL * x % mod;
            p >>= 1;
            x = x * 1LL * x % mod;
        }
        return a;
    }
public:
    int countBalancedPermutations(string num) {
        const int n = num.size(), h = n / 2,
                  S = accumulate(num.begin(), num.end(), 0, [](int x, char c) {
                        return x + c - '0';
                    }),
                  H = S / 2;
        if (S % 2 != 0) return 0;
        vector<vector<int>> f(h + 1, vector<int>(H + 1));
        f[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = h; j >= 0; --j)
                for (int k = H; k >= 0; --k) {
                    int x = num[i] - '0';
                    f[j][k] = (f[j][k] * (i + 1LL - j)) % mod; 
                    if (j > 0 && k - x >= 0)
                        f[j][k] = (f[j][k] + f[j - 1][k - x] * 1LL * j) % mod;
                }
        }
        int count[10] = {};
        for (char c : num) count[c - '0']++;
        vector<int> fact(n + 1);
        fact[0] = 1;
        for (int i = 1; i <= n; ++i)
            fact[i] = (fact[i - 1] * 1LL * i) % mod;
        int ans = f[h][H];
        for (int i = 0; i < 10; ++i)
            ans = (ans * 1LL * inv(fact[count[i]])) % mod;
        return ans;
    }
};",1441359032
BHISHMADEV GHOSH,bhishma_v2,150,3627,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][] minTime = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                minTime[i][j] = Integer.MAX_VALUE;
            }
        }
        minTime[0][0] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0});

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];

            if (curR == n - 1 && curC == m - 1) {
                return time;
            }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + 1;
                    if (newTime < minTime[rr][cc]) {
                        minTime[rr][cc] = newTime;
                        q.offer(new int[]{rr, cc, newTime});
                    }
                }
            }
        }

        return -1;
    }
}
",1441315131
BHISHMADEV GHOSH,bhishma_v2,150,3628,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] minTime = new int[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for(int k = 0; k <= 1; k++){
                minTime[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }
        minTime[0][0][0] = 0;
        minTime[0][0][1] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0,0});
        

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];
            int k = t[3];

            // if (curR == n - 1 && curC == m - 1) {
            //     return time;
            // }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + (k == 0 ? 1 : 2);
                    if (newTime < minTime[rr][cc][k]) {
                        minTime[rr][cc][k] = newTime;
                        q.offer(new int[]{rr, cc, newTime, k == 0 ? 1 : 0});
                    }
                }
            }
        }

        return Math.min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
}
",1441321903
BHISHMADEV GHOSH,bhishma_v2,150,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int sum1 = 0, sum2 = 0;

        for(int i = 0; i < n; i++){
            if(i % 2 == 0)sum1 += (num.charAt(i) - '0');
            else sum2 += (num.charAt(i) - '0');
        }

        return sum1 == sum2;
    }
}",1441282941
BHISHMADEV GHOSH,bhishma_v2,150,3637,java,"import java.util.*;

class Solution {
    int mod = (int) 1e9 + 7;
    long[][][] dp;
    Map<Integer, Integer> freqMap = new HashMap<>();

    long fact(int n) {
        long res = 1;
        for (int i = 1; i <= n; i++) {
            res = (res * i) % mod;
        }
        return res;
    }

    long modInverse(long a, int mod) {
        long res = 1;
        long power = mod - 2;
        while (power > 0) {
            if ((power & 1) != 0) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            power >>= 1;
        }
        return res;
    }

    public int countBalancedPermutations(String num) {
        int sum = 0;
        List<Integer> cur = new ArrayList<>();
        int n = num.length();

        for (char c : num.toCharArray()) {
            int digit = c - '0';
            sum += digit;
            cur.add(digit);
            freqMap.put(digit, freqMap.getOrDefault(digit, 0) + 1);
        }

        if (sum % 2 != 0)
            return 0;

        int odd = n / 2, even = (n + 1) / 2, target = sum / 2;
        dp = new long[n][even + 1][target + 1];

        for (long[][] rr : dp) {
            for (long[] r : rr) Arrays.fill(r, -1);
        }

        long ways = getWays(0, cur, even, target);

        for (int f : freqMap.values()) {
            ways = (ways * modInverse(fact(f), mod)) % mod;
        }

        long factEven = fact(even);
        long factOdd = fact(odd);

        return (int) ((ways * factEven % mod) * factOdd % mod);
    }

    long getWays(int ind, List<Integer> cur, int n, int target) {
        if (n < 0 || target < 0) return 0;
        if (ind == cur.size()) return (n == 0 && target == 0) ? 1 : 0;

        if (dp[ind][n][target] != -1) return dp[ind][n][target];

        long take = 0, notTake = 0;

        if (cur.get(ind) <= target) {
            take = getWays(ind + 1, cur, n - 1, target - cur.get(ind));
        }

        notTake = getWays(ind + 1, cur, n, target);

        return dp[ind][n][target] = (take + notTake) % mod;
    }
}
",1441365713
Abhishek Srivastava,Abhi_Srivastava,151,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        queue<pair<int, int>> q;
        dist[0][0] = 0;
        q.push({0, 0});
        while (!q.empty()) {
            int x = q.front().first, y = q.front().second;
            q.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 1) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 1;
                        q.push({x + i, y + j});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441298457
Abhishek Srivastava,Abhi_Srivastava,151,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        while (!pq.empty()) {
            int dst = pq.top().first, x = pq.top().second.first, y = pq.top().second.second;
            pq.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2)) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2);
                        pq.push({dist[x + i][y + j], {x + i, y + j}});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441311456
Abhishek Srivastava,Abhi_Srivastava,151,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2)
                sum += num[i] - '0';
            else
                sum -= num[i] - '0';
        }
        return !sum;
    }
};",1441281587
Abhishek Srivastava,Abhi_Srivastava,151,3637,cpp,"const int mod = 1e9 + 7;
long long fact[81], inv_fact[81];
long long binpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b % 2)
            (res *= a) %= mod;
        (a *= a) %= mod;
        b /= 2;
    }
    return res;
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if (!fact[0]) {
            fact[0] = 1;
            for (int i = 1; i < 81; i++)
                fact[i] = (fact[i - 1] * i) % mod;
            inv_fact[80] = binpow(fact[80], mod - 2);
            for (int i = 79; i >= 0; i--)
                inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;
        }
        int dig = num.size() / 2, sum = 0;
        int freq[10] = {};
        for (char x : num) {
            sum += x - '0';
            freq[x - '0']++;
        }
        if (sum % 2)
            return 0;
        sum /= 2;
        vector<vector<int>> dp(dig + 1, vector<int>(sum + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i <= 9; i++) {
            vector<vector<int>> ndp(dig + 1, vector<int>(sum + 1, 0));
            for (int j = 0; j <= freq[i]; j++)
                for (int k = j; k <= dig; k++)
                    for (int l = i * j; l <= sum; l++)
                        (ndp[k][l] += dp[k - j][l - i * j] * inv_fact[j] % mod * inv_fact[freq[i] - j] % mod) %= mod;
            swap(dp, ndp);
        }
        return dp[dig][sum] * fact[dig] % mod * fact[num.size() - dig] % mod;
    }
};",1441353464
avienn_x,avienn_x,152,3627,cpp,"class Solution {
public:
    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<long long>> dist(n, vector<long long>(m, INT_MAX));
        dist[0][0] = 0;
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            long long t = curr[0];
            long long i = curr[1];
            long long j = curr[2];
            if (i == n-1 && j == m-1)
                return t;
            if (t > dist[i][j])
                continue;
            for (auto &d : dirs) {
                long long ni = i + d.first;
                long long nj = j + d.second;
                if(!chck(ni, nj, n, m))
                    continue;
                int sr = max(t, 1ll * mt[ni][nj]);
                if (sr + 1 < dist[ni][nj]) {
                    dist[ni][nj] = sr + 1;
                    pq.push({sr + 1, ni, nj});
                }
            }
        }
        return INT_MAX;
    }
};",1441304877
avienn_x,avienn_x,152,3628,cpp,"class Solution {
public:

    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<vector<long long>>> dist(n, vector<vector<long long>>(m, vector<long long>(2, INT_MAX)));
        dist[0][0][0] = 0;
        priority_queue<vector<int>, vector<vector<int>>, std::greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int t = curr[0];
            int i = curr[1];
            int j = curr[2];
            int p = curr[3];
            if (i == n-1 && j == m-1 || t > dist[i][j][p])
                continue;
            for (auto &d : dirs) {
                int ni = i + d.first;
                int nj = j + d.second;
                if(!chck(ni, nj, n, m))
                        continue;
                int sr = max(t, mt[ni][nj]);
                int mv = (p == 0) ? 1 : 2;
                int nxt = sr + mv;
                int np = 1 - p;
                if (nxt < dist[ni][nj][np]){
                        dist[ni][nj][np] = nxt;
                        pq.push({nxt, ni, nj, np});
                }

            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441316491
avienn_x,avienn_x,152,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int a = 0, b= 0 ;
        for(int i = 0; i < n; i++){
            if(i % 2)
                a += num[i] - '0';
            else
                b += num[i] - '0';
        }
        return a == b;
    }
};",1441305980
avienn_x,avienn_x,152,3637,cpp,"
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
const int MAXN = 105; 
const int MAXS = 1100;
typedef long long ll;

ll dp[MAXN][MAXS];
ll f[MAXN], invf[MAXN];
int fr[10];

class Solution {
private:
    ll mpow(ll b, ll p) {
        ll r = 1;
        b %= MOD;
        while (p > 0) {
            if (p & 1) r = (r * b) % MOD;
            b = (b * b) % MOD;
            p >>= 1;
        }
        return r;
    }
    
    void precalc(int sz) {
        f[0] = 1;
        for (int i = 1; i <= sz; i++) {
            f[i] = (f[i-1] * i) % MOD;
        }
        invf[sz] = mpow(f[sz], MOD-2);
        for (int i = sz-1; i >= 0; i--) {
            invf[i] = (invf[i+1] * (i+1)) % MOD;
        }
    }
    
    ll ncr(int n, int r) {
        if (r > n) return 0;
        return (((f[n] * invf[r]) % MOD) * invf[n-r]) % MOD;
    }

public:
    int countBalancedPermutations(string s) {
        int n = s.length();
        int m = (n + 1) / 2;
        int h = n / 2;
        ll sm = 0;
        memset(fr, 0, sizeof(fr));
        for (char c : s){
        	fr[c-'0']++;
        	sm += (c - '0');
        }
        if (sm % 2) return 0;
        ll t = sm / 2;
        precalc(n);
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
   			
        for (int d = 0; d < 10; d++) {
            if (!fr[d]) continue;
            ll available = fr[d];
            for (int cs = t; cs >= 0; cs--) {
                for (int p = m; p >= 0; p--) {
                    if (!dp[p][cs])
                        continue;

                    ll val = dp[p][cs];
                    ll rem = m - p;

                    for (int c = 1; c <= available && c <= rem; c++) {
                        if (cs + 1LL * d * c > t) break;

                        ll cmb = f[fr[d]];
                        (cmb *= invf[c]) %= MOD;
                        (cmb *= invf[fr[d] - c]) %= MOD;

                        (dp[p + c][cs + d * c] += val * cmb) %= MOD;
                    }
                }
            }
        }

        if (!dp[m][t]) return 0;
        
        ll ff = 1;
        for (int d = 0; d < 10; d++) {
            ff = (ff * f[fr[d]]) % MOD;
        }
        
        ll iff = mpow(ff, MOD-2);
        ll ans = dp[m][t];
        ans = (ans * f[m]) % MOD;
        ans = (ans * f[h]) % MOD;
        ans = (ans * iff) % MOD;
        
        return ans;
    }
};",1441366231
ABHAY GUPTA,abhayg_07,153,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq;
        pq.push({0,0,0});
        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0] = 0;
        while(!pq.empty()){
            array<int,3> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy] > max( a[0] , moveTime[newx][newy] ) + 1 ){
                    dis[newx][newy] = max( a[0] , moveTime[newx][newy] ) + 1;
                    pq.push({dis[newx][newy],newx,newy});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441306123
ABHAY GUPTA,abhayg_07,153,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<long long,4>,vector<array<long long,4>>,greater<array<long long,4>>> pq;
        pq.push({0,0,0,0});
        long long dis[n][m][2];
        for( int i = 0 ; i < n ; i++ ){
            for( int j = 0 ; j < m ; j++ ){
                for( int k = 0 ; k < 2 ; k++ ){
                    dis[i][j][k] = 1e15;
                }
            }
        }
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0][0] = 0;
        while(!pq.empty()){
            array<long long,4> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]][a[3]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy][a[3]^1] > max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1 ){
                    dis[newx][newy][a[3]^1] = max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1;
                    pq.push({dis[newx][newy][a[3]^1],newx,newy,a[3]^1});
                }
            }
        }
        return min(dis[n-1][m-1][0],dis[n-1][m-1][1]);
    }
};",1441314055
ABHAY GUPTA,abhayg_07,153,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0 , o = 0;
        for( int i = 0 ; i < num.size() ; i++ ){
            if(i&1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return e == o;
    }
};",1441282354
ABHAY GUPTA,abhayg_07,153,3637,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    vector<long long> fact , ifact;

    long long expo(long long a, long long b, long long m)
    {
        long long res = 1;
        while (b > 0)
        {
            if (b & 1)
                res = (res * a) % m;
            a = (a * a) % m;
            b = b >> 1;
        }
        return res % m;
    }

    long long modinv(long long a, long long m) { return expo(a, m - 2, m) % m; } // m is prime

    long long dp[10][162][1500];
    // // center is 750
    int cnt[10];

    void init(long long  n){
        fact.resize(n);
        ifact.resize(n);
        fact[0]=1;
        for( int i = 1 ; i < n ; i++ ) fact[i]=(fact[i-1]%mod*i)%mod;
        ifact[n-1]=modinv(fact[n-1],mod)%mod;
        for(int i=n-2 ; i>=1 ; i--){
            ifact[i]=(ifact[i+1]%mod*(i+1))%mod;
        }
        ifact[0]=1;
    }

    long long recursion( int d , int c , int diff ){
        if( d == -1 && c== 80 && diff == 750 ) return 1;
        else if( d == -1 ) return 0;
        if( dp[d][c][diff] != -1 )return dp[d][c][diff];
        long long ways = 0;
        for( int i = 0 ; i <= cnt[d] ; i++ ){
            // this much d is given to 1
            int newc = c + i - ( cnt[d] - i );
            int newdiff = diff + i * d - ( cnt[d] - i ) * d;
            int D = ( ifact[i]%mod * ifact[cnt[d]-i]%mod )%mod;
            ways = ( ways%mod + ( recursion( d - 1 , newc , newdiff )%mod * D%mod )%mod )%mod;
        }
        return dp[d][c][diff] = ways;
    }

    int countBalancedPermutations(string num) {
        init(10000);
        
        for( int i = 0 ; i < 10 ; i++ ){
            for( int j = 0 ; j < 162 ; j++ ){
                    for( int l = 0 ; l < 1500 ; l++ ){
                        dp[i][j][l] = -1;
                    }
            }
        }
        for( int i = 0 ; i < 10 ; i++ ){
            cnt[i] = 0;
        }
        for( auto i : num ){
            int d = i - '0';
            cnt[d]++;
        }
        int n = num.size();
        long long ways = recursion( 9 , 80 + (n&1) , 750 );
        ways = ( ways * fact[(n+1)/2]%mod )%mod;
        ways = ( ways * fact[n/2]%mod )%mod;
        return ways;
    }
};",1441354161
Yuanbin Cheng,cybsbbbb,154,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[float('inf')] * n for _ in range(m)]
        distance[0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y = heapq.heappop(queue)
            if distance[cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y = cur_x + dx, cur_y + dy
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1, cur_dis + 1)
                    if distance[nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y))

        return distance[-1][-1]

        ",1441303445
Yuanbin Cheng,cybsbbbb,154,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[[float('inf')] * n for _ in range(m)] for _ in range(2)]
        distance[0][0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y, cur_step = heapq.heappop(queue)
            if distance[cur_step][cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y, nxt_step = cur_x + dx, cur_y + dy, (cur_step + 1) % 2
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1 + cur_step, cur_dis + 1 + cur_step)
                    if distance[nxt_step][nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_step][nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y, nxt_step))

        return min(distance[0][-1][-1], distance[1][-1][-1])
        ",1441309705
Yuanbin Cheng,cybsbbbb,154,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(0, n, 2):
            even += int(num[i])
        for i in range(1, n, 2):
            odd += int(num[i])
        return odd == even
        ",1441284061
Yuanbin Cheng,cybsbbbb,154,3637,python3,"MOD = 10 ** 9 + 7
MAXN = 80
fac = [1] * MAXN
inv_fac = [1] * MAXN
for i in range(1, MAXN):
    fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN - 1] = pow(fac[MAXN - 1], -1, MOD)
for i in range(MAXN - 2, -1, -1):
    inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD

def combination(n, k):
    return (fac[n] * inv_fac[k] % MOD) * inv_fac[n - k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        
        cnt = [0] * 10
        tot = 0
        for i in range(n):
            ni = int(num[i])
            cnt[ni] += 1
            tot += ni
        if tot % 2 == 1:
            return 0

        tot_half = tot // 2
        n_even = n // 2 + n % 2
        n_odd = n // 2

        @cache
        def dp(even_v, odd_v, even_c, odd_c, d):
            if even_c < 0 or odd_c < 0:
                return 0
            
            if d == 0:
                if even_v or odd_v:
                    return 0
                else:
                    return 1
            res = 0
            d_cnt = cnt[d]
            for i in range(d_cnt + 1):
                if even_v < i * d or odd_v < (d_cnt - i) * d:
                    continue
                # print(even_c, odd_c)
                res += comb(even_c, i) * comb(odd_c, d_cnt - i) * dp(even_v - i * d, odd_v - (d_cnt - i) * d, even_c - i, odd_c - (d_cnt - i), d - 1) % MOD
            # print(even_v, odd_v, even_c, odd_c, d, res)
            return res % MOD

        return dp(tot_half, tot_half, n_even, n_odd, 9)
            


        

        
        ",1441360555
Matt,mattagar6,155,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int lo = 0, hi = 1e9 + 1;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 1e9+n+m+1000));
        d[0][0] = 0;

        set<tuple<int,int,int>> s;
        s.insert({0,0,0});

        auto go = [&](int r, int c, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;

            int min_time_to_him = moveTime[nr][nc];
            int his_dis = max(dis, min_time_to_him) + 1;
            if(his_dis < d[nr][nc]) {
                s.erase({d[nr][nc], nr, nc});
                d[nr][nc] = his_dis;
                s.insert({d[nr][nc], nr, nc});
            }
            
        };
        
        while(!s.empty()) {
            auto [dis, r, c] = *s.begin();
            s.erase(s.begin());

            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(abs(dx) + abs(dy) == 1) {
                        go(r, c, dis, r + dx, c + dy);
                    }
                }
            }
        }
        
        return d[n-1][m-1];
    }
};",1441337323
Matt,mattagar6,155,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2,2e9)));
        d[0][0][0] = 0;
        set<tuple<int,int,int,int>> s;
        s.insert({0,0,0,0});
        // arrive at r, c with parity p
        auto go = [&](int r, int c, int p, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;
            // we are going now for sure!
            int starting_time = max(dis, grid[nr][nc]);
            dis=starting_time;
            // go now
            for(int rep = 0; rep < 2; rep++, dis++) {
                int np = (p + 1)%2;
                if( dis + 1 + p % 2 < d[nr][nc][np] ) {
                    s.erase({d[nr][nc][np], nr, nc, np});
                    d[nr][nc][np] = dis + 1 + p % 2;
                    s.insert({d[nr][nc][np], nr, nc, np});
                }
            }
            
            
            // wait, then go
            
        };

        while(!s.empty()) {
            auto [dis, r, c, p] = *s.begin();
            s.erase(s.begin());
            for(int dx = -1; dx <= 1; ++dx) {
                for(int dy = -1; dy <= 1; ++dy) {
                    if(abs(dx)+abs(dy)!=1) continue;
                    go(r, c, p, dis, r + dx, c + dy);
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441366949
Matt,mattagar6,155,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0, b = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                a += num[i] - '0';
            } else {
                b += num[i] - '0';
            }
        }
        return a == b;
    }
};",1441297104
Matt,mattagar6,155,3637,cpp,"// for each group of digits

// x o o o x x o o  o
// have N at even, M at odd


struct I {
    long long x{};
};

const int MOD = 1000*1000*1000+7;

I operator + (I a, I b) {
    return I{(a.x + b.x) % MOD};
}

I operator * (I a, I b) {
    return I {(a.x * b.x) % MOD};
}

const int N = 100;
const int M = 1000;
I choose[N][N];
I dp[11][N][M];



// number of used even squares, sum on even squares
class Solution {
public:
    int countBalancedPermutations(string num) {
        for(int i = 0; i < N; i++) {
            choose[i][0] = choose[i][i] = I{1};
            for(int j = 1; j < i; j++) {
                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];
            }
        }
        for(int i = 0; i < 11; i++) for(int j = 0; j < N; j++) for(int k = 0; k < M; k++) dp[i][j][k] = I{0};

        map<int,int> count;
        for(char ch : num) count[ch - '0']++;

        int n = num.size();
        dp[0][0][0] = I{1};
        for(int d = 0; d < 10; d++) {
            int to_put = count[d];
            int sum_all = 0;
            int count_all = 0;
            for(char ch : num) {
                if(ch-'0' < d) {
                    sum_all += ch-'0';
                    count_all+=1;
                }
            }
            
            for(int even = 0; even <= (n+1)/2; even++) {
                for(int sum_even = 0; sum_even <= 9*even; sum_even++) {
                    int sum_odd = sum_all - sum_even;
                    if(sum_odd < 0) continue;
                    for(int on_even = 0; on_even <= to_put; on_even++) {
                        if(on_even + even > (n + 1) / 2) continue;
                        if(n/2-(count_all-even)<to_put-on_even) continue;//odd indices

                        dp[d+1][on_even + even][sum_even + d * on_even] =  dp[d+1][on_even + even][sum_even + d * on_even] + dp[d][even][sum_even] * choose[(n+1)/2 - even ][ on_even ] * choose[n/2-(count_all-even)][ to_put - on_even ];
                    }
                }
            }
        }
        //cout << dp[2][1][1].x << '\n'; // digit 1 is done, one even, sum 1 -> 1 x x, x x 1
       // cout << dp[2][0][0].x; // x 1 x
        int sum = 0;
        for(char c : num) sum += c - '0';
        if(sum % 2 == 1) return 0;
        return dp[10][(n+1)/2][sum/2].x;
    }
};",1441329857
harshal_02,harshal_02,156,3627,cpp,"

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});  
        vector<vector<ll>>vec(n,vector<ll>(m, INF));
        vec[0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j = upr.j;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1) {
                return b;
            }
            if (b > vec[i][j]) {
                continue;
            }
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + 1;
                    if (maxi < vec[ii][jj]) {
                        vec[ii][jj] = maxi;
                        pq.push(st{ii, jj, 0, maxi});  
                    }
                }
            }
        }
        return -1;
    }
};
",1441334267
harshal_02,harshal_02,156,3628,cpp,"#include <vector>
#include <queue>
#include <algorithm>

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});
        vector<std::vector<std::vector<ll>>> vec(n, std::vector<std::vector<ll>>(m, std::vector<ll>(2, INF)));
        vec[0][0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j= upr.j;
            int p= upr.par;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1){
                return b;
        }
            if (b > vec[i][j][p]){
                continue;
    }
        int tot = (p == 0) ? 1 : 2;
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];    
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + tot;
                    int np = 1 - p;
                    if (maxi < vec[ii][jj][np]) {
                        vec[ii][jj][np] = maxi;
                        pq.push(st{ii, jj, np, maxi});
                    }
                }
            }
        }
        ll ans=min(vec[n - 1][m - 1][0], vec[n - 1][m - 1][1]);
        return ans;
    }
};
",1441316511
harshal_02,harshal_02,156,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.size();
        int e=0;
        int o=0;
        for(int i=0;i<n;i++) {
            if(i%2==0){
                e+=num[i]-'0';
        }
            else{
                o+=num[i]-'0';
            }
        }
        return e==o;
    }
};",1441317691
harshal_02,harshal_02,156,3637,cpp,"#define ll long long int
const int MOD=1e9+7;
struct Solution {
    ll mathpow(ll base, ll exponent) {
        ll result=1;
        base=base%MOD;
        while(exponent>0) {
            if(exponent&1)
                result=result*base;
            result=result%MOD;
            base=base*base;
            base=base%MOD;
            exponent>>=1;
        }
        return result;
    }
    ll compute_factorial(int n) {
        ll fact=1;
        for(int i=1;i<n+1;i++){
            fact=fact*i;
            fact=fact%MOD;
        }
        return fact;
    }
    ll compute_combination(int n, int k) {
        if(k > n || k < 0) 
            return 0;
        ll comb=1;
        for(int i=1; i<=k; i++) {
            comb=comb*(n-i+1);
            comb=comb%MOD;
            ll inverse=mathpow(i, MOD-2);
            comb=comb*inverse;
            comb=comb%MOD;
        }
        return comb;
    }
    int countBalancedPermutations(string digits) {
        int n=digits.size(), digit_count[10]={0};
        for(char ch:digits) digit_count[ch-'0']++;
        ll sum=0;
        for(int i=0;i<10;i++){
        sum+=(ll)i*digit_count[i];
    }
        if(sum%2!=0) 
        return 0;
        ll target_value=sum/2;
        int half_n=(n+1)/2;
        vector<vector<vector<ll>>>dp(11, vector<vector<ll>>(half_n+1, vector<ll>(target_value+1, 0)));
        dp[0][0][0]=1;
        for(int i=0;i<10;i++) {
            for(int j=0;j<half_n+1;j++) {
                for(int k=0;k<target_value+1;k++) {
                    if(dp[i][j][k]==0) 
                    continue;
                    for(int use=0; use<=digit_count[i] && use+j<=half_n && use*i<=target_value-k; use++) {
                        ll combination=compute_combination(digit_count[i], use);
                        dp[i+1][j+use][k+use*i]=(dp[i+1][j+use][k+use*i]+dp[i][j][k]*combination)%MOD;
                    }
                }
            }
        }
        ll summ=0;
        for(int i=0;i<10;i++){
        summ+=digit_count[i];
        }
        ll target_sum=target_value;
        if(half_n<0 || half_n > n || target_value<0)
         return 0;
        ll cnt=dp[10][half_n][target_value];
        if(cnt==0) 
        return 0;
        ll fact_val=compute_factorial(n);
        ll prod_fact=1;
        for(int i=0;i<10;i++) {
            prod_fact=prod_fact*compute_factorial(digit_count[i]);
            prod_fact=prod_fact%MOD;
        }
        ll factorial_k=compute_factorial(half_n);
        ll factorial_nk=compute_factorial(n-half_n);
        ll inverse_prod_fact=mathpow(prod_fact,MOD-2);
        ll ans=cnt*factorial_k;
        ans=ans%MOD;
        ans=ans*factorial_nk;
        ans=ans%MOD;
        ans=ans*inverse_prod_fact;
        ans=ans%MOD;
        return (int)ans;
    }
};",1441373357
Rajat,log1,157,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        
        vector<vector<long>>dist(n,vector<long>(m,N));
        priority_queue<tuple<long,int,int>,vector<tuple<long,int,int>>,greater<tuple<long,int,int>>>pq;
        
        dist[0][0]=0;
        pq.push(make_tuple(0,0,0));
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[i,j,k]=pq.top();pq.pop();
            if(j==n-1 && k==m-1)
            {
                return i;
            }
            if(dist[j][k]<i)continue;
            for(auto& it:dir)
            {
                int Nx=j+it[0],Ny=k+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long long Nz=max(i,(long)moveTime[Nx][Ny])+1;
                    if(Nz<dist[Nx][Ny])
                    {
                        dist[Nx][Ny]=Nz;
                        pq.push(make_tuple(Nz,Nx,Ny));
                    }
                }
            }
        }
        return-1;
    }
};",1441348101
Rajat,log1,157,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        vector<vector<vector<long>>>dist(n,vector<vector<long>>(m,vector<long>(2,N)));
        priority_queue<tuple<long,int,int,int>,vector<tuple<long,int,int,int>>,greater<tuple<long,int,int,int>>>pq;
        dist[0][0][0]=0;
        pq.emplace(0,0,0,0);
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[ct,i,j,k]=pq.top();pq.pop();
            if(i==n-1 && j==m-1)
            {
                return(int)ct;
            }
            if(dist[i][j][k]<ct)continue;
            int cost=(k==0)?1:2;
            for(auto& it:dir)
            {
                int Nx=i+it[0],Ny=j+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long at=max((long)ct,(long)moveTime[Nx][Ny])+(long)cost;
                    int Nz=1-k;
                    if(at<dist[Nx][Ny][Nz])
                    {
                        dist[Nx][Ny][Nz]=at;
                        pq.emplace(at,Nx,Ny,Nz);
                    }
                }
            }
        }
        return -1;
    }
};",1441310912
Rajat,log1,157,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int evenSum=0,oddSum=0;
        for(int i=0;i<n;++i)
        {
            (i&1)?oddSum+=num[i]-'0':evenSum+=num[i]-'0';
        }
        return evenSum==oddSum;
    }
};",1441281609
Rajat,log1,157,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;

ll mod_pow(ll x,ll y)
{
    ll res=1;
    x%=MOD;
    while(y>=1)
    {
        if(y&1)res=res*x%MOD;
        x=x*x%MOD;
        y>>=1;
    }
    return res;
}
class Solution{
public:
    int countBalancedPermutations(string num){
        int n=num.size();
        int dig[10]={0};
        for(int i=0;i<n;++i)
        {
            dig[num[i]-'0']++;
        }
        ll tot=0;
        for(int d=0;d<10;++d)
        {
            tot+=(ll)d*dig[d];
        }
        if(tot%2!=0)
        {
            return 0;
        }
        ll tar=tot/2;
        int k=(n+1)/2;
        vector<vector<vector<ll>>>dp(11,vector<vector<ll>>(k+1,vector<ll>(tar+1,0)));
        dp[0][0][0]=1;
        for(int d=0;d<10;++d)
        {
            for(int c=0;c<=k;++c)
            {
                for(int s=0;s<=tar;++s)
                {
                    if(dp[d][c][s]==0)continue;
                    for(int t=0;t<=dig[d] && t+c<=k && t*d<=tar-s;++t)
                    {
                        ll res=1;
                        for(int i=1;i<=t;++i)
                        {
                            res=res*(dig[d]-i+1)%MOD;
                            ll inv=mod_pow(i,MOD-2);
                            res=res*inv%MOD;
                        }
                        int nxt=d+1,nxtc=c+t,nxts=s+t*d;
                        dp[nxt][nxtc][nxts]=(dp[nxt][nxtc][nxts]+dp[d][c][s]*res)%MOD;
                    }
                }
            }
        }
        if(k<0 || k>n || tar<0)return 0;
        ll ret=dp[10][k][tar];
        if(ret==0)return 0;
        vector<long long>ndp(n+1,1);
        for(int i=1;i<=n;++i)
        {
            ndp[i]=ndp[i-1]*i%MOD;
        }
        ll prod=1;
        for(int d=0;d<10;++d)
        {
            for(int i=1;i<=dig[d];++i)
            {
                prod=prod*i%MOD;
            }
        }
        ll pre1=ndp[k],pre2=ndp[n-k];
        ll prod_inv=mod_pow(prod,MOD-2);
        ll ans=ret*pre1%MOD;
        // for(int i=0;i<ans;++i)
        // {
        //     cout<<ndp[i]<<"" "";
        // }
        // cout<<endl;
        ans=ans*pre2%MOD;
        ans=ans*prod_inv%MOD;
        return(long long)ans;
    }
};",1441332406
chh9976,chh9976,158,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d + 1, moveTime[x-1][y] + 1)
                bfs.add((max(d + 1, moveTime[x-1][y] + 1), (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d + 1, moveTime[x][y-1] + 1)
                bfs.add((max(d + 1, moveTime[x][y-1] + 1), (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d + 1, moveTime[x+1][y] + 1)
                bfs.add((max(d + 1, moveTime[x+1][y] + 1), (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d + 1, moveTime[x][y+1] + 1)
                bfs.add((max(d + 1, moveTime[x][y+1] + 1), (x, y+1)))
                
                ",1441299328
chh9976,chh9976,158,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d, moveTime[x-1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x-1, y)], (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d, moveTime[x][y-1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y-1)], (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d, moveTime[x+1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x+1, y)], (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d, moveTime[x][y+1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y+1)], (x, y+1)))
                
        ",1441304424
chh9976,chh9976,158,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280967
chh9976,chh9976,158,3637,cpp,"
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define ee9 1000000000
#define ee18 1000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
typedef mint<998244353> mint99;
vc<mint17> fact(1, 1), ifact(1, 1);
mint17 C(int a, int b){
    return fact[a] * ifact[b] * ifact[a-b];
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if(fact.size() == 1){
            rep(i, 1, 170) fact.pb(fact.back() * i), ifact.pb(ifact.back() / i);
        }
        int n = num.size();
        map<int, int> cnter;
        for(auto c:num) cnter[c-48]++;
        
        int su = 0;
        for(auto [k, v]:cnter) su += k * v;
        if(su % 2 == 1) return 0;
        int tar = su / 2;
        
        vc dp((1+n) / 2 + 1, vc<mint17>(tar+1)); dp[0][0] = 1;
        int nowcnt = 0;
        for(auto [k, v]:cnter){
            vc ndp((1+n) / 2 + 1, vc<mint17>(tar+1));
            rep(i, 0, v+1){
                rep(j, 0, tar+1) if(i * k + j <= tar) {
                    rep(kk, 0, nowcnt+1) if(i + kk <= (1+n) / 2){
                        ndp[i + kk][i * k + j] += C(i + kk, i) * C(nowcnt - kk + v - i, v - i) * dp[kk][j];
                    }
                }
            }
            nowcnt += v;
            dp = move(ndp);
        }
        return dp[(1+n)/2][tar].x;
        
    }
};",1441361211
colicon,colicon,159,3627,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[2e9]*m for _ in range(n)]
        d[0][0] = 0
        
        h = [(0, 0, 0)]
        while h:
            cd, i, j = heappop(h)

            if d[i][j] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + 1
    
                    if d[ni][nj] > nd:
                        d[ni][nj] = nd
                        heappush(h, (nd, ni, nj))

        return d[-1][-1]
            ",1441297539
colicon,colicon,159,3628,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[[2e9]*2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        w = [1, 2]
        
        h = [(0, 0, 0, 0)]
        while h:
            cd, t, i, j = heappop(h)

            if d[i][j][t] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + w[t]
    
                    if d[ni][nj][t^1] > nd:
                        d[ni][nj][t^1] = nd
                        heappush(h, (nd, t^1, ni, nj))

        return min(d[-1][-1])
            
",1441301085
colicon,colicon,159,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        b = 0

        for i, x in enumerate(num):
            if i&1:
                a += int(x)
            else:
                b += int(x)

        return a == b",1441282279
colicon,colicon,159,3637,python3,"mod = 10**9 + 7

fac = [1] * 100
for i in range(2, 100):
    fac[i] = fac[i-1] * i % mod
ifac = [0] * 100
ifac[99] = pow(fac[99], -1, mod)
for i in range(98, -1, -1):
    ifac[i] = ifac[i+1] * (i+1) % mod

def choose(n, k):
    return fac[n] * ifac[k] % mod * ifac[n-k] % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        n = len(num)

        cnt = [0] * 11
        for x in num:
            cnt[int(x)] += 1

        tot_sum = [0] * 11
        for i in range(10):
            tot_sum[i] = tot_sum[i-1] + cnt[i] * i

        tot_cnt = [0] * 11
        for i in range(10):
            tot_cnt[i] = tot_cnt[i-1] + cnt[i]

        if tot_sum[-2] & 1:
            return 0
        
        dp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        dp[0][0] = 1
        for d in range(10):
            for i in range(min(n//2, tot_cnt[d-1])+1):
                for j in range(tot_sum[d-1]+1):
                    for k in range(min(n//2-i, cnt[d])+1):
                        if j + k*d > tot_sum[-2]//2:
                            break
                        ri = tot_cnt[d-1] - i
                        rk = cnt[d] - k

                        ndp[i + k][j + k*d] += dp[i][j] * choose(i+k, k) % mod * choose(ri+rk, rk) % mod
                        ndp[i + k][j + k*d] %= mod
            dp = ndp
            ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]

        return dp[n//2][tot_sum[-2]//2]
                
            
            ",1441348954
Pranav Raj,ThunderXGod,162,3627,cpp,"#define pii pair<int, int>
vector<vector<int>> d = {{-1,0}, {1, 0}, {0, -1}, {0, 1}};
int zz;
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        
        vector<vector<long long>> a(n, vector<long long>(m, 2e18));
        
        priority_queue<pair<long long,pii>, vector<pair<long long,pii>>, greater<pair<long long,pii>>> pq;
        
        a[0][0] = 0;
        pii p = {0, 0};
        pq.push({0, p});
        long long cur = 0, tm = 0;
        while((int)pq.size()) 
        {
            auto c = pq.top();
            cur += c.first;
            int i = c.second.first, j = c.second.second;
            pq.pop();
            
            if(i == n - 1 && !zz && j == m - 1) 
            {
                int ans = cur;
                return ans;
            }
            long long st;
            if(cur <= a[i][j])
            {
                st -= st;
                st += max(1ll*cur, 1ll*moveTime[i][j]);
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = j;
                    ni += dir[0];
                    nj += dir[1];

                    if (ni > -1 && !zz && ni <= n - 1 && !zz && nj > -1 && !zz && nj <= m - 1) 
                    {
                        long long mt, at = -1;
                        mt = st;
                        at++;
                        tm += max(1ll*cur, 1ll*moveTime[ni][nj]);
                        at -= at;
                        at += tm;
                        
                        //at += max(mt, 1ll*moveTime[ni][nj]);
                        
                        if (at + 1 < a[ni][nj]) 
                        {
                            a[ni][nj] = at + 1;
                            p.first = ni;
                            p.second = nj;
                            pq.push({at + 1, p});
                        }
                        tm -= tm;
                    }
                }
            }
            cur -= cur;
        }
        
        return -1;
    }
};",1441307299
Pranav Raj,ThunderXGod,162,3628,cpp,"vector<vector<int>> d = {{-1,0}, {1,0}, {0,-1}, {0,1}};
#define vll vector<long long>
int zz;
#define liii long long, int, int, int
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        vector<vector<vll>> a(n, vector<vll>(m, vll(2, 2e18)));
        priority_queue<tuple<liii>, vector<tuple<liii>>, greater<tuple<liii>>> pq;
        a[0][0][0] -= a[0][0][0];
        pq.push({0, 0, zz, 0});
        long long c = zz, tm = 0, at = 0;
        while((int)pq.size()) 
        {
            auto cur = pq.top();
            int i = get<1>(cur), j = 0, p = -1;
            j += get<2>(cur);
            c += get<0> (cur);
            
            pq.pop();
            
            if(i+1==n&&j+1==m) 
            {
                int ans = c;
                return ans;
            }
             
            p += get<3>(cur);
            if(c <= a[i][j][p+1]) 
            {  
                int dr = 2;
                if(!(p+1))
                    dr--;
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = i + j;
                    ni+= dir[0];
                    nj += dir[1];
                    nj -= i;
        
                    if(ni > -1 && !zz&& ni <= n - 1 && !zz&& nj > -1 && nj <= m - 1) 
                    {
                        at += 1ll*dr;
                        if(!zz)
                        tm += max(1ll*c, 1ll*moveTime[ni][nj]);
                        at += tm;
                        int np = 1;
                        np-= (p+1);

                        if(at+zz < a[ni][nj][np]) 
                        {
                            a[ni][nj][np] = at;
                            if(!zz)
                            pq.push({at, ni, nj, np});
                        }
                        tm -= tm;
                        at -= at;
                    }
                }
            }
            c-=c;
        }
        
        return -1;
    }
};
",1441331247
Pranav Raj,ThunderXGod,162,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < (int)num.size(); i++)
        {
            if(i&1)
                l += (num[i]-'0');
            else
                r += (num[i]-'0');
        }
        return (l==r);
    }
};",1441281650
Pranav Raj,ThunderXGod,162,3637,cpp,"#define ll long long
const int M = 1e9 + 7;
ll f1(ll x, ll y, ll mv) 
{
    ll r = 1;
    x %= mv;
    while(y>=1)
    {
        if(y&1)
        {
            r*=x;
            r%=mv;
        }
        x*=x;
        x%=mv;
        y >>= 1;
    }
    return r;
}
struct Factorials 
{
    vector<ll> fc,ifc;
    Factorials(int mn, int mv)
    {
        int sz = 1;
        sz += mn;
        fc.resize(sz, 1);
        ifc=fc;
        int i = 1;
        while(i < mn + 1)
        {
            fc[i]=fc[i-1];
            fc[i]*=i;
            fc[i]%=mv;
            i++;
        }
        ifc[mn] = f1(fc[mn], mv -2, mv);
        i = -1;
        i += mn;
        while(i > -1)
        {
            ifc[i] = ifc[i+1];
            ifc[i]*=(1+i);
            ifc[i]%=mv;
            i--;
        }
    }
    ll f2(int n, int k)
    {
        if(k > n)
            return 0;
        if(k <= -1)
            return 0;
        ll ans = fc[n];
        ans *= ifc[k];
        ans %= M;
        ans *= ifc[-k+n];
        return (ans%M);
    }
};

class Solution {
public:
    int n;
    int countBalancedPermutations(string &num) 
    {
        n = (int)num.size();
        int dc[10];
        memset(dc, 0, sizeof(dc));
        ll s =0;
        for(char ch: num)
        {
            int vv=(int)(ch-'0');
            dc[vv]++;
            s+=(vv);
        }
        if(s&1) 
            return 0;
        ll ts = s;
        ts >>= 1;
        int m = 1,p=2*n,d=0,cnt = 1;
        m+=n;
        m>>=1;
        p>>=2;
        int sz = 1;
        sz += ts;
        Factorials f(n, M);
        vector<ll> vec(sz, 0);
        vector<vector<ll>> dp(m +1, vec);
        dp[0][0]++;
        while(d<10)
        {
            vector<vector<ll>> dp2 = dp;
            while(cnt < dc[d]+1)
            {
                int k = m;
                while(1)
                {
                    if(k < cnt)
                        break;
                    int s = 0;
                    s += ts;
                    while(1)
                    {
                        if(s < cnt*d)
                            break;
                        int kk = -d*cnt;
                        kk += s;
                        ll val = dp[-cnt+k][kk];
                        val*=1ll*f.f2(dc[d],cnt);
                        dp2[k][s] += val;
                        dp2[k][s] %= M;
                        s--;
                    }
                    k--;
                }
                cnt++;
            }
            cnt = 1;
            d++;
            dp = dp2;
        }
        d-=d;
        ll dm =1;
        while(d < 10)
        {
            dm *= f.fc[dc[d]];
            dm %= M;
            d++;
        }
        ll fm = 0, fp = 0;
        fm+=f.fc[m];
        fp+=f.fc[p];
        ll ans = dp[m][ts];
        ans *= fm;
        ans%=M;
        ans*=fp;
        ans%=M;
        ans*=f1(dm, M -2, M);
        ans%=M;
        int fans = ans;
        return fans;
    }
};",1441369307
TheRaven,TheRaven,163,3627,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?1:0]) {
                    PQ.add(new Pair(i2,j2,Math.max(p.d+1,moveTime[i2][j2]+1), p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441314301
TheRaven,TheRaven,163,3628,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?0:1]) {
                    int d2 = (p.parity) ? 1 : 2;
                    PQ.add(new Pair(i2,j2,Math.max(p.d+d2,moveTime[i2][j2]+d2), !p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441319121
TheRaven,TheRaven,163,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int eSum = 0;
        int oSum = 0;
        char [] S = num.toCharArray();
        for (int i = 0; i<S.length; ++i) {
            if (i % 2 == 0) eSum += S[i]-'0';
            else oSum += S[i]-'0';
        }
        return eSum == oSum;
        
    }
}",1441284618
TheRaven,TheRaven,163,3637,java,"class Solution {
    long [][][] dp;
    long MOD = 1000000007L;
    int [] cnt;
    long [][] choose = new long [82][82];
    int numtot;
    public int countBalancedPermutations(String num) {
        choose[0][0] = 1;
        for (int i = 1; i<choose.length; ++i) {
            choose[i][0] = choose[i-1][0];
            for (int j = 1; j<=i; ++j) {
                choose[i][j] = (choose[i-1][j] + choose[i-1][j-1]) % MOD;   
            }
        }
        //System.out.println(choose[30][30]);
        
        int sum = 0;
        cnt = new int [10];
        char [] N = num.toCharArray();
        int numtot = N.length;
        for (char c : N) cnt[c-'0']++;
        for (int i = 1; i<=9; ++i) sum += cnt[i]*i;
        if (sum % 2 == 1) return 0;
        if (sum == 0) return 1;
        
        dp = new long [10][sum/2+1][N.length/2+1];
        for (int i = 0; i<10; ++i) for (int j = 0; j<dp[0].length; ++j) Arrays.fill(dp[i][j], -1);
        int goal = sum/2;
        
        long ans = recurse(0, sum/2, N.length/2, N.length - N.length/2);
            
        return (int)(ans % MOD);
    }
    public long recurse(int dig, int goalsum, int numleft, int numother) {
        if (numleft == 0 && goalsum == 0 && numother == 0) return 1;
        if (dig > 9) return 0;
        if (goalsum == 0 && numleft > 0 && dig != 0) return 0;
        if (numother < 0) return 0;
        
        if (dp[dig][goalsum][numleft] == -1) {
            int lim = Math.min(numleft, cnt[dig]);
            long ans = 0;
            for (int i = 0,g=goalsum,j=cnt[dig]; i<=lim && g>=0 && j>=0; ++i,--j,g-=dig) {
                long tmp = recurse(dig+1, g, numleft-i, numother - j);
                tmp *= choose[numleft][i];
                tmp %= MOD;
                tmp *= choose[numother][j];
                ans += (tmp % MOD);
            }
            ans %= MOD;
            dp[dig][goalsum][numleft] = ans;
            //System.out.println(""dig = "" + dig + "" goalsum = "" + goalsum + "" numleft = "" + numleft + "" ans = "" + ans);
        }
        return dp[dig][goalsum][numleft];
    }
}",1441363064
Decision,Decision,165,3627,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[1][m][n];
        for(int i=0;i<1;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = 0;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375984
Decision,Decision,165,3628,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[2][m][n];
        for(int i=0;i<2;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = (nd.st + 1) % 2;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + nd.st + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        if(dist[1][m-1][n-1] >= 0 && (res < 0 || res > dist[1][m-1][n-1])){
            res = dist[1][m-1][n-1];
        }
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375746
Decision,Decision,165,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int odd = 0, even = 0, k = 0;
        for(char ch : num.toCharArray()){
            if(k == 0){
                odd += ch - '0';
            }else{
                even += ch - '0';
            }
            k = (k+1) % 2;
        }
        return odd == even;
    }
}",1441376163
Decision,Decision,165,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        final int n = num.length(), m = 10, odd = (n+1) / 2, k = odd * (m - 1), MODE = 1000000007;
        final int even = n - odd;
        final int[] cs = new int[m];
        int sum = 0;
        long[][] dp = new long[odd+1][k+1], comb = new long[n+1][n+1];
        dp[0][0] = 1L;
        for(char ch : num.toCharArray()){
            cs[ch-'0']++;
            sum += ch - '0';
        }
        comb[0][0] = 1L;
        for(int i=1;i<=n;++i){
            comb[i][0] = comb[i][i] = 1L;
            for(int j=1;j<i;++j){
                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MODE;
            }
        }
        for(int i=0,cnt=0;i<m;++i){
            long[][] dp2 = new long[odd+1][k+1];
            for(int a=0;a<=cnt && a<=odd;++a){
                for(int b=0;b<=k;++b){
                    if(dp[a][b] > 0){
                        for(int c=0;c<=cs[i];++c){
                            if(c + a <= odd && cs[i]-c+(cnt-a) <= even){
                                dp2[c+a][b+i*c] += (comb[odd-a][c] * comb[even-(cnt-a)][cs[i]-c]) % MODE * dp[a][b];
                                dp2[c+a][b+i*c] = dp2[c+a][b+i*c] % MODE;
                            }
                        }
                    }
                }
            }
            cnt += cs[i];
            dp = dp2;
        }
        long res = 0;
        for(int i=0;i<=k;++i){
            if(sum-i == i){
                res = (res + dp[odd][i]) % MODE;
            }
        }
        return (int)res;
    }
}",1441375516
Piyush Kumar,kumarfeldspar,166,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F first
#define S second
#define __builtin_popcount __builtin_popcountll
#define vvi vector<vector<int>>
#define ld long double
#define pb push_back
#define mp make_pair
#define precision(i) cout << fixed << setprecision(i)
#define vpii vector<pair<int, int>>
#define pii pair<int, int>
#define vi vector<int>
#define stoi stoll
#define all(x) x.begin(), x.end()
#define mii map<int, int>
#define pqb priority_queue<int>
#define sz(a) (ll) a.size()
#define fastio                        \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL);
#define pqs priority_queue<int, vi, greater<int>>
#define rsort(a) sort(a.rbegin(), a.rend())
#define get_sum(a) accumulate(a.begin(), a.end(), 0LL)
#define get_max(a) *max_element(a.begin(), a.end())
#define get_min(a) *min_element(a.begin(), a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG);
long long rnd(long long x, long long y)
{
    return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout << x << nl
#define inf 1e18
#define ld long double
#define w(t)  \
    int t;    \
    cin >> t; \
    while (t--)
#define in(k) \
    int k;    \
    cin >> k;
#define f(i, x) for (int i = 0; i < x; i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i, a, b) for (int i = a; i < b; i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x << endl
#define dbg2(x, y) cout << #x << "" "" << x << "" "" << #y << "" "" << y << endl
#define dbg3(x, y, z) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << endl
#define dbg4(x, y, z, w) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << endl
#define dbg5(x, y, z, w, a) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << "" "" << #a << "" "" << a << endl
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)         \
    cout << #x << "" => ""; \
    _print1(x);           \
    cout << ""\n"";
void _print(ll t) { cerr << t; }
void _print(int t) { cerr << t; }
void _print(string t) { cerr << t; }
void _print(char t) { cerr << t; }
void _print(ld t) { cerr << t; }
void _print(double t) { cerr << t; }
template <class T, class V>
void _print(pair<T, V> p);
template <class T>
void _print(vector<T> v);
template <class T>
void _print(set<T> v);
template <class T, class V>
void _print(map<T, V> v);
template <class T>
void _print(multiset<T> v);
template <class T, class V>
void _print(pair<T, V> p)
{
    cerr << ""{"";
    _print(p.first);
    cerr << "","";
    _print(p.second);
    cerr << ""}"";
}
template <class T>
void _print(vector<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(set<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(multiset<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T, class V>
void _print(map<T, V> v)
{
    cerr << ""[ "";
    for (auto i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
    // shows from left
    string res;
    while (x > 0)
    {
        if (x % 2 == 0)
            res += '0';
        else
            res += '1';
        x /= 2;
    }
    reverse(all(res));
    return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX; j += i)
            {
                if (spf[j] == j)
                    spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m)
{
    a %= m;
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n, ll r)
{
    if (n < r)
        return 0;
    if (r > n - r)
        r = n - r;
    ll ans = 1;
    ll i;
    for (i = 1; i <= r; i++)
    {
        ans *= n - r + i;
        ans /= i;
    }
    return ans;
}
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }
ll MI(ll a, ll m) { return bpow(a, m - 2, m); }
void meta(int x) { cout << ""Case #"" << x << "": ""; }

class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size();
        int m = tm[0].size();
        vector<vector<ll>> dist(n, vector<ll>(m, 1e18));
        priority_queue<pair<ll, pair<int, int>>, vector<pair<long long, pair<int, int>>>, greater<pair<long long, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.empty())
        {
            auto current = pq.top();
            pq.pop();
            long long t = current.F;
            int i = current.second.F;
            int j = current.second.S;
            if (i == n - 1 && j == m - 1)
                return t;
            if (t > dist[i][j])
                continue;
            f(k,4)
            {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if (ni >= 0 && ni < n && nj >= 0 && nj < m)
                {
                    long long nt = max(t, (long long)tm[ni][nj]) + 1;
                    if (nt < dist[ni][nj])
                    {
                        dist[ni][nj] = nt;
                        pq.push({nt, {ni, nj}});
                    }
                }
            }
        }
        return -1;
    }
};",1441296485
Piyush Kumar,kumarfeldspar,166,3628,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define unewxq(s) s.resize(unewxque(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
// long long rnd(long long x, long long y)
// {
// return unewxform_int_distribution<long long>(x, y)(RNG);
// }
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX ; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX ; j += i)
            {
            if(spf[j]==j)	
                spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX ; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX ; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
// #define int long long int
#define mod             1000000007
const int N = 4e5 + 5;


class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size(), m = tm[0].size();
        vector<vector<ll>> d0(n, vector<long long>(m, 1e18));
        vector<vector<ll>> d1(n, vector<long long>(m, 1e18));
        d0[0][0] = 0;
        priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty())
        {
            auto [t, i, j, p] = pq.top();
            pq.pop();

            if (i == n - 1 && j == m - 1)
                return t;

            if ((p == 0 && t > d0[i][j]) || (p == 1 && t > d1[i][j]))
                continue;

            f(k,4)
            {
                int newx = i + dx[k], newy = j + dy[k];

                if (newx >= 0 && newx < n && newy >= 0 && newy < m)
                {
                    long long temp = 2;
                    if(p==0)temp=1;
                    long long nt = max(t, (long long)tm[newx][newy]) + temp;
                    int np = 1 - p;

                    if (np == 0)
                    {
                        if (nt < d0[newx][newy])
                        {
                            d0[newx][newy] = nt;
                            // cout<<nt<<"" ""<<newx<<"" ""<<newy<<"" ""<<np<<endl;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                    else
                    {
                        if (nt < d1[newx][newy])
                        {
                            d1[newx][newy] = nt;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                }
            }
        }

        return -1;
    }
};
",1441302838
Piyush Kumar,kumarfeldspar,166,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            } else {
                oddSum += num[i] - '0';
            }
        }
        
        return evenSum == oddSum;
    }
};",1441286993
Piyush Kumar,kumarfeldspar,166,3637,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
long long rnd(long long x, long long y)
{
return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
// #define MAX 500007
// vector<int> primes;
// bool isprime[MAX];
// int spf[MAX];
// void sieve()
// {
//     f(i, MAX) spf[i] = i;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (spf[i] == i)
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//             {
//             if(spf[j]==j)	
//                 spf[j] = i;
//             }
//         }
//     }
//     f(i, MAX) isprime[i] = true;
//     isprime[1] = false;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (isprime[i])
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//                 isprime[j] = false;
//         }
//     }

//     // for (ll p = 2; p < MAX; p++)
//     // 	if (isprime[p])
//     // 		primes.push_back(p);
// }
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
#define MOD 1000000007

ll bpow(ll x, ll y)
{
    ll res = 1;
    x %= MOD;
    while (y > 0)
    {
        if (y & 1)
            res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int n = num.size();
        int k = (n + 1) / 2;
        int l = n / 2;
        ll S = 0;
        int freq[10];
        memset(freq,0,sizeof(freq));
        for (char c : num)
        {
            S += (c - '0');
            freq[c - '0']++;
        }
        if (S&1)
            return 0;
        ll target = S / 2;
        int MAX = n;
        vector<ll> fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++)
            fact[i] = fact[i - 1] * i % MOD;

        vector<ll> inv_fact(MAX + 1, 1);
        inv_fact[MAX] = bpow(fact[MAX], MOD - 2);
        for (int i = MAX - 1; i >= 0; i--)
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;

        vector<vector<ll>> old_dp(k + 1, vector<ll>(target + 1, 0));
        old_dp[0][0] = 1;
        for (int d = 0; d <= 9; d++)
        {
            vector<vector<ll>> dp_next(k + 1, vector<ll>(target + 1, 0));
            for (int c = 0; c <= k; c++)
            {
                for (int s = 0; s <= target; s++)
                {
                    if (old_dp[c][s] == 0)
                        continue;
                    for (int assign = 0; assign <= min(freq[d], k - c); assign++)
                    {
                        if (s + (ll)assign * d > target)
                            continue;
                        ll val = old_dp[c][s] * inv_fact[assign] % MOD;
                        val = val * inv_fact[freq[d] - assign] % MOD;
                        dp_next[c + assign][s + assign * d] = (dp_next[c + assign][s + assign * d] + val) % MOD;
                    }
                }
            }
            old_dp = dp_next;
        }
        ll value = old_dp[k][target];
        if (value == 0)
            return 0;
        ll ans = fact[k]*fact[l] % MOD;
        ans = ans * value % MOD;
        return (int)ans;
    }
};
",1441371265
Linh Nguyen,ll931110,168,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[55][55];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = inf;
            }
        }
        dist[0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2];
            if (-u[0] != dist[ux][uy]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i];
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = 1 + max(dist[ux][uy], moveTime[vx][vy]);

                if (dist[vx][vy] > ts) {
                    dist[vx][vy] = ts;
                    pq.push({-ts, vx, vy});
                }
            }
        }

        return dist[m - 1][n - 1];
    }
};",1441293859
Linh Nguyen,ll931110,168,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[755][755][2];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }

        dist[0][0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2], uz = u[3];
            if (-u[0] != dist[ux][uy][uz]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i], vz = uz ^ 1;
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = max(dist[ux][uy][uz], moveTime[vx][vy]);
                if (uz == 0) {
                    ts++;
                } else {
                    ts += 2;
                }

                if (dist[vx][vy][vz] > ts) {
                    dist[vx][vy][vz] = ts;
                    pq.push({-ts, vx, vy, vz});
                }
            }
        }

        return min(dist[m - 1][n - 1][0], dist[m - 1][n - 1][1]);
    }
};",1441296588
Linh Nguyen,ll931110,168,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int delta = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0) {
                delta += d;
            } else {
                delta -= d;
            }
        }
        return (delta == 0);
    }
};",1441281045
Linh Nguyen,ll931110,168,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int even = n/2, odd = n - even;
        int maxn = 42;
        int mod = 1e9 + 7;

        int binom[maxn][maxn];
        memset(binom, 0, sizeof binom);
        binom[0][0] = 1;
        for (int i = 1; i < maxn; i++) {
            for (int j = 0; j <= i; j++) {
                binom[i][j] = binom[i - 1][j];
                if (j) {
                    binom[i][j] = (binom[i][j] + binom[i - 1][j - 1]) % mod;
                }
            }
        }

        int D = 361;
        int cur[maxn][maxn][2 * D + 1], nxt[maxn][maxn][2 * D + 1];
        
        memset(cur, 0, sizeof cur);
        cur[even][odd][D] = 1;

        int counter[10];
        memset(counter, 0, sizeof counter);
        for (auto c : num) {
            counter[c - '0']++;
        }

        vector< vector<int> > curs, nexts;
        curs.push_back({even, odd, D});

        for (int d = 0; d < 10; d++) {
            memset(nxt, 0, sizeof nxt);
            nexts.clear();
            for (auto u : curs) {
                int e = u[0], o = u[1], delta = u[2];
                for (int chosen = 0; chosen <= counter[d]; chosen++) {
                    int _e = e - chosen;
                    int _o = o - (counter[d] - chosen);
                    if (_e < 0 || _o < 0) {
                        continue;
                    }
                    int _delta = delta + chosen * d - (counter[d] - chosen) * d;
                    if (_delta < 0 || _delta >= 2 * D) {
                        continue;
                    }

                    long long ways = cur[e][o][delta];
                    ways = (ways * binom[e][chosen]) % mod;
                    ways = (ways * binom[o][counter[d] - chosen]) % mod;
                    if (!nxt[_e][_o][_delta]) {
                        nexts.push_back({_e, _o, _delta});
                    }
                    nxt[_e][_o][_delta] += ways;
                    nxt[_e][_o][_delta] %= mod;
                }
            }
            for (int e = 0; e <= even; e++) {
                for (int o = 0; o <= odd; o++) {
                    for (int d = 0; d < 2 * D; d++) {
                        cur[e][o][d] = nxt[e][o][d];
                    }
                }
            }
            curs = nexts;
        }

        return cur[0][0][D];
    }
};",1441325657
LeeetCode,user3517H,170,3627,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0))]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1
    grid[0][0] = 0
    while heap:
      t, (i, j) = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j)))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += 1
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj)))
",1441299374
LeeetCode,user3517H,170,3628,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0), 1)]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1 + (i + j + 1) % 2
    grid[0][0] = 0
    while heap:
      t, (i, j), d = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j), d))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += d
      d = 3 - d
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj), d))
",1441312441
LeeetCode,user3517H,170,3636,python3,"class Solution:
  def isBalanced(self, num: str) -> bool:
    return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
",1441281990
LeeetCode,user3517H,170,3637,python3,"class Solution:
  def countBalancedPermutations(self, num: str) -> int:
    @cache
    def dfs(i, l, r, o, e):
      if i == 9:
        return 0 if o * 9 != l or o > cnt[9] else 1
      res = 0
      # j >= cnt[i] - r / i
      # cnt[i] - j <= e
      lo = max(0, cnt[i] - e, 0 if i == 0 else cnt[i] - r // i)
      hi = 1 + min(o, inf if i == 0 else l // i, cnt[i])
      for j in range(lo, hi):
        k = cnt[i] - j
        res = (res + dfs(i + 1, l - i * j, r - i * k, o - j, e - k) * comb(o, j) * comb(e, k)) % mod
      return res

    mod = 10 ** 9 + 7
    cnt = [0] * 10
    tot = 0
    n = len(num)
    for i in num:
      i = int(i)
      cnt[i] += 1
      tot += i
    if tot % 2 == 1:
      return 0
    return dfs(0, tot // 2, tot // 2, (n + 1) // 2, n // 2)",1441360652
yahoo010206,yahoo010206,171,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, (0, 0))]
        used = set()
        while heap[0][1]!=target:
            t, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+1, (x, y)))
        return heap[0][0]
                        
            
        ",1441300685
yahoo010206,yahoo010206,171,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, 0, (0, 0))]
        used = set()
        while heap[0][2]!=target:
            t, l, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+(2 if l&1 else 1), (l+1)%2, (x, y)))
        return heap[0][0]
                        
            
        ",1441304135
yahoo010206,yahoo010206,171,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2))== sum(int(num[i]) for i in range(1, len(num), 2))",1441281480
yahoo010206,yahoo010206,171,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits = [int(d) for d in num]
        total = sum(digits)
        if total%2:
            return 0

        modulo = 1000000007
        digits_cnts = Counter(digits)
        length1 = len(digits)>>1
        length2 = (len(digits)>>1)+(len(digits)&1)
        mem = {}
        def solve(d, value, l1, l2):
            key = (d, value, l1, l2)
            # print(d, value, l1, l2)
            if key in mem:
                return mem[key]
            if d==-1:
                # print(""**"")
                return 1 if value==0 and l2==0 else 0

            res = 0
            for cnt in range(0, min(digits_cnts[d], l1)+1):
                if (_value:=value-cnt*d)>=0:
                    if (_res:=solve(d-1, _value, l1-cnt, l2-(digits_cnts[d]-cnt)))!=0:
                        # print(""--"", _res, d, (l1, cnt), (l2, digits_cnts[d]-cnt))
                        res += _res*(
                            math.comb(l1, cnt)%modulo*
                            math.comb(l2, digits_cnts[d]-cnt)%modulo
                        )
                        
            mem[key] = res%modulo if res else 0
            return mem[key]
        return solve(9, total>>1, length1, length2)",1441367015
AxxxxxA,blackhatinside,174,3627,python3,"class Solution:
    def minTimeToReach(self, moTi, flag = 1, temp = 5, ext = 5, dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]):
        if flag: far = [[float('inf')] * len(moTi[0]) for _ in range(len(moTi))]
        if flag: pq = [(0, 0, 0)]
        if flag: far[0][0] = 0
        while pq:
            if flag: tm, rw, cl = heapq.heappop(pq)
            if tm <= far[rw][cl]:
                for i in range(len(dirs)):
                    if 0 <= rw + dirs[i][0] < len(moTi) and 0 <= cl + dirs[i][1] < len(moTi[0]):
                        if (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1) < far[rw + dirs[i][0]][cl + dirs[i][1]]:
                            if flag: far[rw + dirs[i][0]][cl + dirs[i][1]] = (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1)
                            if flag: heapq.heappush(pq, ((max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1), rw + dirs[i][0], cl + dirs[i][1]))
        return temp + far[ext + (-1) - ext][ext + (-1) -ext] - temp",1441334916
AxxxxxA,blackhatinside,174,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, movt, directions = [(0, 1), (1, 0), (0, -1), (-1, 0)], flag = 1, temp = 5):
        if not movt or not movt[0]:
            return 0
        if flag: n, m = len(movt), len(movt[0])
        if flag: pq = [(0, 0, 0, 0)]
        if flag: vsit = set()
        while pq:
            if flag: curt, chk, r, c = heapq.heappop(pq)
            if r == n - 1 and c == m - 1:
                return curt
            if flag: st = (r, c, chk)
            if st not in vsit:
                if flag: vsit.add(st)
                for dx, dy in directions:
                    if 0 <= (temp + r + dx - temp) < n and 0 <= (temp + c + dy - temp) < m:
                        if flag: heapq.heappush(pq, (curt + (max(0, movt[temp + r + dx - temp][temp + c + dy - temp] - curt)) + \
                            (2 if chk else 1), not chk, temp + r + dx - temp, temp + c + dy - temp))
        return -1",1441309396
AxxxxxA,blackhatinside,174,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(len(num)) if i % 2 == 0) == sum(int(num[i]) for i in range(len(num)) if i % 2 == 1)",1441289373
AxxxxxA,blackhatinside,174,3637,python3,"class Solution:
    def countBalancedPermutations(self, num, one = 1, two = 2, flag = 1, temp = 5, MOD = int(1e9 + 7)):
        if flag: tsum = sum(int(d) for d in num)
        if flag and (tsum % two == 0):
            if flag: hp = [0] * 10
            for d in num:
                if flag: hp[int(d)] += (temp + one - temp)
            if flag: half_len = (len(num) + one) // two
            if flag: fact = [temp + one - temp] * (len(num) + one)
            for i in range(temp + one - temp, len(num) + one):
                if flag: fact[i] = (i * fact[i-one]) % MOD
            if flag: ivft = [pow(f, MOD-two, MOD) for f in fact]
            if flag: dp = [[0] * ((tsum // two) + one) for _ in range(half_len + one)]
            if flag: dp[0][0] = temp + one - temp
            for d in range(10):
                if flag and hp[d]:
                    for k in range(half_len - one, -one, -one):
                        for s in range((tsum // two) - d, -one, -one):
                            if flag and dp[k][s]:
                                for cps in range(one, min(hp[d] + one, half_len - k + one)):
                                    if flag and (s + d * cps <= (tsum // two)):
                                        if flag: dp[k + cps][s + d * cps] = (dp[k + cps][s + d * cps] + dp[k][s] * ((fact[hp[d]] * ivft[cps] % MOD * ivft[hp[d] - cps] % MOD))) % MOD
            if flag: anss = dp[-1][-1]
            if dp[-1][-1]:
                if flag: anss = (anss * fact[half_len] * fact[len(num) - half_len] % MOD * prod(ivft[f] for f in hp if f > 1)) % MOD
            return anss
        else:
            return 0

",1441380184
parallel_stream,parallel_stream,175,3627,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;

    State(int row, int col, int time) {
      this.row = row;
      this.col = col;
      this.time = time;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][] arrivalTime = new int[n][m];
    Arrays.stream(arrivalTime).forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    arrivalTime[0][0] = 0;
    PriorityQueue<State> pq = new PriorityQueue<>();
    pq.offer(new State(0, 0, 0));
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + 1;
            if (newArrivalTime < arrivalTime[newRow][newCol]) {
              arrivalTime[newRow][newCol] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441295264
parallel_stream,parallel_stream,175,3628,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;
    int moveToggle;

    State(int row, int col, int time, int moveToggle) {
      this.row = row;
      this.col = col;
      this.time = time;
      this.moveToggle = moveToggle;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][][] arrivalTime = new int[n][m][2];
    Arrays.stream(arrivalTime)
        .flatMap(Arrays::stream)
        .forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    PriorityQueue<State> pq = new PriorityQueue<>();
    State start = new State(0, 0, 0, 0);
    pq.offer(start);
    arrivalTime[0][0][0] = 0;
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      int moveToggle = current.moveToggle;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col][moveToggle]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveDuration = (moveToggle == 0) ? 1 : 2;
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + moveDuration;
            int newMoveToggle = 1 - moveToggle;
            if (newArrivalTime < arrivalTime[newRow][newCol][newMoveToggle]) {
              arrivalTime[newRow][newCol][newMoveToggle] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime, newMoveToggle));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441374155
parallel_stream,parallel_stream,175,3636,java,"class Solution {
  public boolean isBalanced(String num) {
    int evenSum = 0;
    int oddSum = 0;
    for (int i = 0; i < num.length(); i++) {
      int digit = num.charAt(i) - '0';
      if (i % 2 == 0) {
        evenSum += digit;
      } else {
        oddSum += digit;
      }
    }
    return evenSum == oddSum;
  }
}",1441282265
parallel_stream,parallel_stream,175,3637,java,"class Solution {

  private static final int MOD = 1_000_000_007;

  private long[] fact;
  private long[] invFact;

  public int countBalancedPermutations(String num) {
    int n = num.length();
    int[] count = new int[10];
    long totalSum = 0;
    for (char c : num.toCharArray()) {
      count[c - '0']++;
      totalSum += (c - '0');
    }
    if (totalSum % 2 != 0) {
      return 0;
    }
    long target = totalSum / 2;
    int A = (n + 1) / 2;
    int B = n / 2;
    precomputeFactorials(n);
    long freqFactor = 1;
    for (int d = 0; d <= 9; d++) {
      freqFactor = (freqFactor * fact[count[d]]) % MOD;
    }
    long[][] dp = new long[A + 1][(int) target + 1];
    dp[0][0] = 1;
    for (int d = 0; d <= 9; d++) {
      if (count[d] == 0) {
        continue;
      }
      for (int k = A; k >= 0; k--) {
        for (int s = 0; s <= target; s++) {
          if (dp[k][s] != 0) {
            for (int t = 1; t <= Math.min(count[d], A - k); t++) {
              if (s + (long) t * d > target) {
                break;
              }
              long comb = (fact[count[d]] * invFact[t] % MOD) * invFact[count[d] - t] % MOD;
              dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb) % MOD;
            }
          }
        }
      }
    }
    long iff = powMod(freqFactor, MOD - 2);
    long ans = (fact[A] * fact[B]) % MOD;
    ans = (ans * dp[A][(int) target]) % MOD;
    ans = (ans * iff) % MOD;
    return (int) ans;
  }

  private void precomputeFactorials(int max) {
    fact = new long[max + 1];
    fact[0] = 1;
    for (int i = 1; i <= max; i++) {
      fact[i] = fact[i - 1] * i % MOD;
    }
    invFact = new long[max + 1];
    invFact[max] = powMod(fact[max], MOD - 2);
    for (int i = max - 1; i >= 0; i--) {
      invFact[i] = invFact[i + 1] * (i + 1) % MOD;
    }
  }

  private long powMod(long a, long b) {
    long res = 1;
    a %= MOD;
    while (b > 0) {
      if ((b & 1) != 0) {
        res = res * a % MOD;
      }
      a = a * a % MOD;
      b >>= 1;
    }
    return res;
  }
}",1441331229
Jie Hong Lin,tusov8899,176,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 0, 0)]
        ret = 0
        while pq:
            t, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

                
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + 1, moveTime[i][j] + 1)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, i, j))",1441301835
Jie Hong Lin,tusov8899,176,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 2, 0, 0)]
        ret = 0
        while pq:
            t, prev_cost, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

            next_cost = 2 if prev_cost == 1 else 1
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + next_cost, moveTime[i][j] + next_cost)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, next_cost, i, j))",1441307944
Jie Hong Lin,tusov8899,176,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = sum(int(num[i]) for i in range(n) if i & 1)
        odd = sum(int(num[i]) for i in range(n) if i & 1 == 0)
        return odd == even",1441283976
Jie Hong Lin,tusov8899,176,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def f(on, os, en, es):
            if on == en == 0: return int(os == es)
            i = n - (on + en)
            ret = 0
            if on:
                ret = (ret + f(on - 1, os + A[i], en, es) * on)#  % MOD
            if en:
                ret = (ret + f(on, os, en - 1, es + A[i]) * en)#   % MOD

            return ret
           
        def help(a):
            ret = 1
            while a:
                ret *= a
                a -= 1
            return ret
                
        MOD = 1_000_000_007
        A = list(map(int, list(num)))
        A.sort()
        n = len(A)
        cnt = Counter(A)
        div =1
        for v in cnt.values():
            div *= help(v)
        en = n // 2
        on = en + (n & 1)
        ret = f(on, 0, en, 0)
        # print(ret, div)
        return (ret // div)  % MOD
        ",1441361636
pulkit0707chawla,pulkit0707chawla,177,3627,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<long long>>grid(n+1,vector<long long>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<long long>,vector<vector<long long>>,greater<vector<long long>>>pq;
        pq.push({0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            long long t=v[0],x=v[1],y=v[2];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k],ny=y+dy[k];
                if(nx>=0 and ny>=0 and nx<n and ny<m){
                    long long val=1+t;
                    if(val<1+mat[nx][ny]) val=1+mat[nx][ny];
                    if(grid[nx][ny]>val){
                        grid[nx][ny]=val;
                        pq.push({grid[nx][ny],nx,ny});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441328732
pulkit0707chawla,pulkit0707chawla,177,3628,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<int>>grid(n+1,vector<int>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;
        pq.push({0,0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            int t=v[0],x=v[1],y=v[2],c=v[3];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k];
                int ny=y+dy[k];
                if(nx<n and ny<m and nx>=0 and ny>=0){
                    if(grid[nx][ny]>max(1+c+t,mat[nx][ny]+1+c)){
                        grid[nx][ny]=max(1+c+t,mat[nx][ny]+1+c);
                        pq.push({grid[nx][ny],nx,ny,1-c});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441320388
pulkit0707chawla,pulkit0707chawla,177,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd=0,even=0;
        bool c=0;
        for(auto x:num){
            if(c) odd+=x-'0';
            else even+=x-'0';
            c=!c;
        }
        return odd==even;
    }
};",1441291044
pulkit0707chawla,pulkit0707chawla,177,3637,cpp,"class Solution {
public:
    int mod=1e9+7;
    int countBalancedPermutations(string num) {
        int n=num.size();
        int e=(n+1)/2,o=n/2;
        string s=num;
        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }
        long long sum = 0;
        for(int d = 0; d < 10; d++) {
            sum += (long long)d * cnt[d];
        }
        if(sum%2) return 0;
        long long target = sum / 2;
        int mx=80;
        vector<long long> factorial(mx + 1, 1);
        for(int i = 1; i <= mx; i++) {
            factorial[i] = factorial[i -1] * i % mod;
        }
        vector<long long> inv_fact(mx + 1, 1);
        inv_fact[mx] = power(factorial[mx], mod - 2, mod);
        for(int i = mx -1; i >=0; i--){
            inv_fact[i] = inv_fact[i +1] * (i +1) % mod;
        }
        auto comb = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return factorial[n] * inv_fact[k] % mod * inv_fact[n -k] % mod;
        };
        vector<vector<long long>> dp(e +1, vector<long long>(target +1, 0));
        dp[0][0] =1;

        for(int d =0; d <10; d++) {
            if(cnt[d] ==0) continue;
            for(int t = e; t >=0; t--){
                for(long long s = target; s >=0; s--){
                    if(dp[t][s] ==0) continue;
                    for(int k =1; k <= cnt[d] && t +k <= e && s + (long long)d *k <= target; k++){
                        dp[t +k][s + (long long)d *k] = (dp[t +k][s + (long long)d *k] + dp[t][s] * comb(cnt[d], k)) % mod;
                    }
                }
            }
        }

        string l = num;
        long long valid = dp[e][target];
        long long p =1;
        for(int d =0; d <10; d++) {
            p = p * factorial[cnt[d]] % mod;
        }
        long long ans= valid;
        ans = ans * factorial[e] % mod;
        ans = ans * factorial[o] % mod;
        long long inv_product = power(p, mod -2, mod);
        ans = ans * inv_product % mod;
        return (int)ans;
    }

private:
    long long power(long long base, long long exp, long long mod){
        long long res =1;
        base %= mod;
        while(exp >0){
            if(exp &1) res = res * base % mod;
            base = base * base % mod;
            exp >>=1;
        }
        return res;
    }
};",1441355524
xs_pg,xs_pg,178,3627,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny] + 1, d + 1)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12",1441291533
xs_pg,xs_pg,178,3628,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny], d) + (1 if (nx+ny) % 2 == 1 else 2)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12
        ",1441294433
xs_pg,xs_pg,178,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = 0
        b = 0
        for i in range(0, n, 2):
            a += int(num[i])
            if i + 1 < n:
                b += int(num[i+1])
        return a == b
        ",1441281376
xs_pg,xs_pg,178,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num)
        t = n // 2
        
        d = defaultdict(int)
        S = 0
        for x in num:
            d[int(x)] += 1
            S += int(x)
        if S % 2 == 1:
            return 0
        
        f = [1]
        for i in range(n):
            f.append(f[-1] * (i+1) % mod)
        nf = [pow(x, mod-2, mod) for x in f]
        # print(f, nf)
        
        ks = list(d.keys())
        nk = len(ks)
        # print(ks)
        
        @cache
        def dp(index, cnt, v):
            if index >= nk:
                if cnt == t and v == S//2:
                    return f[t] * f[n-t] % mod
                return 0
            if cnt > t or v > S//2:
                return 0
            ans = 0
            c = d[ks[index]]
            for i in range(c+1):
                ans += nf[i] * nf[c-i] * dp(index+1, cnt+i, v+i*ks[index]) % mod
            return ans % mod
        
        return dp(0, 0, 0)
            ",1441380685
lawrencewxy,lawrencewxy,179,3627,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //newd = Math.abs(A[x][y] - A[x0][y0]);  res, res = Math.max(a[2], res);res
               //  newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));  a[2] PQ
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                newd += 1;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y]});
                }

            }


        }

        return res;
    }
	   



}",1441305509
lawrencewxy,lawrencewxy,179,3628,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            int step = a[3];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //newd = Math.abs(A[x][y] - A[x0][y0]);  res, res = Math.max(a[2], res);res
               //  newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));  a[2] PQ
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                if(step%2 == 0)newd += 1;
                if(step%2 == 1)newd += 2;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y], step + 1});
                }

            }


        }

        return res;
    }
}",1441310354
lawrencewxy,lawrencewxy,179,3636,java,"class Solution {
    public boolean isBalanced(String A) {
        
        int a = 0;
        int b = 0;
        int n = A.length();
        int j = 0;
        for(int i = 0; i < n; i++){
            int x = A.charAt(i)- '0';
            if(i %2 == 0){
                a +=x;
            }
            else{
                b += x;
            }
            
            
            
        }
        
        return a == b;
        
    }
}",1441284898
lawrencewxy,lawrencewxy,179,3637,java,"
class Solution {
 

    int mod = (int)(1e9 + 7);
    public int countBalancedPermutations(String num) {
 
        int n = num.length();
        int[] digitCnt = new int[10];
        int sum = 0;
        for (char ch : num.toCharArray()) {
            int digit = ch - '0';
            digitCnt[digit]++;
            sum += digit;
        }

        if (sum % 2 != 0) {
            return 0;
        }

        int target = sum / 2;
        int evenPos = (n + 1) / 2;
        int oddPos = n / 2;

        long[][][] state = new long[11][target + 1][evenPos + 1];
        state[0][0][0] = 1;

        long[] f = new long[n + 1];
        long[] invF = new long[n + 1];
        f[0] = invF[0] = 1;
        for (int i = 1; i <= n; i++) {
            f[i] = f[i - 1] * i % mod;
            invF[i] = modInverse(f[i]);
        }

        long[][] combs = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            combs[i][0] = combs[i][i] = 1;
            for (int j = 1; j < i; j++) {
                combs[i][j] = (combs[i - 1][j - 1] + combs[i - 1][j]) % mod;
            }
        }

        
        //  
        for (int d = 0; d <= 9; d++) {
            int currentCount = digitCnt[d];
            for (int s = 0; s <= target; s++) {
                for (int c = 0; c <= evenPos; c++) {
                    if (state[d][s][c] == 0) continue;

                    for (int k = 0; k <= currentCount && c + k <= evenPos && s + k * d <= target; k++) {
                        state[d + 1][s + k * d][c + k] = (state[d + 1][s + k * d][c + k] + state[d][s][c] * combs[currentCount][k]) % mod;
                    }
                }
            }
        }

        long finalCount = state[10][target][evenPos];
        if (finalCount == 0) return 0;

        long evenWays = f[evenPos];
        long oddWays = f[oddPos];

        long denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * f[digitCnt[d]] % mod;
        }
        //get the final result
        long res = finalCount * evenWays % mod * oddWays % mod * modInverse(denom) % mod;
        return (int)(res);
    }

    long modInverse(long a) {
        return powMod(a, mod - 2);
    }

    // long powMod(long a, long b, int mod) {
     long powMod(long a, long b){
         long res = 1;
         
         a %= mod; // a  2^31 1969 Minimum Non-Zero Product of the Array Elements    
          
         while(b > 0){
             if(b%2 != 0) { //  if((b&1) == 1){
                 res = (res*a)%mod;
             }
            
             b = b/2;  //  b = b>>1;
             a = (a *a)%mod;
         }
         //System.out.println(""res = "" +res);
         return res;
     }

}",1441374842
Ritik Rathor,ritik_369,180,3627,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441356192
Ritik Rathor,ritik_369,180,3628,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 + (b) ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1+b) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441364305
Ritik Rathor,ritik_369,180,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    array < int , 2 > ar ; 
    ar[0] = ar[1] = 0 ; 
    int i = 0 ; 
    for(auto a : num)
       ar[(i ++ ) & 1] += a - '0' ;       
    return ar[0] == ar[1] ; 
    }
};",1441356045
Ritik Rathor,ritik_369,180,3637,cpp,"const int mod = 1e9 + 7;
string s ; 
int sm , to , n ; 
vector < int > vec , fac , ifac ; 
int dp[10][400][45] ; 
int f(int idx , int cur , int ct)
{
   if(cur > sm)return 0 ; 
   if(ct > to)return 0 ; 
   if(idx == 10)
   {
      return 1ll * (1ll * (cur == sm and ct == to) * 1ll * fac[ct] * fac[n - ct]) % mod ; 
   }
   int  & res = dp[idx][cur][ct] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   for(int i = 0 ; i <= vec[idx] ; i += 1)
   {
      int h = 0 ; 
      h = 1ll * (1ll * h + 1ll * f(idx + 1 , cur + (i * idx) , ct + i)) % mod ; 
      h = 1ll * (1ll * h * ifac[i]) % mod ; 
      h = 1ll * (1ll * h * ifac[vec[idx] - i]) % mod ; 
      res = 1ll * (1ll * res + 1ll * h) % mod ; 
   }
   return res ; 
}
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}


class Solution {
public:
    int countBalancedPermutations(string num)
    {
      if(fac.size() == 0)
      {
         fac = vector < int > (100 , 0) ; 
         ifac = vector < int > (100 , 0) ; 
         fac[0] = 1 ; 
         ifac[0] = binpow(1 , mod-2 , mod) ; 
         for(int i = 1 ; i <= 90 ; i += 1)
         {
            fac[i] = (1ll * fac[i-1] * i) % mod ; 
            ifac[i] = binpow(fac[i] , mod-2 , mod) ; 
         }
      }
      memset(dp , -1 , sizeof(dp)) ; 

      n = num.size() ; 
        vec = vector < int > (10 , 0) ; 
        sm = 0 ; 
        for(auto a : num)
        {
         vec[a - '0'] ++  ; 
         sm += a - '0' ; 
        }
        if(sm & 1)return 0 ; 
        sm /= 2 ;
        to = ((num.size() + 1) / 2) ; 
        return f(0 , 0 , 0) ; 
    }
};",1441369052
CLOWNTK,CLOWNTK,181,3627,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441355375
CLOWNTK,CLOWNTK,181,3628,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+ turn+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441353979
CLOWNTK,CLOWNTK,181,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int tot=0;
        for(int i=0;i<num.size();i++){
            if(i%2){
                tot+= (num[i]-'0');
            }
            else{
                tot-= (num[i]-'0');
            }
        }
        if(tot==0) return 1;
        return 0;
    }
};",1441356632
CLOWNTK,CLOWNTK,181,3637,cpp,"typedef long long ll;
int M= 1e9+7;
ll inv[85], fact[85];
ll dp[85][11][850];

long long power(long long a,long long b){
    if(b<0){
        return 0;
    }
    if(b==0){
        return 1;
    }
    if(abs(a)>=M){
        a= a%M;
    }
    if(a<0){
        a+=M;
    }
    long long  z = power((a*a)%M,b>>1);
    if(b&1){
        z=(z*a)%M;
    }
    return z;
}

class Solution {
public:
    ll solve(int i, int d, int sum, vector<int> &freq, int n, int tot){
        if(sum> (tot/2)){
            return 0;
        }
        if(d> 9){
            if(i!=(n+1)/2) return 0;
            if(sum!= (tot/2)) return 0;
            return 1;
        }
        if(dp[i][d][sum]!=-1){
            return dp[i][d][sum];
        }
        
        ll ans=0;

        for(int f=0;f<=freq[d] && (i+f)<=(n+1)/2;f++){
            ll now= (solve(i+f,d+1,sum+f*d,freq,n,tot)*inv[f])%M;
            now= (now*inv[freq[d]-f])%M;
            ans= (ans+now)%M;
            if(sum+ f*d> (tot/2)) break;
        }

        return dp[i][d][sum]= ans;
        
    }
    int countBalancedPermutations(string num) {
        fact[0]= inv[0]=1;

        for(int i=1;i<=84;i++){
            fact[i]= (i*fact[i-1])%M;
            inv[i]= power(fact[i], M-2);
        }

        int n= num.size();
        vector<int> freq(10);
        int tot=0;
        for(auto x: num){
            freq[x-'0']++;
            tot+= (x-'0');
        }
 
        if(tot%2) return 0;
        for(int i=0;i<=n;i++){
            for(int j=0;j<=9;j++){
                for(int sum=0;sum<=tot;sum++){
                    dp[i][j][sum]=-1;
                }
            }
        }
        
        ll now= (fact[n/2]*fact[(n+1)/2])%M;
        return (solve(0,0,0,freq,n,tot)*now)%M;
    }
};",1441340805
a_k,a0518,182,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+1
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc))
        
                
            ",1441287203
a_k,a0518,182,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c, x = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+(1 if x == 0 else 2)
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc,x^1))
        
                
            ",1441289199
a_k,a0518,182,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = b = 0
        for i in range(len(num)):
            if i%2:
                a+=int(num[i])
            else: b+=int(num[i])
        return a==b",1441280894
a_k,a0518,182,3637,python3,"from collections import Counter
from functools import cache

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9+7
        n = len(num)
        mp = Counter(num)

        tot = sum(int(d) for d in num)
        if tot % 2 != 0:  
            return 0

        fac = [1] * (n + 1)
        for i in range(1, n + 1):
            fac[i] = (fac[i - 1] * i) % mod

        def mod_inverse(v, p):
            return pow(v, p - 2, p)

        t = tot // 2

        dp = [[[0] * (n // 2 + 1) for _ in range(t + 1)] for _ in range(n + 1)]
        dp[0][0][0] = 1 

        for i in range(1, n + 1):
            digit = int(num[i - 1])
            for cur in range(t + 1):
                for cnt in range(n // 2 + 1):
                    if dp[i - 1][cur][cnt] > 0:
                        if cur + digit <= t and cnt + 1 <= n // 2:
                            dp[i][cur + digit][cnt + 1] = (dp[i][cur + digit][cnt + 1] + dp[i - 1][cur][cnt]) % mod
                        dp[i][cur][cnt] = (dp[i][cur][cnt] + dp[i - 1][cur][cnt]) % mod

        a = dp[n][t][n // 2] * fac[n // 2] % mod 
        b = fac[n - n // 2] 
        res = (a * b) % mod

        for v in mp.values():
            res = (res * mod_inverse(fac[v], mod)) % mod

        return res
",1441350922
Nat,4nIlUcEGTM,185,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (int[] dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
}",1441359050
Nat,4nIlUcEGTM,185,3628,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        d[0][0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) {
            vector<int> current = pq.top();
            pq.pop();

            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (auto dir : directions) {
                int ni = i + dir.first;
                int nj = j + dir.second;

                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};

",1441361470
Nat,4nIlUcEGTM,185,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        # Iterate through each digit and accumulate sums based on index parity
        for i, digit in enumerate(num):
            if i % 2 == 0:  # even index
                even_sum += int(digit)
            else:           # odd index
                odd_sum += int(digit)
        
        # Check if the sums are equal
        return even_sum == odd_sum
",1441313791
Nat,4nIlUcEGTM,185,3637,rust,"impl Solution {
    const MOD: i64 = 1_000_000_007;

    pub fn count_balanced_permutations(num: String) -> i32 {
        let length = num.len();
        let total_sum: i32 = num.chars().map(|c| c.to_digit(10).unwrap() as i32).sum();

        // Count occurrences of each digit
        let mut counts = vec![0; 10];
        for digit in num.chars() {
            counts[digit.to_digit(10).unwrap() as usize] += 1;
        }

        // If the total sum is odd, it's impossible to divide it into two equal parts
        if total_sum % 2 != 0 {
            return 0;
        }

        let half_sum = total_sum / 2;
        let m = (length + 1) / 2;

        // Factorial and inverse factorial arrays
        let mut factorial = vec![1i64; length + 1];
        for i in 1..=length {
            factorial[i] = factorial[i - 1] * i as i64 % Self::MOD;
        }

        let mut inv_factorial = vec![1i64; length + 1];
        inv_factorial[length] = Self::mod_inverse(factorial[length], Self::MOD);
        for i in (0..length).rev() {
            inv_factorial[i] = inv_factorial[i + 1] * (i as i64 + 1) % Self::MOD;
        }

        // DP table for counting balanced subsets
        let mut dp = vec![vec![0i64; (half_sum + 1) as usize]; m + 1];
        dp[0][0] = 1;

        for d in 0..10 {
            if counts[d] == 0 {
                continue;
            }

            for k in (0..=m).rev() {
                for s in (0..=half_sum as usize).rev() {
                    if dp[k][s] == 0 {
                        continue;
                    }

                    for t in 1..=counts[d] {
                        if k + t > m || s + (d * t) > half_sum as usize {
                            break;
                        }
                        let new_k = k + t;
                        let new_s = s + (d * t);
                        dp[new_k][new_s] = (dp[new_k][new_s] + dp[k][s] * Self::comb(counts[d], t, &factorial, &inv_factorial, Self::MOD)) % Self::MOD;
                    }
                }
            }
        }

        let w = dp[m][half_sum as usize];
        let mut result = factorial[m] * factorial[length - m] % Self::MOD;

        for d in 0..10 {
            result = result * inv_factorial[counts[d]] % Self::MOD;
        }

        result = result * w % Self::MOD;
        result as i32
    }

    fn mod_inverse(a: i64, m: i64) -> i64 {
        let mut result = 1;
        let mut base = a;
        let mut p = m - 2;

        while p > 0 {
            if p & 1 == 1 {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        result
    }

    fn comb(n: usize, k: usize, factorial: &[i64], inv_factorial: &[i64], m: i64) -> i64 {
        if k > n {
            return 0;
        }
        factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m
    }
}
",1441382752
EthanZyh,EthanZyh,186,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[int(1e10) for j in range(m)] for i in range(n)]
        f[0][0]=0
        q = [(0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y = heapq.heappop(q)
            d[(x,y)] = True
            if x==n-1 and y==m-1:
                return f[x][y]
            if x<n-1:
                t = max(f[x][y], moveTime[x+1][y])+1
                if t<f[x+1][y] and (x+1,y) not in d:
                    f[x+1][y]=t
                    heapq.heappush(q, (t,x+1,y))
            
            if x>=1:
                t = max(f[x][y], moveTime[x-1][y])+1
                if t<f[x-1][y] and (x-1,y) not in d:
                    f[x-1][y]=t
                    heapq.heappush(q, (t,x-1,y))
            
            if y<m-1:
                t = max(f[x][y], moveTime[x][y+1])+1
                if t<f[x][y+1] and (x,y+1) not in d:
                    f[x][y+1]=t
                    heapq.heappush(q, (t,x,y+1))
            
            if y>=1:
                t = max(f[x][y], moveTime[x][y-1])+1
                if t<f[x][y-1] and (x,y-1) not in d:
                    f[x][y-1]=t
                    heapq.heappush(q, (t,x,y-1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441307882
EthanZyh,EthanZyh,186,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[[int(1e10), int(1e10)] for j in range(m)] for i in range(n)]
        f[0][0][0]=0
        q = [(0,0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y,z = heapq.heappop(q)
            d[(x,y,z)] = True
            if x==n-1 and y==m-1:
                return f[x][y][z]
            if x<n-1:
                t = max(f[x][y][z], moveTime[x+1][y])+(z+1)
                if t<f[x+1][y][z^1] and (x+1,y,z^1) not in d:
                    f[x+1][y][z^1]=t
                    heapq.heappush(q, (t,x+1,y,z^1))
            
            if x>=1:
                t = max(f[x][y][z], moveTime[x-1][y])+(z+1)
                if t<f[x-1][y][z^1] and (x-1,y,z^1) not in d:
                    f[x-1][y][z^1]=t
                    heapq.heappush(q, (t,x-1,y,z^1))
            
            if y<m-1:
                t = max(f[x][y][z], moveTime[x][y+1])+(z+1)
                if t<f[x][y+1][z^1] and (x,y+1,z^1) not in d:
                    f[x][y+1][z^1]=t
                    heapq.heappush(q, (t,x,y+1,z^1))
            
            if y>=1:
                t = max(f[x][y][z], moveTime[x][y-1])+(z+1)
                if t<f[x][y-1][z^1] and (x,y-1,z^1) not in d:
                    f[x][y-1][z^1]=t
                    heapq.heappush(q, (t,x,y-1,z^1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441315726
EthanZyh,EthanZyh,186,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s = sum([int(num[i]) for i in range(len(num)) if i %2==0])
        t = sum([int(num[i]) for i in range(len(num)) if i %2==1])
        return s==t
        ",1441284111
EthanZyh,EthanZyh,186,3637,python,"class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        P = int(1e9+7)
        def Pow(a, b):
            ans = 1
            while b:
                if b%2==1:
                    ans = ans*a%P
                a = a*a%P
                b //= 2
            return ans
        ton = [0 for i in range(10)]
        n = len(num)
        num_list = [int(a) for a in num]
        S = sum(num_list)
        if S%2==1:
            return 0
        target = S//2
        for a in num:
            ton[int(a)] += 1
        N = 100
        fac = [0 for i in range(N)]
        ifac = [0 for i in range(N)]
        fac[0] = 1
        for i in range(1,N):
            fac[i]=fac[i-1]*i%P
        ifac[N-1] = Pow(fac[N-1], P-2)
        for i in range(N-2, -1, -1):
            ifac[i] = ifac[i+1] * (i+1) %P
        def C(n ,m):
            ans = (fac[n]*ifac[m]%P)*ifac[n-m]%P
            return ans
        f = [[[0 for k in range(target+1)] for j in range(n//2+1)] for i in range(11)]
        f[0][0][0] = 1
        used_pos = 0
        for i in range(10):
            for j in range(n//2+1):
                for k in range(target+1):
                    now = f[i][j][k]
                    if now==0:
                        continue
                    for l in range(ton[i]+1):
                        newK = k + l * i
                        newJ = j + l
                        if newK>target or newJ>n//2:
                            continue
                        f[i+1][newJ][newK] = (f[i+1][newJ][newK]+(now*C(n//2-j,l)%P)* \
                                              C(n-n//2-(used_pos-j),ton[i]-l))%P
            used_pos += ton[i]
        return f[10][n//2][target]
        ",1441358062
Vladislav,timetoai,189,3627,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0)]
        while h:
            t, i, j = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1
                    if (ni, nj) not in mem or mem[ni, nj] > nt:
                        mem[ni, nj] = nt
                        heappush(h, (nt, ni, nj))

        ",1441298463
Vladislav,timetoai,189,3628,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0, 0)]
        while h:
            t, i, j, add = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j, add] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1 + add
                    nadd = add ^ 1
                    if (ni, nj, nadd) not in mem or mem[ni, nj, nadd] > nt:
                        mem[ni, nj, nadd] = nt
                        heappush(h, (nt, ni, nj, nadd))

        ",1441302001
Vladislav,timetoai,189,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(1, len(num), 2)) == sum(int(num[i]) for i in range(0, len(num), 2))",1441280875
Vladislav,timetoai,189,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        cnt = [0] * 10
        for n in num:
            cnt[int(n)] += 1
        base = factorial(len(num) // 2) * factorial(len(num) - len(num) // 2)

        @cache
        def go(i, left, bal):
            if left == 0:
                if bal - sum(j * cnt[j] for j in range(i, 10)) == 0:
                    ret = base
                    for j in range(i, 10):
                        ret //= factorial(cnt[j])
                    return ret
                else:
                    return 0
            if i == 10:
                return 0
            if cnt[i] == 0:
                return go(i + 1, left, bal)
            res = 0
            for cur in range(0, min(left, cnt[i]) + 1):
                res += go(
                    i + 1, 
                    left - cur, 
                    bal + (2 * cur - cnt[i]) * i
                ) // factorial(cnt[i] - cur) // factorial(cur)
            return res

        return go(0, len(num) // 2, 0) % mod if sum(digit * cnt[digit] for digit in range(10)) % 2 == 0 else 0
        ",1441341525
Superultra,Superultra,191,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + 1;
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441360320
Superultra,Superultra,191,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + (p + 1);
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441359927
Superultra,Superultra,191,3636,cpp,"class Solution {
public:
    bool isBalanced(string S) {
        int e = 0, o = 0;
        for (int i = 0; i < S.size(); i++){
            if (i % 2 == 0)
                e += S[i] - '0';
            else
                o += S[i] - '0';
        }
        return e == o;
    }
};",1441361327
Superultra,Superultra,191,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int md = 1e9 + 7;

struct mint{
    int v;
    mint() : v(0) {}
    mint(ll v_) : v(int(v_ % md)){ if (v < 0) v += md; }
    explicit operator int() const{ return v; }
    friend std::ostream& operator << (std::ostream& out, const mint& n){ return out << int(n); }
    friend std::istream& operator >> (std::istream& in, mint& n){ ll v_; in >> v_; n = mint(v_); return in; }
 
    friend bool operator == (const mint& a, const mint& b){ return a.v == b.v; }
    friend bool operator != (const mint& a, const mint& b){ return a.v != b.v; }
    friend bool operator < (const mint& a, const mint& b){ return a.v < b.v; }
    friend bool operator <= (const mint& a, const mint& b){ return a.v <= b.v; }
    friend bool operator > (const mint& a, const mint& b){ return a.v > b.v; }
    friend bool operator >= (const mint& a, const mint& b){ return a.v >= b.v; }

    mint& operator += (const mint& o){ ((v += o.v) >= md) ? v -= md : 0; return *this; }
    mint& operator -= (const mint& o){ ((v -= o.v) < 0) ? v += md : 0; return *this; }
    mint& operator *= (const mint& o){ v = int((ll)v * o.v % md); return *this; }
    mint& operator /= (const mint& o){ return (*this) *= inv(o); }

    mint operator - () const{ return mint(-v); }
    friend mint operator + (mint a, const mint& b){ return a += b; }
    friend mint operator - (mint a, const mint& b){ return a -= b; }
    friend mint operator * (mint a, const mint& b){ return a *= b; }
    friend mint operator / (mint a, const mint& b){ return a /= b; }

    friend mint pow(mint a, ll p){ return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);	}
    friend mint inv(const mint& a){ return pow(a, md - 2); }
};

class Solution {
public:
    int countBalancedPermutations(string A) {
        vector<int> cnt(10, 0);
        int sum = 0;

        for (char c : A){
            cnt[c - '0']++;
            sum += (c - '0');
        }

        if (sum % 2){
            return 0;
        }

        int n = A.size();
        int targSz = n / 2;
        int targSum = sum / 2;

        mint dp[10][targSz + 5][targSum + 5];
        for (int i = 0; i < 10; i++)
            for (int j = 0; j <= targSz; j++)
                for (int k = 0; k <= targSum; k++)
                    dp[i][j][k] = 0;

        mint F[n + 5];
        F[0] = 1;

        for (int i = 1; i <= n; i++)
            F[i] = F[i - 1] * i;
        
        mint inv[n + 1][n + 1];
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= n; j++)
                inv[i][j] = 1 / (F[i] * F[j]);

        for (int i = 0; i < 10; i++){
            int mxSz = 0, mxSum = 0;
            for (int j = 0; j <= i; j++){
                mxSz += cnt[j];
                mxSum += cnt[j] * j;
            }
            for (int sz = 0; sz <= min(targSz, mxSz); sz++){
                for (int sum = 0; sum <= min(targSum, mxSum); sum++){
                    auto &cur = dp[i][sz][sum];
                    // Base
                    if (!i){
                        if (sum == 0 and sz <= cnt[i]){
                            cur = F[targSz] * F[n - targSz] / (F[sz] * F[(cnt[i] - sz)]);
                        }
                        // cout << i << "" "" << sz << "" "" << sum << "": "" << cur << endl;
                        // cout << F[targSz] << "" "" << 
                        continue;
                    }
                    for (int take = 0; take <= min(sz, cnt[i]) and sum - take * i >= 0; take++){
                        auto &temp = dp[i - 1][sz - take][sum - take * i];
                        cur += temp * inv[take][cnt[i] - take];
                    }
                }
            }
        }
        return dp[9][targSz][targSum].v;
    }
};
",1441341620
Reversal,ReversalGM,192,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0)]
        visited = set()
        while min_heap:
            cur_time, i, j = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j) in visited:
                continue
            visited.add((i, j))
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:
                    heapq.heappush(min_heap, (max(cur_time + 1, moveTime[new_i][new_j] + 1), new_i, new_j))
        return -1
                
                    
                    ",1441301107
Reversal,ReversalGM,192,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0, 1)]
        visited = set()
        while min_heap:
            cur_time, i, j, next_move_cost = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j, next_move_cost) in visited:
                continue
            visited.add((i, j, next_move_cost))
            new_next_move_cost = 2 if next_move_cost == 1 else 1
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n:
                    if new_next_move_cost == 2:
                        if (new_i, new_j, 1) not in visited and (new_i, new_j, 2) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
                    else:
                        if (new_i, new_j, 1) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
        return -1
                
                    
                    ",1441313629
Reversal,ReversalGM,192,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for idx, val in enumerate(num):
            if idx % 2 == 0:
                even_sum += int(val)
            else:
                odd_sum += int(val)
        return even_sum == odd_sum",1441282216
Reversal,ReversalGM,192,3637,python3,"class Solution:
    # even - odd
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10 ** 9 + 7
        required_evens = math.ceil(n / 2)
        required_odds = n - required_evens
        prev_ways = collections.Counter([(0, 0)])

        global_counter = collections.Counter([int(char) for char in num])

        picked_items = 0
        for val, val_count in global_counter.items():
            new_ways = collections.Counter()
            for (perm_sum, perm_even_count), perm_ways in prev_ways.items():
                for chosen_evens in range(val_count + 1):
                    chosen_odds = val_count - chosen_evens
                    new_perm_sum = perm_sum + ((chosen_evens - chosen_odds) * val)

                    even_spots_remaining = required_evens - perm_even_count
                    odd_spots_remaining = required_odds - (picked_items - perm_even_count)
                    
                    even_ways = math.comb(even_spots_remaining, chosen_evens) if even_spots_remaining > 0 else 1
                    odd_ways = math.comb(odd_spots_remaining, chosen_odds) if odd_spots_remaining > 0 else 1
                    if even_spots_remaining < chosen_evens:
                        break
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] += even_ways * odd_ways * perm_ways
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] = new_ways[(new_perm_sum, perm_even_count + chosen_evens)] % MOD
                    
            picked_items += val_count
            prev_ways = new_ways
        return prev_ways[(0, required_evens)]
                
            ",1441367686
robezh765,robezh765,193,3627,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 1);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};",1441297593
robezh765,robezh765,193,3628,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 2);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};
",1441296978
robezh765,robezh765,193,3636,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;

class Solution {
public:
    bool isBalanced(string num) {
        int s = 1;
        int sum = 0;
        for (char c : num) {
            sum += s * int(c - '0');
            s *= -1;
        }
        return sum == 0;
    }
};
",1441281118
robezh765,robezh765,193,3637,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;


const int MOD = (int)1e9 + 7;

struct mi {
    typedef decay<decltype(MOD)>::type T;
    /// don't silently convert to T
    T v; explicit operator T() const { return v; }
    mi() { v = 0; }
    mi(ll _v) {
        v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;
        if (v < 0) v += MOD;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
//    friend void re(mi& a) { ll x; re(x); a = mi(x); }
//    friend str ts(mi a) { return ts(a.v); }

    mi& operator+=(const mi& m) {
        if ((v += m.v) >= MOD) v -= MOD;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += MOD;
        return *this; }
    mi& operator*=(const mi& m) {
        v = (ll)v*m.v%MOD; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, ll p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,MOD-2); }

    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
};


mt19937 rng(2333);
const int S = 400 * 2 + 1, M = 400;
mi rdp[2][41][S];

class Solution {
public:
    int countBalancedPermutations(string num) {
        int c0 = (sz(num) + 1) / 2, c1 = sz(num) - c0;
//        cout << sz(num) << endl;

        int nw = 1, la = 0;
        memset(rdp, 0, sizeof rdp);
//        vector<vector<vector<mi>>> dp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
        rdp[nw][0][M] = 1;
        vi cnt(10);

        int sum = 0;
        shuffle(all(num), rng);
        for (char c : num) {
            swap(nw, la);
            int x = c - '0';
            cnt[x]++;
            auto &ndp = rdp[nw];
            auto &dp = rdp[la];
            memset(rdp[nw], 0, sizeof rdp[nw]);
//            vector<vector<vector<mi>>> ndp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
            rep(i, 0, c0 + 1) {
                rep(s, 0, S) {
                    if (s + x < S && i + 1 < c0 + 1) ndp[i + 1][s + x] += (i + 1) * dp[i][s];
                    if (s - x >= 0) ndp[i][s - x] += (sum - i + 1) * dp[i][s];
                }
            }
            sum += 1;

//            dp = ndp;
        }
        mi res = rdp[nw][c0][M];
//        return int(res);
        rep(i, 0, 10) {
            rep(j, 1, cnt[i] + 1) res /= j;
        }
        return int(res);
    }
};

",1441329938
Anshuman Tripathi,anshumantripathi878,194,3627,cpp,"class Solution {
public:
    int solve(vector<vector<int>>& moveTime) {
    int xxxx = moveTime.size(), yyyy = moveTime[0].size();
    vector<vector<int>> zzzz(xxxx, vector<int>(yyyy, INT_MAX));
    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

    zzzz[0][0] = 0;
    pq.push({0, 0, 0}); // (time, row, col)
    
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    while (!pq.empty()) {
        auto [timeNow, xx, yy] = pq.top();
        pq.pop();

        if (xx == xxxx - 1 && yy == yyyy - 1) return timeNow;
        
        for (auto& dir : directions) {
            int nx = xx + dir[0], ny = yy + dir[1];
            if (nx >= 0 && ny >= 0 && nx < xxxx && ny < yyyy) {
                int timeNext = max(timeNow + 1, moveTime[nx][ny] + 1);
                if (timeNext < zzzz[nx][ny]) {
                    zzzz[nx][ny] = timeNext;
                    pq.push({timeNext, nx, ny});
                }
            }
        }
    }
    
    return zzzz[xxxx - 1][yyyy - 1];
}

int minTimeToReach(vector<vector<int>>& moveTime) {
    return solve(moveTime);
}
};",1441308314
Anshuman Tripathi,anshumantripathi878,194,3628,python3,"import heapq
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        xxxx = len(moveTime)
        yyy = len(moveTime[0])
        
        zzzz = [[[float('inf')] * 2 for _ in range(yyy)] for _ in range(xxxx)]
        zzzz[0][0][0] = 0
        
        pq = []
        heapq.heappush(pq, (0, (0, 0, 0)))
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            
            if t > zzzz[i][j][p]:
                continue
            
            for di, dj in directions:
                ni = i + di
                nj = j + dj
                
                if 0 <= ni < xxxx and 0 <= nj < yyy:
                    nt = max(t, moveTime[ni][nj]) + (2 if p else 1)
                    
                    if nt < zzzz[ni][nj][1 - p]:
                        zzzz[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))
        
        return min(zzzz[xxxx - 1][yyy - 1][0], zzzz[xxxx - 1][yyy - 1][1])
",1441336487
Anshuman Tripathi,anshumantripathi878,194,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
         int evenSum = 0, oddSum = 0;
    for (int i = 0; i < num.size(); ++i) {
        if (i % 2 == 0)
            evenSum += num[i] - '0';
        else
            oddSum += num[i] - '0';
    }
    return evenSum == oddSum;
    }
};",1441287216
Anshuman Tripathi,anshumantripathi878,194,3637,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;
    typedef long long ll;

    // Function to compute power modulo
    long long zzzzz(long long aaaaa, long long bbbbb, long long ccccc) {
        long long ddddd = 1;
        while (bbbbb > 0) {
            if (bbbbb % 2 == 1) {
                ddddd = (ddddd * aaaaa) % ccccc;
            }
            aaaaa = (aaaaa * aaaaa) % ccccc;
            bbbbb /= 2;
        }
        return ddddd;
    }

    void eeeee(vector<long long>& fffff, vector<long long>& ggggg, int hhhhh) {
        fffff.resize(hhhhh + 1, 1);
        for (int iiiii = 1; iiiii <= hhhhh; ++iiiii) {  // Changed `iiii` to `iiiii`
            fffff[iiiii] = fffff[iiiii - 1] * iiiii % MOD; // Use `iiiii` here
        }
        ggggg.resize(hhhhh + 1, 1);
        ggggg[hhhhh] = zzzzz(fffff[hhhhh], MOD - 2, MOD);
        for (int jjjjj = hhhhh - 1; jjjjj >= 0; --jjjjj) {
            ggggg[jjjjj] = ggggg[jjjjj + 1] * (jjjjj + 1) % MOD;
        }
    }

    // Function to compute the number of balanced permutations
    int countBalancedPermutations(string num) {
        int kkkkk = num.length();
        int lllll[10] = {0};
        ll mmmmm = 0;

        for (char nnnnn : num) {
            lllll[nnnnn - '0']++;
            mmmmm += (nnnnn - '0');
        }

        if (mmmmm % 2 != 0) {
            return 0;
        }

        ll ooooo = mmmmm / 2;
        int ppppp = (kkkkk + 1) / 2;

        vector<ll> qqqqq, rrrrr;
        eeeee(qqqqq, rrrrr, kkkkk);

        vector<vector<ll>> sssss(ppppp + 1, vector<ll>(ooooo + 1, 0));
        sssss[0][0] = 1;

        for (int ttttt = 0; ttttt < 10; ++ttttt) {
            int uuuuu = lllll[ttttt];
            vector<vector<ll>> vvvvv(ppppp + 1, vector<ll>(ooooo + 1, 0));
            for (int wwwww = 0; wwwww <= ppppp; ++wwwww) {
                for (ll xxxxx = 0; xxxxx <= ooooo; ++xxxxx) {
                    if (sssss[wwwww][xxxxx] == 0) continue;
                    int yyyyy = min(uuuuu, ppppp - wwwww);
                    for (int zzzzz = 0; zzzzz <= yyyyy; ++zzzzz) {
                        ll aaaaa = wwwww + zzzzz;
                        ll bbbbb = xxxxx + (ll)ttttt * zzzzz;
                        if (bbbbb > ooooo) continue;
                        vvvvv[aaaaa][bbbbb] = (vvvvv[aaaaa][bbbbb] + sssss[wwwww][xxxxx] * rrrrr[zzzzz] % MOD * rrrrr[uuuuu - zzzzz] % MOD) % MOD;
                    }
                }
            }
            sssss = vvvvv;
        }

        ll ccccc = sssss[ppppp][ooooo];

        ll ddddd = qqqqq[ppppp] * qqqqq[kkkkk - ppppp] % MOD;
        ddddd = ddddd * ccccc % MOD;

        return (int)ddddd;
    }
};
",1441375431
xlx2,xlx2,195,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        h = [(0, 0, 0)]
        f[0][0] = 0
        while h:
            t, i, j = heapq.heappop(h)
            if f[i][j] != t:
                continue
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + 1
                    if x < f[a][b]:
                        f[a][b] = x
                        heapq.heappush(h, (x, a, b))
        return f[-1][-1]",1441314344
xlx2,xlx2,195,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        vis = [[[0,0] for _ in range(n)] for _ in range(m)]
        h = [(0, 0, 0, 0)]
        f[0][0] = 0
        # vis[0][0][0] = 1
        while h:
            t, i, j, k = heapq.heappop(h)
            if vis[i][j][k]:
                continue
            vis[i][j][k] = 1
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + k+1
                    if vis[a][b][k^1] == 0:
                        if x < f[a][b]:
                            f[a][b] = x
                        heapq.heappush(h, (x, a, b, k^1))
        return f[-1][-1]",1441314113
xlx2,xlx2,195,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        s = sum(int(x) for x in num)
        s2 = sum(int(x) for x in num[::2])
        return s == 2 * s2",1441314562
xlx2,xlx2,195,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(x) for x in num) % 2:
            return 0

        M = 10**9 + 7
        n = len(num)
        p, q = (n+1)//2, n//2
        r = sum(int(v) for v in num) // 2
        c = [0] * 10
        for v in num:
            c[int(v)] += 1
        
        d = defaultdict(int)
        d[(0, 0, 0, 0)] = 1
        for i,v in enumerate(c):
            g = defaultdict(int)
            for j in range(v+1):
                for a,s,b,t in d:
                    if a+j <= p and b+v-j <= q and s+j*i <= r and t+(v-j)*i <= r:
                        x = d[(a,s,b,t)] * math.comb(a+j, j) * math.comb(b+v-j, v-j) % M
                        g[(a+j, s+j*i, b+v-j, t+(v-j)*i)] += x
            d = g
        
        return d[(p, r, q, r)] % M
",1441375631
Abhinav Nagar,abhinav_2696,197,3627,java,"class Solution {
    public int minTimeToReach(int[][] mt) {
        int r = mt.length;
        int c = mt[0].length;
        
        int[][] d = fn2(r, c);
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        fn3(pq, d);
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] t = pq.poll();
            int ct = t[0], cr = t[1], cc = t[2];
            
            if (ct > d[cr][cc]) continue;
            
            fn4(pq, mt, d, dirs, ct, cr, cc, r, c);
        }
        
        return d[r - 1][c - 1];
    }
    void fn3(PriorityQueue<int[]> pq, int[][] d) {
        pq.offer(new int[]{0, 0, 0});
        d[0][0] = 0;
    }
    int[][] fn2(int r, int c) {
        int[][] d = new int[r][c];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                d[i][j] = Integer.MAX_VALUE;
            }
        }
        return d;
    }
    void fn4(PriorityQueue<int[]> pq, int[][] mt, int[][] d, int[][] dirs, int ct, int cr, int cc, int r, int c) {
        for (int[] dir : dirs) {
            int nr = cr + dir[0];
            int nc = cc + dir[1];
            
            if (nr >= 0 && nr < r && nc >= 0 && nc < c) {
                int nt = Math.max(ct, mt[nr][nc]) + 1;
                
                if (nt < d[nr][nc]) {
                    d[nr][nc] = nt;
                    pq.offer(new int[]{nt, nr, nc});
                }
            }
        }
    }
}",1441336597
Abhinav Nagar,abhinav_2696,197,3628,java,"class Solution {
    int fn3(int[][] mt) {
        return mt[0].length;
    }
    boolean fn6(int nr, int nc, int r, int c) {
        return nr >= 0 && nr < r && nc >= 0 && nc < c;
    }
    public int minTimeToReach(int[][] mt) {
        int r = fn2(mt), c = fn3(mt);
        int[][][] mtm = fn4(r, c);
        mtm[0][0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.add(new int[]{0, 0, 0, 0});
        
        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ct = cur[0], rw = cur[1], cl = cur[2], pr = cur[3];
            
            if (ct > mtm[rw][cl][pr]) continue;
            
            fn5(pq, dir, mt, mtm, ct, rw, cl, pr, r, c);
        }
        
        return Math.min(mtm[r - 1][c - 1][0], mtm[r - 1][c - 1][1]);
    }
    void fn5(PriorityQueue<int[]> pq, int[][] dir, int[][] mt, int[][][] mtm, int ct, int rw, int cl, int pr, int r, int c) {
        for (int[] d : dir) {
            int nr = rw + d[0], nc = cl + d[1];
            
            if (fn6(nr, nc, r, c)) {
                int nt = Math.max(ct, mt[nr][nc]) + (pr == 1 ? 2 : 1);
                
                if (nt < mtm[nr][nc][1 - pr]) {
                    mtm[nr][nc][1 - pr] = nt;
                    pq.add(new int[]{nt, nr, nc, 1 - pr});
                }
            }
        }
    }
    int fn2(int[][] mt) {
        return mt.length;
    }
    int[][][] fn4(int r, int c) {
        int[][][] mtm = new int[r][c][2];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                mtm[i][j][0] = Integer.MAX_VALUE;
                mtm[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return mtm;
    }
}",1441345445
Abhinav Nagar,abhinav_2696,197,3636,python3,"class Solution:
    def fn4(self, es, os):
        return es == os
        
    def fn3(self, i):
        return i % 2 == 0
        
    def fn2(self, c):
        return int(c) - 0
    
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            d = self.fn2(num[i])
            if self.fn3(i):
                es += d
            else:
                os += d
        return self.fn4(es, os)",1441305485
Abhinav Nagar,abhinav_2696,197,3637,python3,"MOD = int(1e9 + 7)

class Solution:
    def fn3(self, dp, fq, fact, inv_fact, m, tgt):
        for d in range(10):
            if fq[d] == 0:
                continue
            for j in range(m, -1, -1):
                for k in range(tgt, -1, -1):
                    if dp[j][k] == 0:
                        continue
                    for c in range(1, min(fq[d], m - j) + 1):
                        if k + d * c > tgt:
                            break
                        cmb = fact[fq[d]] * inv_fact[c] % MOD * inv_fact[fq[d] - c] % MOD
                        dp[j + c][k + d * c] = (dp[j + c][k + d * c] + dp[j][k] * cmb) % MOD

    def fn2(self, a, b):
        res = 1
        a %= MOD
        while b > 0:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
        
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        m = (n + 1) // 2
        l = n // 2
        fq = [0] * 10
        for c in num:
            fq[ord(c) - ord('0')] += 1
        s = sum(d * fq[d] for d in range(10))
        if s % 2 == 1:
            return 0
        tgt = s // 2
        fact = [1] * (n + 1)
        inv_fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i % MOD
        inv_fact[n] = self.fn2(fact[n], MOD - 2)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        dp = [[0] * (tgt + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        self.fn3(dp, fq, fact, inv_fact, m, tgt)
        dp_val = dp[m][tgt]
        if dp_val == 0:
            return 0
        ans = self.fn4(dp_val, fact, inv_fact, fq, m, l)
        return ans
    
    def fn4(self, dp_val, fact, inv_fact, fq, m, l):
        fact_m = fact[m]
        fact_l = fact[l]
        fact_fq = 1
        for d in range(10):
            fact_fq = fact_fq * fact[fq[d]] % MOD
        inv_fact_fq = self.fn2(fact_fq, MOD - 2)
        ans = dp_val * fact_m % MOD * fact_l % MOD * inv_fact_fq % MOD
        return ans
",1441388024
Orz,retired_kid,198,3627,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], 1<<30);
        }
        dp[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[] {0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]] > Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1) {
                    dp[c[0] + dr[i]][c[1] + dc[i]] = Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i]});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441294378
Orz,retired_kid,198,3628,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][][] dp = new int[n + 1][m + 1][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                Arrays.fill(dp[i][j], 1<<30);
            }
        }
        dp[0][0][0] = 0;
        PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(v -> v[3]));
        q.add(new int[] {0, 0, 0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            int k = c[2];
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] >
                        Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k) {
                    dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] = Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i], k ^ 1, dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1]});
                }
            }
        }
        return Arrays.stream(dp[n - 1][m - 1]).min().getAsInt();
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441299893
Orz,retired_kid,198,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length(), e = 0, o = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) e+=num.charAt(i)-'0';
            else o+=num.charAt(i)-'0';
        }
        return e == o;
    }
}",1441281401
Orz,retired_kid,198,3637,java,"class Solution {
    static long[] inv, f;
    static boolean init = false;
    static int mod = (int) 1e9 + 7, MM = 10;
    Map<Integer, Integer>[][] dp;
    Map<Integer, Integer> cnt = new HashMap<>();
    public int countBalancedPermutations(String num) {
        if (!init) {
            fc();
        }
        int n = num.length();
        dp = new Map[MM][n + 1];
        for (int i = 0; i < MM; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = new HashMap<>();
            }
        }
        for (int i = 0; i < n; i++) {
            int v = num.charAt(i) - '0';
            cnt.put(v, cnt.getOrDefault(v, 0) + 1);
        }
        return dfs(0, n / 2, 0, n);
    }
    public int dfs(int d, int even, int s, int n) {
        // System.out.println(even + "" "" + d);
        if (d == MM) return s == 0 && even == 0 ? 1 : 0;
        else if (dp[d][even].containsKey(s)) return dp[d][even].get(s);
        long ret = 0;
        int ct = cnt.getOrDefault(d, 0);
        for (int j = 0; j <= Math.min(ct, even); j++) { // how many we put at left / right
            long p = ( C(even, j) % mod * C(n - even, (ct - j)) % mod * dfs(d + 1, even - j, s + (j * d) - (ct - j) * d, n - ct) % mod ) % mod;
            ret += p;
            ret %= mod;
        }
        dp[d][even].put(s, (int) ret);
        return (int) ret;
    }
    static void fc() {
        init = true;
        inv = new long[100]; f = new long[100];
        f[0] = inv[0] = 1;
        for (int i = 1; i < 100; i++) {
            f[i] = (f[i-1] % mod * i % mod) % mod;
            inv[i] = pow(f[i], mod-2);
        }
    }
    public static long C(int n, int r) {
        // System.out.println(n + "" "" + r);
        if (n < r) return 0;
        return (f[n] % mod * inv[r] % mod * inv[n-r] % mod) % mod;
    }
    static long pow (long x, long exp){
        if (exp==0) return 1;
        long t = pow(x, exp/2);
        t = t*t % mod;
        if (exp%2 == 0) return t;
        return t*x % mod;
    }
}",1441375957
Chuan-Chih Chou,chuan-chih,199,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, i, j = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y))
        
                    
            ",1441300467
Chuan-Chih Chou,chuan-chih,199,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0, False)]
        while heap:
            t, i, j, p = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + p + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y, not p))",1441303185
Chuan-Chih Chou,chuan-chih,199,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(d) for d in num[::2]) == sum(int(d) for d in num[1::2])",1441281012
Chuan-Chih Chou,chuan-chih,199,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num) // 2
        total, p = divmod(sum(int(d) for d in num), 2)
        if p:
            return 0
        f = [1, 1]
        for i in range(2, len(num) + 1):
            f.append(f[-1] * i % mod)
        count = [0] * 10
        for d in num:
            count[int(d)] += 1
        base = [0] * 10
        b = 1
        for i, c in enumerate(count):
            base[i] = b
            b *= (c + 1)
        
        def decode(b):
            c = []
            x = b
            for curr in reversed(base):
                d, x = divmod(x, curr)
                c.append(d)
            c.reverse()
            return c
        
        nom = f[n] * f[len(num) - n] % mod
        
        @cache
        def recur(d, used, s):
            if d == 10:
                if used != n:
                    return 0
                if s != total:
                    return 0
                return nom
            to_use = n - used
            ans = 0
            for use in range(min(to_use, count[d]) + 1):
                factor = pow(f[use], -1, mod) * pow(f[count[d] - use], -1, mod) % mod
                ans += recur(d + 1, used + use, s + use * d) * factor % mod
            # print(d, used, s, ans)
            return ans % mod
            
            
        return recur(0, 0, 0)
        
            ",1441376296
Jasper,JasperT37449,200,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        pq.push({0, {0, 0}});
        int t, i, j;
        vector<vector<int>> time(n+1, vector<int>(m+1, 1e9));
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+1, moveTime[i+1][j]+1), {i+1, j}});
            if(j+1<=m)pq.push({max(t+1, moveTime[i][j+1]+1), {i, j+1}});
            if(i-1>=0)pq.push({max(t+1, moveTime[i-1][j]+1), {i-1, j}});
            if(j-1>=0)pq.push({max(t+1, moveTime[i][j-1]+1), {i, j-1}});
        }
        return t;
    }
};",1441313753
Jasper,JasperT37449,200,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,pair<int, int>>>, vector<pair<int, pair<int, pair<int, int>>>>, greater<pair<int, pair<int, pair<int, int>>>>> pq;
        pq.push({0, {0, {0, 1}}});
        int t, i, j, turn;
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second.first, turn = pq.top().second.second.second%2;
            if(!turn)turn = 2;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            //cout<<""T : ""<<t<<"" ""<<i<<"" ""<<j<<endl;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+turn, moveTime[i+1][j]+turn), {i+1, {j, turn+1}}});
            if(j+1<=m)pq.push({max(t+turn, moveTime[i][j+1]+turn), {i, {j+1, turn+1}}});
            if(i-1>=0)pq.push({max(t+turn, moveTime[i-1][j]+turn), {i-1, {j, turn+1}}});
            if(j-1>=0)pq.push({max(t+turn, moveTime[i][j-1]+turn), {i, {j-1, turn+1}}});
        }
        return t;
    }
};",1441328086
Jasper,JasperT37449,200,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        for(int i = 0;i<num.size();i++){
            if(i%2==0){
                odd+=num[i]-48;
            }
            else {
                even+=num[i]-48;
            }
        }
        if(odd==even)return true;
        return false;
    }
};",1441282589
Jasper,JasperT37449,200,3637,cpp,"typedef long long ll;

class Solution {
public:
    ll power(ll a, ll b, ll mod) {
        ll res = 1;
        a %= mod;
        while(b >0){
            if(b &1){
                res = res * a % mod;
            }
            a = a *a % mod;
            b >>=1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size(), cnt[10] = {0}, sum =0, mod = 1e9 + 7;
        for(char c: num){
            cnt[c - '0']++;
            sum += (c - '0');
        }
        if(sum %2 !=0)return 0;
        ll s = sum /2;
        int k = (n+1)/2;
        vector<ll> fact(n+1,1), table(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] *i % mod;
        table[n] = power(fact[n], mod-2, mod);
        for(int i=n-1;i>=0;i--) table[i] = table[i+1] * (i+1) % mod;
        vector< vector<ll> > prev(k+1, vector<ll>(s+1, 0));
        prev[0][0] =1;
        for(int d=0; d<=9; d++){
            int c_d = cnt[d];
            vector< vector<ll> > curr(k+1, vector<ll>(s+1, 0));
            for(int k_prev=0; k_prev <=k; k_prev++){
                for(int s_prev=0; s_prev <=s; s_prev++){
                    if(prev[k_prev][s_prev] ==0) continue;
                    for(int x=0; x<=c_d; x++){
                        if(k_prev +x >k) break;
                        if((ll)s_prev + (ll)d *x >s) break;
                        int new_k = k_prev +x, new_s = s_prev + d *x;
                        ll val = prev[k_prev][s_prev];
                        val = val * table[x] % mod;
                        val = val * table[c_d -x] % mod;
                        curr[new_k][new_s] = (curr[new_k][new_s] + val) % mod;
                    }
                }
            }
            prev = move(curr);
        }
        if(k >n || s > 9*80)return 0;
        ll res = fact[k];
        res = res * fact[n -k] % mod;
        res = res * prev[k][s] % mod;
        return res;
    }
};",1441376524
lu-chen-chen,lu-chen-chen,201,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t + 1, moveTime[x][y] + 1)});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441298612
lu-chen-chen,lu-chen-chen,201,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t, moveTime[x][y]) + 1 + (x + y + 1) % 2});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441305940
lu-chen-chen,lu-chen-chen,201,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int a = 0;
        int b = 0;
        char[] chars = num.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (i % 2 == 0) {
                a += chars[i] - '0';
            } else {
                b += chars[i] - '0';
            }
        }
        return a == b;
    }
}",1441281556
lu-chen-chen,lu-chen-chen,201,3637,java,"import java.math.BigInteger;
class Solution {
    public int countBalancedPermutations(String num) {
        long mod = (long) (1e9 + 7);
        char[] chars = num.toCharArray();
        int n = chars.length;
        int sum = 0;
        int[] cnt = new int[10];
        for (char c : chars) {
            cnt[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 1) {
            return 0;
        }
        Factorial fac = new Factorial(n + 5, (int) mod);
        long[][][] dp = new long[10][n / 2 + 1][sum / 2 + 1];
        for (int i = 0; i <= Math.min(cnt[0], n / 2); i++) {
            dp[0][i][0] = 1;
        }
        int curCnt = cnt[0];
        for (int i = 1; i < 10; i++) {
            curCnt += cnt[i];
            for (int j = 0; j <= n / 2; j++) {
                for (int k = 0; k <= sum / 2; k++) {
                    for (int l = 0; l <= cnt[i]; l++) {
                        int j1 = j + l;
                        int k1 = k + l * i;
                        if (j1 > n / 2 || k1 > sum / 2) {
                            break;
                        }
                        dp[i][j1][k1] += fac.comb(j1, l) * dp[i - 1][j][k] % mod * fac.comb(curCnt - j1, cnt[i] - l) % mod;
                        dp[i][j1][k1] %= mod;
                    }
                }
            }
        }
        long ans = dp[9][n / 2][sum / 2];
        return (int) ((ans + mod) % mod);
    }
}

class Factorial {
    long[] fac;
    long[] inv;
    long mod;

    public Factorial(long[] fac, long[] inv, long mod) {
        this.mod = mod;
        this.fac = fac;
        this.inv = inv;
        fac[0] = inv[0] = 1;
        int n = fac.length;
        for (int i = 1; i < n; i++) {
            fac[i] = i;
            fac[i] = (int) (fac[i] * fac[i - 1] % mod);
        }
        inv[n - 1] = BigInteger.valueOf(fac[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();
        for (int i = n - 2; i >= 1; i--) {
            inv[i] = (int) (inv[i + 1] * (i + 1) % mod);
        }
    }

    public Factorial(int limit, int mod) {
        this(new long[Math.min(limit + 1, mod)], new long[Math.min(limit + 1, mod)], mod);
    }

    public long getMod() {
        return mod;
    }

    public long fac(int n) {
        if (n >= mod) {
            return 0;
        }
        return fac[n];
    }

    public long inv(int n) {
        if (n >= mod) {
            throw new IllegalArgumentException();
        }
        return inv[n];
    }

    public long comb(int n, int m) {
        if (n < m) {
            return 0;
        }
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    }

    public long combInv(int n, int m) {
        if (n < m) {
            throw new IllegalArgumentException();
        }
        return inv[n] * fac[m] % mod * fac[n - m] % mod;
    }
}",1441364181
unnu,unnu,202,3627,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty]+1,t+1);
                    if(dis[tx][ty]>t1){
                        st.erase({dis[tx][ty],tx,ty});
                        st.insert({t1,tx,ty});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
        
    }
};",1441302269
unnu,unnu,202,3628,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2],z=v[3];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty],t);
                    if(z%2==0) t1+=1;
                    else t1+=2;
                    if(dis[tx][ty]>t1){
                        // st.erase({dis[tx][ty],tx,ty,});
                        st.insert({t1,tx,ty,1-z});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
    }
};",1441305679
unnu,unnu,202,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int x=0;int y=0;int n=num.size();
        for(int i=0;i<n;i++){
            if(i%2) x+=(num[i]-'0');
            else y+=(num[i]-'0');
        }
        return (x==y);
    }
};",1441289924
unnu,unnu,202,3637,cpp,"#define ll long long
class Solution {
public:
    const int mod=1e9+7;
    ll dp[12][41][365];
    vector<int>freq;int p;
    vector<ll>fact,invf;

ll power(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)
        {
            res=(res*a)%mod;
        }
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}

void precompute(int n)
{
    fact.resize(n+1);
    invf.resize(n+1);
    fact[0]=1;
    for(int i=1;i<=n;i++)
    {
        fact[i]=(fact[i-1]*i)%mod;
    }
    invf[n]=power(fact[n],mod-2);
    for(int i=n-1;i>=0;i--)
    {
        invf[i]=(invf[i+1]*(i+1))%mod;
    }
}

ll nCr(int n,int r)
{
    if(r>n)
    {
        return 0;
    }
    ll ans=(invf[r])%mod;
    ans=(ans*invf[n-r])%mod;
    return ans;
}
    ll f(int idx,int cnt,int sum,int k){
        // int n=v.size();
        // int p=n/2;
        // if(idx>=n && sum==k && cnt==p) return 1;
        // if(idx>=n || sum>k || cnt>p) return 0;
        // if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        // ll take=f(idx+1,cnt+1,sum+v[idx],k,v);
        // ll nt=f(idx+1,cnt,sum,k,v);
        // ll ans=(take+nt)%mod;
        // return dp[idx][cnt][sum]=ans;
        
        int n=freq.size();
        if(idx>=n && sum==k && cnt==p) {
          //  cout<<sum<<"" ""<<cnt<<endl;
            return 1;
        }
        if(idx>=n || sum>k || cnt>p) return 0;
        if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        ll take=0,nt=0;ll res=0;
        for(int i=0;i<=freq[idx];i++){
            take=(f(idx+1,cnt+i,sum+(i)*idx,k)*nCr(freq[idx],(i)))%mod;
           // nt=(f(idx+1,cnt+i,sum+(i*idx),k)*nCr(freq[idx],i))%mod;
            //cout<<take<<"" ""<<nt<<"" p""<<i<<endl;
            res+=((take%mod))%mod;
            res%=mod;
            res=(res+mod)%mod;
        }
         //nt=(f(idx+1,cnt+freq[idx],sum+(freq[idx]*idx),k))%mod;
        // res+=(nt%mod);
        // res%=mod;
        // res=(res+mod)%mod;
       // cout<<idx<<"" ""<<cnt<<"" ""<<sum<<"" ""<<res<<endl;
        return dp[idx][cnt][sum]=res;
    }
    int countBalancedPermutations(string num) {
        vector<int>v;freq.resize(10,0);precompute(81);
        for(auto ch:num) v.push_back(ch-'0');
        int k=0;p=v.size()/2;
        for(auto it:v) k+=it,freq[it]++;
        if(k%2) return 0;
        memset(dp,-1,sizeof(dp));
        ll ans=(fact[p]*fact[v.size()-p])%mod;
        ll tmp=f(0,0,0,k/2)%mod;
        ll res=(ans*tmp)%mod;
        res=(res+mod)%mod;
        return res;
        
        
        // return f(0,0,0,k/2);
    }
};",1441385344
op33,op33,203,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        visited = set()
        queue = [(0, (0,0))]
        while queue:
            time, (row, col) = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    heapq.heappush(queue, (ntime, (nr, nc)))
            

        # should always return earlier",1441297937
op33,op33,203,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        # another variable to track move parity
        visited = set()
        queue = [(0, (0,0), True)]
        while queue:
            time, (row, col), parity = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    if not parity:
                        ntime += 1
                    heapq.heappush(queue, (ntime, (nr, nc), not parity))
            

        # should always return earlier",1441300716
op33,op33,203,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens, odds = 0, 0
        for i, char in enumerate(num):
            digit = int(char)
            if i % 2 == 0:
                evens += digit
            else:
                odds += digit
        return evens == odds",1441283006
op33,op33,203,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # naively you can compute n! perms * n to count all
        # They must sum to sum(num) / 2 which must be even in total
        # sum(num) // 2 = S
        # how many subsets will sum to S? -> This is a known problem, N^2
        # How many permutations of each of these subsets are there as well
        # If a subset has duplicates, you need to divide by m! for each duplicate for overcounting
        # num.length is max 80 which can make it easier
        # Can manually go through each distinct subset after collecting each?
        # Or can iteratively build a count and correct for overcounting at each step?
        # What if you track each counts of each digit set, such as {7:2,9:1} -> 2
        # Or track each sum -> unique digit sets such as 21 -> {{7:3}, {8:2, 5:1}}
        # This is an option but might be too slow/memory(?)

        # count each digit and then do coin change like dp?
        # This could work since you can iteratively build the denominator at each step
        # For example, if there are 3 2s available and you choose to use 3 of them, then you eventually need to overcorrect by a factor of 3!, so you can pass that down in the dp process, no matter what is chosen later.
        # need to store num_elems so far chosen, denominator so far, index, sum so far
        # also need to store denom for the other subset
        # Forgot that num elems must match or be off by 1 at most
        # Also if sum > S at any point, early break
        # If num elems is > half at any point, only add 0 elems in future.
        # maybe set1 is evens, set2 is odds. Can have at most 1 extra for either by the end -> No only even can have more
        # maybe can reduce time using symmetry of even/odd sets?? maybe only if even digits_count
        # If odd digit count, then there will be exactly 1 extra even compared to odds
        # Do we need denom1/denom2 in the cache state? No? Can just divide on demand when receiving the output
        # 851350267
        
        MOD = 10**9 + 7

        @cache
        def factorial(n):
            if n == 0:
                return 1
            answer = 1
            for i in range(1, n + 1):
                answer *= i
            return answer

        digits = [int(char) for char in num]
        digits_count = len(digits)
        evens_digit_count = digits_count // 2
        if digits_count % 2 == 1:
            evens_digit_count += 1

        T = sum(digits)
        if T % 2 == 1:
            return 0
        
        S = T // 2

        counts = list(Counter(digits).items())
        counts = sorted(counts) # ex - [(0, 5), (1, 2), (3, 1), ... (9, 1)]

        @cache
        def count_bal_perms(idx, sum_so_far, num_elems):
            if idx == len(counts):
                if sum_so_far == S and num_elems == evens_digit_count:
                    total1 = factorial(num_elems) # should always divide cleanly
                    total2 = factorial(digits_count - num_elems)
                    return total1 * total2
                else:
                    return 0

            cur_dig, count = counts[idx]
            bal_perms = 0
            for i in range(count + 1):
                new_num_elems = num_elems + i
                new_sum = sum_so_far + i * cur_dig
                if new_num_elems > evens_digit_count or new_sum > S:
                    continue

                denom1, denom2 = factorial(i), factorial(count - i)

                bal_perms += count_bal_perms(idx + 1, new_sum, new_num_elems) // denom1 // denom2

            return bal_perms

        return count_bal_perms(0, 0, 0) % MOD
            
        ",1441379448
user9821NM,user9821NM,204,3627,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<int>>dist(n, vector<int>(m, INT_MAX));
        
        set<tuple<int,int,int>>q; q.insert({0, 0, 0}); dist[0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y] = *q.begin(); q.erase(*q.begin());
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && dist[X][Y] > max(dist[x][y] + 1, moveTime[X][Y] + 1)) {
                    q.erase({dist[X][Y], X, Y});
                    dist[X][Y] =  max(dist[x][y] + 1, moveTime[X][Y] + 1);
                    q.insert({dist[X][Y], X, Y});
                }
            }
        };
        
        return dist[n - 1][m - 1];
    }
};",1441344848
user9821NM,user9821NM,204,3628,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<vector<int>>>dist(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        
        set<tuple<int,int,int,int>>q; q.insert({0, 0, 0, 0}); dist[0][0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y, move] = *q.begin(); q.erase(*q.begin());
            
            int cost = ((move ^ 1) ? 1 : 2);
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && 
                    dist[X][Y][move ^ 1] > max(dist[x][y][move] + cost, moveTime[X][Y] + cost)) {
                    q.erase({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                    dist[X][Y][move ^ 1] =  max(dist[x][y][move] + cost, moveTime[X][Y] + cost);
                    q.insert({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                }
            }
        };
        
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441351431
user9821NM,user9821NM,204,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int>sum(2);
        for(int i = 0;i < num.size(); i++) {
            sum[i % 2] += num[i] - '0';
        }
        
        return sum[0] == sum[1];
    }
};",1441326964
user9821NM,user9821NM,204,3637,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int expo(int a, int b) {
        int res = 1;
        while(b) {
            if(b & 1) res = (1ll * res * a) % MOD;
            b >>= 1; a = (1ll * a * a) % MOD;
        }
        return res;
    }
    
    int countBalancedPermutations(string num) {
        vector<int>fr(10), fact(num.size() + 1, 1), ifact(num.size() + 1, 1); int sum = 0;
        for(auto &i : num) fr[i - '0']++, sum += (i - '0');
                
        if((sum % 2 == 1)) return 0;
        
        for(int i = 1; i <= num.size(); i++) {
            fact[i] = (1ll * i * fact[i - 1]) % MOD;
            ifact[i] = expo(fact[i], MOD - 2);
        }
                        
        vector<vector<vector<int>>>dp(10, vector<vector<int>>(num.size() / 2 + 1, vector<int>(sum + 1, -1)));
        
        int permutationsCount = (1ll * fact[num.size() / 2] * fact[(num.size() + 1) / 2]) % MOD;
        
        auto f = [&](int number, int taken, int currentSum, auto &&self) -> int {            
            if(number == 10) {
                return (currentSum == sum / 2 && taken == num.size() / 2 ? permutationsCount : 0);
            }
            
            if(dp[number][taken][currentSum] != -1) return dp[number][taken][currentSum];
            
            int ways = 0;
            
            for(int i = 0; i <= min(fr[number], (int) num.size() / 2 - taken); i++) {
                ways = (ways + (1ll * (1ll * ifact[i] * ifact[fr[number] - i]) % MOD * self(number + 1, taken + i, currentSum + i * number, self)) % MOD) % MOD;
            }
            
            return dp[number][taken][currentSum] = ways;
        };
        
        return f(0, 0, 0, f);
    }
};",1441379576
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue

                new_cost = max(c, moveTime[x][y]) + 1
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441295323
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue
                extra_cost = 0 if (x + y) & 1 else 1
                new_cost = max(c, moveTime[x][y]) + 1 + extra_cost
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441307109
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0

        for i in range(len(num)):
            if i & 1:
                odd += (ord(num[i]) - ord('0'))
            else:
                even += (ord(num[i]) - ord('0'))
        return odd == even",1441281363
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits_freq = [0] * 10
        for c in num:
            digits_freq[ord(c) - ord('0')] += 1
        s = 0
        for i in range(10):
            s += i * digits_freq[i]

        if s & 1:
            return 0

        MOD = 10**9 + 7
        
        @lru_cache(None)
        def c(n, k): 
            if k == 0:
                return 1
            if n == k:
                return 1
            else:
                return (c(n-1, k-1) + c(n-1, k)) % MOD

        @lru_cache(None)
        def dp(d, diff, n_even, n_odd):
            if n_even < 0 or n_odd < 0:
                return 0

            if d == -1:
                return 1 if diff == 0 else 0

            res = 0
            for e in range(digits_freq[d] + 1):
                remain_even = n_even-e
                remain_odd = n_odd-(digits_freq[d]-e)
                if remain_even < 0 or remain_odd < 0:
                    continue

                temp = dp(d-1, diff + e*d - (digits_freq[d]-e)*d, remain_even, remain_odd)
                temp = (temp * c(n_even, e) * c(n_odd, digits_freq[d]-e)) % MOD
                res = (res + temp) % MOD
            return res
            
        return dp(9, 0, (len(num) + 1) // 2, len(num) // 2)",1441385680
Anuj Anand,coleworld223,206,3627,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 1};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312661
Anuj Anand,coleworld223,206,3628,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 2};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312149
Anuj Anand,coleworld223,206,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      array <int, 2> c = {0, 0};
      for (int i = 0; i < num.size(); ++i) {
        c[i % 2] += (num[i] - '0');
      }
      return c[0] == c[1];
    }
};",1441282080
Anuj Anand,coleworld223,206,3637,cpp,"int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

struct fact {
  mi fac[1000];
  mi ifac[1000];
  fact() {
    fac[0] = ifac[0] = 1;
    for (int i = 1; i < 1000; ++i) {
      fac[i] = fac[i - 1] * i;
      ifac[i] = inv(fac[i]);
    }
  }
};

fact F;
mi C(int n, int r) {
  if (n <= 0 or r > n) { return (mi)0; }
  return F.fac[n] * F.ifac[r] * F.ifac[n - r];
}

mi dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(string num) {
      int n = num.size();
      for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 81; ++j) {
          for (int k = 0; k < 801; k++) {
            dp[i][j][k] = 0;
          }
        }
      }
      vector <int> cnt (10);
      int T = 0;
      for (char x : num) {
        cnt[x - '0'] += 1;
        T += (x - '0');
      }
      
      if (T % 2) { return 0; }
      T /= 2;
      
      for (int x = 0; x <= cnt[0]; x++) {
        dp[0][x][0] += 1 * F.ifac[x] * F.ifac[cnt[0] - x];
      }
      for (int i = 0; i < 9; ++i) {
        int nxt = i + 1;
        int tot = cnt[i + 1];
        int cur_tot = cnt[i];
        for (int take = 0; take <= 80; take++) {
          for (int sum = 0; sum <= 800; sum++) {
            if (dp[i][take][sum] == 0) { continue; }
            for (int x = 0; x <= tot; x++) {
              int ntake = take + x;
              int nsum = sum + x * (i + 1);
              if (nsum <= 800 and ntake <= 80) dp[i + 1][ntake][nsum] += dp[i][take][sum] * F.ifac[x] * F.ifac[tot - x];
            }
          }
        }
      }
      
      // cout << dp[2][2][3] << '\n';
      // cout << dp[3][2][3] << '\n';
      int siz = n / 2;
      // cout << siz << ' ';
      // cout << T << '\n';
      // cout << dp[9][siz][T] << '\n';
      mi ans = dp[9][siz][T] * F.fac[siz] * F.fac[n - siz];
      return ans.v;
    }
};",1441367561
Vivan,Vivan_geekfreak,207,3627,java,"import java.util.*;
class Solution 
{
    public int minTimeToReach(int[][] moveTime)
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var dist = new int[n][m];
        int i = 0;
        if(n>0)
            do
            {
                Arrays.fill(dist[i], Integer.MAX_VALUE);
                i++;
            } 
            while (i < n);
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for(;!pq.isEmpty();)
        {
            var curr = pq.poll();
            var time = curr[0];
            var row = curr[1];
            var col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0; 
            do 
            {
                var dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
            while (dirIndex < dirs.length);
        }
        return dist[n - 1][m - 1];
    }
}
",1441366743
Vivan,Vivan_geekfreak,207,3628,java,"import java.util.*;

class Solution 
{
    public int minTimeToReach(int[][] moveTime) 
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var d = new int[n][m][2];
        int i = 0;
        do 
        {
            int j = 0;
            do 
            {
                d[i][j][0] = Integer.MAX_VALUE;
                d[i][j][1] = Integer.MAX_VALUE;
                j++;
            } 
            while (j < m);
            i++;
        } 
        while (i < n);
        d[0][0][0] = 0;
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0});
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for(;(!(!pq.isEmpty())==false);)
        {
            var current = pq.poll();
            var t = current[0];
            var iCur = current[1];
            var jCur = current[2];
            var p = current[3];

            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            int dirIndex = 0;
            do 
            {
                var dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.offer(new int[]{nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            } 
            while (dirIndex < directions.length);
        }

        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441332797
Vivan,Vivan_geekfreak,207,3636,java,"class Solution 
{
    public boolean isBalanced(String num) 
    {
        int evenSum = 0;
        int oddSum = 0;
        int i=0;
        if(num.length()>0)
            do
            {
                int digit = num.charAt(i) - '0'; 
                if (!(i % 2 == 0) == false)
                    evenSum += digit;
                else
                    oddSum += digit;
                i++;
            }
            while(i<num.length());
        return evenSum == oddSum;
    }
}
",1441292613
Vivan,Vivan_geekfreak,207,3637,java,"import java.util.*;
class Solution
{
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;
    private long powerMod(long a, long b) 
    {
        long res = 1;
        a %= MOD;
        while (b > 0) 
        {
            if (!((b & 1) == 1) ==false)
                res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }
    private void initFact(int n) 
    {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        int i = 1;
        do 
        {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do 
        {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        }
        while (j >= 0);
    }
    public int countBalancedPermutations(String num) 
    {
        var n = num.length();
        var freq = new int[10];
        long totalSum = 0;
        var C=Arrays.copyOfRange(num.toCharArray(), 0, n);
        int i=0;
        if(n>0)
            do
            {
                char c=C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            }
            while(i<n);

        if (!(totalSum % 2 != 0) ==false)
            return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        var dp = new long[k + 1][(int) sumHalf + 1];
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0)==false)
            {
                d++;
                continue;
            }
            int c = k;
            do 
            {
                long s = sumHalf;
                do 
                {
                    if (!(dp[c][(int) s] == 0)==false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    do 
                    {
                        if (!(t > Math.min(freq[d], k - c)) ==false)
                            break;
                        if (!(s + (long) d * t > sumHalf)==false)
                            break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                        t++;
                    } 
                    while (true);
                    s--;
                } 
                while (s >= 0);
                c--;
            } 
            while (c >= 0);
            d++;
        } 
        while (d <= 9); 

        long validAssignments = dp[k][(int) sumHalf];
        if (!(validAssignments == 0) == false)
            return 0;
        long prodFactFd = 1;
        int digit=0;
        do 
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        while(digit <= 9);
        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int) answer;
    }
}
",1441392291
Fasdr,Fasdr,208,3627,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][] time = new int[n][m];
        int max = Integer.MAX_VALUE;
        for (int row[] : time) {
            Arrays.fill(row, max);
        }
        // t, i, j
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2];
            if (time[i][j] <= t) {
                continue;
            }
            time[i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int nt = Math.max(moveTime[ni][nj] + 1, t + 1);
                frontier.add(new int[] {nt, ni, nj});
            }
        }
        
        return time[n - 1][m - 1];
    }
}",1441297738
Fasdr,Fasdr,208,3628,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][][] time = new int[2][n][m];
        int max = Integer.MAX_VALUE;
        for (int[][] table : time) {
            for (int[] row : table) {
                Arrays.fill(row, max);
            }
        }
        // t, i, j, a
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2], a = cur[3];
            if (time[a][i][j] <= t) {
                continue;
            }
            time[a][i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int extra = (a == 0) ? 1 : 2;
                int nt = Math.max(moveTime[ni][nj], t) + extra;
                frontier.add(new int[] {nt, ni, nj, 1 - a});
            }
        }
        
        return Math.min(time[0][n - 1][m - 1], time[1][n - 1][m - 1]);
    }
}",1441306270
Fasdr,Fasdr,208,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int odd = 0, even = 0;
        for (int i = 0; i < n; i += 2) {
            even += (num.charAt(i) - '0');
        }
        for (int i = 1; i < n; i += 2) {
            odd += (num.charAt(i) - '0');
        }
        return even == odd;
    }
}",1441282457
Fasdr,Fasdr,208,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        int[] qty = new int[10];
        long mod = 1_000_000_007;
        int n = num.length();
        int total = 0;
        for (char chr : num.toCharArray()) {
            total += chr - '0';
        }
        if (total == 0) {
            total = 1;
        }
        total = 2 * total;
        long[][] dp = new long[total + 1][2 * n + 1];
        dp[total / 2][n] = 1;
        for (char chr : num.toCharArray()) {
            int digit = chr - '0';
            qty[digit]++;
            long[][] newDp = new long[total + 1][2 * n + 1];
            for (int sum = 0; sum < total + 1; sum++) {
                for (int cnt = 0; cnt < 2 * n + 1; cnt++) {
                    if (dp[sum][cnt] == 0) {
                        continue;
                    }
                    // add to even
                    newDp[sum + digit][cnt + 1] = (newDp[sum + digit][cnt + 1] + dp[sum][cnt]) % mod;
                    // add to odd
                    newDp[sum - digit][cnt - 1] = (newDp[sum - digit][cnt - 1] + dp[sum][cnt]) % mod;
                }
            }
            dp = newDp;
        }
        
        long res = n % 2 == 0? dp[total / 2][n] : dp[total / 2][n + 1];
        int half = n / 2;
        for (int i = 1; i <= half; i++) {
            res = (res * i * i) % mod;
        }
        
        if (n % 2 != 0) {
            res = (res * (half + 1)) % mod;
        }
        
        for (int digitQty : qty) {
            for (int i = 2; i <= digitQty; i++) {
                res = (res * modInv(i, mod)) % mod;
            }
        }
        
        return (int) res;
    }
    
    private long modInv(long num, long mod) {
        return pow(num, mod - 2, mod);
    }
    
    private long pow(long base, long exp, long mod) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp = exp >> 1;
        }
        
        return res;
    }
    
}",1441367839
Gautam Ankoji,gautamankoji,209,3627,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        v = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        q = [(0, 0, 0)]
        while q:
            t, i, j = heapq.heappop(q)
            if t > d[i][j]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + 1
                    if d[ni][nj] > nt:
                        d[ni][nj] = nt
                        heapq.heappush(q, (nt, ni, nj))
        res = d[n - 1][m - 1]
        return d[n - 1][m - 1]",1441323814
Gautam Ankoji,gautamankoji,209,3628,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0
        v = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        q = [(0, 0, 0, 0)]
        while q:
            t, i, j, p = heapq.heappop(q)
            if t > d[i][j][p]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + (2 if p else 1)
                    if d[ni][nj][1 - p] > nt:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(q, (nt, ni, nj, 1 - p))
        res = min(d[n - 1][m - 1])
        return res",1441327957
Gautam Ankoji,gautamankoji,209,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res1, res2 = 0, 0
        for i, d in enumerate(num):
            if i % 2 != 0:
                res2 += int(d)
            else:
                res1 += int(d)
        return res1 == res2
",1441291369
Gautam Ankoji,gautamankoji,209,3637,python3,"MOD = 1_000_000_007

class Solution:
    def power(self, base: int, exp: int, mod: int) -> int:
        res = 1
        base %= mod
        while exp:
            if exp & 1:
                res = res * base % mod
            base = base * base % mod
            exp >>= 1
        return res
    
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        e, O = (n + 1) // 2, n // 2
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1
        tot_sum = sum(d * cnt[d] for d in range(10))
        if tot_sum % 2: return 0
        t_sum = tot_sum // 2
        max_val = 80
        fact = [1] * (max_val + 1)
        for i in range(1, max_val + 1):
            fact[i] = fact[i - 1] * i % MOD
        not_fact = [1] * (max_val + 1)
        not_fact[max_val] = self.power(fact[max_val], MOD - 2, MOD)
        for i in range(max_val - 1, -1, -1):
            not_fact[i] = not_fact[i + 1] * (i + 1) % MOD
        def comb(n: int, k: int) -> int:
            return (fact[n] * not_fact[k] % MOD * not_fact[n - k] % MOD) if k <= n else 0
        dp = [[0] * (t_sum + 1) for _ in range(e + 1)]
        dp[0][0] = 1
        for d in range(10):
            if not cnt[d]: continue
            for t in range(e, -1, -1):
                for s in range(t_sum, -1, -1):
                    if dp[t][s]:
                        for k in range(1, cnt[d] + 1):
                            if t + k <= e and s + d * k <= t_sum:
                                dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD
        p_cnt = 1
        for d in range(10):
            p_cnt = p_cnt * fact[cnt[d]] % MOD
        ans = (dp[e][t_sum] * fact[e] % MOD * fact[O] % MOD * self.power(p_cnt, MOD - 2, MOD)) % MOD
        return ans
",1441386398
Nguyn Minh,minhnguyenxuan60,210,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<vector<int>> dp(n, vector<int>(m, 1e9 + 1e8));
        dp[0][0] = 0;

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        for (int k = 0; k < n * m; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    for (int r = 0; r < 4; r++) {
                        int i1 = i + diri[r], j1 = j + dirj[r];
                        if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                        dp[i1][j1] = min(dp[i1][j1], dp[i][j] + 1);
                        if (i1 != 0 || j1 != 0) dp[i1][j1] = max(dp[i1][j1], moveTime[i1][j1] + 1);
                    }
                }
            }
        }

        return dp[n - 1][m - 1];
    }
};",1441297906
Nguyn Minh,minhnguyenxuan60,210,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> q;
        q.push({{0, 1}, {0, 0}});

        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        vector<vector<bool>> vis(n, vector<bool>(m));
        while(!q.empty()) {
            int u = q.top().first.first, t = q.top().first.second, i = q.top().second.first, j = q.top().second.second;
            q.pop();
            if (vis[i][j]) continue;
            vis[i][j] = true;
            if (i == n - 1 && j == m - 1) {
                return max(u, moveTime[i][j] + 1);
            }

            for (int k = 0; k < 4; k++) {
                int i1 = i + diri[k], j1 = j + dirj[k];
                if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                q.push({{max(u, moveTime[i1][j1]) + t, 3 - t}, {i1, j1}});
            }
        }
        return 0;
    }
};",1441313182
Nguyn Minh,minhnguyenxuan60,210,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281260
Nguyn Minh,minhnguyenxuan60,210,3637,cpp,"class Solution {
public:

    const int mod = 1e9 + 7;
    int countBalancedPermutations(string num) {
        vector<vector<int64_t>> c(100, vector<int64_t> (100, 0));
        for (int i = 0; i < 100; i++) c[i][0] = 1;
        for (int i = 1; i < 100; i++) {
            for (int j = i; j < 100; j++) {
                c[j][i] = (c[j - 1][i] + c[j - 1][i - 1]) % mod;
            }
        }

        // for (int i = 0; i <= 10; i++) {
        //     for (int j = 0; j <= 10; j++) cout << c[i][j] << "" "";
        //     cout << '\n';
        // }

        vector<int> cnt(10);
        int total = 0;
        for (char c: num) {
            cnt[c - '0']++;
            total += c - '0';
        }

        if (total % 2) return 0;
        total /= 2;

        int len = num.size() / 2;

        vector<vector<int64_t>> dp(len + 1, vector<int64_t>(total + 1, 0));

        dp[0][0] = 1;
        int curNum = 0;
        
        for (int num = 0; num < 10; num++) {
            vector<vector<int64_t>> tmp(len + 1, vector<int64_t>(total + 1, 0));
            for (int l = 0; l <= curNum; l++) {
                for (int sum = 0; sum <= total; sum++) {
                    for (int used = 0; used <= cnt[num]; used++) {
                        int numLeft = l + used, numRight = curNum - l + cnt[num] - used;
                        if (sum + num * used > total || numLeft > len) break;
                        tmp[numLeft][sum + num * used] += dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod;
                        // if (dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod > 1) {
                        //     // cout << numLeft << "" "" << used << "" "" << numRight << "" "" << cnt[num] - used << "" "" << dp[l][sum] << '\n';
                        //     // cout << l << "" "" << sum << "" "" << num << "" "" << '\n';
                        //     cout << dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod << '\n';
                        // }
                        tmp[numLeft][sum + num * used] %= mod;
                    }
                }
            }
            swap(tmp, dp);
            curNum += cnt[num];
        }

        // for (int i = 0; i <= len; i++) {
        //     for (int sum = 0; sum <= total; sum++) {
        //         cout << dp[i][sum] << "" "";
        //     }
        //     cout << '\n';
        // }

        return dp[len][total];

        

        return 0;
    }
};",1441368456
user3013OR,user3013OR,211,3627,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c = h[0]
            heappop(h)
            if (r,c) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            seen[(r,c)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+1
                heappush(h,(nt,r-1,c))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+1
                heappush(h,(nt,r+1,c))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+1
                heappush(h,(nt,r,c-1))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+1
                heappush(h,(nt,r,c+1))
            
        ",1441293940
user3013OR,user3013OR,211,3628,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
        
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c,s = h[0]
            heappop(h)
            if (r,c,s) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            ns = 1-s
            mv = 1+s
            seen[(r,c,s)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+mv
                heappush(h,(nt,r-1,c,ns))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+mv
                heappush(h,(nt,r+1,c,ns))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+mv
                heappush(h,(nt,r,c-1,ns))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+mv
                heappush(h,(nt,r,c+1,ns))",1441297026
user3013OR,user3013OR,211,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        sign = 1
        for c in num:
            val = int(c)
            s += sign * val
            sign = -sign
        return s==0
        ",1441282298
user3013OR,user3013OR,211,3637,python3,"class Solution:
    def helper(self,n,mod):
        even_n = n//2
        odd_n = n-even_n

        res = (self.fact[even_n]*self.fact[odd_n])%mod
        for i in range(10):
            res = (res*(self.inverse[self.temp[i]]))%mod
            res = (res*(self.inverse[self.cnt[i]-self.temp[i]]))%mod
        self.ans+=res
        self.ans%=mod
        return
        
    def inv(self,a,mod):
        return self.power(a,mod-2,mod)
    def power(self,a,p,mod):
        if p==0:
            return 1
        elif p==1:
            return a
        else:
            res = self.power(a,p//2,mod)
            ans = (res*res)%mod
            if p%2==1:
                ans = (ans*a)%mod
            return ans
    def dfs(self,ind,ts,tn,cs,cn,mod):
        if ind==10:
            if ts == cs*2 and cn == tn//2:
                self.helper(tn,mod)
            return
        if cs>ts//2:
            return
        if cn>tn//2:
            return
        if (tn//2-cn)*9+cs<ts//2:
            return
        for i in range(self.cnt[ind]+1):
            self.temp[ind]=i
            self.dfs(ind+1,ts,tn,cs+i*ind,cn+i,mod)
    def comb(self,a,b,mod):
        ans = self.fact[a]*self.inverse[b]*self.inverse[a-b]
        return ans%mod
    def countBalancedPermutations(self, num: str) -> int:
        self.cnt = [0 for i in range(10)]
        s = 0
        n = len(num)
        #print (n)
        for c in num:
            val = int(c)
            self.cnt[val]+=1
            s+=val
        if s%2==1:
            return 0
        self.fact = [1 for i in range(n+1)]
        self.inverse = [1 for i in range(n+1)]
        mod = int(1e9+7)
        for i in range(n):
            self.fact[i+1]=(self.fact[i]*(i+1))%mod
            self.inverse[i+1]=self.inv(self.fact[i+1],mod)
        self.ans = 0
        self.temp = [0 for i in range(10)]
        self.presum = [[] for i in range(10)]
        for i in range(10):
            base = 0
            for j in range(9,i,-1):
                for _ in range(self.cnt[j]):
                    base+=j
                    self.presum[i].append(base)
        #self.dfs(0,s,n,0,0,mod)
        dp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
        dp[0][0]=1
        ts = 0
        tn = 0
        for ind in range(10):

            temp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
            for n1 in range(n//2+1):
                for s1 in range(s//2+1):
                    n2 = tn - n1
                    s2 = ts - s1
                    if dp[n1][s1]==0:
                        continue
                    for i in range(self.cnt[ind]+1):
                        if n1+i<=n//2 and n2+self.cnt[ind]-i <= n-n//2 and s1+ind*i<=s//2 and s2+ind*(self.cnt[ind]-i) <= s//2:
                            temp[n1+i][s1+ind*i] += dp[n1][s1] * self.comb(n//2-n1,i,mod) * self.comb(n-n//2-n2,self.cnt[ind]-i,mod)
                            temp[n1+i][s1+ind*i] %=mod
            dp = temp
            ts += self.cnt[ind]*ind
            tn += self.cnt[ind]
            
                                    
        return dp[n//2][s//2]",1441362085
Ivan_len,Ivan_len,212,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
        pq.push({0, 0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            if (dp[cur[1]][cur[2]] <= cur[0]) continue;
            dp[cur[1]][cur[2]] = cur[0];
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = cur[1] + dx;
                int new_y = cur[2] + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur[0], moveTime[new_x][new_y]);
                    pq.push({t + 1, new_x, new_y});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441297432
Ivan_len,Ivan_len,212,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.push({0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            int X = cur.second / m;
            int Y = cur.second % m;
            if (dp[X][Y] <= cur.first) continue;
            dp[X][Y] = cur.first;
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = X + dx;
                int new_y = Y + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur.first, moveTime[new_x][new_y]);
                    if (((new_x + new_y) & 1) && t + 1 < dp[new_x][new_y]) {
                        pq.push({t + 1, new_x * m + new_y});
                    }
                    if (((new_x + new_y) % 2 == 0) && t + 2 < dp[new_x][new_y]) {
                        pq.push({t + 2, new_x * m + new_y});
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441303354
Ivan_len,Ivan_len,212,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0;
        int i = 0;
        for (auto c : num) {
            int cnt = (int)(c - '0');
            if (i & 1) a += cnt;
            else a -= cnt;
            i++;
        }
        return a == 0;
    }
};",1441281416
Ivan_len,Ivan_len,212,3637,cpp,"template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
}
 
template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;
 
    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }
 
    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }
 
    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }
 
    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }
 
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }
 
    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }
 
    friend const Type& abs(const Modular& x) { return x.value; }
 
    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);
 
private:
    Type value;
};
 
template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
 
template<typename T, typename U>
Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}
 
template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/
 
constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
 
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<int> cnt(10);
        for (auto c : num) cnt[(int)(c - '0')]++;
        int n = num.size();
        const int shift = ((n + 1) / 2) * 9;
        vector<vector<Mint>> d((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1)), f;
        d[0][shift] = 1; 
        int acc = 0;
        int up = 0, lo = 0;
        for (int i = 0; i <= 9; i++) {
            f.clear();
            f.resize((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1));
            acc += cnt[i];
            for (int even = 0; even <= (n + 1) / 2; even++) {
                for (int ceven = 0; ceven <= even; ceven++) {
                    int codd = cnt[i] - ceven;
                    int odd = acc - even - cnt[i] + ceven;
                    if (codd < 0) break;
                    if (odd > n / 2) break;
                    if (codd > n / 2) continue;
                    if (odd < 0) continue;
                    // even - odd
                    for (int sum = max(-shift, -(i * (n + 1) / 2)); sum <= min(shift, i * (n + 1) / 2); sum++) {
                        int pre = sum - (ceven - codd) * i;
                        if (pre < -shift) continue;
                        if (pre > shift) break;
                        f[even][sum + shift] += d[even - ceven][pre + shift] * C((n + 1) / 2 - (even - ceven), ceven) * C(n / 2 - odd, codd);
                    }
                }
            }
            swap(d, f);
        }
        Mint ans = 0;
        for (int even = 0; even <= ((n + 1) / 2); even++) ans += d[even][shift];
        return (int)ans;
    }
};",1441362584
I_have_learn,I_have_learn,213,3627,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0); 

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();
            if (r == n - 1 && c == m - 1) return currTime;

            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = 1;
                ll newCost = currTime + waitTime + cost;

                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag); 
                }
            }
        }

        return -1;
    }
};
",1441320973
I_have_learn,I_have_learn,213,3628,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        // Min-heap to store (currentTime, row, col, flag)
        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0);  // Start from (0, 0) at time t = 0 with flag = false

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();

            // If we reached the target cell, return the minimum time
            if (r == n - 1 && c == m - 1) return currTime;

            // Visit adjacent cells
            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;

                // Calculate wait time to ensure that we can enter the room
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = flag ? 2 : 1;
                ll newCost = currTime + waitTime + cost;

                // Update if a cheaper path is found
                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag);  // Toggle flag for the next move
                }
            }
        }

        return -1;  // Return -1 if unreachable
    }
};
",1441319656
I_have_learn,I_have_learn,213,3636,cpp,"class Solution {
public:
    bool isBalanced(string nums) {
        int sum1=0,sum2=0;

        for(int i=0;i<nums.size();i+=2) sum1+=nums[i]-'0';

        for(int i=1;i<nums.size();i+=2) sum2+=nums[i]-'0';
        return sum1==sum2;
    }
};",1441284219
I_have_learn,I_have_learn,213,3637,cpp,"#define MOD 1000000007
typedef long long ll;

ll fact[81];
ll inv_fact[81];

ll power_mod(ll x, ll y) {
    ll res = 1;
    x %= MOD;
    while (y > 0) {
        if (y & 1LL) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        y >>= 1LL;
    }
    return res;
}

// Precompute factorials and modular inverses
void compute_factorials() {
    fact[0] = 1;
    for (int i = 1; i <= 80; i++) fact[i] = fact[i - 1] * i % MOD;
    inv_fact[80] = power_mod(fact[80], MOD - 2);
    for (int i = 79; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

// Function to compute C(n, k) % MOD
ll comb(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
}

class Solution {
public:
    ll countBalancedPermutations(string num) {
        compute_factorials();
        
        unordered_map<char, int> freq;
        ll total_sum = 0;
        for (char c : num) {
            freq[c]++;
            total_sum += (c - '0');
        }

        if (total_sum % 2 != 0) return 0;  // Odd total sum means no balanced partition possible
        
        ll target_sum = total_sum / 2;
        int n = num.size();
        int num_even = (n + 1) / 2;
        
        vector<vector<ll>> dp(num_even + 1, vector<ll>(target_sum + 1, 0));
        dp[0][0] = 1;

        for (auto &[digit, count] : freq) {
            int d = digit - '0';
            for (int k = num_even; k >= 0; --k) {
                for (int s = target_sum; s >= 0; --s) {
                    for (int t = 1; t <= count && k + t <= num_even && s + t * d <= target_sum; ++t) {
                        dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb(count, t) % MOD) % MOD;
                    }
                }
            }
        }

        ll C_t = dp[num_even][target_sum];
        if (C_t == 0) return 0;

        ll fact_even = fact[num_even];
        ll fact_odd = fact[n - num_even];
        
        ll denominator = 1;
        for (auto &[digit, f] : freq) {
            denominator = denominator * fact[f] % MOD;
        }
        
        ll result = C_t * fact_even % MOD * fact_odd % MOD * power_mod(denominator, MOD - 2) % MOD;
        return result;
    }
};
",1441356696
nghia0510,phantrongnghia510,214,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[float(""inf"") for _ in range(m)] for _ in range(n)]
        d[0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0)]

        while queue:
            t, i, j = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + 1
                    if nt < d[ni][nj]:
                        d[ni][nj] = nt
                        heappush(queue, (nt, ni, nj))
        return -1
        ",1441316415
nghia0510,phantrongnghia510,214,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[[float(""inf"") ] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0, 0)]

        while queue:
            t, i, j, c = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j][c]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + (1 if not c else 2)
                    nc = c ^ 1
                    if nt < d[ni][nj][nc]:
                        d[ni][nj][nc] = nt
                        heappush(queue, (nt, ni, nj, nc))
        return -1
        ",1441312545
nghia0510,phantrongnghia510,214,3636,python,"class Solution(object):
    def isBalanced(self, num):
        even, odd = 0, 0
    
        for i in range(len(num)):
          if i % 2 == 0:
            even += int(num[i])
          else:
            odd += int(num[i])
    
        return even == odd",1441285916
nghia0510,phantrongnghia510,214,3637,python3,"from collections import Counter
import math

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        count = Counter(num)
        c = [0] * 10
        for d in range(10): 
            c[d] = count.get(chr(d + ord(""0"")), 0)
        total = sum(c[d] * d for d in range(10))
        if total % 2 != 0:
            return 0
        n = len(num)
        H, K  = total // 2, (n + 1) // 2
        dp0 = [[0] * (H + 1) for _ in range(K + 1)]
        dp0[0][0] = 1

        for d in range(10):
            if c[d] == 0:
                continue
            dp1 = [[0] * (H + 1) for _ in range(K + 1)]
            for k in range(K + 1):
                for h in range(H + 1):
                    if dp0[k][h] == 0:
                        continue
                    max_d = min(c[d], K - k)
                    if d > 0:
                        max_d = min(max_d, (H - h) // d)
                    for u in range(max_d + 1):
                        new_k = k + u
                        new_h = h + d * u
                        if new_k > K or new_h > H:
                            continue
                        ways = math.comb(c[d], u)
                        dp1[new_k][new_h] = (dp1[new_k][new_h] + dp0[k][h] * ways) % MOD
            dp0 = dp1

        if dp0[K][H] == 0:
            return 0

        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = (fact[i - 1] * i) % MOD

        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

        prod_inv = 1
        for i in range(10):
            prod_inv = (prod_inv * inv_fact[c[i]]) % MOD

        
        res = dp0[K][H]
        res = (res * fact[K]) % MOD
        res = (res * fact[n - K]) % MOD
        res = (res * prod_inv) % MOD

        return res
",1441394228
hcseo,hcseo,215,3627,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 2;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(1, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return dp[0][n-1][m-1];
    }
};",1441302021
hcseo,hcseo,215,3628,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 3;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(2, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return min(dp[0][n-1][m-1], dp[1][n-1][m-1]);
    }
};",1441300575
hcseo,hcseo,215,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<num.size(); ++i){
            if(i%2==0){
                sum1 += num[i]-'0';
            }else{
                sum2 += num[i]-'0';
            }
        }
        return sum1==sum2;
    }
};",1441281165
hcseo,hcseo,215,3637,cpp,"#define MOD 1000000007

int n;
long long nCr[81][81];

class Solution {
public:
    int countBalancedPermutations(string num) {
        nCr[0][0] = 1;
        for(int i=1; i<81; ++i){
            nCr[i][0] = 1;
            nCr[i][i] = 1;
            for(int j=1; j<i; ++j) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;
        }
        int totalSum = 0;
        n = num.size();
        vector<int> cnt(10);
        for(int i=0; i<n; ++i) {
            totalSum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        if(totalSum%2==1) return 0;
        vector<long long> tmp(totalSum/2+1);
        vector<vector<long long>> dp(n/2+1, tmp); // countOfGroup1 / sumOfGroup1
        dp[0][0] = 1;
        int done = 0;
        int doneSum = 0;
        for(int i=0; i<10; ++i){
            if(cnt[i]==0) continue;
            vector<vector<long long>> dpNext(n/2+1, tmp);
            for(int countOfGroup1 = 0; countOfGroup1<=n/2; ++countOfGroup1){
                for(int sumOfGroup1=0; sumOfGroup1<=totalSum/2; sumOfGroup1++){
                    if(dp[countOfGroup1][sumOfGroup1]==0) continue;
                    int countOfGroup2 = done - countOfGroup1;
                    int sumOfGroup2 = doneSum - sumOfGroup1;
                    for(int j=0; j<=cnt[i]; ++j){
                        int nextSumOfGroup1 = sumOfGroup1+j*i;
                        int nextCountOfGroup1 = countOfGroup1+j;

                        int nextCountOfGroup2 = countOfGroup2 + (cnt[i]-j);
                        int nextSumOfGroup2 = sumOfGroup2 + (cnt[i]-j)*i;

                        if(nextSumOfGroup1>totalSum/2 || nextCountOfGroup1>(n/2) || nextSumOfGroup2> totalSum/2 || nextCountOfGroup2>(n+1)/2) continue;
                        int remainSeats1 = n/2-countOfGroup1;
                        int remainSeats2 = (n+1)/2-countOfGroup2;
                        long long nowWays = (nCr[remainSeats1][j] * nCr[remainSeats2][cnt[i]-j])%MOD;
                        nowWays = (nowWays*dp[countOfGroup1][sumOfGroup1])%MOD;
                        dpNext[nextCountOfGroup1][nextSumOfGroup1] = (dpNext[nextCountOfGroup1][nextSumOfGroup1] + nowWays)%MOD;
                    }
                }
            }
            done += cnt[i];
            doneSum += cnt[i]*i;
            dp = dpNext;
        }
        return dp[n/2][totalSum/2];
    }
};",1441388329
lukewu28,lukewu28,216,3627,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1, npos});
            }
        }
        
        return -1;
    }
};",1441300860
lukewu28,lukewu28,216,3628,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            
            int par = (i + j) % 2; 
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1 + par, npos});
            }
        }
        
        return -1;
    }
};",1441303488
lukewu28,lukewu28,216,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int r = 0;
        for(int i = 0 ; i < num.size(); i++){
            if(i % 2) r -= num[i] - '0';
            else r += num[i] - '0';
        }
        return r == 0;
    }
};",1441288436
lukewu28,lukewu28,216,3637,cpp,"typedef long long ll;
typedef pair<ll, ll> PII;
    const int MAXN = 80;

    const ll MOD = 1000000007;
class Solution {
public:
    ll fac[81], invfac[81];
    ll inv(ll x){return x>1?inv(MOD%x)*(MOD-MOD/x)%MOD:x;}
    void factorial() {
        fac[0] = 1;
        for (ll i = 1; i <= MAXN; i++) {
            fac[i] = fac[i - 1] * i % MOD;
        }
    }
    void inverses() {
        invfac[MAXN] = inv(fac[MAXN]);
        for (ll i = MAXN; i >= 1; i--) {
            invfac[i - 1] = invfac[i] * i % MOD;
        }
    }
    ll C(ll g, ll r) {
        return fac[g] * invfac[r] % MOD * invfac[g - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        int sum = 0;
        
        factorial();
        inverses();
        
        int freq[10] = {};
        for(int i : num) sum += i - '0', freq[i - '0']++;
        if(sum % 2) return 0;
        sum /= 2;
        
        int n = num.size() / 2;
        
        vector<vector<PII>> dp(n + 1, vector<PII>(sum + 1, {0, 0})), dp2(n + 1, vector<PII>(sum + 1, {0, 0}));
        for(int i = 0; i <= min(n, freq[0]); i++){
            dp2[n - i][sum].first = invfac[i] * invfac[freq[0] - i] % MOD;
        }
//         cout << 0 << endl;
//         for(int cnt = 0; cnt <= n; cnt++){
//                 for(int s = 0; s <= sum; s++){

//                     cout << cnt << ' ' << s << ' ' << dp2[cnt][s].first << ' '  << dp2[cnt][s].second << endl;
//                 }
//             }
        for(int i = 1; i < 10; i++){
            // cout << i << ' ' << freq[i] << endl;
            for(int cnt = 0; cnt <= n; cnt++){
                for(int s = 0; s <= sum; s++){
                    dp[cnt][s] = {0 , 0};
                    for(int k = 0; k <= freq[i]; k++){
                        if(s + k*i > sum || cnt + k > n) continue;
                        
                        ll curfac = invfac[k] * invfac[freq[i] - k] % MOD;
                        dp[cnt][s].first = (dp[cnt][s].first + (dp2[cnt + k][s + k*i].first * curfac % MOD) )% MOD;
                        // dp[cnt][s].second = (dp[cnt][s].second + (dp2[cnt + k][s + k*i].second *  % MOD) )% MOD;
                    }

                    // cout << cnt << ' ' << s << ' ' << dp[cnt][s].first << ' '  << dp[cnt][s].second << endl;
                }
            }
            swap(dp, dp2);
        }
        
        ll re = ((dp2[0][0].first * fac[n] % MOD) * fac[num.size() - n] % MOD) % MOD;
        return re;
    }
};",1441376281
vedantgore_2004,vedantgore_2004,217,3627,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<int,pair<int,int>> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({0,{0,0}});
        while(!q.empty()){
            ll t=q.top().first;
            ll x=q.top().second.first;
            ll y=q.top().second.second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+1;
                    if(vis[xx][yy]==-1)
                    q.push({tt,{xx,yy}});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441310976
vedantgore_2004,vedantgore_2004,217,3628,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<pair<int,pair<int,int>>,int> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({{0,{0,0}},1});
        while(!q.empty()){
            ll t=q.top().first.first;
            ll x=q.top().first.second.first;
            ll y=q.top().first.second.second;
            ll move=q.top().second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+move;
                    if(vis[xx][yy]==-1)
                    q.push({{tt,{xx,yy}},(move==1? 2:1)});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441317292
vedantgore_2004,vedantgore_2004,217,3636,cpp,"class Solution {
public:
    bool isBalanced(string a) {
        int x=0;
        int y=0;
        for(int i=0;i<a.size();i++){
            if(i&1){
                x+=a[i]-'0';
            }else y+=a[i]-'0';
        }
        return x==y;
    }
};",1441282073
vedantgore_2004,vedantgore_2004,217,3637,cpp,"class Solution {
public:
    typedef long long ll;
    const int mod = 1e9 + 7;
    ll fact[81], ifact[81];

    ll modPow(ll x, ll y, ll p) {
        ll res = 1;
        x %= p;
        while (y > 0) {
            if (y & 1)
                res = res * x % p;
            y >>= 1;
            x = x * x % p;
        }
        return res;
    }

    // Function to find modular inverse of b under MOD
    ll modInverse(ll b, ll mod) { return modPow(b, mod - 2, mod); }

    // Function to perform modular division a / b under MOD
    ll div(ll a, ll b, ll mod) { return (a * modInverse(b, mod)) % mod; }

    void precompute() {
        fact[0] = 1;
        for (ll i = 1; i <= 80; i++)
            fact[i] = fact[i - 1] * i % mod;
        for (ll i = 0; i <= 80; i++)
            ifact[i] = modPow(fact[i], mod - 2, mod);
    }

    ll func(ll ind, ll tk, ll sum, string& s, vector<vector<vector<ll>>>& dp) {
        ll n = s.size();
        if (ind == n) {
            return sum == 0 && tk == 0;
        }
        if (dp[ind][tk][sum] != -1)
            return dp[ind][tk][sum];
        ll i = s[ind] - '0';
        ll ways = func(ind + 1, tk, sum, s, dp);
        if (sum >= i && tk > 0) {
            ways = (ways + func(ind + 1, tk - 1, sum - i, s, dp)) % mod;
        }
        return dp[ind][tk][sum] = ways;
    }
    int countBalancedPermutations(string s) {
        ll n = s.size();
        ll sum = 0;
        map<ll, ll> fr;
        for (int i = 0; i < n; i++) {
            sum += (s[i] - '0');
            fr[s[i] - '0']++;
        }
        if (sum & 1)
            return 0;
        else
            sum /= 2;
        precompute();
        ll k = n / 2;
        ll rem = n - k;
        vector<vector<vector<ll>>> dp(
            n + 1, vector<vector<ll>>(k + 1, vector<ll>(sum + 1, -1)));
        ll ways = func(0, k, sum, s, dp);
        ways = (ways * fact[rem]) % mod;
        ways = (ways * fact[k]) % mod;
        // cout<<ways<<endl;
        for(int i=0;i<=9;i++){
            ll x=fr[i];
            if(x>1){
                ways=div(ways,fact[x],mod);
            }
        }
        return ways%mod;
    }
};",1441382415
Kashyap Sukshavasi,enkixly,218,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dungeonHeight = moveTime.size();
        int dungeonWidth = moveTime[0].size();
        
        int finalRoomX = dungeonHeight - 1;
        int finalRoomY = dungeonWidth - 1;
        
        vector<vector<int>> quickestPath(dungeonHeight, vector<int>(dungeonWidth, INT_MAX));
        
        queue<pair<int, pair<int, int>>> roomQueue;
        roomQueue.push({0, {0, 0}});
        quickestPath[0][0] = 0;
        
        vector<pair<int, int>> possibleMoves = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!roomQueue.empty()) {
            int timeSpent = roomQueue.front().first;
            int myX = roomQueue.front().second.first;
            int myY = roomQueue.front().second.second;
            roomQueue.pop();
            
            if (timeSpent > quickestPath[myX][myY]) continue;
            
            for (auto& nextMove : possibleMoves) {
                int nextX = myX + nextMove.first;
                int nextY = myY + nextMove.second;
                
                if (nextX >= 0 && nextX < dungeonHeight && nextY >= 0 && nextY < dungeonWidth) {
                    int timeToNext = max(timeSpent, moveTime[nextX][nextY]) + 1;
                    
                    if (timeToNext < quickestPath[nextX][nextY]) {
                        quickestPath[nextX][nextY] = timeToNext;
                        roomQueue.push({timeToNext, {nextX, nextY}});
                    }
                }
            }
        }
        
        return quickestPath[finalRoomX][finalRoomY];
    }
};",1441291465
Kashyap Sukshavasi,enkixly,218,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int height = moveTime.size();
        int width = moveTime[0].size();
        
        vector<vector<long long>> bestOddPath(height, vector<long long>(width, LLONG_MAX));
        vector<vector<long long>> bestEvenPath(height, vector<long long>(width, LLONG_MAX));
        
        priority_queue<pair<long long, tuple<int, int, int>>, 
                      vector<pair<long long, tuple<int, int, int>>>, 
                      greater<>> paths;
                      
        paths.push({0, {0, 0, 0}});
        bestEvenPath[0][0] = 0;
        
        int row[] = {-1, 0, 1, 0};
        int col[] = {0, 1, 0, -1};
        
        while (!paths.empty()) {
            auto [time, current] = paths.top();
            auto [x, y, steps] = current;
            paths.pop();
            
            if ((steps % 2 == 0 && time > bestEvenPath[x][y]) || 
                (steps % 2 == 1 && time > bestOddPath[x][y])) {
                continue;
            }
            
            if (x == height-1 && y == width-1) {
                return time;
            }
            
            for (int i = 0; i < 4; i++) {
                int nextX = x + row[i];
                int nextY = y + col[i];
                
                if (nextX < 0 || nextY < 0 || nextX >= height || nextY >= width) continue;
                
                long long nextTime = max(time, (long long)moveTime[nextX][nextY]) + (steps % 2 == 0 ? 1 : 2);
                bool isNextOdd = !bool(steps % 2);
                auto& bestPath = isNextOdd ? bestOddPath : bestEvenPath;
                
                if (nextTime < bestPath[nextX][nextY]) {
                    bestPath[nextX][nextY] = nextTime;
                    paths.push({nextTime, {nextX, nextY, steps + 1}});
                }
            }
        }
        
        return -1;
    }
};",1441296965
Kashyap Sukshavasi,enkixly,218,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for (int i = 0; i < num.size(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                even += digit;
            } else {
                odd += digit;
            }
        }
        return even == odd;
    }
};
",1441286920
Kashyap Sukshavasi,enkixly,218,3637,python3,"MOD = 1000000007

def powerModFunc(a, b):
    res = 1
    a %= MOD
    while b > 0:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def initFact(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invFact = [1] * (n + 1)
    invFact[n] = powerModFunc(fact[n], MOD - 2)
    for i in range(n - 1, -1, -1):
        invFact[i] = invFact[i + 1] * (i + 1) % MOD
    return fact, invFact

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        totalSum = 0
        
        for c in num:
            d = int(c)
            freq[d] += 1
            totalSum += d
        
        if totalSum % 2 != 0:
            return 0
        
        sumHalf = totalSum // 2
        k = (n + 1) // 2
        
        fact, invFact = initFact(n)
        
        dp = [[0] * (sumHalf + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d in range(10):
            if freq[d] == 0:
                continue
            for c in range(k, -1, -1):
                for s in range(sumHalf, -1, -1):
                    if dp[c][s] == 0:
                        continue
                    for t in range(1, min(freq[d], k - c) + 1):
                        if s + d * t > sumHalf:
                            break
                        comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD
        
        validAssignments = dp[k][sumHalf]
        if validAssignments == 0:
            return 0
        
        prodFactFd = 1
        for d in range(10):
            prodFactFd = prodFactFd * fact[freq[d]] % MOD
        
        fkFnk = (fact[k] * fact[n - k]) % MOD
        invProdFactFd = powerModFunc(prodFactFd, MOD - 2)
        answer = (fkFnk * validAssignments) % MOD
        answer = (answer * invProdFactFd) % MOD
        
        return answer
",1441382904
RONAK GARG,Ronak9910,219,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<tuple<long long, int, int>>> pq;
        pq.push({0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1);
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny});
                    }
                }
            }
        }
        return -1;
    }
};",1441303897
RONAK GARG,Ronak9910,219,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, greater<tuple<long long, int, int, int>>> pq;
        pq.push({0, 0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y, l] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1) + l;
                    bool m = 0;
                    if(l == 0)
                        m = 1;
                    else
                        m = 0;
                        
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny, m});
                    }
                }
            }
        }
        return -1;
    }
};",1441316741
RONAK GARG,Ronak9910,219,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < n; i++)
        {
            int val = num[i] - '0';
            if(i & 1)
                sum1 += val;
            else
                sum2 += val;
        }
        return (sum1 == sum2);
    }
};",1441283517
RONAK GARG,Ronak9910,219,3637,cpp,"class Solution {
private:
    long long modInv(long long a, int m) {
        long long res = 1, base = a, p = m - 2;
        while (p > 0) {
            if (p & 1) res = (res * base) % m;
            base = (base * base) % m;
            p >>= 1;
        }
        return res;
    }

    long long comb(int n, int k, const vector<long long>& fact, const vector<long long>& inv_fact) {
        if (k > n) return 0;
        return ((fact[n] * inv_fact[k]) % MOD * inv_fact[n - k]) % MOD;
    }

    static const int MOD = 1e9 + 7;

public:
    int countBalancedPermutations(const std::string& num) {
        int len = num.length();
        int total = 0;
        for(auto i : num)
                total += (i - '0');
        if (total % 2 != 0) return 0;

        int half = total / 2;
        int m = (len + 1) / 2;
        std::vector<int> cnt(10, 0);
        for (char d : num) cnt[d - '0']++;

        vector<long long> fact(len + 1, 1);
        for (int i = 1; i <= len; i++) fact[i] = (fact[i - 1] * i) % MOD;

        vector<long long> inv_fact(len + 1, 1);
        inv_fact[len] = modInv(fact[len], MOD);
        for (int i = len - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;

        vector<vector<long long>> dp(m + 1, vector<long long>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            for (int k = m; k >= 0; k--) {
                for (int s = half; s >= 0; s--) {
                    if (dp[k][s] == 0) continue;
                    for (int t = 1; t <= cnt[d]; t++) {
                        if (k + t > m || s + d * t > half) break;
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(cnt[d], t, fact, inv_fact)) % MOD;
                    }
                }
            }
        }

        long long w = dp[m][half];
        long long res = (fact[m] * fact[len - m]) % MOD;
        for (int d = 0; d < 10; d++) res = (res * inv_fact[cnt[d]]) % MOD;
        res = (res * w) % MOD;
        return (res);
    }
};
",1441383218
Sam Chen,SamChen856,220,3627,python3,"class Solution:
    # Dijkstra, priority queue, time O(nmlog(nm)), space O(nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]  # (current time, x, y)
        
        while pq:
            t, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + 1
                    if dist[nx][ny] > new_t:
                        dist[nx][ny] = new_t
                        heappush(pq, (new_t, nx, ny))

        assert False",1441304382
Sam Chen,SamChen856,220,3628,python3,"class Solution:
    # Dijkstra, priority queue, time O(2nmlog(nm)), space O(2nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[[inf] * m for _ in range(n)] for _ in range(3)]
        dist[1][0][0] = 0  # (speed, x, y)
        pq = [(0, 1, 0, 0)]  # (current time, speed, x, y)

        while pq:
            t, s, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[s][x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + s
                    new_s = 3 - s
                    if dist[new_s][nx][ny] > new_t:
                        dist[new_s][nx][ny] = new_t
                        heappush(pq, (new_t, new_s, nx, ny))

        assert False
        ",1441312485
Sam Chen,SamChen856,220,3636,python3,"class Solution:
    # 1 pass, time O(n), space O(1)
    def isBalanced(self, num: str) -> bool:
        sums = [0, 0]
        for i, x in enumerate(num):
            sums[i % 2] += int(x)
        return sums[0] == sums[1]",1441289057
Sam Chen,SamChen856,220,3637,python3,"M = 1000
MOD = 10**9 + 7

fact = [1] * (M + 1)
for i in range(M):
    fact[i + 1] = fact[i] * (i + 1) % MOD
inv_fact = [1] * (M + 1)
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for i in reversed(range(M)):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


class Solution:
    # DP + combinatorics, time O(100L^3), space O(10L^2), L = num.length
    def countBalancedPermutations(self, num: str) -> int:
        num = list(map(int, num))

        target_sum = sum(num)
        if target_sum % 2:
            return 0
        target_sum //= 2

        L = len(num)
        L_even = (L + 1) // 2
        cnt = Counter(num)
        dp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
        dp[0][0] = 1

        for d in range(10):
            ndp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
            for i in range(L_even + 1):
                for j in range(target_sum + 1):
                    if dp[i][j] == 0:
                        continue
                    for c in range(min(cnt[d], L_even - i) + 1):
                        ni, nj = i + c, j + d * c
                        if nj <= target_sum:
                            ndp[ni][nj] = (ndp[ni][nj] + dp[i][j] * inv_fact[c] * inv_fact[cnt[d] - c]) % MOD
            dp = ndp

        return fact[L_even] * fact[L - L_even] * dp[L_even][target_sum] % MOD",1441383568
Ayush Sharma,ayush-018,221,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        int r = moveTime.size();
        int c = moveTime[0].size();

        vector<vector<int>> minDist(r, vector<int>(c, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;

        minHeap.push({0, 0, 0}); // {time, row, col}
        minDist[0][0] = 0;

        vector<vector<int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!minHeap.empty()) {
            auto current = minHeap.top();
            minHeap.pop();
            int cT = current[0];
            int cR = current[1];
            int cC = current[2];

            if (cT > minDist[cR][cC]) continue;

            for (const auto& d : direction) {
                int newRow = cR + d[0];
                int newCol = cC + d[1];

                if (newRow >= 0 && newRow < r && newCol >= 0 && newCol < c) {
                    int newTime = max(cT, moveTime[newRow][newCol]) + 1;

                    if (newTime < minDist[newRow][newCol]) {
                        minDist[newRow][newCol] = newTime;
                        minHeap.push({newTime, newRow, newCol});
                    }
                }
            }
        }

        return minDist[r - 1][c - 1] == INT_MAX ? -1 : minDist[r - 1][c - 1];

    }
};",1441321399
Ayush Sharma,ayush-018,221,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<int>>> minTime(n, vector<vector<int>>(m, vector<int>(2, numeric_limits<int>::max())));
        minTime[0][0][0] = 0;

        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> gPq;
        gPq.push({0, {0, 0, 0}});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!gPq.empty()) {
            auto [currentTime, pos] = gPq.top();
            gPq.pop();
            int row = pos[0], col = pos[1], parity = pos[2];

            if (currentTime > minTime[row][col][parity]) continue;

            for (auto [dx, dy] : directions) {
                int x = row + dx;
                int y = col + dy;

                if (x >= 0 && x < n && y >= 0 && y < m) {
                    int nextTime = max(currentTime, moveTime[x][y]) + (parity == 0 ? 1 : 2);
                    
                    if (nextTime < minTime[x][y][1 - parity]) {
                        minTime[x][y][1 - parity] = nextTime;
                        gPq.push({nextTime, {x, y, 1 - parity}});
                    }
                }
            }
        }
        
        return min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
};",1441327061
Ayush Sharma,ayush-018,221,3636,cpp,"class Solution {
private:
    int calculateEven(const string& num) {
        int evenSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            }
        }
        return evenSum;
    }

    int calculateOdd(const string& num) {
        int oddSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 != 0) {
                oddSum += num[i] - '0';
            }
        }
        return oddSum;
    }
public:
    bool isBalanced(string num) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int evenSum = calculateEven(num);
        int oddSum = calculateOdd(num);
        if(evenSum==oddSum) return true;
        else return false;
    }
};",1441291164
Ayush Sharma,ayush-018,221,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int n = num.size();
        int evenC = (n + 1) / 2;
        int oddC = n / 2;

        string inputString = num;
        int digitCount[10] = {0};
        for (char digit : num) {
            digitCount[digit - '0']++;
        }

        long long totalSum = 0;
        for (int digit = 0; digit < 10; digit++) {
            totalSum += (long long)digit * digitCount[digit];
        }

        if (totalSum % 2 != 0) return 0;

        long long targetSum = totalSum / 2;
        vector<long long> factorial = preFact(80, MOD);
        vector<long long> invFact = ComputeFact(factorial, MOD);

        auto comb = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFact[k] % MOD * invFact[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenC + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int digit = 0; digit < 10; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int t = evenC; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int k = 1; k <= digitCount[digit] && t + k <= evenC && s + (long long)digit * k <= targetSum; k++) {
                        dp[t + k][s + (long long)digit * k] = (dp[t + k][s + (long long)digit * k] + dp[t][s] * comb(digitCount[digit], k)) % MOD;
                    }
                }
            }
        }

        long long validAssign = dp[evenC][targetSum];
        long long productFactorial = 1;
        for (int digit = 0; digit < 10; digit++) {
            productFactorial = productFactorial * factorial[digitCount[digit]] % MOD;
        }

        long long result = validAssign;
        result = result * factorial[evenC] % MOD;
        result = result * factorial[oddC] % MOD;
        long long inverseProduct = power(productFactorial, MOD - 2, MOD);
        result = result * inverseProduct % MOD;

        return (int)result;
    }

private:
    vector<long long> preFact(int maxValue, int mod) {
        vector<long long> factorial(maxValue + 1, 1);
        for (int i = 1; i <= maxValue; i++) {
            factorial[i] = factorial[i - 1] * i % mod;
        }
        return factorial;
    }

    vector<long long> ComputeFact(const vector<long long>& factorial, int mod) {
        int maxValue = factorial.size() - 1;
        vector<long long> invFact(maxValue + 1, 1);
        invFact[maxValue] = power(factorial[maxValue], mod - 2, mod);
        for (int i = maxValue - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod;
        }
        return invFact;
    }

    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }
};
",1441365481
Evan Tian,etian6795,222,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][] d = new long[n][m];
        boolean[][] seen = new boolean[n][m];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = Long.MAX_VALUE;
            }
        }
        d[0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[2], b[2]));
        pq.add(new long[]{0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            long time = curr[2];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y]) continue;
            seen[x][y] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + 1;

                    if(next <= moveTime[nx][ny] + 1) {
                        next = moveTime[nx][ny] + 1;
                    }


                    if(next < d[nx][ny]) {
                        d[nx][ny] = next;
                        pq.add(new long[]{nx, ny, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342435
Evan Tian,etian6795,222,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][][] d = new long[n][m][2];
        boolean[][][] seen = new boolean[n][m][2];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                Arrays.fill(d[i][j], Long.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[3], b[3]));
        pq.add(new long[]{0, 0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            int p = (int)curr[2];
            long time = curr[3];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y][p]) continue;
            seen[x][y][p] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + ((p == 0) ? 1 : 2);

                    if(next <= moveTime[nx][ny] + ((p == 0) ? 1 : 2)) {
                        next = moveTime[nx][ny] + ((p == 0) ? 1 : 2);
                    }

                    int nextp = 1 - p;

                    if(next < d[nx][ny][nextp]) {
                        d[nx][ny][nextp] = next;
                        pq.add(new long[]{nx, ny, nextp, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342250
Evan Tian,etian6795,222,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int e = 0;
        int o = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = Character.getNumericValue(num.charAt(i));
            if (i % 2 == 0) {
                e += digit;
            } else {
                o += digit;
            }
        }

        return e == o;
    }
}",1441343466
Evan Tian,etian6795,222,3637,java,"class Solution {
    public long MOD = 1_000_000_007;
    public long[] fact;
    public long[] invFact;
    public int n;
    public int[] f = new int[10];
    Map<String, Long> memo;

    public int countBalancedPermutations(String num) {
        for(char c : num.toCharArray()){
            f[c - '0']++;
        }
        n = num.length();

        int target = 0;
        for(int i = 0; i <= 9; i++) {
            target += i * f[i];
        }

        if(target % 2 != 0){
            return 0;
        }
        target /= 2;

        int e = (n + 1) / 2;
        int o = n / 2;

        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        invFact[n] = expo(fact[n], MOD - 2);
        for(int i = n - 1; i >= 0; i--){
            invFact[i] = (invFact[i+1] * (i+1)) % MOD;
        }

        memo = new HashMap<>();

        long qwe = rec(0, target, e);

        long asd = 1;
        for(int i = 0; i <= 9; i++) {
            if(f[i] > n) {
                return 0;
            }
            asd = (asd * fact[f[i]]) % MOD;
        }
        asd = expo(asd, MOD - 2);

        long ans = fact[e] * fact[o] % MOD;
        ans = (ans * qwe) % MOD;
        ans = (ans * asd) % MOD;

        return (int)(ans);
    }

    private long rec(int digit, int sum, int count){
        String key = digit + "","" + sum + "","" + count;

        if(memo.containsKey(key)){
            return memo.get(key);
        }

        if(digit == 10){
            if(sum == 0 && count == 0){
                return 1;
            }
            else{
                return 0;
            }
        }

        if(sum < 0 || count < 0){
            return 0;
        }

        long total = 0;
        int max = Math.min(count, f[digit]);
        for(int i = 0; i <= max; i++){
            if(i * digit > sum){
                break;
            }
            
            long qwe = combination(f[digit], i);

            total = (total + qwe * rec(digit + 1, sum - i * digit, count - i)) % MOD;
        }

        memo.put(key, total);
        return total;
    }

    private long combination(int n, int k){
        if(k < 0 || k > n){
            return 0;
        }
        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;
    }

    private long expo(long a, long b){
        long res =1;
        a %= MOD;
        while(b >0){
            if( (b &1) ==1 ){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>=1;
        }
        return res;
    }
}
",1441384193
Paridhi Agarwal,paridhi_,224,3627,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>
#include <array>

class Solution
{
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, std::numeric_limits<int>::max()));
        int i = 0;
        if (n > 0)
            do
            {
                std::fill(dist[i].begin(), dist[i].end(), std::numeric_limits<int>::max());
                i++;
            }
            while (!(i < n)==false);
        using T = std::array<int, 3>;
        auto cmp = [](const T& a, const T& b) { return a[0] > b[0]; };
        std::priority_queue<T, std::vector<T>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        std::vector<std::vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (; (!(!pq.empty())==false);)
        {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0;
            while (!(dirIndex < dirs.size()) ==false)
            {
                auto dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = std::max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
        }
        return dist[n - 1][m - 1];
    }
};
",1441371856
Paridhi Agarwal,paridhi_,224,3628,cpp,"#include <vector>
#include <queue>
#include <array>
#include <climits>
#include <functional>
class Solution
{
public:
    int minTimeToReach(const std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<std::array<int, 2>>> d(n, std::vector<std::array<int, 2>>(m, {INT_MAX, INT_MAX}));
        int i = 0;
        do
        {
            int j = 0;
            while (j < m)
            {
                d[i][j][0] = INT_MAX;
                d[i][j][1] = INT_MAX;
                j++;
            }
            i++;
        }
        while (i < n);
        d[0][0][0] = 0;
        auto cmp = [](const std::array<int, 4>& a, const std::array<int, 4>& b) {
            return a[0] > b[0];
        };
        std::priority_queue<std::array<int, 4>, std::vector<std::array<int, 4>>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0, 0});
        std::vector<std::array<int, 2>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for (; !(!pq.empty()) == false; )
        {
            auto current = pq.top();
            pq.pop();
            int t = current[0];
            int iCur = current[1];
            int jCur = current[2];
            int p = current[3];
            
            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            
            int dirIndex = 0;
            while (!(dirIndex < directions.size()) == false)
            {
                auto dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = std::max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            }
        }
        return std::min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};
",1441353548
Paridhi Agarwal,paridhi_,224,3636,cpp,"#include <string>
class Solution
{
public:
    bool isBalanced(const std::string& num)
    {
        int evenSum = 0;
        int oddSum = 0;
        int i = 0;
        do
        {
            int digit = num[i] - '0';
            if (!(i % 2 == 0) == false) 
                evenSum += digit;
            else
                oddSum += digit;
            i++;
        }
        while (!(i < num.length()) == false);
        return (!(evenSum == oddSum) == false);
    }
};
",1441295940
Paridhi Agarwal,paridhi_,224,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>

class Solution {
private:
    static const int MOD = 1000000007;
    std::vector<long long> fact;
    std::vector<long long> invFact;

    long long powerMod(long long a, long long b) {
        long long res = 1;
        a %= MOD;
        while (b > 0) {
            if (!((b & 1) == 1) == false) {
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void initFact(int n) {
        fact.resize(n + 1);
        invFact.resize(n + 1);
        fact[0] = 1;
        int i = 1;
        do {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        } while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        } while (j >= 0);
    }

public:
    int countBalancedPermutations(std::string num) {
        int n = num.length();
        std::vector<int> freq(10, 0);
        long long totalSum = 0;
        std::vector<char> C(num.begin(), num.end());
        int i = 0;
        if (n > 0) {
            do {
                char c = C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            } while (i < n);
        }

        if (!(totalSum % 2 != 0) == false) {
            return 0;
        }
        long long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        std::vector<std::vector<long long>> dp(k + 1, std::vector<long long>((int)sumHalf + 1, 0));
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0) == false)
            {
                d++;
                continue;
            }
            int c = k;
            while (c >= 0)
            {
                long long s = sumHalf;
                do
                {
                    if (!(dp[c][(int)s] == 0) == false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    while (true)
                    {
                        if (!(t > std::min(freq[d], k - c)) == false)
                            break;
                        if (!(s + (long long)d * t > sumHalf) == false)
                            break;
                        long long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int)(s + d * t)] = (dp[c + t][(int)(s + d * t)] + dp[c][(int)s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                while (s >= 0);
                c--;
            }
            d++;
        }
        while (d <= 9);
        long long validAssignments = dp[k][(int)sumHalf];
        if (!(validAssignments == 0) == false) {
            return 0;
        }
        long long prodFactFd = 1;
        int digit = 0;
        while (digit <= 9)
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        long long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int)answer;
    }
};
",1441396969
jacobj2,jacobj2,225,3627,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[inf]*len(m[0]) for i in range(len(m))]
        dp[0][0] = inf
        heap = [(0,0,0)]
        while heap:
            time, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc] > max(time + 1, m[dr][dc] + 1):
                    dp[dr][dc] = max(time+1,m[dr][dc] + 1)
                    heappush(heap, (dp[dr][dc],dr,dc))
        return -1",1441301318
jacobj2,jacobj2,225,3628,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[[inf,inf] for _ in range(len(m[0]))] for i in range(len(m))]
        dp[0][0][0] = 0
        heap = [(0,0,0,0)]
        while heap:
            time, od, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if od==0:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 1, m[dr][dc] + 1):
                        dp[dr][dc][1-od] = max(time+1,m[dr][dc] + 1)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
                elif od==1:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 2, m[dr][dc] + 2):
                        dp[dr][dc][1-od] = max(time+2,m[dr][dc] + 2)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
        return -1",1441304952
jacobj2,jacobj2,225,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i in range(len(num)):
            if i%2==0:
                e+=int(num[i])
            else:
                o+=int(num[i])
        return e==o",1441280777
jacobj2,jacobj2,225,3637,python3,"MOD = 10**9+7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        tot = 0
        for i in range(len(num)):
            tot+=int(num[i])
        if tot%2==1:
            return 0
        ct = defaultdict(int)
        for i in range(len(num)):
            ct[int(num[i])]+=1
        r1 = len(num) - len(num)//2
        pref = [0]*10
        for i in range(len(pref)):
            pref[i] = ct[i]
            if i > 0:
                pref[i]+=pref[i-1]
        #print(pref)
        @cache
        def dfs(index, remSum, remInd):
            if remSum < 0 or remInd < 0:
                return 0
            if index==10:
                return int(remSum==0 and remInd==0)
            usedOdd = 0 if index==0 else pref[index - 1] - (len(num)//2 - remInd)
            leftOdd = len(num) - len(num)//2 - usedOdd
            if leftOdd < 0:
                return 0
            res = 0
            for x in range(ct[index]+1):
                left = ct[index] - x
                if left > leftOdd:
                    continue
                res+=(((dfs(index+1,remSum-x*index, remInd - x)*math.comb(remInd, x))%MOD)*math.comb(leftOdd,left))%MOD
                if res >= MOD:
                    res-=MOD
            return res
        a = dfs(0,tot//2,len(num)//2)
        dfs.cache_clear()
        return a",1441372719
IphoneX,hahahiehie,226,3627,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + e.w) {
                        if (w + e.w > board[e.to]) {
                            dist[e.to] = w + e.w;
                            q.add(new Edge(e.to, w + e.w));
                        } else {
                            dist[e.to] = board[e.to] + 1;
                            q.add(new Edge(e.to, board[e.to] + 1));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441298213
IphoneX,hahahiehie,226,3628,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            int last;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }

            public Edge(int to, long w, int last) {
                this.to = to;
                this.w = w;
                this.last = last;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0, 2));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                int last = cur.last;
                int nextStep = last == 1 ? 2 : 1;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + nextStep) {
                        if (w + nextStep >= board[e.to] + nextStep) {
                            dist[e.to] = w + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        } else {
                            dist[e.to] = board[e.to] + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441304580
IphoneX,hahahiehie,226,3636,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    public boolean isBalanced(String num) {
        int n = num.length();
        int a = 0;
        int b = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                a += num.charAt(i) - '0';
            } else {
                b += num.charAt(i) - '0';
            }
        }
        return a == b;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441281429
IphoneX,hahahiehie,226,3637,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static Combination comb = new Combination(100, MOD);
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int sum = 0;
        int targetLength0 = 0;
        int targetLength1 = 0;
        long[] digitCount = new long[10];
        for (int i = 0; i < n; i++) {
            sum += num.charAt(i) - '0';
            digitCount[num.charAt(i) - '0']++;
            if (i % 2 == 0) {
                targetLength0++;
            } else {
                targetLength1++;
            }
        }
        if (sum % 2 != 0) return 0;
        int targetSum = sum / 2;


        long[][][] dp = new long[10][n + 1][sum + 1];

        for (int i = 0; i <= digitCount[0] && i <= targetLength0; i++) {
            if (targetLength0 >= i && targetLength1 >= (int) digitCount[0] - i) {
                dp[0][i][0] = comb.C(targetLength0, i) * comb.C(targetLength1, (int) digitCount[0] - i) % MOD;
            }
        }

        int[] preSum = new int[10];
        preSum[0] = (int) digitCount[0];
        for (int i = 1; i < 10; i++) {
            preSum[i] = preSum[i - 1] + (int) digitCount[i];
        }
        for (int i = 1; i <= 9; i++) {

            for (int j = 0; j <= targetLength0; j++) {
                for (int k = 0; k <= targetSum; k++) {
                    if (dp[i - 1][j][k] == 0) continue;

                    for (int c = 0; c <= digitCount[i]; c++) {
                        if (c + j > targetLength0) break;
                        if (c * i + k > targetSum) break;
                        int c2 = (int) digitCount[i] - c;
                        int len2 = targetLength1 - (preSum[i - 1] - j);
                        if (len2 >= 0 && len2 <= targetLength1 && len2 >= c2) {
                            dp[i][j + c][k + c * i] = (dp[i][j + c][k + c * i] + dp[i - 1][j][k] * comb.C(targetLength0 - j, c) % MOD * comb.C(len2, c2)) % MOD;
                        }
                    }
                }
            }
        }
        return (int) dp[9][targetLength0][targetSum];


    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441385012
JOZLEETCODE,JLZ998112,227,3627,java,"class Solution {
    private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][] dist = new int[m][n];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i], Max);
            }
        }
        dist[0][0] = 0;        
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x,y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            if(r==m-1 && c==n-1){
                return cd;
            }
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n && dist[nr][nc] == Max){
                    int nd = Math.max(cd+1, g[nr][nc]+1);
                    dist[nr][nc] = nd;
                    pq.offer(new int[]{nr, nc, nd});
                }
            }
        }
        return -1;
    }
}",1441294725
JOZLEETCODE,JLZ998112,227,3628,java,"class Solution {
     private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][][] dist = new int[m][n][3];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i][j], Max);
            }
        }
        dist[0][0][1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x, y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0, 1});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            int steps = top[3];
            if(r==m-1 && c==n-1){
                return cd;
            }
            int nsteps = (steps == 1?2:1);
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n ){
                    int nd = Math.max(cd+steps, g[nr][nc]+steps);
                    if(dist[nr][nc][nsteps] > nd){
                        dist[nr][nc][nsteps] = nd;
                        pq.offer(new int[]{nr, nc, nd, nsteps});
                    }
                }
            }
        }
        return -1;
    }
}",1441305565
JOZLEETCODE,JLZ998112,227,3636,java,"class Solution {
    public boolean isBalanced(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int odd = 0;
        int even = 0;
        for(int i=0; i<n; ++i){
            int cind = c[i]-'0';
            if(i%2==0){
                even += cind;
            }else{
                odd += cind;
            }
        }
        return odd == even;
    }
}",1441283731
JOZLEETCODE,JLZ998112,227,3637,java,"class Solution {
    private final long Mod = (long) (1e9 + 7);
    private long[][][] dp;
    private int oddi = 0;
    private int eveni = 0;
    private long sum = 0;
    private final int nums = 10;

    public int countBalancedPermutations(String s) {
        int n = s.length();
        initfact();
        oddi = 0;
        eveni = 0;
        sum = 0;

        int[] count = new int[10];

        for (int i = 0; i < n; ++i) {
            int cind = s.charAt(i) - '0';
            ++count[cind];
            if (i % 2 == 0) {
                ++eveni;
            } else {
                ++oddi;
            }
            sum += cind;
        }
        dp = new long[nums][800][oddi + 1];

        for (int i = 0; i < nums; ++i) {
            for (int j = 0; j < 800; ++j) {
                Arrays.fill(dp[i][j], -1);
            }

        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        long rt = solve(count, 0, 0, oddi);

        return (int) rt;
    }

    private long solve(int[] a, int i, int osum, int indexes) {
        if (indexes < 0) {
            return 0;
        }
        if (i == nums) {
            if (osum != sum || indexes != 0) {
                return 0;
            } else {
                long ep = fact[eveni];
                long op = fact[oddi];
                long res = ep * op;
                res %= Mod;
                return res;
            }
        }
        if (dp[i][osum][indexes] != -1) {
            return dp[i][osum][indexes];
        }
        long res = 0;
        for (int j = 0; j <= a[i]; ++j) {
            int nosum = osum + j * i;
            long cur = solve(a, i + 1, nosum, indexes - j);
            cur *= modinverse(fact[j]);
            cur %= Mod;
            int toodd = a[i] - j;
            cur *= modinverse(fact[toodd]);
            cur %= Mod;
            res += cur;
            res %= Mod;
        }
        dp[i][osum][indexes] = res;
        return res;
    }

    private long[] fact = new long[101];

    private void initfact() {
        fact[0] = 1;
        for (int i = 1; i <= 100; ++i) {
            fact[i] = fact[i - 1] * i;
            fact[i] %= Mod;
        }
    }

    private long modinverse(long a) {
        long m = Mod;
        long y = 0;
        long x = 1;
        while (a > 1) {
            long q = a / m;
            long t = m;
            m = a % m;
            a = t;
            t = y;
            y = x - q * y;
            x = t;
        }
        if (x < 0) {
            x += Mod;
        }
        return x;
    }
}",1441372874
Kalix1110,Kalix1110,229,3627,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vll dis(n+5,vl(m+5,1e13));
        
        priority_queue<vl,vll,greater<vl>>pq;
        dis[0][0]=0;
        pq.push({0,0,0});
        
        while(pq.size()>0){
            auto p=pq.top();
            pq.pop();
            ll wt=p[0];
            int x=p[1];
            int y=p[2];
            
            if(wt>dis[x][y]) continue;
            for(auto &it:delta1){
                int nx=x+it[0];
                int ny=y+it[1];
                
                if(nx<0 || ny<0 || nx>=n || ny>=m) continue;
                ll d=max(wt,(ll)v[nx][ny])+1;
                if(d < dis[nx][ny]){
                    dis[nx][ny]=d;
                    pq.push({d,nx,ny});
                }
            }
        }
        
        return dis[n-1][m-1];
    }
};",1441297076
Kalix1110,Kalix1110,229,3628,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size(), m = v[0].size();
        
        // 3D distance array: dis[x][y][iinc] where iinc is 0 or 1
        vector<vector<vector<long long>>> dis(n, vector<vector<long long>>(m, vector<long long>(2, 1e13)));
        
        // Priority queue for Dijkstra's algorithm
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        
        // Initialize starting point
        dis[0][0][0] = 0;
        pq.push({0, 0, 0, 0});  // {distance, x, y, iinc}
        
        // Direction vectors for 4 possible moves
        vector<vector<int>> delta1 = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            
            long long wt = p[0];
            int x = p[1];
            int y = p[2];
            int iinc = p[3];
            
            // Skip if this path is outdated
            if (wt > dis[x][y][iinc]) continue;
            
            // Traverse through all possible moves
            for (auto &it : delta1) {
                int nx = x + it[0];
                int ny = y + it[1];
                
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                
                // Calculate new distance
                long long d = max(wt, (long long)v[nx][ny]) + iinc + 1;
                int new_iinc = 1 - iinc;  // Toggle increment for the next step
                
                if (d < dis[nx][ny][new_iinc]) {
                    dis[nx][ny][new_iinc] = d;
                    pq.push({d, nx, ny, new_iinc});
                }
            }
        }
        
        // Get the minimum time to reach the bottom-right corner
        return min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
    }
};
",1441331796
Kalix1110,Kalix1110,229,3636,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool isBalanced(string num) {
        ll a=0,b=0;
        int f=0;
        for(auto &it:num){
            if(f) a+=it-'0';
            else b+=it-'0';
            
            f=!f;
        }
        
        return a==b;
    }
};",1441281597
Kalix1110,Kalix1110,229,3637,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

ll power(ll a,ll n , ll mod=MOD){
	a%=mod;
    ll res=1;
    while(n){
        if(n%2){
            res=res*a;
			res%=mod;
            n--;
        }else{
            a=(a*a);
			a%=mod;
            n/=2;
        }
    }
    
    return res;
}



const int N=100;

// array to store inverse of 1 to N 
ll  factorialNumInverse[N + 1]; 
  
// array to precompute inverse of 1! to N! 
ll  naturalNumInverse[N + 1]; 
  
// array to store factorial of first N numbers 
ll  fact[N + 1]; 


void factorial(ll  p=MOD) 
{ 
    fact[0] = 1; 
  
    // precompute factorials 
    for (ll i = 1; i <= N; i++) { 
        fact[i] = (fact[i - 1] * i) % p; 
    } 
} 

ll inv(ll x){
    return power(fact[x],MOD-2);
}

class Solution {
public:
    ll dp[85][900][50];
    int n;
    ll solve(int i,int sum,int odd,string &s){
        
        if(sum<-400) return 0;
        if(i==s.size()){
            // cout<<sum<<endl;
            if(sum==0) return 1;
            return 0;
        }
        if(dp[i][sum+400][odd] != -1) return dp[i][sum+400][odd];
        
        ll ans=0;
        ll even=(n-i)-odd;
        if(odd>0) ans+=(solve(i+1,sum-(s[i]-'0'),odd-1,s)*odd)%MOD;
        ans%=MOD;
        
        if(even>0) ans+=(solve(i+1,sum+(s[i]-'0'),odd,s)*even)%MOD;
         ans%=MOD;
        
        return dp[i][sum+400][odd]=ans;
    }
    int countBalancedPermutations(string num) {
        memset(dp,-1);
        factorial(MOD); 
         n=num.size();
        ll odd=n/2;
        ll even=n/2;
        if(n%2) odd++;
        ll ans= solve(0,0,odd,num);
        vl v(10);
        for(auto &it:num) v[it-'0']++;
        for(int i=0;i<10;i++){
            if(v[i]==0) continue;
            ans*=inv(v[i]);
            ans%=MOD;
        }
        
        return ans;
    }
};",1441372921
dapu81000,dapu81000,232,3627,cpp,"class Solution {
public:
    int dp[55][55] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        #define pii pair<int,int>
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        pq.push({0, 0});
        while(!pq.empty()){
            pii tmp = pq.top();pq.pop();
            int x = tmp.second/m, y = tmp.second%m, dist = tmp.first;
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+1, moveTime[xx][yy]+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441306672
dapu81000,dapu81000,232,3628,cpp,"class Solution {
public:
    int dp[755][755] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0});
        while(!pq.empty()){
            vector<int> v=pq.top();pq.pop();
            int x = v[1]/m, y = v[1]%m, dist = v[0], add = v[2];
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+add+1, moveTime[xx][yy]+add+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy, !add});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441314240
dapu81000,dapu81000,232,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int res[2] = {};
        for(int i=0;i<num.size();i++){
            int cur = (i&1)^1;
            res[cur] += num[i]-'0';
        }
        return res[0] == res[1];
    }
};",1441281741
dapu81000,dapu81000,232,3637,cpp,"class Solution {
public:
    int dp[41][401] = {};
    int fac[88] = {};
    const int mod = 1e9+7;
    void build(){
        fac[0] = fac[1] = 1;
        for(int i=2;i<=80;i++){
            fac[i] = (1ll*fac[i-1]*i)%mod;
        }
    }
    int powmod(long long x,int n){
        long long res = 1;
        while(n){
            if(n&1) res = (res*x)%mod;
            x = (x*x)%mod;
            n>>=1;
        }
        return res;
    }
    int cnt[10] = {};
    int countBalancedPermutations(string num) {
        build();
        int tot = 0;
        for(char ch:num) tot += ch-'0', cnt[ch-'0']++;
        if(tot&1) return 0;
        if(tot==1) return 1;
        int mid = tot/2, n = num.size();
        dp[0][0] = 1;

        for(int i=0;i<n;i++){
            int cur = num[i]-'0';
            for(int j=min(i+1,n/2);j>0;j--){
                for(int k=mid;k>=cur;k--){
                    dp[j][k] += dp[j-1][k-cur];
                    dp[j][k] %= mod;
                }
            }
        }
        long long res = dp[n/2][mid];
        res = (res*fac[n/2])%mod;
        res = (res*fac[n-n/2])%mod;

        for(int i=0;i<=9;i++){
            if(cnt[i]>1){
                res = (res*powmod(fac[cnt[i]],mod-2))%mod;
            }
        }
        return res;
    }
};",1441367211
Anh Ti Trn,anh_tai,234,3627,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 );
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441372865
Anh Ti Trn,anh_tai,234,3628,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 + f);
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441371858
Anh Ti Trn,anh_tai,234,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0, mul = 1;
        for (char&c : num){
            s += mul * (c - '0');
            mul = mul * -1;
        }
        return s == 0; 
    }
};",1441350523
Anh Ti Trn,anh_tai,234,3637,cpp,"int fact[81], ifact[81];

const int mod = 1e9 + 7;

int add(int u, int v){
    u += v;
    if (u >= mod) u -= mod;
    return u; 
}

int sub(int u, int v){
    return add(u, mod - v);
}

int mul(int u, int v){
    return 1LL * u * v % mod;
}

int power(int u, int v){
    int res = 1;
    while (v > 0){
        if (v & 1){
            res = mul(res, u);
        }
        u = mul(u, u);
        v >>= 1;
    }
    return res; 
}

void init(){
    if (fact[0] > 0){
        return; 
    }
    
    fact[0] = ifact[0] = 1;
    for (int i = 1; i <= 80; i++){
        fact[i] = mul(fact[i-1],i);
        ifact[i] = power(fact[i], mod - 2);
        //cout << i << "" "" << fact[i] << "" "" << ifact[i] << ""\n""; 
    }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        init(); 
        int n = num.size();
        vector<int> cnt(10);
        int tot = 0; 
        for (char& c : num){
            cnt[c - '0']++;
            tot += (c - '0');
        }

        if (tot&1){
            return 0; 
        }

        tot >>= 1; 
        vector<vector<int>> dp(41, vector<int>(361)), ndp(41, vector<int>(361)); 
        dp[0][0] = 1;

        // for (int sum = 0; sum <= tot; sum++){
        //     for (int digits = 0; digits <= (n + 1) / 2; digits++){
        //         for (int d = 0; d < 10; d++){
        //             for (int sk = 0; sk <= cnt[d];sk++){
        //                 int n_sum = sum + sk * d;
        //                 int n_digits = digits + sk;
        //                 if (n_sum <= tot && n_digits <= (n + 1) / 2){
        //                     ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], ifact[sk]));
        //                 }
        //             }
        //         }
        //     }
        // }
        
        for (int d = 0; d < 10; d++){
            for (int sk = 0; sk <= cnt[d]; sk++){
                for (int sum = 0; sum <= tot; sum++){
                    for (int digits = 0; digits <= (n + 1) / 2; digits++){
                        int n_sum = sum + sk * d;
                        int n_digits = digits + sk;
                        if (n_sum <= tot && n_digits <= (n + 1) / 2){
                            ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], mul(ifact[sk], ifact[cnt[d] - sk])));
                        }
                    } 
                }   
            }

            for (int sum = 0; sum <= tot; sum++){
                for (int digits = 0; digits <= (n + 1) / 2; digits++){
                    dp[digits][sum] = ndp[digits][sum];
                    ndp[digits][sum] = 0; 
                }
             }
        }
        
        int ans = mul(fact[(n + 1) / 2], dp[(n + 1) / 2][tot]);
        ans = mul(ans, fact[n -(n + 1) / 2]);
        return ans; 
    }
};",1441385911
Pikachu0123,Pikachu0123,236,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        queue<vector<int>> q;
        q.push({0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.front()[0];
            int c = q.front()[1];
            int d = q.front()[2];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = d;
                if (d < moveTime[nr][nc]){
                    new_d = moveTime[nr][nc];
                }
                if (new_d + 1 < dis[nr][nc]){
                    dis[nr][nc] = new_d + 1;
                    q.push({nr, nc, new_d + 1});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441298296
Pikachu0123,Pikachu0123,236,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.top()[1];
            int c = q.top()[2];
            int d = -q.top()[0];
            int type = q.top()[3];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = max(d, moveTime[nr][nc]);
                int cost = new_d + (type == 0 ? 1 : 2);
                if (cost < dis[nr][nc]){
                    dis[nr][nc] = cost;
                    q.push({-cost,nr, nc, !type});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441303211
Pikachu0123,Pikachu0123,236,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i=0; i<n; i+=2) sum1 += num[i]-'0';
        for(int i=1; i<n; i+=2) sum2 += num[i] - '0';
        return sum1 == sum2;
    }
};",1441281379
Pikachu0123,Pikachu0123,236,3637,cpp,"
const int mod = 1e9 + 7;
const int offset = 730;
long long dp[10][1500][42];
long long ncr[101][101];

void precompute_nCr() {
    for (int i = 0; i <= 100; ++i) {
        ncr[i][0] = ncr[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;
        }
    }
}

class Solution {
long long solve(int i,  int sum, int odd, int even, vector<int> &freq){
    if (i == 10){
        if (sum == 0) return 1;
        else return 0;
    }
    if (freq[i] == 0){
        return solve(i + 1, sum, odd, even, freq);
    }
    if (dp[i][sum+offset][even] != -1) return dp[i][sum+offset][even];
    long long ans = 0;
    int val = freq[i];
    for(int j=0; j<=val; j++){
        int taken_odd = j;
        int taken_even = val - j;
        if (odd >= taken_odd and even >= taken_even){
            (ans += ((ncr[odd][taken_odd] * 1LL * ncr[even][taken_even]) % mod * solve(i + 1, sum - i * taken_odd + i * taken_even, odd - taken_odd, even - taken_even, freq)) % mod) %= mod;
        }
    }
    return dp[i][sum+offset][even] = ans;
}
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> freq(10, 0);
        
        for(char &ch : num)
            freq[ch-'0'] += 1;
        int odd = (n + 1) / 2, even = n / 2;
        memset(dp, -1, sizeof dp);
        memset(ncr, 0, sizeof ncr);
        precompute_nCr();
        return solve(0, 0, odd, even, freq);
    }
};",1441369861
pooyaz,pooyaz,237,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        vector<vector<int>> cnt(n, vector<int>(m, -1));
        priority_queue<vector<int>> q;
        q.push({0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2];
            if(cnt[i][j] != -1) continue;
            cnt[i][j] = dis;
            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj] == -1){
                    int ndist = max(t[ni][nj], dis) + 1;
                    q.push({-ndist, ni, nj});
                }
            }
        }
        return cnt[n - 1][m - 1];
    }
};",1441319916
pooyaz,pooyaz,237,3628,cpp,"class Solution {
public:
    int cnt[760][760][2];
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        memset(cnt, -1, sizeof cnt);
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2], s = v[3];
            if(cnt[i][j][s] != -1) continue;
            
            cnt[i][j][s] = dis;
            if(i == n - 1 && j == m - 1) break;

            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                int ns = 1 - s;
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj][ns] == -1){
                    int ndist = max(t[ni][nj], dis) + 1 + s;
                    q.push({-ndist, ni, nj, ns});
                }
            }
        }
        if(cnt[n - 1][m - 1][0] == -1){
            return cnt[n - 1][m - 1][1];
        }
        else if(cnt[n - 1][m - 1][1] == -1){
            return cnt[n - 1][m - 1][0];
        }
        return min(cnt[n - 1][m - 1][0], cnt[n - 1][m - 1][1]);
    }
};",1441331858
pooyaz,pooyaz,237,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.length(); i++){
            if(i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281862
pooyaz,pooyaz,237,3637,cpp,"#define Mod 1000000007L

class Solution {
public:
    int n;
    int sum[11];
    int dig[11];
    int cnt[11] = {};
    long long com[50][50] = {};
    long long dp[11][50][500];

    long long mem(int idx, int sp, int rem){
        if(idx == 10){
            return sp == 0 && rem == 0;
        }
        long long& ref = dp[idx][sp][rem];
        if(ref != -1) return ref;
        ref = 0;

        int sp2 = dig[idx] - sp;
        int rem2 = sum[idx] - rem;
        for(int i = 0; i <= cnt[idx]; i++){
            if(i > sp || i * idx > rem) continue;
            if(cnt[idx] - i > sp2 || (cnt[idx] - i) * idx > rem2) continue;
            long long nex = mem(idx + 1, sp - i, rem - i * idx);
            long long c1 = com[i][sp];
            long long c2 = com[cnt[idx] - i][sp2];
            // cout << idx << ' ' << sp << ' ' << rem << ' ' << i << ' ' << nex << ' ' << c1 << ' ' << c2 << endl;
            ref = (ref + nex * (c1 * c2 % Mod)) % Mod;
            // cout << ref << endl;
        }
        return ref;
    }
    int countBalancedPermutations(string num) {
        n = num.length();
        memset(dp, -1, sizeof dp);
        for(int i = 0; i < n; i++){
            int d = num[i] - '0';
            cnt[d]++;
        }
        for(int i = 9; i >= 0; i--){
            sum[i] = sum[i + 1] + cnt[i] * i;
            dig[i] = dig[i + 1] + cnt[i];
        }
        if(sum[0] % 2) return 0;
        for(int i = 0; i <= dig[0] / 2 + 1; i++){
            com[0][i] = 1;
            com[i][i] = 1;
        }
        for(int i = 1; i <= dig[0] / 2 + 1; i++){
            for(int j = 1; j < i; j++){
                com[j][i] = (com[j - 1][i - 1] + com[j][i - 1]) % Mod;
                // cout << i << ' ' << j << ' ' << com[j][i] << ' ' << com[j - 1][i - 1] << ' ' << com[j][i - 1] << endl;
            }
        }
        
        long long ans = mem(0, dig[0] / 2, sum[0] / 2);
        return (int)ans;
    }
};",1441382229
KGowtham04,KGowtham04,238,3627,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({0, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+1;
                    pq.push({newTime, {newX, newY}});
                    seen[newX][newY] = true;
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }

    

    
};",1441325312
KGowtham04,KGowtham04,238,3628,cpp,"class Solution {
public:
    int n, m;
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({{0, 1}, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first.first;
            int move = pq.top().first.second;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+move;
                    int newMove = move == 2 ? 1 : 2; 
                    pq.push({{newTime, newMove}, {newX, newY}});
                    seen[newX][newY] = true;
                    
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }       
};",1441338140
KGowtham04,KGowtham04,238,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {

        int odd = 0, even  = 0;

        for(int i=0; i<num.size(); i++){
            if(i%2==0){
                even += num[i] - 48;
            }
            else{
                odd+= num[i] - 48;
            }
        }

        return even == odd;
        
    }
};",1441289755
KGowtham04,KGowtham04,238,3637,cpp,"typedef long long ll;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int MOD = 1e9+7;
                int n = num.size();
        int m = (n + 1) / 2; // Number of even indices (0-based)

        // Count digits
        int count_digits[10] = {0};
        ll sum_total =0;
        for(char ch: num){
            int d = ch - '0';
            count_digits[d]++;
            sum_total += d;
        }

        // If total sum is odd, no balanced permutation exists
        if(sum_total %2 !=0){
            return 0;
        }
        ll sum_target = sum_total /2;

        // Precompute factorial and inverse factorial
        vector<ll> fact(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] * i % MOD;

        // Compute inverse factorial
        vector<ll> inv_fact(n+1,1);
        inv_fact[n] = power_mod_func(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }

        // Compute product of inverse factorials of counts
        // Not needed in the final formula
        // ll inv_fact_prod_counts =1;
        // for(int d=0; d<=9; d++) {
        //     inv_fact_prod_counts = inv_fact_prod_counts * inv_fact[count_digits[d]] % MOD;
        // }

        // Initialize DP
        // dp[k][s] represents the number of ways to assign k digits with sum s, adjusted by inverse factorials
        vector<vector<ll>> dp_prev(m+1, vector<ll>(sum_target +1, 0));
        dp_prev[0][0] =1;

        for(int d=0; d<=9; d++){
            int c_d = count_digits[d];
            if(c_d ==0){
                continue;
            }
            // Initialize next layer
            vector<vector<ll>> dp_next(m+1, vector<ll>(sum_target +1, 0));

            for(int k=0; k<=m; k++){
                for(ll s=0; s<=sum_target; s++){
                    if(dp_prev[k][s] ==0){
                        continue;
                    }
                    // Try assigning t digits of this digit to even positions
                    for(int t=0; t<=c_d && t <= m -k; t++){
                        if(s + (ll)t *d > sum_target){
                            continue;
                        }
                        // Update dp_next
                        dp_next[k +t][s + (ll)t *d] = (dp_next[k +t][s + (ll)t *d] + dp_prev[k][s] * inv_fact[t] % MOD * inv_fact[c_d - t] % MOD) % MOD;
                    }
                }
            }
            // Update dp_prev
            dp_prev = move(dp_next);
        }

        // After processing all digits, check dp_prev[m][sum_target]
        ll dp_final = 0;
        if(m <= n && sum_target <= sum_total){
            dp_final = dp_prev[m][sum_target];
        }

        // Compute the final answer
        // The correct formula is: fact[m] * fact[n -m} * dp_final % MOD
        ll answer = fact[m] * fact[n -m] % MOD;
        answer = answer * dp_final % MOD;

        return (int)answer;
    }
    
   ll power_mod_func(ll x, ll power, ll mod_val) {
        ll result = 1;
        x %= mod_val;
        while(power > 0){
            if(power & 1){
                result = result * x % mod_val;
            }
            x = x * x % mod_val;
            power >>=1;
        }
        return result;
    }
};",1441388333
Varun Deep Saini,sojabhai,240,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<pair<int, int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };
        
        vector<vector<int>> dist(n, vector<int>(m, 1e18));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        pq.emplace(0, make_pair(0, 0));
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            
            int w = curr.first;
            int x = curr.second.first;
            int y = curr.second.second;
            
            if (x == n -1 && y == m -1) {
                return (int)w;
            }
            
            if (w > dist[x][y]) {
                continue;
            }
            
            for (auto &dir : directions) {
                int nx = x + dir.first;
                int ny = y + dir.second;
                
                if (nx >=0 && nx < n && ny >=0 && ny < m) {
                    int timee = max((int)w, (int)moveTime[nx][ny]);
                    int d = timee + 1;
                    
                    if (d < dist[nx][ny]) {
                        dist[nx][ny] = d;
                        pq.emplace(d, make_pair(nx, ny));
                    }
                }
            }
        }
        #undef int
        return 69;
    }
};
",1441374028
Varun Deep Saini,sojabhai,240,3628,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };
        
    struct Compare {
    bool operator()(const vector<long long>& a, const vector<long long>& b) const {
            return a[0] > b[0];
        }
    };

    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist1(n, vector<int>(m, LLONG_MAX));
        vector<vector<int>> dist2(n, vector<int>(m, LLONG_MAX));
        
        priority_queue<vector<int>, vector<vector<int>> , Compare> pq;
        
        dist1[0][0] = 0;
        pq.push({0, 0, 0, 0});
        
        while(!pq.empty()){
            auto current = pq.top();
            pq.pop();
            
            int timee = current[0];
            int i = current[1];
            int j = current[2];
            int k = current[3];
            
            if(i == n-1 && j == m-1){
                return timee;
            }
            
            if( (k == 0 && timee > dist1[i][j]) ||
                (k == 1 && timee > dist2[i][j]) ){
                continue;
            }
            
            for(auto &[di, dj] : directions){
                int ni = i + di;
                int nj = j + dj;
                
                if(ni >= 0 && ni < n && nj >= 0 && nj < m){
                    
                    int cost = (k == 0) ? 1 : 2;
                    
                    int movee = max(timee, (int)moveTime[ni][nj]);
                    
                    int tot = movee + cost;
                    
                    if(k == 1){
                        if(tot < dist1[ni][nj]){
                            dist1[ni][nj] = tot;
                            pq.push({tot, ni, nj, 0});
                        }
                    }
                    else{
                        if(tot < dist2[ni][nj]){
                            dist2[ni][nj] = tot;
                            pq.push({tot, ni, nj, 1});
                        }
                    }
                }
            }
        }
        #undef int
        return -1;

    }
};",1441368729
Varun Deep Saini,sojabhai,240,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even_sum = 0; 
        int odd_sum = 0;  

        for(int i = 0; i < num.length(); ++i){
            if(i % 2 == 0){
                even_sum += num[i] - '0';
            }
            else{
                odd_sum += num[i] - '0';
            }
        }

        return even_sum == odd_sum;

    }
};",1441350550
Varun Deep Saini,sojabhai,240,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MOD = 1e9 + 7;
int z = 0;

int fact[102];
int inv_fact[102];

class Solution {
public:

    void pre() {
        if(z) return;
        z = 1;

        fact[0] = 1;
        for(int i = 1; i <= 101; i++) fact[i] = fact[i-1] * i % MOD;

        inv_fact[101] = power(fact[101], MOD - 2);
        for(int i = 100; i >= 0; i--) inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        
    }

    int power(int a , int b){
        int res = 1;
        a %= MOD;
        while(b > 0){
            if(b & 1){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int comb(int n, int r){
        return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        pre();
        map<int ,int> freq;
        int n = num.length();
        int sum = 0;
        for(auto &i : num){
            freq[i - '0']++;
            sum += i - '0';
        }
        
        if(sum % 2 != 0){
            return 0;
        }
        
        int target = sum / 2;
        
        int even = (n + 1) / 2; 
        int odd = n / 2;       
        
        vector<vector<int>> dp(target + 1, vector<int>(even + 1, 0));
        dp[0][0] = 1;
        
        for(int d = 0; d <= 9; d++){
            if(freq[d] == 0) continue;
            for(int i = target; i >= 0; i--){
                for(int j = even; j >= 0; j--){
                    if(dp[i][j] == 0) continue;

                    // add cnt d
                    for(int cnt = 1; cnt <= freq[d]; cnt++){
                        if(cnt + j > even) break;
                        if(i + cnt*d > target) break;
                        dp[i + cnt*d][j + cnt] = (dp[i + cnt*d][j + cnt] + dp[i][j] * comb(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        
        int ways = dp[target][even];
        
        int den = 1;
        for(int d = 0; d <= 9; d++) den = den * fact[freq[d]] % MOD;
        den = power(den, MOD - 2);

        int ans = ways * fact[even] % MOD;
        ans = ans * fact[odd] % MOD;
        ans = ans * den % MOD;
        
        return ans;
    }
};
#undef int",1441388578
otto,_otto,241,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        hp = []
        heappush(hp, (0, 0, 0))

        while hp:
            curr, r, c = heappop(hp)
            if r == n-1 and c == m-1:
                return curr
            if curr > dist[r][c]:
                continue
            for dr, dc in pairwise([-1, 0, 1, 0, -1]):
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < m:
                    new = max(curr, moveTime[nr][nc]) + 1
                    if new < dist[nr][nc]:
                        dist[nr][nc] = new
                        heappush(hp, (new, nr, nc))
        return -1",1441304953
otto,_otto,241,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        n = len(A)
        m = len(A[0])

        dist = [[[inf] * 2 for _ in range(m)] for _ in range(n)]
        dist[0][0][0] = 0

        hp = []
        heappush(hp, (0, 0, 0, 0))
        while hp:
            t, i, j, p = heappop(hp)
            if i == n-1 and j == m-1:
                return t
            if t > dist[i][j][p]: continue

            for di, dj in pairwise([-1, 0, 1, 0, -1]):
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    curr = max(t, A[ni][nj])
                    cos = 1 if p == 0 else 2
                    new = curr + cos
                    next_p = 1 - p
                    if new < dist[ni][nj][next_p]:
                        dist[ni][nj][next_p] = new
                        heappush(hp, (new, ni, nj, next_p))

        return -1
",1441323111
otto,_otto,241,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        a = b = 0
        for i, x in enumerate(str(num)):
            if i % 2 == 0:
                a += int(x)
            else:
                b += int(x)
        return a == b",1441281200
otto,_otto,241,3637,python3,"MOD = int(1e9 + 7)
MAXN = 81
fac = [1] * (MAXN + 1)
inv_fac = [1] * (MAXN + 1)
for i in range(1, MAXN + 1): fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN] = pow(fac[MAXN], MOD - 2, MOD)
for i in range(MAXN, 0, -1): inv_fac[i - 1] = inv_fac[i] * i % MOD
comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for n in range(MAXN + 1):
    comb[n][0] = 1
    for k in range(1, n + 1):
        comb[n][k] = (comb[n - 1][k - 1] + comb[n - 1][k]) % MOD

class Solution:
    def countBalancedPermutations(self, s: str) -> int:
        n = len(s)
        c = [0] * 10
        fuck = 0
        for ch in s: 
            c[int(ch)] += 1
            fuck += int(ch)
        if fuck % 2 != 0: return 0
        target = fuck // 2
        even = (n + 1) // 2
        odd = n // 2
        dp = [[0] * (even + 1) for _ in range(target + 1)]
        dp[0][0] = 1

        for d in range(10):
            f = c[d]
            if f == 0:
                continue
            ndp = [dp_row[:] for dp_row in dp]
            for s in range(target + 1):
                for cnt in range(even + 1):
                    v = dp[s][cnt]
                    if v == 0:
                        continue
                    for k in range(1, min(f, even - cnt) + 1):
                        news = s + d * k
                        newcnt = cnt + k
                        if news > target or newcnt > even: break
                        ndp[news][newcnt] = (ndp[news][newcnt] + v * comb[f][k]) % MOD
            dp = ndp

        shit = dp[target][even] # slots
        
        # combs
        fuck_even = fac[even]
        for d in range(10):
            for k in range(0, min(c[d], even) + 1):
                if k > even: break
                if target - d * k < 0: break
                if dp[s - d * k][even - k] == 0:continue
                ways = comb[c[d]][k]
                fuck_even = fuck_even * inv_fac[k] % MOD
                break
        fuck_odd = fac[odd]
        for d in range(10):
            fuck_odd = fuck_odd * inv_fac[c[d]] % MOD
        tot = fuck_even * fuck_odd % MOD

        return (shit * tot) % MOD",1441382688
garyjhu,garyjhu,242,3627,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + 1 < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + 1;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441295879
garyjhu,garyjhu,242,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                int e = (x + y) % 2 == 1 ? 1 : 2;
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + e < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + e;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441297024
garyjhu,garyjhu,242,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumE = 0, sumO = 0;
        int n = num.length();
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) sumE += num.charAt(i) - '0';
            else sumO += num.charAt(i) - '0';
        }
        return sumE == sumO;
    }
}
",1441284545
garyjhu,garyjhu,242,3637,java,"import java.util.ArrayList;
import java.util.Arrays;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);
    static long[] invFac;
    public int countBalancedPermutations(String num) {
        if (invFac == null) init();
        int n = num.length();
        int sum = 0;
        int[] count = new int[10];
        for (char c : num.toCharArray()){
            sum += c - '0';
            count[c - '0']++;
        }
        if (sum % 2 == 1) return 0;
        int goal = sum / 2;
        long[][] dp = new long[n + 1][goal + 1];
//        ModIntFactory.ModInt[][] dp = new ModIntFactory.ModInt[n + 1][goal + 1];
//        for (ModIntFactory.ModInt[] row : dp) Arrays.fill(row, factory.create(0));
        dp[0][0] = 1;
//        dp[0][0] = factory.create(1);
        for (int i = 0; i < 10; i++) {
            long[][] tp = new long[n + 1][goal + 1];
//            ModIntFactory.ModInt[][] tp = new ModIntFactory.ModInt[n + 1][goal + 1];
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) tp[j][k] = factory.create(0);
//            }
            for (int j = 0; j < n; j++) {
                for (int k = 0; k <= goal; k++) {
                    for (int l = 0; l <= count[i]; l++) {
                        if (j + l <= n && k + l * i <= goal) {
                            tp[j + l][k + l * i] = (tp[j + l][k + l * i] + factory.create(dp[j][k]).mul(invFac[l]).mul(invFac[count[i] - l]).value);
//                            tp[j + l][k + l * i].addAsg(dp[j][k].mul(factory.factorial(l).mul(factory.factorial(count[i] - l)).inv()));
                        }
                    }
                }
            }
            dp = tp;
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) {
//                    System.out.print(dp[j][k] + "" "");
//                }
//                System.out.println();
//            }
//            System.out.println();
        }
//        System.out.println();
        return factory.factorial(n / 2).mul(factory.factorial((n + 1) / 2)).mul(dp[n / 2][goal]).value;
//        ModIntFactory.ModInt res = dp[n / 2][goal].mul(factory.factorial(n / 2)).mul(factory.factorial((n + 1) / 2));
//        return res.value;
    }
    
    static void init() {
        invFac = new long[100];
        for (int i = 0; i < 100; i++) invFac[i] = factory.factorial(i).inv().value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1441383191
samjack,samjack,243,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time + 1, moveTime[nx][ny] + 1)
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
        
        return -1",1441292166
samjack,samjack,243,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy

                time += ((nx + ny + 1) % 2 + 1)
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time, moveTime[nx][ny] + ((nx + ny + 1) % 2 + 1))
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
                time -= ((nx + ny + 1) % 2 + 1)
        
        return -1
",1441307140
samjack,samjack,243,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum, odd_sum = 0, 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum
",1441281017
samjack,samjack,243,3637,cpp,"#include <bits/stdc++.h>
#define vi vector<int>
#define vb vector<bool>
#define vl vector<long long>
#define vii vector<vector<int>>
#define vll vector<vector<long long>>
#define pi pair<int, int>
#define pl pair<ll, ll>
#define vpi vector<pair<int, int>>
#define vpl vector<pair<ll, ll>>
#define a first 
#define b second
#define pb push_back
#define hset unordered_set
#define hmap unordered_map
#define vm vector<mi>
#define vmm vector<vector<mi>>
using namespace std;
const int MOD = 1e9+7;
using ll = long long;
using big = __int128_t;
using ld = long double;
int uMin(int& a, int b){return a = min(a,b);}
int uMax(int& a, int b){return a = max(a,b);}
struct mi {
  ll v;
  explicit operator int() const { return v; }
  mi() { v = 0; }
  mi(ll _v) : v(_v % MOD) { v += (v < 0) * MOD; }
  bool operator<(const mi& other) const {
    return v < other.v;
  }
  friend std::ostream& operator<<(std::ostream& os, const mi& m) {
      os << m.v;
      return os;
  }
};
mi &operator+=(mi &a, mi b) {
  if ((a.v += b.v) >= MOD) a.v -= MOD;
  return a;
}
mi &operator-=(mi &a, mi b) {
  if ((a.v -= b.v) < 0) a.v += MOD;
  return a;
}
mi operator+(mi a, mi b) { return a += b; }
mi operator-(mi a, mi b) { return a -= b; }
mi operator*(mi a, mi b) { return mi(a.v * b.v); }
mi &operator*=(mi &a, mi b) { return a = a * b; }
mi pow(mi a, ll p) {
  assert(p >= 0);
  return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);
}
mi inv(mi a) {
  assert(a.v != 0);
  return pow(a, MOD - 2);
}
mi operator/(mi a, mi b) { return a * inv(b); }
bool operator==(mi a, mi b) {return a.v == b.v;}
template <class T>
class Matrix {
private:
    vector<std::vector<T>> data;
    size_t size;
public:
    Matrix(size_t n, T v = T()) : size(n), data(n, std::vector<T>(n, v)) {}
    Matrix(const Matrix<T>& other) : size(other.size), data(other.data) {}
    T& operator()(size_t i, size_t j) { return data[i][j]; }
    const T& operator()(size_t i, size_t j) const { return data[i][j]; }
    Matrix<T> operator+(const Matrix<T>& other) const {
        Matrix<T> result(size);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result(i, j) = data[i][j] + other(i, j);
        return result;
    }
    Matrix<T> operator*(const Matrix<T>& other) const {
        Matrix<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                for (size_t k = 0; k < size; ++k)
                    result(i, k) += data[i][j] * other(j, k);
        return result;
    }
    std::vector<T> operator*(const std::vector<T>& vec) const {
        std::vector<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result[j] += data[i][j] * vec[i];
        return result;
    }
    Matrix<T> pow(ll e) const {
        Matrix<T> result = identity(size);
        Matrix<T> base = *this;
        while(e) {
            if(e&1) result = result * base;
            base = base * base;
            e>>=1;
        }
        return result;
    }
    bool operator==(const Matrix<T>& other) const {
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                if (data[i][j] != other(i, j))
                    return false;
        return true;
    }
    static Matrix<T> identity(size_t n) {
        Matrix<T> id(n, 0);
        for (size_t i = 0; i < n; ++i)
            id(i, i) = 1;
        return id;
    }
    friend std::ostream& operator<<(std::ostream& os, const Matrix<T>& matrix) {
        os << ""[\n"";
        for (const auto& row : matrix.data) {
            os << ""\t["";
            for(int i = 0; i<row.size(); i++)
                os << row[i] << (i==row.size()-1?""]\n"":"", "");
        }
        os << ""]\n"";
        return os;
    }
};
template <class T> class BIT {
    int N; vector<T> data;
    bool c, queried;
    public:
    BIT(int _N, bool constant) : c(constant) {
        N = _N+1;
        data.resize(N);
        if(constant) queried = 0;
    }
    void add(int p, T x) { if(c){assert(!queried); data[p]+=x;}else for (p++;p<=N;p+=p&-p) data[p-1]+=x; }
    T sum(int l, int r) { return sum(r)-(l==0?0:sum(l-1)); }
    T sum(int r) { 
        if(c){
            if(!queried){
                queried = 1;
                partial_sum(data.begin(),data.end(),data.begin());
            }
            return data[r];
        }
        T s = 0; r++; for(;r;r-=r&-r)s+=data[r-1]; return s; }
    int lower_bound(T sum) {
        assert(!c);
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1<<25; pw; pw >>= 1) {
            int npos = pos+pw;
            if (npos <= N && data[npos-1] < sum)
                pos = npos, sum -= data[pos-1];
        }
        return pos;
    }
};
template <class T> class RURQ {
    BIT<T> bit1, bit2;
    int sz;
    RURQ(int size) : sz(size), bit1(size), bit2(size) {}
    void add(int start, int end, T value) {
        bit1.add(start, value);
        bit2.add(start, value*(start - 1));
        if(end != sz-1){
            bit1.add(end+1, -value);
            bit2.add(end+1, -value*end);
        }
    }
    T pref(int index) {
        if(index==-1) return 0;
        return (bit1.sum(index))*index-bit2.sum(index);
    }
    T sum(int start, int end) {
        return pref(end)-pref(start-1);
    }
};
struct Line {
    long double m,b;
    Line(long double slope, long double yIntercept) : m(slope), b(yIntercept) {}
    long double getY(long double x) const {
        return m * x + b;
    }
};

struct LineContainer {
    std::vector<Line> lines;
    bool isAbove(const Line& l1, const Line& l2, const Line& l3) const {
        return (l3.b - l1.b) * (l1.m - l2.m) > (l2.b - l1.b) * (l1.m - l3.m);
    }
    void add(long double slope, long double yIntercept) {
        Line newLine(slope, yIntercept);
        while (lines.size() >= 2 && !isAbove(lines[lines.size() - 2], 
                                    lines[lines.size() - 1], newLine))
            lines.pop_back();
        lines.push_back(newLine);
    }
    long double queryMax(long double x) const {
        if (lines.empty())
            return -LLONG_MAX;
        int left = 0, right = lines.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (lines[mid].getY(x) < lines[mid + 1].getY(x))
                left = mid + 1;
            else right = mid;
        }
        return lines[left].getY(x);
    }
};
vl euclid(ll a, ll b) {
    vl x = {1, 0, a};
    vl y = {0, 1, b};
    while(y[2]){
        ll k = x[2] / y[2];
        x[0]-=k*y[0];
        x[1]-=k*y[1];
        x[2]-=k*y[2];
        swap(x, y);
    }
    return x;  // x[0] * a + x[1] * b = x[2], x[2] = gcd(a, b)
}
pl modSolver(vpl& mods){
    pl ans = {mods[0].a,mods[0].b};
    for(int i = 1; i<mods.size(); i++){
        vl g = euclid(ans.b, mods[i].b);
        if((mods[i].a-ans.a)%g[2]) return {-1,-1};
        ans.a+=(mods[i].a-ans.a)/g[2]*ans.b*g[0];
        ans.b = ans.b/g[2]*mods[i].b;
        ans.a%=ans.b;
        ans.a+=ans.b;
        ans.a%=ans.b;
    }
    return ans;
}
int sq(ll n){
    ll a = 0;
    for(int i = 31; i>=0; i--){
        ll x = 1<<i|a;
        if(x*x <= n) a = x;
    }
    return a;
}
struct LZST {
    ll n;
    vector<pair<vl,bool>> nodes; // [[val,min,max,add],isSet]
    vi left,right;
    private:
        void set(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0] = num*(r-l+1);
            g[1] = g[2] = g[3] = num;
            nodes[i].b = 1;
        }
        void add(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0]+=num*(r-l+1);
            g[1]+=num;
            g[2]+=num;
            g[3]+=num;
        }
        void prop(int i, ll l, ll r){
            ll m = l+((r-l)>>1);
            if(left[i] == -1){
                left[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(right[i] == -1){
                right[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(nodes[i].b){
                nodes[i].b = 0;
                if(l != r){
                    ll a = nodes[i].a[3];
                    set(a,left[i],l,m);
                    set(a,right[i],m+1,r);
                }
            }else if(nodes[i].a[3]){
                if(l != r){
                    ll a = nodes[i].a[3];
                    add(a,left[i],l,m);
                    add(a,right[i],m+1,r);
                }
            }
            nodes[i].a[3] = 0;
        }
        void upd(int i){
            vl& g = nodes[i].a, l = nodes[left[i]].a, r = nodes[right[i]].a;
            g[0] = l[0]+r[0];
            g[1] = l[1]<r[1]?l[1]:r[1];
            g[2] = l[2]>r[2]?l[2]:r[2];
        }
        void set(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                set(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) set(s,e,num,left[i],l,m);
            else if(s > m) set(s,e,num,right[i],m+1,r);
            else{
                set(s,m,num,left[i],l,m);
                set(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        void add(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                add(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) add(s,e,num,left[i],l,m);
            else if(s > m) add(s,e,num,right[i],m+1,r);
            else{
                add(s,m,num,left[i],l,m);
                add(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        ll sum(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[0];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return sum(s,e,left[i],l,m);
            if(s > m) return sum(s,e,right[i],m+1,r);
            return sum(s,m,left[i],l,m)+sum(m+1,e,right[i],m+1,r);
        }
        ll min(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[1];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return min(s,e,left[i],l,m);
            if(s > m) return min(s,e,right[i],m+1,r);
            ll a = min(s,m,left[i],l,m), b = min(m+1,e,right[i],m+1,r);
            return a<b?a:b;
        }
        ll max(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[2];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return max(s,e,left[i],l,m);
            if(s > m) return max(s,e,right[i],m+1,r);
            ll a = max(s,m,left[i],l,m), b = max(m+1,e,right[i],m+1,r);
            return a>b?a:b;
        }
    public:
        LZST(ll N){
            n = N;
            nodes.pb({vl(4),0});
            left.pb(-1);
            right.pb(-1);
        }
        void set(ll s, ll e, ll num){
            set(s,e,num,0,0,n-1);
        }
        void add(ll s, ll e, ll num){
            add(s,e,num,0,0,n-1);
        }
        ll sum(ll s, ll e){
            return sum(s,e,0,0,n-1);
        }
        ll min(ll s, ll e){
            return min(s,e,0,0,n-1);
        }
        ll max(ll s, ll e){
            return max(s,e,0,0,n-1);
        }
        ll get(ll s){
            return sum(s,s,0,0,n-1);
        }
        void add(ll s, ll num){
            add(s,s,num,0,0,n-1);
        }
        void set(ll s, ll num){
            set(s,s,num,0,0,n-1);
        }
        friend std::ostream& operator<<(std::ostream& os, LZST& m) {
            os << ""["";
            for(int i = 0; i<m.n; i++) os << m.get(i) << (i==m.n-1?""]"":"", "");
            return os;
        }
};
int dGet(int a, vi& d){return d[a]<0?a:(d[a]=dGet(d[a],d));}
bool unite(int a, int b, vi& d){
    a = dGet(a,d), b = dGet(b,d);
    if(a == b) return 0;
    if(d[a]>d[b]) swap(a,b);
    d[a]+=d[b];
    d[b] = a;
    return 1;
}
int lg(int n){
    int i = 0;
    for(n>>=1; n; n>>=1) i++;
    return i;
}
vector<pair<vm,vm>> genSeeds(int cnt){
    auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();
    mt19937 rng(static_cast<unsigned int>(seed));
    vector<pair<vm,vm>> ans(cnt,{vm(2),vm(2)});
    for(int i = 0; i<cnt; i++){
        ans[i].a[0]=ans[i].b[0]=1;
        ans[i].a[1] = uniform_int_distribution<int>(1,MOD-1)(rng);
        ans[i].b[1] = 1/ans[i].a[1];
    }
    return ans;
}
struct Hash {
    vector<pair<vm,vm>>& h;
    string s;
    vector<pair<BIT<mi>,BIT<mi>>> v;
    void resizeHashes(int n){
        while(h[0].a.size() < n){
            int sz = h[0].a.size();
            for(int i = 0; i<h.size(); i++){
                h[i].a.pb(h[i].a[sz-1]*h[i].a[1]);
                h[i].b.pb(h[i].b[sz-1]*h[i].b[1]);
            }
        }
    }
    Hash(string& str, vector<pair<vm,vm>>& seeds, bool constant=1) : h(seeds),s(str){
        resizeHashes(str.size());
        v.reserve(h.size());
        for(int i = 0; i<h.size(); i++) v.emplace_back(BIT<mi>(s.size(),constant),BIT<mi>(s.size(),constant));
        for(int i = 0; i<s.size(); i++){
            for(int j = 0; j<h.size(); j++){
                v[j].a.add(i,(s[i]+1)*h[j].a[i]);
                v[j].b.add(i,(s[i]+1)*h[j].b[i]);
            }
        }
    }
    void rep(int ind, char c){
        for(int i = 0; i<h.size(); i++){
            v[i].a.add(ind,(c-s[ind])*h[i].a[ind]);
            v[i].b.add(ind,(c-s[ind])*h[i].b[ind]);
        }
        s[ind] = c;
    }
    pair<vm,int> get(int a, int b){
        bool rev = a>b;
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = v[i].b.sum(b,a)*h[i].a[a];
            else ans[i] = v[i].a.sum(a,b)*h[i].b[a];
        return {ans,abs(a-b)+1};
    }
    pair<vm,int> comb(pair<vm,int>& left, pair<vm,int>& right, bool rev=0){
        resizeHashes(rev?right.b:left.b);
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = left.a[i]*h[i].a[right.b]+right.a[i];
            else ans[i] = left.a[i]+right.a[i]*h[i].a[left.b];
        return {ans,left.b+right.b};
    }
};
struct PairHash {
    size_t operator()(const std::pair<std::vector<mi>, int>& p) const {
        return p.a[0].v;
    }
};
class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> cnt(10);
        for(char c: num) cnt[c-'0']++;
        vector<mi> fac(n+1);
        fac[0] = 1;
        for(int i = 1; i<=n; i++) fac[i] = fac[i-1]*i;
        vector<mi> facInv(n+1);
        for(int i = 0; i<=n; i++) facInv[i] = 1/fac[i];
        int sum = 0;
        for(char c: num) sum+=c-'0';
        if(sum&1) return 0;
        vector<vector<mi>> dp((sum>>1)+1,vector<mi>(num.size()/2+1));
        dp[0][0] = fac[n/2]*fac[(n+1)/2];
        for(int i = 0; i<10; i++)
            for(int j = dp.size()-1; j>=0; j--)
                for(int k = dp[j].size()-1; k>=0; k--)
                    for(int l = 0; l<=min(i?j/i:INT_MAX,min(cnt[i],k)); l++)
                        if(l == 0) dp[j][k] = dp[j][k]/fac[cnt[i]];
                        else dp[j][k]+=dp[j-l*i][k-l]*facInv[l]*facInv[cnt[i]-l];
        return dp[dp.size()-1][dp[0].size()-1].v;
    }
};",1441352749
James_067,James_067,245,3627,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 1 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441304201
James_067,James_067,245,3628,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 2 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441303283
James_067,James_067,245,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) 
    {
        int sum1 = 0 , sum2 = 0;
        for( int i = 0; i < s.size(); i++ )
        {
             if(i&1) sum1 += ( s[i] - '0' );
            else sum2 += ( s[i] - '0' );
        }
        return sum1 == sum2;
    }
};",1441281735
James_067,James_067,245,3637,cpp,"
#define MOD 1000000007
#define ll long long

ll mod(ll a, ll m = MOD) { return (a % m + m) % m; }

template <class T>
class Math 
{
public:
    vector<T> fact, invfact;
    Math() {}
    Math(int n) 
    {
        fact.resize(n + 1);
        invfact.resize(n + 1);

        fact[0] = invfact[0] = 1;
        for (int i = 1; i <= n; i++) 
        {
            fact[i] = mod(i * fact[i - 1]);
            invfact[i] = modinv(fact[i]);
        }
    }
    T modinv(T x, T m = MOD) { return expo(x, m - 2, m); }
    T expo(T base, T exp, T m = MOD) 
    {
        T res = 1;
        while (exp) 
        {
            if (exp & 1) res = mod(res * base, m);
            base = mod(base * base, m);
            exp >>= 1;
        }
        return res;
    }
    T choose(T n, T k) 
    {
        if (k < 0 || k > n || n < 0) return 0;
        T ans = fact[n];
        ans = mod(ans * invfact[n - k]);
        ans = mod(ans * invfact[k]);
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string s) 
    {
        int n = s.size(), tot_d_sum = 0;
        int n1 = (n + 1) / 2 , n2 = n - n1;
        
        Math<ll> M(s.size());
        
        vector<int> freq(10);
        for (auto& d : s) 
        {
            freq[d - '0']++;
            tot_d_sum += (d - '0');
        }
        
        if (tot_d_sum % 2 != 0) return 0;
        
        int target_sum = tot_d_sum / 2;
        
        int dp[11][1001][41][41];
        memset(dp, -1, sizeof(dp));
        
        auto f = [&](auto&& self, int i, int j, int k, int l) -> ll
        {
            if (k > n1 || j > target_sum || l > n2 ) return 0;
            if (i == 10) return (j == target_sum && k == n1) ? 1 : 0;
            if (dp[i][j][k][l] != -1) return dp[i][j][k][l];
            
            ll result = 0;
            for (int c = 0; c <= freq[i]; ++c) 
            {
                if (c <= n1 - k && j + c * i <= target_sum && freq[i] - c <= n2 - l) 
                {
                    ll ways_to_choose_c = 1;
                    ll ways_to_fill_remaining = mod(M.choose(n1 - k, c)* M.choose(n2 - l , freq[i] - c));
                    result = (result + mod(mod(ways_to_choose_c * ways_to_fill_remaining) * self(self, i + 1, j + c * i, k + c, l + (freq[i] - c)))) % MOD;
                }
            }
            
            return dp[i][j][k][l] = result;
        };
        
        return f(f, 0, 0, 0, 0);
    }
};
",1441390801
xymabinogi,xymabinogi,246,3627,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = 1;
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441303362
xymabinogi,xymabinogi,246,3628,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = ((ni + nj) % 2 == 0 ? 2 : 1);
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441302979
xymabinogi,xymabinogi,246,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int even = 0, odd = 0;
        for (int i = 0; i < n; i++){
            int v = num[i] - '0';
            if (i % 2) even += v;
            else odd += v;
        }
        return even == odd;
    }
};",1441281584
xymabinogi,xymabinogi,246,3637,cpp,"using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1E9 + 7;
using Z = MInt<P>;
 
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        vector<int> cnt(10, 0);
        int tot = 0;
        for (auto ch : num){
            cnt[ch - '0']+= 1;
            tot += (ch - '0');
        }
        if (tot % 2) return 0;
        tot /= 2;
        
        Z res = 0;
        int n_first = n / 2 + n % 2;
        int n_second = n / 2;
       
        
        vector<vector<Z>> dp(n_first + 1, vector<Z>(tot + 1));
        dp[0][0] = Z(1);
        
        
        
        for (int i = 0; i < 10; i++) if (cnt[i]){
            for (int k = n_first; k >= 0; k--){
                for (int l = tot; l >= 0; l--){
                    if (!dp[k][l].val()) continue;
                    for (int j = 1; j <= cnt[i]; j++){
                        if (k + j > n_first) continue;
                        if (l + j * i <= tot){
                            dp[k + j][l + j * i] += dp[k][l] * comb.binom(cnt[i], j);
                        }
                    }
                }
            }
        }
        Z multi = comb.fac(n_first) * comb.fac(n_second);
        for (int i = 0; i < 10; i++){
            multi *= comb.invfac(cnt[i]);
        }
        
        dp[n_first][tot] *= multi;
        return  dp[n_first][tot].val();
        
        
        
        
        
    }
};",1441374001
luck,papaya,247,3627,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited ; 
        priority_queue< tuple<int64, int64 >> q ; 
        
        visited.assign( n , false ) ;  
        dis.assign( n , INF ); 

        dis[ src ] = 0 ; //start_time[ src ] ; 
        q.emplace( -dis[ src ] ,  src ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }
            if( visited[ u ] ) {
                continue ; 
            }
            visited[ u ] = true ; 
            for( auto [ v , w ] : g[u] ) {
                if( visited[v] ) {
                    continue ; 
                }
                int64 DD  = dis[u] + w ; 
                DD = max( DD , start_time[v] + 1 ) ; 

                if( dis[v] >  DD ) {
                    
                    dis[v] = DD ;
                    q.emplace( -dis[v] , v ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int ma22in( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 } ,  { 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    a = { { 56 , 93 } , { 3 , 38 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441312773
luck,papaya,247,3628,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis[2] ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited[2]; 
        priority_queue< tuple<int64, int64 , int  >> q ; 
        
        visited[0].assign( n , false ) ;  
        visited[1] = visited[0] ; 

        dis[0].assign( n , INF ); 
        dis[1].assign( n , INF ) ; 

        dis[1][ src ] = 0 ; //start_time[ src ] ; 
        q.emplace(  0  ,  src , 1 ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u , is_odd ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            int W = 2 ; 
            if( is_odd ) {
                W = 1 ; 
            }

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }

            if( visited[ is_odd ][ u ] ) {
                continue ; 
            }
            visited[ is_odd ][ u ] = true ; 

            int next_odd = 1 - is_odd ; 

            for( auto [ v , _ ] : g[u] ) {
                if( visited [ next_odd ] [ v ] ) {
                    continue ; 
                }
                int64 DD  = now_acc_cost + W ; 
                DD = max( DD , start_time[v] + W ) ; 

                if( dis[next_odd][v] >  DD ) {
                    
                    dis[next_odd][v] = DD ;
                    q.emplace( -dis[next_odd][v] , v , next_odd ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int mai33n( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 , 0 } ,  { 0 , 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    // a = { { 56 , 93 } , { 3 , 38 } } ; 


    a = { { 0,58 } , { 27,69 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441324094
luck,papaya,247,3636,python3,"import math 
import copy
from typing import * 
from heapq import * 
from collections import * 

class Solution:
    def isBalanced(self, num: str) -> bool:
        
        
        a = [ int( x ) for x in num ] ; 
        n = len( a ) ; 
        
        
        s1 = 0 ; 
        s2 = 0 ;
        
        for i in range( n ) :
            if( i % 2 == 0 ) :
                s1 += a[i] ; 
            else  :
                s2 += a[i] ;
        
        # print( s1 , s2 ) ; 
        
        return s1 == s2 ; 
    
    
def main( ) : 

    t = Solution() ; 

    num = ""1234""
    
    # num = ""24123"" ; 
    
    ans = t.isBalanced ( num ) ; 

    print(  ans ); 

if __name__ == '__main__':
    main()",1441289883
luck,papaya,247,3637,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 INF = 1e18 ; 
const int64 MOD = 1e9 + 7 ; 
const int BASE = 720 ; //int64 base = 720 ; 
const int UP =  BASE * 2 ; 

struct Comb { 
    vector< vector<int64> > C ;
    int n ; 

    void init( int tn ){
        n = tn ;
        C.assign( n + 1 , vector<int64>( n + 1 , 0 ) ) ;

        C[0][0] = 1 ; 
        for( int i = 1 ; i <= n ; i++ ) {
            C[i][0] = C[i][i] = 1 ; 
            for(int j = 1 ; j < i ; j++ ) {
                C[i][j] = C[i-1][j] + C[i-1][j-1] ;
                C[i][j] %= MOD ;
            }
        }
    }
} ; 

class Solution {
public:
    vector<int> a  , cnt ; 
    int n ; 
    int need_select ; 
    Comb comb ; 
    vector< int > aft_sum ; 

    int get( char c ) {
        return int( c ) - int( '0' ) ; 
    }
    vector< vector< vector<int64 >> > cache ; // f[2] ; 
    
    int64 dp( int choices , int other_choices  ,  int d  , int sum ) { 
        
        // cout << "" choices: "" << choices << "" D: "" << d << "" sum: "" << sum << ""\n"" ; 

        if( d >= 10 ) {
            return (choices == 0 && sum == BASE) ? 1 : 0 ; 
        }
        auto &ret = cache[ choices][d][sum] ;
        if( -1 != ret ) {
            return ret ;
        }
        ret = 0 ; 

        if( aft_sum[d] +  sum < BASE ) { // all select 
            return 0 ; 
        }
        if( aft_sum[d] - sum > BASE ) { // all not select 
            return 0 ; 
        }


        int all_s = cnt[d] * d ; 
        int all_cnt = cnt[d] ; 
        for( int select_cnt = 0 ; select_cnt <= cnt[d] && select_cnt <= choices ;  select_cnt++ ) { 
            
            if( other_choices - (all_cnt-select_cnt)  < 0 ) {
                continue ; 
            }
            
            int select_sum_s1 = d * select_cnt ; 
            int other_s2 = all_s - select_sum_s1 ; 

            int64 cnt = dp( choices - select_cnt ,  other_choices - (all_cnt-select_cnt) ,  d + 1 , sum + select_sum_s1 - other_s2 ) ; 
            int64 cnt2 = comb.C[ choices ][ select_cnt ] ; 
            int64 cnt3 = comb.C[ other_choices ] [ all_cnt - select_cnt ] ; 

            int64 t_ans = ( cnt * cnt2 ) % MOD ; 
            t_ans = ( t_ans * cnt3 ) % MOD ; 

            // if( select_cnt >= 1 ) { 
            //     // cout << "" choices: "" << choices << "" selec_cnt: "" << select_cnt << "" D: "" <<d << "" t_ans: "" << t_ans << ""\n"" ; 
            // }

            ret = ( ret + t_ans ) % MOD ; 
        }
        return ret ; 
    }

    void init( ) { 
        aft_sum.assign( 13 , 0 ) ; 
        for( int j = 9 ; j >= 0 ; j-- ) {
            int val = cnt[j] * j ; 
            aft_sum[j] = aft_sum[j+1] + val ; 
        }
    }
    int solve() { 
        init() ; 

        comb.init( n + 1 ) ; 

        cache.resize( n + 1 ) ; 
        for( int i = 0 ; i <= n ;i++ ) { 
            cache[i].assign( 10 , vector<int64> ( UP + 1 , -1  )) ; 
        }

        int sum = accumulate( a.begin()  ,a.end() , 0 ) ; 
        if( sum % 2 != 0 ) {
            return 0 ; 
        }
        auto ans = dp(  need_select  , n - need_select ,   0 , BASE  ) ; 
        return ans ; 
    }
    int countBalancedPermutations(string num) {

        n = num.size() ; 
        need_select = ( n + 1 ) / 2 ; 
        
        cnt.assign( 10 , 0 ) ; 
        a.assign( n + 1 , 0 ) ; 
        for( int i = 0 ; i < n ; i++ ) { 
            int d = get( num[i] ) ; 
            a[ i + 1 ] = d ; 
            cnt[d]++ ; 
        }
        return solve() ;  
    }
};




int ma33in( )  { 
    Solution  t; 

    string s = ""123"" ; 

    // s = ""112"" ; 

    // s = ""12345"" ; 

    // s = ""4567"" ; 

    auto ans = t.countBalancedPermutations ( s ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441380293
Aylup,Aylup,248,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 3>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto [d, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + 1, moveTime[rd][cd] + 1), rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441314422
Aylup,Aylup,248,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 4>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto [d, b, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + b + 1, moveTime[rd][cd] + b + 1), b ^ 1, rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441316347
Aylup,Aylup,248,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i % 2) {
                ans += num[i] - '0';
            } else {
                ans -= num[i] - '0';
            }
        }
        return ans == 0;
    }
};",1441294643
Aylup,Aylup,248,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9 + 7
        total = sum(map(int, num))
        if total % 2 != 0:
            return 0
        n = len(num)
        m = (n + 1) // 2
        m2 = n // 2
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i
            fact[i] %= mod
        target = total // 2
        count = Counter(map(int, num))
        pfx = [0] * 11
        for i in range(10):
            pfx[i] = pfx[i - 1] + count[i]
        @cache
        def dp(i, j, k):
            if k > target:
                return 0
            if i == 10:
                if j != m or k != target:
                    return 0
                return (fact[m] * fact[m2]) % mod
            ans = 0
            high = min(m, count[i])
            for z in range(0, high + 1):
                val = dp(i + 1, j + z, k + z * i)
                val *= pow(fact[z], -1, mod)
                val %= mod
                val *= pow(fact[count[i] - z], -1, mod)
                val %= mod
                
                ans += val
                ans %= mod
            return ans
        return dp(0, 0, 0)",1441381250
abhishek vaish,abhishekvaish,249,3627,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + 1, moveTime[nx][ny]+1):
                    dist[nx][ny] = max(dist[i][j] + 1, moveTime[nx][ny] + 1)
                    hpush(h, (dist[nx][ny], nx, ny) )
                
        # return 
                
        ",1441294943
abhishek vaish,abhishekvaish,249,3628,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0,1) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j,mv = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + mv, moveTime[nx][ny]+mv):
                    dist[nx][ny] = max(dist[i][j] + mv, moveTime[nx][ny] + mv)
                    hpush(h, (dist[nx][ny], nx, ny,  1 if mv == 2 else 2  ) )
                ",1441299436
abhishek vaish,abhishekvaish,249,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o = 0,0
        for i in range(len(num)):
            if i % 2 == 0:
                e += int(num[i])
            else:
                o += int(num[i])
        return e == o
            ",1441281220
abhishek vaish,abhishekvaish,249,3637,python3,"MOD = 10**9+7
fact = [1] * 81
ifact = [1] * 81
for i in range(1,81):
    fact[i] = (i * fact[i-1]) % MOD

ifact[80] = pow(fact[80],-1,MOD)
for i in range(79,-1, -1):
    ifact[i] = (ifact[i+1] * (i+1)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int,num))
        if s%2 == 1: return 0
        mx = [0]*10
        for x in num:
            mx[int(x)] += 1
        # print(""---""*n)
        def count_perm(count):
            # print(count)
            si = sum(count)
            p1, p2 = fact[si] , fact[n - si]
            for i in range(10):
                c1 = count[i]
                c2 = mx[i] - count[i]
                p1 = (p1 * ifact[c1]) % MOD
                p2 = (p2 * ifact[c2]) % MOD
                
            
            return (p1 * p2) % MOD
        
        @cache
        def DP(x, ele, target):
            if ele < 0 : return 0
            if target < 0 : return 0
            if x == 10 :
                if ele == 0 and target == 0:
                    return (fact[n//2] * fact[n-(n//2)]) % MOD
                return 0
            
            p = 0
            for i in range(mx[x]+1):
                c = DP(x+1,ele-i, target - (x*i))
                p += (c * ifact[i] * ifact[mx[x]-i]) % MOD
            return p % MOD
        
        return DP(0,n//2,s//2)
            
            
        
#         def dfs(x, count):
#             if x == 10:
#                 # print(count)
#                 sum_ = sum([ x*i for i,x in enumerate(count)])
#                 sum_i = sum(count)
#                 if n % 2 == 0 and sum_i != n // 2:
#                     return 0
#                 if n % 2 == 1 and sum_i != n // 2 :
#                     return 0
#                 if sum_ == s // 2 :
#                     return count_perm(count)
#                 return 0 
            
#             res = 0
#             for i in range(mx[x]+1):
#                 count[x] = i
#                 res = (res + dfs(x+1, count)) % MOD
#             count[x] = 0
#             return res
        
#         return dfs(0,[0]*10)

# 2
# 1
# 0
# 793764298
# 144920189
            
        ",1441382043
Zardinality,Zardinality,250,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<long long>> dist(n, vector<long long>(m, LLONG_MAX));
        dist[0][0] = 0;
        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>,
                      greater<pair<long long, pair<int, int>>>> pq;
        
        pq.push({0, {0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + 1LL;
                    
                    if (wait_time < dist[new_row][new_col]) {
                        dist[new_row][new_col] = wait_time;
                        pq.push({wait_time, {new_row, new_col}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441326235
Zardinality,Zardinality,250,3628,cpp,"using ll = long long;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, LLONG_MAX)));
        dist[0][0][0] = 0;
        priority_queue<pair<ll, array<int, 3>>, 
                      vector<pair<ll, array<int, 3>>>,
                      greater<pair<ll, array<int, 3>>>> pq;
        
        pq.push({0, {0, 0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col, step] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col][step]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + (step == 0?1LL:2LL);
                    int nstep = 1-step;
                    if (wait_time < dist[new_row][new_col][nstep]) {
                        dist[new_row][new_col][nstep] = wait_time;
                        pq.push({wait_time, {new_row, new_col, nstep}});
                    }
                }
            }
        }
        auto& pres = dist[n-1][m-1];
        return min(pres[0], pres[1]);
    }
};",1441339665
Zardinality,Zardinality,250,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ns = num.size();
        int en = 0;
        int on = 0;
        for(int i=0;i<ns;i++){
            if(i%2){
                en += (num[i]-'0');
            }
            else{
                on += (num[i]-'0');
            }
        }
        return en == on;
    }
};",1441287239
Zardinality,Zardinality,250,3637,cpp,"#define PRIME 1000000007
using ll = long long;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int ns = num.size();
        vector<int> buf(ns, 0);
        int tsum = 0;
        for(int i=0;i<ns;i++){
            buf[i] = num[i]-'0';
            tsum += buf[i];
        }
        vector<int> freq(10, 0);
        for (char c : num) {
            freq[c - '0']++;
        }
        
        if(tsum%2) return 0;
        int target = tsum/2;
        int even_cnt = ns/2;
        vector<vector<ll>> dp(even_cnt+1, vector<ll>(target+1, 0));
        dp[0][0] = 1;
        for(int i=0;i<ns;i++){
            vector<vector<ll>> ndp = dp;
            int cdigit = buf[i];
            for(int j=0;j<even_cnt;j++){
                for(int k=0;k<=target;k++){
                    if(k+cdigit<=target){
                        // std::cout<<j+1<<"" ""<<k+cdigit<<"" ""<<dp.size()<<"" ""<<dp[0].size()<<endl;
                        ndp[j+1][k+cdigit] += dp[j][k];
                        ndp[j+1][k+cdigit] %= PRIME;
                    }
                }
            }
            dp = std::move(ndp);
        }
        int num_subsets = dp.back().back();
        auto factorial = [](int n){
            if(!n) return 1LL;
            ll res = n;
            while(--n){
                res *= n;
                res %= PRIME;
            }
            return res;
        };
                auto modPow = [&](ll base, ll exp) {
            ll result = 1;
            while (exp > 0) {
                if (exp & 1) result = (result * base) % PRIME;
                base = (base * base) % PRIME;
                exp >>= 1;
            }
            return result;
        };
        
        auto modInverse = [&](ll n) {
            return modPow(n, PRIME - 2);
        };
        // cout<<num_subsets<<"" ""<<factorial(even_cnt)<<endl;
        ll even_fact = factorial(even_cnt);
        ll odd_fact = factorial(ns-even_cnt);
        auto result = ((num_subsets * even_fact) % PRIME) * odd_fact % PRIME;
                
        for (int i = 0; i < 10; i++) {
            if (freq[i] > 1) {
                result = (result * modInverse(factorial(freq[i]))) % PRIME;
            }
        }
        return result;
    }
};",1441395191
minamego001,minamego001,252,3627,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[55][55];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({0, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({-max(cur,moveTime[nx][ny]) - 1 , {nx,ny}});
            }
        }
        return 0;
    }
};",1441294632
minamego001,minamego001,252,3628,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[760][760];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({{0,0}, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            int add = -a.first.second;
            int nadd = -1;
            if(add == 1) nadd = -2;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({{-max(cur,moveTime[nx][ny]) + nadd, nadd} , {nx,ny}});
            }
        }
        return 0;
    }
};",1441299481
minamego001,minamego001,252,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0 , b = 0;
        for(int i = 0 ; i<num.size(); ++i) {
            if(i&1) a+= num[i]-'0';
            else b += num[i]-'0';
        }
        return a == b;
    }
};",1441281602
minamego001,minamego001,252,3637,cpp,"class Solution {
public:
    int cnt[10];
    const int mod = 1e9 + 7;
unsigned long long fac[88];
long long ncr[88][88];
unsigned long long power(unsigned long long x, 
                                  int y)
{
    unsigned long long res = 1; // Initialize result
 
    x = x % mod; // Update x if it is more than or
    // equal to p
 
    while (y > 0) 
    {
     
        // If y is odd, multiply x with result
        if (y & 1)
            res = (res * x) % mod;
 
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % mod;
    }
    return res;
}
 
// Returns n^(-1) mod p
unsigned long long modInverse(unsigned long long n
                                            )
{
    return power(n, mod - 2);
}
 
// Returns nCr % p using Fermat's little
// theorem.
unsigned long long nCr(unsigned long long n,
                                 int r)
{
    // If n<r, then nCr should return 0
    if (n < r)
        return 0;
    // Base case
    if (r == 0)
        return 1;
 
    return (fac[n] * modInverse(fac[r]) % mod
            * modInverse(fac[n - r]) % mod)
           % mod;
}
    int dp[10][41][730];
    int ans = 0;
    int acc[11];
    long long solve(int i, int odd,int even, int sum) {
        if(sum == ans && odd == 0 && even == 0) return 1;
        if(sum > ans || odd < 0 || i == 10 || even < 0) return 0;

        int &ret = dp[i][odd][sum];
        if(~ret) return ret;
        ret = 0;
        for(int a = 0 ; a<= cnt[i] ; ++a) {
            long long x =  (ncr[odd][a] * solve(i+1,odd - a, even - (cnt[i] - a), sum + a * i))%mod;
            //cout<<i<< "" ""<<a<<"" ""<<sum<<"" ""<<x<<"" ""<<endl;
            x = (x * ncr[even][cnt[i]-a]) % mod;
            ret += x;
            ret%=mod;
        }
        return ret;
        
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        for(auto a : num) 
            {
                sum += a - '0';
                cnt[a-'0']++;
            }
        
        int n = num.size();
            fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % mod;
    acc[0] = cnt[0];
    for(int i = 1 ; i<=9 ; ++i) acc[i] = cnt[i] + acc[i-1];
    for(int i = 0 ; i <=n ; ++i) 
        for(int j = 0 ; j<=i ; ++j) ncr[i][j] = nCr(i,j);
        int odd = (n+1)/2;
        int even = n/2;
        if(sum & 1) return 0;
        ans = sum/2;
        memset(dp,-1,sizeof(dp));
        return solve(0,odd,even,0);
    }
};",1441377894
derrick2001,derrick2001,253,3627,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> pq;
        pq.push({0,0,0});
        dd[0][0]= 0;        
        while(pq.size()) {
            auto[d, x, y] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_++;
                    if (t_ < dd[nx][ny]) {
                        pq.push({t_,nx,ny});
                        dd[nx][ny] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441337233
derrick2001,derrick2001,253,3628,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5][2];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, greater<tuple<int,int,int,int>>> pq;
        pq.push({0,0,0,0});
        dd[0][0][0] = 0;        
        while(pq.size()) {
            auto[d, x, y,p] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y][p]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_ += (1 + (p!=0));
                    if (t_ < dd[nx][ny][p^1]) {
                        pq.push({t_,nx,ny,p^1});
                        dd[nx][ny][p^1] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441334453
derrick2001,derrick2001,253,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o=0,0
        for i,x in enumerate(num):
            if i%2:
                o += int(x)
            else:
                e += int(x)
        return o==e
        ",1441305760
derrick2001,derrick2001,253,3637,cpp,"const int MOD = 1e9 + 7;
typedef long long ll;



ll power_mod(ll x, ll y, ll mod) {
    ll res = 1;
    x %= mod;
    while(y > 0){
        if(y & 1LL){
            res = res * x % mod;
        }
        x = x * x % mod;
        y >>= 1LL;
    }
    return res;
}


struct Factorials {
    vector<long long> fact;
    vector<long long> inv_fact;
    int max_n;

    Factorials(int n_max) : max_n(n_max), fact(n_max + 1, 1), inv_fact(n_max + 1, 1) {
        for(int i = 1; i <= max_n; ++i){
            fact[i] = fact[i-1] * i % MOD;
        }
        inv_fact[max_n] = power_mod(fact[max_n], MOD - 2, MOD);
        for(int i = max_n -1; i >=0; --i){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
    }


    ll comb(int n, int k){
        if(n < k || k < 0) return 0;
        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
    }

    ll factorial(int n){
        if(n < 0 || n > max_n) return 0;
        return fact[n];
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        Factorials factorials(n);

        
        int freq[10] = {0};
        for(char ch : num){
            freq[ch - '0']++;
        }
    
        int total_sum = 0;
        for(int d =0; d <=9; ++d){
            total_sum += d * freq[d];
        }

        
        if(total_sum % 2 != 0){
            return 0;
        }

        int target_sum = total_sum / 2;
        int k = (n +1)/2; 

        vector<vector<int>> dp(k +1, vector<int>(target_sum +1, 0)); //sm at even
        dp[0][0] = 1;

        for(int d =0; d <=9; ++d){
            if(freq[d] ==0) continue;
            vector<vector<int>> temp(k +1, vector<int>(target_sum +1, 0));
            for(int c =0; c <=k; ++c){
                for(int s =0; s <=target_sum; ++s){
                    if(dp[c][s] ==0) continue;
                    for(int m =0; m <= min(freq[d], k - c); ++m){
                        if(s + d * m > target_sum) break;
                        // Number of ways to choose m digits of this digit
                        // which is C(freq[d], m)
                        ll combinations = factorials.comb(freq[d], m);
                        temp[c + m][s + d * m] = (temp[c + m][s + d * m] + dp[c][s]%MOD * combinations%MOD) % MOD;
                    }
                }
            }
            dp = temp;
        }
        
        int ways = dp[k][target_sum];


        if(ways ==0){
            return 0;
        }
        int fk = factorials.factorial(k);
        int fck = factorials.factorial(n -k);

        int denom =1;
        for(int d =0; d <=9; ++d){
            denom = denom * factorials.fact[freq[d]] % MOD;
        }

        long long numerator = 1LL* fk * fck % MOD;


        long long inv = power_mod(denom, MOD -2, MOD);
        long long ans = 1LL* ways * numerator % MOD;
        ans = ans%MOD * inv % MOD;

        return (int)ans;
    }
};",1441352897
Jiabei Zhu,zzjjbb,255,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 1, t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441316122
Jiabei Zhu,zzjjbb,255,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 2 - ((i + j) & 1), t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1 + ((i + j) & 1)
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441315209
Jiabei Zhu,zzjjbb,255,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281111
Jiabei Zhu,zzjjbb,255,3637,python3,"M = 1_000_000_007
fact = [1]
for i in range(1, 100):
    fact.append(fact[-1] * i % M)
ifact = [pow(i, -1, M) for i in fact]
 

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        num = list(map(int, num))
        goal = rgoal = sum(num)
        if goal % 2:
            return 0
        goal >>= 1
        c = Counter(num)
        c = [c[i] for i in range(10)]
        l = defaultdict(int)
        l[0, 0] = 1
        ctl = 0
        for di in range(10):
            nl = defaultdict(int)
            cdi = c[di]
            for (cs, cl), cnt in l.items():
                for i in range(cdi + 1):
                    ad = (cnt * fact[cl + i]) % M
                    ad = (ad * ifact[cl]) % M
                    ad = (ad * ifact[i]) % M
                    ad = (ad * fact[ctl + cdi - cl - i]) % M
                    ad = (ad * ifact[ctl - cl]) % M
                    ad = (ad * ifact[cdi - i]) % M
                    # print(cnt, ad)
                    nl[cs + di * i, cl + i] += ad
            l = nl
            ctl += cdi
        # print(nl)
        # print(l)
        ans = 0
        for (cs, cl), cnt in l.items():
            if cs == goal and cl == n // 2:
                ans = (ans + cnt) % M
        return ans
",1441396831
youknowwho99,youknowwho99,256,3627,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2]});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2]});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441330065
youknowwho99,youknowwho99,256,3628,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t;
                if(a[3]==0)
                 t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]+1][a[2]]+2,a[0]+2);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2],a[3]^1});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]+1]+2,a[0]+2);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1,a[3]^1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                else
                    t=max(vec[a[1]-1][a[2]]+2,a[0]+2);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2],a[3]^1});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]-1]+2,a[0]+2);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1,a[3]^1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441335847
youknowwho99,youknowwho99,256,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int e=0;
        int o=0;
        for(int i=0;i<s.length();i+=2){
            e+=s[i]-'0';
        }
        for(int i=1;i<s.length();i+=2){
            o+=s[i]-'0';
        }
        return o==e;
    }
};",1441281561
youknowwho99,youknowwho99,256,3637,cpp,"class Solution {
public:
    long long powerMod(long long base, long long exp, long long mod) {
        long long res = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) res = res * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return res;
    }
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int len = num.size();
        int evenCount = (len + 1) / 2; 
        int oddCount = len / 2; 

        int digitCount[10] = {0};
        for (char ch : num) {
            digitCount[ch - '0']++;
        }

        long long totalSum = 0;
        for (int d = 0; d < 10; d++) {
            totalSum += (long long)d * digitCount[d];
        }

        if (totalSum % 2 != 0) return 0; 
        long long targetSum = totalSum / 2;

        const int MAX_LEN = 80;
        vector<long long> factorial(MAX_LEN + 1, 1);
        for (int i = 1; i <= MAX_LEN; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        vector<long long> invFactorial(MAX_LEN + 1, 1);
        invFactorial[MAX_LEN] = powerMod(factorial[MAX_LEN], MOD - 2, MOD);
        for (int i = MAX_LEN - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        auto combination = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFactorial[k] % MOD * invFactorial[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenCount + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (digitCount[d] == 0) continue; 
            for (int t = evenCount; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue; 
                    for (int k = 1; k <= digitCount[d] && t + k <= evenCount && s + (long long)d * k <= targetSum; k++) {
                        dp[t + k][s + (long long)d * k] = (dp[t + k][s + (long long)d * k] + dp[t][s] * combination(digitCount[d], k)) % MOD;
                    }
                }
            }
        }

        long long validPermutations = dp[evenCount][targetSum];

        long long productFactorials = 1;
        for (int d = 0; d < 10; d++) {
            productFactorials = productFactorials * factorial[digitCount[d]] % MOD;
        }

        long long result = validPermutations;
        result = result * factorial[evenCount] % MOD;
        result = result * factorial[oddCount] % MOD;

        long long invProduct = powerMod(productFactorials, MOD - 2, MOD);
        result = result * invProduct % MOD;

        return (int)result;
    }


};
",1441384835
Akash,Akash_0P,257,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
            pq.push({0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + cur;
                            pq.push({dp[nr][nc], nr, nc});
                        }
                    }else if(moveTime[nr][nc] + 1 < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1;
                        pq.push({dp[nr][nc], nr, nc});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};",1441364556
Akash,Akash_0P,257,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
            pq.push({0, 0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j, flag] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + flag + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + flag + cur;
                            pq.push({dp[nr][nc], nr, nc, !flag});
                        }
                    }else if(moveTime[nr][nc] + 1 + flag < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1 + flag;
                        pq.push({dp[nr][nc], nr, nc, !flag});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};
",1441366468
Akash,Akash_0P,257,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();

        vector<int> v(2);

        for(int i = 0; i < n; i++) {
            v[i & 1] += num[i] - '0';
        }

        return v[0] == v[1];
    }
};",1441281902
Akash,Akash_0P,257,3637,cpp,"using ll = long long;

const int N = 2e5 + 5, M = 1e9 + 7;
ll fact[N], ifact[N];

ll add(ll a, ll b) {
  return (a + b) % M;
}

ll mul(ll a, ll b) {
  return (a * b) % M;
}

ll expo(ll a, ll b) {
  ll res = 1;
  while(b) {
    if(b & 1) res = mul(res, a);
    a = mul(a, a);
    b >>= 1;
  }
  return res;
}

void pre() {
  fact[0] = 1;
  for(ll i = 1; i < N; i++) fact[i] = mul(i, fact[i - 1]);
  ifact[N-1] = expo(fact[N-1], M-2);
  for(ll i = N-2; i >= 0; i--) ifact[i] = mul(i + 1, ifact[i + 1]);
}

ll nCr(ll n, ll r) {
  if(r > n) return 0;
  return mul(fact[n], mul(ifact[n - r], ifact[r]));
}

int flag = 0;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if(!flag) pre();
            
        int n = num.size(), target = 0;

        vector<int> freq(10);
        for(auto &i: num) freq[i - '0']++, target += i - '0';

        if(target & 1) return 0;

        vector dp(11, vector (n, vector (target + 1, -1)));

        vector<pair<int, int>> temp;

        auto f = [&](int i, int s, int val, auto && f) -> ll {

            if(i == 10) {
                if(val == 0 && s == 0) return mul(fact[(n + 1) / 2], fact[n / 2]);
                return 0;
            }

            if(dp[i][s][val] != -1) return dp[i][s][val];

            ll ans = 0;

            for(int x = 0; x <= freq[i]; x++) {
                if(s - x >= 0 && val - x * i >= 0) {
                    ans = add(ans, mul(mul(ifact[x], ifact[freq[i] - x]), f(i + 1, s - x, val - x * i, f)));
                }
            }

            return dp[i][s][val] = ans;

        };

        return f(0, (n + 1) / 2, target / 2, f);

    }
};",1441384985
Hongbo Zhong,neverbackdown,258,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 0, 0)]
        while Q:
            t, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = 1+max(moveTime[x][y], t)
                    heappush(Q, (new_t, x, y))
        
            ",1441305664
Hongbo Zhong,neverbackdown,258,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 1, 0, 0)]
        while Q:
            t, c, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = c+max(moveTime[x][y], t)
                    heappush(Q, (new_t, 1 if c==2 else 2, x, y))",1441308620
Hongbo Zhong,neverbackdown,258,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            d = int(num[i])
            if i%2 == 0:
                even += d
            else:
                odd += d
        return even == odd",1441281665
Hongbo Zhong,neverbackdown,258,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        digits = [int(ch) for ch in num]
        total = sum(digits)
        if total%2 == 1:
            return 0
            
        mod = 10**9+7
        memo = [defaultdict(lambda: 0) for _ in range(n)]
        for i in range(n):
            d = digits[i]
            if i == 0:
                memo[i][(d, 1)] = 1
                memo[i][(0, 0)] = 1
            else:
                for num, cnt in memo[i-1]:
                    memo[i][(num+d, cnt+1)] += memo[i-1][(num, cnt)]
                    memo[i][(num, cnt)] += memo[i-1][(num, cnt)]

        ans = memo[n-1][(total//2, n//2)]*perm(n//2, n//2)*perm(n-n//2, n-n//2)
        counter = Counter(digits)
        for freq in counter.values():
            ans //= perm(freq, freq)
        return ans % mod",1441391236
RAHUL YADAV,imdotrahul,259,3627,cpp,"#include <vector>
#include <queue>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        if (rows == 0) return 0;
        int cols = moveTime[0].size();
        if (cols == 0) return 0;

        vector<vector<int>> minTime(rows, vector<int>(cols, numeric_limits<int>::max()));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        initializePriorityQueue(pq, minTime);
        vector<vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!pq.empty()) {
            auto current = pq.top();
            pq.pop();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > minTime[currentRow][currentCol]) continue;

            exploreNeighbors(currentRow, currentCol, currentTime, moveTime, minTime, pq, directions);
        }

        return getMinTimeToDestination(minTime, rows, cols);
    }

private:
    void initializePriorityQueue(priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                                  vector<vector<int>>& minTime) {
        pq.push({0, 0, 0});
        minTime[0][0] = 0;
    }

    void exploreNeighbors(int row, int col, int time, vector<vector<int>>& moveTime, 
                          vector<vector<int>>& minTime, priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                          const vector<vector<int>>& directions) {
        for (const auto& dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];

            if (isValidCell(newRow, newCol, minTime)) {
                int newTime = calculateNewTime(time, moveTime[newRow][newCol]);
                updateMinTime(newRow, newCol, newTime, minTime, pq);
            }
        }
    }

    bool isValidCell(int row, int col, const vector<vector<int>>& minTime) {
        return row >= 0 && row < minTime.size() && col >= 0 && col < minTime[0].size();
    }

    int calculateNewTime(int currentTime, int moveTime) {
        return max(currentTime, moveTime) + 1;
    }

    void updateMinTime(int row, int col, int newTime, vector<vector<int>>& minTime, 
                       priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq) {
        if (newTime < minTime[row][col]) {
            minTime[row][col] = newTime;
            pq.push({newTime, row, col});
        }
    }

    int getMinTimeToDestination(const vector<vector<int>>& minTime, int rows, int cols) {
        return minTime[rows - 1][cols - 1];
    }
};",1441385871
RAHUL YADAV,imdotrahul,259,3628,cpp,"
class Solution {
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        std::vector<std::vector<std::vector<int>>> minTime(rows, std::vector<std::vector<int>>(cols, std::vector<int>(2, std::numeric_limits<int>::max())));
        
        minTime[0][0][0] = 0;
        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> priorityQueue;
        priorityQueue.push({0, 0, 0, 0});

        std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!priorityQueue.empty()) {
            auto current = priorityQueue.top();
            priorityQueue.pop();
            int currentTime = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];
            
            if (currentTime > minTime[row][col][parity]) continue;
            
            exploreNeighbors(currentTime, row, col, parity, moveTime, minTime, priorityQueue, directions);
        }
        
        return std::min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }

private:
    void exploreNeighbors(int currentTime, int row, int col, int parity, 
                          const std::vector<std::vector<int>>& moveTime,
                          std::vector<std::vector<std::vector<int>>>& minTime,
                          std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>>& priorityQueue,
                          const std::vector<std::vector<int>>& directions) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        
        for (const auto& direction : directions) {
            int newRow = row + direction[0];
            int newCol = col + direction[1];
            
            if (isValid(newRow, newCol, rows, cols)) {
                int nextTime = std::max(currentTime, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);
                if (nextTime < minTime[newRow][newCol][1 - parity]) {
                    minTime[newRow][newCol][1 - parity] = nextTime;
                    priorityQueue.push({nextTime, newRow, newCol, 1 - parity});
                }
            }
        }
    }

    bool isValid(int row, int col, int rows, int cols) {
        return row >= 0 && row < rows && col >= 0 && col < cols;
    }
};",1441366801
RAHUL YADAV,imdotrahul,259,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sumeven = 0;
        int sumodd = 0;
        for(int i = 0;i<n;i+=2)
        {
            sumeven+=num[i]-'0';
        }
        for(int i = 1;i<n;i+=2)
            {
                sumodd += num[i]-'0';
            }

        if(sumodd == sumeven)
        {
            return true;
        }
        else{
            return false;
        }
    }
};",1441291928
RAHUL YADAV,imdotrahul,259,3637,cpp,"#define MOD 1000000007
typedef long long ll;

vector<ll> factorial;
vector<ll> inv_factorial;

ll mod_power(ll base, ll exp) {
    ll result = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp & 1) result = result * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return result;
}

void initialize_factorials(int limit) {
    factorial.assign(limit + 1, 1);
    for (int i = 1; i <= limit; i++) {
        factorial[i] = factorial[i - 1] * i % MOD;
    }
    inv_factorial.assign(limit + 1, 1);
    inv_factorial[limit] = mod_power(factorial[limit], MOD - 2);
    for (int i = limit - 1; i >= 0; i--) {
        inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
    }
}

ll compute_combinations(int digit_count[], int digit, int used, int half_length) {
    if (used > digit_count[digit] || used > half_length) return 0;
    return (factorial[digit_count[digit]] * inv_factorial[used] % MOD) * inv_factorial[digit_count[digit] - used] % MOD;
}

void fill_dp_table(int digit_count[], vector<vector<ll>>& dp, ll half_sum, int half_length) {
    for (int d = 0; d <= 9; d++) {
        if (digit_count[d] == 0) continue;
        for (int c = half_length; c >= 0; c--) {
            for (ll s = half_sum; s >= 0; s--) {
                if (dp[c][s] == 0) continue;
                for (int t = 1; t <= min(digit_count[d], half_length - c); t++) {
                    if (s + (ll)d * t > half_sum) break;
                    ll combinations = compute_combinations(digit_count, d, t, half_length - c);
                    dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * combinations) % MOD;
                }
            }
        }
    }
}

class Solution {
public:
    int countBalancedPermutations(string digits) {
        int length = digits.size();
        int digit_count[10] = {0};
        ll total_digit_sum = 0;
        for (char c : digits) {
            int digit = c - '0';
            digit_count[digit]++;
            total_digit_sum += digit;
        }
        if (total_digit_sum % 2 != 0) return 0;
        ll half_sum = total_digit_sum / 2;
        int half_length = (length + 1) / 2;
        initialize_factorials(length);
        vector<vector<ll>> dp(half_length + 1, vector<ll>(half_sum + 1, 0));
        dp[0][0] = 1;
        fill_dp_table(digit_count, dp, half_sum, half_length);
        ll valid_permutations = dp[half_length][half_sum];
        if (valid_permutations == 0) return 0;
        ll product_factorials = 1;
        for (int d = 0; d <= 9; d++) {
            product_factorials = product_factorials * factorial[digit_count[d]] % MOD;
        }
        ll combinations_k_nk = (factorial[half_length] * factorial[length - half_length]) % MOD;
        ll inv_product_factorials = mod_power(product_factorials, MOD - 2);
        ll final_answer = (combinations_k_nk * valid_permutations) % MOD;
        final_answer = (final_answer * inv_product_factorials) % MOD;

        return (int)final_answer;
    }
};
",1441378126
Jingzhe Tang,skywalkert,261,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 51, maxm = 2501, INF = 0x3f3f3f3f;
        static int f[maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<pair<int, int> > cand[2];
        auto upd = [&](int x, int y, int t) {
            // printf(""chk %d %d %d\n"", x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[x][y] || t <= tim[x][y])
                return;
            // assert(cur <= t && t <= cur + 1);
            f[x][y] = t;
            cand[t - cur].push_back({x, y});
            // printf(""new %d %d: %d\n"", x, y, t);
        };
        f[0][0] = 0;
        cand[0].push_back({0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d\n"", cur, pos, cand[0].size(), cand[1].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1 && f[x][y] == INF; ++dx)
                    for(int dy = -1; dy <= 1 && f[x][y] == INF; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c || f[xx][yy] >= cur)
                            continue;
                        f[x][y] = cur + 1;
                    }
                // if(f[x][y] != cur + 1) {
                //     printf(""cur %d x %d y %d pos %d\n"", cur, x, y, pos);
                //     for(int i = 0; i < r; ++i)
                //         for(int j = 0; j < c; ++j)
                //             printf(""%d%c"", f[i][j] < INF ? f[i][j] : -1, "" \n""[j == c - 1]);
                // }
                // assert(f[x][y] == cur + 1);
                if(f[x][y] == cur + 1) {
                    // printf(""new2 %d %d: %d\n"", x, y, cur + 1);
                    cand[1].push_back({x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(x + dx, y + dy, f[x][y] + 1);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                ++cur;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        return f[r - 1][c - 1];
    }
};",1441346708
Jingzhe Tang,skywalkert,261,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 751, maxm = 562501, INF = 0x3f3f3f3f;
        static int f[2][maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[0][i][j] = f[1][i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<array<int, 3> > cand[3];
        auto upd = [&](int o, int x, int y, int t) {
            // printf(""chk %d %d %d %d\n"", o, x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[o][x][y])
                return;
            if(t - !o <= tim[x][y]) {
                f[o][x][y] = tim[x][y] + 2 - o;
            } else {
                assert(cur <= t && t <= cur + 2);
                f[o][x][y] = t;
                cand[t - cur].push_back({o, x, y});
            }
            // printf(""new %d %d %d: %d\n"", o, x, y, t);
        };
        f[0][0][0] = 0;
        cand[0].push_back({0, 0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d %d\n"", cur, pos, cand[0].size(), cand[1].size(), cand[2].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[0][x][y] < INF && f[1][x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c)
                            continue;
                        if(f[1][x][y] == INF && f[0][xx][yy] < cur)
                            f[1][x][y] = cur + 1;
                        if(f[0][x][y] == INF && f[1][xx][yy] < cur)
                            f[0][x][y] = cur + 2;
                    }
                if(f[0][x][y] >= cur && f[0][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 0, x, y, f[0][x][y]);
                    cand[f[0][x][y] - cur].push_back({0, x, y});
                }
                if(f[1][x][y] >= cur && f[1][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 1, x, y, f[1][x][y]);
                    cand[f[1][x][y] - cur].push_back({1, x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[o, x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(!o, x + dx, y + dy, f[o][x][y] + 1 + o);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                cand[2].swap(cand[1]);
                ++cur;
            } else if(!cand[2].empty()) {
                cand[2].swap(cand[0]);
                cur += 2;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        // for(int i = 0; i < r; ++i)
        //     for(int j = 0; j < c; ++j)
        //         printf(""[%d|%d]%c"", f[0][i][j] < INF ? f[0][i][j] : -1, f[1][i][j] < INF ? f[1][i][j] : -1, "" \n""[j == c - 1]);
        return min(f[0][r - 1][c - 1], f[1][r - 1][c - 1]);
    }
};",1441380781
Jingzhe Tang,skywalkert,261,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int dt = 0;
        for(char ch: num)
            dt = ch - '0' - dt;
        return !dt;
    }
};",1441280946
Jingzhe Tang,skywalkert,261,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        typedef long long LL;
        static const int maxd = 10, maxm = 41, maxh = 361, mod = (int)1e9 + 7;
        static int f[maxm][maxh], iact[maxm << 1 | 1], ctr[maxd + 1];
        int n = num.size(), s = 0;
        memset(ctr, 0, sizeof ctr);
        for(char ch: num) {
            int o = ch - '0';
            ++ctr[o];
            s += o;
        }
        if(s & 1)
            return 0;
        int m = n >> 1, h = s >> 1;
        for(int i = 0; i <= m; ++i)
            memset(f[i], 0, (h + 1) * sizeof(int));
        iact[1] = 1;
        for(int i = 2; i <= n; ++i)
            iact[i] = mod - (int)(mod / i * (LL)iact[mod % i] % mod);
        iact[0] = 1;
        for(int i = 1; i <= n; ++i)
            iact[i] = (LL)iact[i - 1] * iact[i] % mod;
        f[0][0] = 1;
        for(int o = 0; o < maxd; ++o) {
            if(!ctr[o])
                continue;
            for(int i = m; i >= 0; --i)
                for(int j = h; j >= 0; --j) {
                    int ways = 0;
                    for(int k = min(ctr[o], o ? min(i, j / o) : i); k >= 0; --k)
                        ways = (ways + (LL)f[i - k][j - o * k] * iact[k] % mod * iact[ctr[o] - k]) % mod;
                    f[i][j] = ways;
                }
        }
        int ways = f[m][h];
        for(int i = 2; i <= m; ++i)
            ways = (LL)ways * i * i % mod;
        if(m + m < n)
            ways = (LL)ways * (n - m) % mod;
        return ways;
    }
};",1441307509
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3627,cpp,"struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 1);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny,  (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441364022
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 2);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441362661
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int e = 0, o = 0;
        for(int i = 0; i< n; i++) {
            if(i & 1) {
                e += s[i] - '0';
                continue;
            }
            o += s[i] - '0';
            
        }

        return (e == o);
    }
};",1441283173
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3637,cpp,"class Solution {
public:
  
int power(long long n, long long k, int mod) {
  int ans = 1 % mod; n %= mod; if(n < 0) n += mod;

  while(k) {
    if(k & 1) ans = 1ll *  ans * n % mod;
    n = 1ll *  n * n % mod;
    k >>= 1;
  }

  return ans;
}
    int countBalancedPermutations(string num) {
        const int mod = 1e9 + 7;
        int n = num.size();
        int m = (n + 1) / 2;


        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }

        long long t = 0;
        for(int i = 0; i < 10; i++) {
            t += 1ll * i * cnt[i];
        }

        if(t % 2 != 0) return 0;

        long long tot = t / 2;

        const int q = 80;
        vector<long long> fac(q + 1, 1);
        for(int i = 1; i <= q; i++) {
            fac[i] = fac[i -1] * i % mod;
        }

        vector<long long> inv_fac(q + 1, 1);
        inv_fac[q] = power(fac[q], mod - 2, mod);
        for(int i = q - 1; i >= 0; i--){
            inv_fac[i] = 1ll * inv_fac[i +1] * (i +1) % mod;
        }

        auto ncr = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return fac[n] * inv_fac[k] % mod * inv_fac[n -k] % mod;
        };

        vector<vector<long long>> dp(m + 1, vector<long long>(tot + 1, 0));
        dp[0][0] = 1;

        for(int i =0; i < 10; i++) {
            if(!cnt[i]) continue;
            for(int t = m; t >= 0; t--){
                for(long long s = tot; s >= 0; s--){
                    if(dp[t][s] == 0) continue;
                    for(int k = 1; k <= cnt[i] and t + k <= m and s + 1ll * i * k <= tot; k++){
                        dp[t + k][s + 1ll * i * k] = (dp[t + k][s + 1ll * i * k] + dp[t][s] * ncr(cnt[i], k)) % mod;
                    }
                }
            }
        }

        long long calc = 1;
        for(int i = 0; i < 10; i++) {
            calc = calc * fac[cnt[i]] % mod;
        }

        int ans = 1ll * (dp[m][tot] % mod) * fac[m] % mod;
        ans = 1ll * ans * fac[n / 2] % mod;
        ans = 1ll * ans * power(calc, mod -2, mod) % mod;

        return ans;
    }
};",1441393320
birds3345,birds3345,264,3627,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, coord] = pq.top();
            auto [i, j] = coord;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + 1;
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {i + 1, j}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + 1;
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {i, j + 1}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + 1;
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {i - 1, j}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + 1;
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {i, j - 1}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441297556
birds3345,birds3345,264,3628,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<bool, pair<int, int>>>, vector<pair<int, pair<bool, pair<int, int>>>>, greater<>> pq;
        pq.push({0, {true, {0, 0}}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, info] = pq.top();
            auto move = info.first;
            auto [i, j] = info.second;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {!move, {i + 1, j}}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {!move, {i, j + 1}}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {!move, {i - 1, j}}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {!move, {i, j - 1}}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441303359
birds3345,birds3345,264,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0;
        int odd = 0;
        
        for (int i = 0; i < num.size(); i++)
        {
            if (i & 1)
                odd += num[i] - '0';
            else
                even += num[i] - '0';
        }
        
        return even == odd;
    }
};",1441280998
birds3345,birds3345,264,3637,cpp,"long long dp[81][1441][41];

class Solution {
public:
    int MOD = 1e9 + 7;
    
    long long solve(int i, int sum, int evenCount, string& num, int totalEven, int totalOdd)
    {
        if (dp[i][sum + 720][evenCount] != -1)
            return dp[i][sum + 720][evenCount];
        if (i == num.size())
            return sum == 0 && evenCount == totalEven;
        
        int oddCount = i - evenCount;
        
        long long res = 0;
        if (oddCount < totalOdd)
            res = (res + solve(i + 1, sum + (num[i] - '0'), evenCount, num, totalEven, totalOdd) * (totalOdd - oddCount)) % MOD;
        if (evenCount < totalEven)
            res = (res + solve(i + 1, sum - (num[i] - '0'), evenCount + 1, num, totalEven, totalOdd) * (totalEven - evenCount)) % MOD;
        
        return dp[i][sum + 720][evenCount] = res;
    }
    
    long long factorial(long long n)
    {
        long long res = 1;
        for (int i = 1; i <= n; i++)
            res = (res * i) % MOD;
        
        return res;
    }
    
    long long modInverse(long long a, long long mod)
    {
        long long m0 = mod, t, q;
        long long x0 = 0, x1 = 1;
        if (mod == 1) return 0;
        while (a > 1)
        {
            q = a / mod;
            t = mod;
            mod = a % mod, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0) x1 += m0;
        return x1;
    }
    
    int countBalancedPermutations(string num) {
        memset(dp, -1, sizeof(dp));
        long long res = solve(0, 0, 0, num, num.size() / 2, num.size() - num.size() / 2);
        
        unordered_map<char, int> freq;
        for (char c: num)
            freq[c]++;
        
        for (auto& [k, v]: freq)
        {
            long long fact = factorial(v);
            long long invFact = modInverse(fact, MOD);
            
            res = (res * invFact) % MOD;
        }
        
        return res;
    }
};",1441393394
junbinliang,junbinliang,267,3627,cpp,"vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int d[55][55];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = 2e9;
            }
        }
        
        queue<pair<int, int>> q;
        q.push({0, 0});
        d[0][0] = 0;
        
        while(q.size()) {
            pair<int, int> p = q.front();
            q.pop();
            int r = p.first, c = p.second;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                if(d[rr][cc] > max(d[r][c] + 1, a[rr][cc] + 1)) {
                    d[rr][cc] = max(d[r][c] + 1, a[rr][cc] + 1);
                    q.push({rr, cc});
                }
            }
        }
        
        return d[n - 1][m - 1];
    }
};",1441292763
junbinliang,junbinliang,267,3628,java,"
class Solution {
    public int minTimeToReach(int[][] a) {
        int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int n = a.length, m = a[0].length;
        int[][][] d = new int[n][m][2];
        boolean[][][] st = new boolean[n][m][2];
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = 2000000000;
            }
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> {
            return x[3] - y[3];
        });
        d[0][0][0] = 0;
        pq.add(new int[]{0, 0, 0, 0});
        
        while(pq.size() > 0) {
            int[] p = pq.poll();
            int r = p[0], c = p[1], t = p[2], dis = p[3];
            if(st[r][c][t]) continue;
            st[r][c][t] = true;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(int[] di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > Math.max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = Math.max(d[r][c][t] + w, a[rr][cc] + w);
                    pq.add(new int[]{rr, cc, t ^ 1, d[rr][cc][t ^ 1]});
                }
            }
        }
        
        
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}

/*
vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
const int INF = 2e9;
int d[760][760][2];

struct P {
    int r, c, t;
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = INF;
            }
        }
        
        queue<P> q;
        q.push({0, 0, 0});
        d[0][0][0] = 0;
        while(q.size()) {
            P p = q.front(); q.pop();
            int r = p.r, c = p.c;
            int t = p.t;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = max(d[r][c][t] + w, a[rr][cc] + w);
                    q.push({rr, cc, t ^ 1});
                }
            }
        }
        
            
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
    
    
};
*/",1441305515
junbinliang,junbinliang,267,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int s1 = 0, s2 = 0;
        for(int i = 0; i < s.size(); i++) {
            if(i % 2 == 0) s1 += s[i] - '0';
            else s2 += s[i] - '0';
        }
        return s1 == s2;
    }
};",1441280910
junbinliang,junbinliang,267,3637,cpp,"const int MOD = 1e9 + 7;
int tot = 0;
using ll = long long;
long long fact[100];

ll fpow(ll x, int y){
	ll res = 1;
	while(y){
		if(y & 1) res = (res * x) % MOD;
		x = (x * x) % MOD;
		y >>= 1;
	}
	return res;
}  

ll modInverse(ll a, ll m) {
    ll m0 = m;
    ll y = 0, x = 1;
    if (m == 1)
        return 0;
    while (a > 1) {
          // q is quotient
        ll q = a / m;
        ll t = m;
        // m is remainder now, process
        // same as Euclid's algo
        m = a % m;
        a = t;
        t = y;
        // Update x and y
        y = x - q * y;
        x = t;
    }
    // Make x positive
    if (x < 0)
        x += m0;
    return x;
}


bool yes = false;
long long C[101][101];
void init() {
    if(yes) return;
    yes = true;
    C[0][0] = 1;
    for(int i = 1;i <= 100; i++) {
      C[i][0]=1;
      for(int j = 1;j <= i;j++) {
        C[i][j] = ( C[i-1][j] + C[i-1][j-1] ) % MOD;
      }
    }
}

long long dp[11][370][45];
int p[10];
int toteven = 0, totodd = 0;

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        vector<int> cnt(10);
        tot = 0;
        for(char c : s) {
            cnt[c - '0']++;
            tot += (c - '0');
        }
        
        if(tot % 2 == 1) {
            return 0;
        }
        
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= tot / 2 + 1; j++) {
                for(int k = 0; k <= (s.size() / 2 + 1); k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        
        p[0] = cnt[0];
        for(int i = 1; i < 10; i++) {
            p[i] = cnt[i] + p[i - 1];
        }
        
        toteven = s.size() / 2;
        totodd = s.size() - toteven;
        
        int ans = dfs(cnt, 0, tot / 2, (s.size() + 1) / 2);
        //cout << endl;
        return ans;
    }
    
    long long dfs(vector<int>& cnt, int i, int s, int odd) { //10 * 360 * 40
        if(i >= cnt.size()) {
            if(odd == 0 && s == 0) {
                return 1;
            }
            return 0;
        }
        if(dp[i][s][odd] != -1) {
            return dp[i][s][odd];
        }
        

        if(cnt[i] == 0) {
            return dp[i][s][odd] = dfs(cnt, i + 1, s, odd);
        }
        long long ans = 0;
        
        
        int sum = 0;
        if(i > 0) sum = p[i - 1];
        int oddtaken = totodd - odd;
        int remainEven = toteven - (sum - oddtaken);
        
        //cout << i << "" "" << s << "" "" << odd << "" "" << oddtaken << "" "" << sum << ""  "" << remainEven << endl;
        
        
        for(int x = 0; x <= min(odd, cnt[i]); x++) {
            int sum1 = x * i;
            if(sum1 <= s) {
                if(remainEven < 0 || remainEven < (cnt[i] - x)) continue;
                long long w1 = C[odd][x];
                long long w2 = C[remainEven][cnt[i] - x];
                ll w = (w1 * w2) % MOD;
                
                /*if(i == 5 || i == 6) {
                    cout << i <<"" ""  << odd << endl;
                    cout << x << ""  "" << w1 << "" "" << w2 << "" "" << w <<""  "" << dfs(cnt, i + 1, s - sum1, odd - x) << endl << endl;
                }*/
                
                ans += (w * dfs(cnt, i + 1, s - sum1, odd - x));
                ans %= MOD;
            }
        }
        //cout << i << "" "" << s << "" "" << odd << ""  "" << ans << endl;
        return dp[i][s][odd] = ans;
    }
};

//""4567""   8
//""46453"" 6",1441383288
uf21-6,uf21-6,268,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        # Initialize distance matrix with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0  # Start from top-left corner with time 0
        
        # Min-heap priority queue: each entry is (time, row, col)
        pq = [(0, 0, 0)]
        
        # Possible directions: up, right, down, left
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            time, row, col = heapq.heappop(pq)
            
            # If the current time exceeds known minimum, skip
            if time > dist[row][col]:
                continue
            
            for dr, dc in directions:
                newRow, newCol = row + dr, col + dc
                
                # Check if within bounds
                if 0 <= newRow < n and 0 <= newCol < m:
                    # Calculate the time to move to this cell
                    newTime = max(time, moveTime[newRow][newCol]) + 1
                    
                    # Update if found a shorter time to this cell
                    if newTime < dist[newRow][newCol]:
                        dist[newRow][newCol] = newTime
                        heapq.heappush(pq, (newTime, newRow, newCol))
        
        return dist[n - 1][m - 1]
",1441316581
uf21-6,uf21-6,268,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows, cols = len(moveTime), len(moveTime[0])
        
        # Initialize distance array with a large number
        dist = [[[float('inf')] * 2 for _ in range(cols)] for _ in range(rows)]
        dist[0][0][0] = 0
        
        # Min-heap priority queue to process cells in ascending time
        heap = [(0, 0, 0, 0)]  # (time, row, col, parity)
        
        # Possible moves: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            time, x, y, parity = heapq.heappop(heap)
            
            # Skip if we already have a shorter path
            if time > dist[x][y][parity]:
                continue
            
            # Explore neighboring cells
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                # Check if neighbor is within bounds
                if 0 <= nx < rows and 0 <= ny < cols:
                    next_time = max(time, moveTime[nx][ny]) + (2 if parity else 1)
                    
                    # Update distance if a shorter path is found
                    if next_time < dist[nx][ny][1 - parity]:
                        dist[nx][ny][1 - parity] = next_time
                        heapq.heappush(heap, (next_time, nx, ny, 1 - parity))
        
        return min(dist[rows - 1][cols - 1][0], dist[rows - 1][cols - 1][1])
",1441309467
uf21-6,uf21-6,268,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                odd += int(num[i])
            else:
                even += int(num[i])
        return even == odd",1441283881
uf21-6,uf21-6,268,3637,python3,"MOD = 1_000_000_007

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        E = (N + 1) // 2  # Number of even indices (0-based)
        O = N // 2         # Number of odd indices

        # Count frequency of each digit
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1

        # Calculate total sum
        total_sum = sum(d * cnt[d] for d in range(10))

        # If total_sum is odd, no balanced permutation exists
        if total_sum % 2 != 0:
            return 0

        sum_target = total_sum // 2

        # Precompute factorial and inverse factorial
        MAX = 80
        factorial = [1] * (MAX + 1)
        for i in range(1, MAX + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_fact = [1] * (MAX + 1)
        inv_fact[MAX] = pow(factorial[MAX], MOD - 2, MOD)
        for i in range(MAX - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        # Function to compute combination C(n, k) mod MOD
        def comb(n, k):
            if k > n:
                return 0
            return factorial[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD

        # Initialize DP table
        dp = [[0] * (sum_target + 1) for _ in range(E + 1)]
        dp[0][0] = 1

        for d in range(10):
            if cnt[d] == 0:
                continue
            for t in range(E, -1, -1):
                for s in range(sum_target, -1, -1):
                    if dp[t][s] == 0:
                        continue
                    for k in range(1, cnt[d] + 1):
                        if t + k > E or s + d * k > sum_target:
                            break
                        dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD

        number_of_valid_assignments = dp[E][sum_target]

        # Compute product of factorials of digit counts
        product_cnt_d_fact = 1
        for d in range(10):
            product_cnt_d_fact = product_cnt_d_fact * factorial[cnt[d]] % MOD

        # Compute the final answer
        answer = number_of_valid_assignments
        answer = answer * factorial[E] % MOD
        answer = answer * factorial[O] % MOD
        inv_product = pow(product_cnt_d_fact, MOD - 2, MOD)
        answer = answer * inv_product % MOD

        return answer
",1441395798
naresh50,naresh50,269,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 1 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323940
naresh50,naresh50,269,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 2 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323065
naresh50,naresh50,269,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int count=0;
        for(int i=0;i<num.length();i++){
            int val = (int)num.charAt(i) -48;
            if(i%2==0) count+=val;
            else  count-=val;
        }
        if(count==0) return true;
        else return false;
    }
}",1441292047
naresh50,naresh50,269,3637,java,"class Solution {
    int mod = (int)1e9 +7;
    
    public int countBalancedPermutations(String num) {
        int n = num.length();
        long halfFact1 = factorial(n/2);
        long halfFact2 = factorial((n+1)/2);

        long[] factArray = new long[81];
         long[] modArray = new long[81];
        formArray(factArray , modArray);
       

        
        int[] count  = new int[10];
        int total=0;
        for(int i=0;i<num.length();i++){
            int val=num.charAt(i)-'0';
            count[val]++;
            total+=val;
        }
        if(total%2==1) return 0;
        long[][][] dp= new long[10][810][81];
        for(int i=0;i<dp.length;i++){
            for(int j=0;j<dp[i].length;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        long ans = helper(0,total/2 , num.length()/2 , dp,count ,factArray , halfFact1 , halfFact2 ,modArray);
        ans%=mod;
        return (int)ans;
        
    }
    public long helper(int num , int sum , int rem , long[][][] dp , int[] count , long[] factArr , long h1 , long h2 , long[] modArr ){
        if(num==10){
           if(sum==0 && rem==0) return (h1*h2)%mod;
            else return 0;
        }
        if(dp[num][sum][rem]!=-1) return dp[num][sum][rem];
        long ans=0;

        int freq = count[num];
        
        for(int i=0;i<=freq;i++){
            long temp = 0;
            if(sum>=i*num && rem>=i) temp+=helper(num+1 , sum-(i*num) , rem-i ,  dp,count , factArr ,h1,h2 , modArr );
            if(i>0) temp = (temp * modArr[i]) % mod;
            if(freq-i >0) temp = (temp * modArr[freq-i]) % mod;

            ans+=temp;
            ans%=mod;
        }
        return dp[num][sum][rem] = ans%mod;
    }
    public long factorial(int n){
        long ans=1;
        for(int i=1;i<=n;i++){
            ans*=i;
            ans%=mod;
        }
        return ans;
    }
    public void formArray(long[] arr, long[] modArr){
        arr[1]=1L;
        arr[0]=1L;
        for(int i=2;i<=80;i++){
            arr[i] = (long)i*arr[i-1];
            arr[i]%=mod;
        }

        for(int i=0;i<arr.length;i++){
            modArr[i]=modInverse(arr[i]);
        }
    }
    public  long modInverse(long a) {
        return modExp(a, mod - 2);
    }

    public long modExp(long base, long exp) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }
        return res;
    }
}",1441383508
her0e1c1,her0e1c1,270,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        heappush(pq, (nt + 1, ni, nj))
                ",1441298882
her0e1c1,her0e1c1,270,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j, c = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        nc = 1 if c == 0 else 0
                        heappush(pq, (nt + 1 + c, ni, nj, nc))
                        ",1441302584
her0e1c1,her0e1c1,270,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o = e = 0
        for i, n in enumerate(num):
            if i % 2 == 0:
                e += int(n)
            else:
                o += int(n)
        return o == e",1441282100
her0e1c1,her0e1c1,270,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def dfs(i, c, c2, acc):
            if i > 10:
                return 0
            if acc > total // 2:
                return 0
            if c > N1 or c2 > N2:
                return 0
            if c == N1 and c2 == N2:
                if acc == total // 2:
                    return 1
                return 0
            rv = 0
            for k in range(C[i] + 1):  # nCr
                n1 = N1 - c
                n2 = N2 - c2
                k2 = C[i] - k
                rv += comb(n1, k) * comb(n2, k2) * dfs(i + 1, c + k, c2 + k2, acc + k * i)
                rv %= M
            return rv
        
        C = defaultdict(int)
        N1, N2 = len(num) // 2, (len(num) + 1) // 2
        total = 0
        for n in num:
            C[int(n)] += 1
            total += int(n)
        if total % 2 == 1:
            return 0
        # print(total, N1, N2, C)
        M = 10 ** 9 + 7
        return dfs(0, 0, 0, 0) % M",1441395883
Jashanpreet Singh,jashanp2005,271,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309945
Jashanpreet Singh,jashanp2005,271,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = fact ? 2 : 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309340
Jashanpreet Singh,jashanp2005,271,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    int ans = 0, ans2 = 0;
    int n = num.length();
    for(int i = 0; i < n; i++) {
        if(i % 2 == 0) 
            ans += num[i] - '0';  
        else 
            ans2 += num[i] - '0';  
    }
    return ans == ans2;
}
};",1441283829
Jashanpreet Singh,jashanp2005,271,3637,cpp,"
vector<int> fact(101), inv(101);

vector<int> v(10, 0);

class Solution {
#define int long long

const int mod = 1e9 + 7;
const int N = 100;

int n;
int tot = 0;

int binaryexpo(int a, int b) {
    int ans = 1;
    while (b > 0) {
        if (b & 1) {
            ans = (ans * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return ans;
}

void findinverse() {
    for (int i = 0; i <= N; i++) {
        inv[i] = binaryexpo(fact[i], mod - 2);
    }
}

void findfact() {
    fact[0] = 1;
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }
}

int solve(int index, int count, int sum, vector<vector<vector<int>>> &dp) {
    if (index == 10) {
        if (2 * sum == tot && count == (n+1)/2) {
            return (fact[count]%mod * fact[n - count]%mod) % mod;
        }
        return 0; 
    }

    if(dp[index][count][sum] != -1) return dp[index][count][sum];

    int ans = 0;
    for (int i = 0; i <= v[index]; i++) {
        if (count + i <= (n + 1) / 2) {
            int term = (((solve(index + 1, count + i, sum + index * i, dp) * inv[i]) % mod) * inv[v[index] - i]) % mod;
            ans = (ans + term) % mod;
        }
    }
    return dp[index][count][sum] = ans;
}

public:
    int countBalancedPermutations(string num) {
        findfact();
    findinverse();
    tot = 0;
    n = num.length();
    v.assign(10, 0);

        

    for (char c : num) {
        tot += c - '0';
        v[c - '0']++;
    }

        vector<vector<vector<int>>> dp(10, vector<vector<int>>(n/2 + 2, vector<int>(tot+1, -1)));

    return solve(0, 0, 0, dp);
}
};
#undef int
",1441389745
craggy,craggy,272,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        d = deque()
        d.append((0, 0, 0))
        vis = [[0 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        while len(d) > 0:
            t, r, c = d.popleft()
            if vis[r][c] and vis[r][c] <= t: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                d.append((max(t, moveTime[nr][nc])+1, nr, nc))
            
        return vis[len(moveTime)-1][len(moveTime[0])-1]
        ",1441300823
craggy,craggy,272,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        vis = [[-1 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        heap = [(0, 0, 0)]
        while len(heap):
            t, r, c = heappop(heap)
            if vis[r][c] != -1: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                heappush(heap, (max(t, moveTime[nr][nc])+1+(r+c)%2, nr, nc))

        return vis[len(moveTime)-1][len(moveTime[0])-1]

    

        ",1441309959
craggy,craggy,272,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        t = [0,0]
        for i in range(len(num)):
            t[i%2] += int(num[i])

        return t[0] == t[1]
        ",1441281821
craggy,craggy,272,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        M = int(1e9)+7
        cnt = Counter(num)
        fct = [1]
        for i in range(len(num)):
            fct.append((fct[-1] * (i+1))%M)
            
        inv_fct = [1] * (len(num) + 1)
        for i in range(1, len(fct)):
            inv_fct[i] = pow(fct[i], M - 2, M)

        @cache
        def get(diff_val, diff_num, i):
            if i == 10: return (fct[len(num)//2+len(num)%2] * fct[len(num)//2]) % M if ((diff_val == 0 and diff_num == (len(num) % 2))) else 0
            ret = 0
            if cnt[str(i)] == 0: return get(diff_val, diff_num, i+1)
            for j in range(cnt[str(i)]+1):
                a = j
                b = cnt[str(i)]-j
                ret = (ret + get(diff_val+i*a-i*b, diff_num+a-b, i+1) * inv_fct[j] * inv_fct[cnt[str(i)] - j]) % M


            return ret

        return get(0, 0, 0)

        ",1441396118
invertedwinger,invertedwinger,273,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<int>> dist(n, vector<int> (m,2e9));
        dist[0][0] = 0;
        set<pair<int,pair<int,int>>> s;
        s.insert({0, {0,0}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            int d = it->first, x = it->second.first, y = it->second.second;
            s.erase(it);
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    int D = max(d+1, a[x1][y1]+1);
                    if(D<dist[x1][y1]){
                        if(dist[x1][y1] < 2e9) s.erase({dist[x1][y1], {x1,y1}});
                        s.insert({D, {x1,y1}});
                        dist[x1][y1] = D;
                    }
                }
            }
        }

        return dist[n-1][m-1];
        
    }
};",1441304415
invertedwinger,invertedwinger,273,3628,cpp,"typedef long long ll;
const ll INF = 1e18;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>> (m, vector<ll> (2,INF)));
        dist[0][0][1] = INF;
        set<pair<ll,pair<pair<int,int>, int >>> s;
        s.insert({0, {{0,0}, 1}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            ll d = it->first, x = it->second.first.first, y = it->second.first.second, z = it->second.second;
            s.erase(it);
            z = 1-z;
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    ll D =max(d+z+1, 1LL*a[x1][y1]+z+1);
                    if(D<dist[x1][y1][z]){
                        if(dist[x1][y1][z] < INF) s.erase({dist[x1][y1][z], {{x1,y1},z}});
                        s.insert({D, {{x1,y1}, z}});
                        dist[x1][y1][z] = D;
                    }
                }
            }
        }

        return min(dist[n-1][m-1][0], dist[n-1][m-1][1]);
        
    }        
    
};",1441324071
invertedwinger,invertedwinger,273,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int c1 = 0, c2 = 0;
        for(int i=0; i<n; i++){
            if(i&1) c1 += num[i]-'0';
            else c2 += num[i]-'0';
        }
        return (c1 == c2);
    }
};",1441283779
invertedwinger,invertedwinger,273,3637,cpp,"typedef long long ll;
const ll mod = 1e9+7;
const ll N=45;
ll fct[N],inv[N],invfct[N];
ll ncr(ll n,ll r){
    if(n<0 || r<0 || n-r<0)return 0;
    ll ans = fct[n]*invfct[r];
    ans%=mod;
    ans = ans * invfct[n-r];
    ans%=mod;
    return ans;
}
void init(){
    fct[0]=fct[1]=1;
    inv[1]=1;
    invfct[0]=invfct[1]=1;
    for(ll i=2;i<N;i++){
        fct[i]=i*fct[i-1]%mod;
        inv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;
        invfct[i]=ll(inv[i])*invfct[i-1]%mod;
    }
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        int sum = 0;
        int n = s.length();
        for(int i=0; i<n; i++) sum += s[i]-'0';
        if(sum&1) return 0;
        int cnt[10] = {0};
        for(int i=0; i<n; i++) cnt[s[i]-'0']++;
        sum /=2;
        int x = n/2, y = n-x;
        vector<vector<ll>> ways(sum+1, vector<ll> (x+1, 0));
        ways[0][0] = 1;
        int total = 0;
        for(int k=0; k<10; k++){
            vector<vector<ll>> temp(sum+1, vector<ll> (x+1, 0));
            for(int t=0; t<=cnt[k]; t++){
                for(int sm = 0; sm <= sum; sm++){
                    for(int i=0; i<=x; i++){
                        int j = total - i;
                            int X = i+t, Y = j+(cnt[k]-t), S = sm+t*k;
                            if(S>sum || X>x || Y>y || ways[sm][i] == 0) continue;
                            ll z = (ncr(x-i, t)*ncr(y-j, cnt[k]-t))%mod;
                            temp[S][X] = (temp[S][X] + z*ways[sm][i])%mod;
                    }
                }
            }
            total += cnt[k];
            ways = temp;
        }
        return ways[sum][x];
    }
};",1441383901
Chen Jian,xiaojian9527,275,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        f = [[0] * m for _ in range(n)]

        d = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m

        seen = set()
        pq = [(0, 0, 0)]
        while pq:
            h, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if inArea(nx, ny):
                    if (nx, ny) not in seen:
                        seen.add((nx, ny))
                        t = max(h, moveTime[nx][ny])+1
                        heappush(pq, (t, nx, ny))
        return -1
        ",1441316329
Chen Jian,xiaojian9527,275,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # step: 0, 1
        n, m = len(moveTime), len(moveTime[0])
        seen = set()
        pq = [(0, 0, 0, 0)]
        d = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m
        
        while pq:
            h, step, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h

            ns = 1-step
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if not inArea(nx, ny):
                    continue

                if (nx, ny, ns) in seen:
                    continue
                seen.add((nx, ny, ns))
                nh = max(h, moveTime[nx][ny]) + step + 1
                heappush(pq, (nh, ns, nx, ny))
        return -1
        ",1441329221
Chen Jian,xiaojian9527,275,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        for i, c in enumerate(num):
            if i % 2 == 0:
                odd -= int(c)
            else:
                odd += int(c)
        return odd == 0",1441283871
Chen Jian,xiaojian9527,275,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        sm = 0
        n = len(num)
        cnt = defaultdict(int)
        for c in num:
            sm += int(c)
            cnt[int(c)] += 1
        if sm % 2: return 0

        even = (n+1) // 2
        odd = n // 2

        MOD = 10 ** 9 + 7
        @cache
        def dfs(i: int, s: int, oc: int, ec: int) -> int:
            if i == 10:
                return s == 0 and oc == 0 and ec == 0
                
            if oc < 0 or ec < 0: return 0

            if cnt[i] == 0:
                return dfs(i+1, s, oc, ec)

            ans = 0
            for j in range(0, cnt[i]+1):
                if j > oc: break
                k = cnt[i] - j
                if k > ec: continue
                # print(comb(oc, j), comb(ec, k))
                ans += comb(oc, j) * comb(ec, k) * dfs(i+1, s + j * i - k * i, oc -j, ec - k) % MOD
            return ans % MOD
            
        return dfs(0, 0, odd, even)",1441396468
eatfood,eatfood,276,3627,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=deque()
        dq.append((0,0))
        while len(dq):
            x,y=dq.popleft()
            # check to improve
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    newdist = max(dp[x][y]+1, mt[nx][ny]+1)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.append((nx,ny))
        # for i in range(n):
        #     print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441298031
eatfood,eatfood,276,3628,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
from sortedcontainers import SortedList

class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=SortedList()
        dq.add((0,0,0))
        while len(dq):
            d,x,y=dq.pop(0)
            # check self
            if d > dp[x][y]:
                continue
            # check nbrs
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    w = 1 if ((x+y)%2 == 0) else 2
                    newdist = max(d+w, mt[nx][ny]+w)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.add((newdist,nx,ny))
        for i in range(n):
            print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441306775
eatfood,eatfood,276,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        cnt=0
        for i,ch in enumerate(s):
            d = ord(ch)-ord('0')
            cnt += d if (i % 2 == 0) else -d
        return cnt==0",1441284963
eatfood,eatfood,276,3637,python3,"'''
dp[d][num slots left][tot sum]
'''
from collections import defaultdict
mod=int(1e9+7)

f = [0] * 81
f[0] = 1
for i in range(1, 81):
    f[i] = f[i-1]*i % mod
fi = [0] * 81
fi[80] = pow(f[80], mod-2, mod)
for i in range(79, -1, -1):
    fi[i] = fi[i+1] * (i+1) % mod


# print(f[:10])
# print(fi[:10])

class Solution:
    def countBalancedPermutations(self, s: str) -> int:

        def choose(n,k):
            if k==0 or k==n:
                return 1
            if k>n or k<0:
                return 0
            return (f[n] * fi[k] * fi[n-k]) % mod
                
            
        arr=[ord(ch)-ord('0') for ch in s]
        freq=defaultdict(int)
        for x in arr:
            freq[x]+=1
        sm=sum(arr)
        if sm % 2 != 0:
            return 0
        tgt=sm//2
        slots=(len(arr)+1) // 2
        slots2 = len(arr)-slots
        # need to make tgt with exactly slots numbers
        dp=[[0]*(tgt+1) for _ in range(slots+1)]

        dp[slots][0]=1 # empty string

        num_processed = 0
        for x, fx in freq.items():
            # init dp2
            dp2=[[0]*(tgt+1) for _ in range(slots+1)]
            # for ns in range(len(dp)-1, -1, -1):
            for ns in range(len(dp)):
                for sm in range(len(dp[0])):
                    if dp[ns][sm] == 0:
                        continue
                    for k in range(0, fx+1): # pick k of x to continue this value
                        if k > ns:
                            break
                        if sm + k*x > tgt:
                            break
                        # pick k from ns to put the nums into
                        w1=choose(ns, k)
                        rem2 = slots2 - (num_processed - (slots-ns))
                        w2=choose(rem2, fx-k)
                        # print(ns, sm, k, x)
                        # print('w1', ns, k, w1)
                        # print('w2', rem2, fx-k, w2)
                        dp2[ns-k][sm + k*x] += dp[ns][sm] * (w1 * w2 % mod) % mod
                        dp2[ns-k][sm + k*x] %= mod
            
            num_processed += fx
            dp,dp2=dp2,dp
            
        #     print(x, fx)
        #     for row in dp:
        #         print(row)
        # print(tgt)
        return dp[0][tgt]
        ",1441390678
codinghermit05,codinghermit05,279,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        # Initialize distance array with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        
        # Priority queue to store (time, row, col)
        # Python's heapq is used instead of Java's PriorityQueue
        pq = [(0, 0, 0)]
        dist[0][0] = 0
        
        # All four directions: up, right, down, left
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            # Get current state with minimum time
            time, row, col = heapq.heappop(pq)
            
            # Skip if we've found a better path
            if time > dist[row][col]:
                continue
            
            # Try all four directions
            for dx, dy in dirs:
                new_row = row + dx
                new_col = col + dy
                
                # Check if new position is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate new time (wait until moveTime if necessary)
                    new_time = max(time, moveTime[new_row][new_col]) + 1
                    
                    # If found better path, update and add to queue
                    if new_time < dist[new_row][new_col]:
                        dist[new_row][new_col] = new_time
                        heapq.heappush(pq, (new_time, new_row, new_col))
        
        return dist[n-1][m-1]",1441322051
codinghermit05,codinghermit05,279,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        if not moveTime or not moveTime[0]:
            return 0
            
        n, m = len(moveTime), len(moveTime[0])
        
        # Directions for movement: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # Priority queue to store (current_time, is_odd_move, row, col)
        pq = [(0, False, 0, 0)]  # Start at (0,0) with time 0
        
        # Keep track of visited states including the odd/even move status
        visited = set()
        
        while pq:
            current_time, is_odd_move, row, col = heapq.heappop(pq)
            
            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return current_time
                
            # Skip if we've seen this state
            state = (row, col, is_odd_move)
            if state in visited:
                continue
            visited.add(state)
            
            # Try all possible moves
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy
                
                # Check if move is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Move cost alternates between 1 and 2 seconds
                    move_cost = 2 if is_odd_move else 1
                    
                    # Wait until we can enter the new room
                    wait_time = max(0, moveTime[new_row][new_col] - current_time)
                    
                    # Total time includes: current time + waiting time + move cost
                    new_time = current_time + wait_time + move_cost
                    
                    # Add new state to priority queue with flipped odd/even status
                    heapq.heappush(pq, (new_time, not is_odd_move, new_row, new_col))
        
        return -1  # If no path is found
",1441300207
codinghermit05,codinghermit05,279,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Initialize variables to store sums
        even_sum = 0
        odd_sum = 0
        
        # Iterate through the string using index
        for i in range(len(num)):
            # Convert character to integer
            digit = int(num[i])
            
            # If index is even, add to even_sum
            if i % 2 == 0:
                even_sum += digit
            # If index is odd, add to odd_sum
            else:
                odd_sum += digit
        
        # Return true if sums are equal, false otherwise
        return even_sum == odd_sum",1441284044
codinghermit05,codinghermit05,279,3637,python3,"class Solution(object):
    MOD = 1000000007

    def countBalancedPermutations(self, num):
        """"""
        Count the number of balanced permutations of a given number string.
        
        :type num: str
        :rtype: int
        """"""
        # Initialize basic variables
        length = len(num)
        total_sum = sum(int(digit) for digit in num)
        counts = [0] * 10
        for digit in num:
            counts[int(digit)] += 1
        
        # Early return if sum is odd (can't be balanced)
        if total_sum % 2 != 0:
            return 0
        
        half_sum = total_sum // 2
        m = (length + 1) // 2
        
        # Precompute factorials and their inverses
        factorial = [1] * (length + 1)
        for i in range(1, length + 1):
            factorial[i] = factorial[i - 1] * i % self.MOD
        
        inv_factorial = [1] * (length + 1)
        inv_factorial[length] = self.mod_inverse(factorial[length], self.MOD)
        for i in range(length - 1, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % self.MOD
        
        # Initialize DP table for counting balanced subsets
        dp = [[0] * (half_sum + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        # Fill DP table
        for d in range(10):
            if counts[d] == 0:
                continue
                
            for k in range(m, -1, -1):
                for s in range(half_sum, -1, -1):
                    if dp[k][s] == 0:
                        continue
                        
                    for t in range(1, counts[d] + 1):
                        if k + t > m or s + d * t > half_sum:
                            break
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + 
                                               dp[k][s] * 
                                               self.comb(counts[d], t, factorial, inv_factorial, self.MOD)) % self.MOD
        
        # Calculate final result
        w = dp[m][half_sum]
        result = factorial[m] * factorial[length - m] % self.MOD
        
        for d in range(10):
            result = result * inv_factorial[counts[d]] % self.MOD
            
        result = result * w % self.MOD
        return int(result)
    
    def mod_inverse(self, a, m):
        """"""
        Calculate modular multiplicative inverse using fast exponentiation.
        """"""
        result = 1
        p = m - 2
        base = a
        
        while p > 0:
            if p & 1:
                result = result * base % m
            base = base * base % m
            p >>= 1
            
        return result
    
    def comb(self, n, k, factorial, inv_factorial, m):
        """"""
        Calculate combination (n choose k) using precomputed factorials.
        """"""
        if k > n:
            return 0
        return factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m",1441354877
yaominzh,yaominzh,280,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  
        visited = [[False] * m for _ in range(n)]
        min_heap = [(0, 0, 0)]  # (time, x, y)
        
        while min_heap:
            current_time, x, y = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if visited[x][y]:
                continue
            visited[x][y] = True
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
                    wait_time = max(current_time + 1, moveTime[nx][ny]+1)
                    heapq.heappush(min_heap, (wait_time, nx, ny))
        return -1
",1441367140
yaominzh,yaominzh,280,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
        visited = [[float('inf')] * m for _ in range(n)]
        min_heap = [(0, 0, 0, 1)]  # (time, x, y, next_move_time)
        
        while min_heap:
            current_time, x, y, move_cost = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if current_time >= visited[x][y]:
                continue
            visited[x][y] = current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    wait_time = max(current_time + move_cost, moveTime[nx][ny]+move_cost)
                    next_move_cost = 1 if move_cost == 2 else 2
                    heapq.heappush(min_heap, (wait_time, nx, ny, next_move_cost))
        
        return -1 
    
",1441380163
yaominzh,yaominzh,280,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
    
        for i in range(len(num)):
            if i % 2 == 0:  
                even_sum += int(num[i])
            else:          
                odd_sum += int(num[i])
    
        return even_sum == odd_sum
        ",1441287516
yaominzh,yaominzh,280,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        mod = 10**9 + 7

        total_counts = [0] * 10
        for ch in num:
            total_counts[int(ch)] += 1

        n = len(num)
        n_even = (n + 1) // 2  # Number of even indices (0-based)
        n_odd = n // 2         # Number of odd indices

        max_sum = sum(d * c for d, c in enumerate(total_counts))
        if max_sum % 2 != 0:
            return 0
        half_sum = max_sum // 2

        MAX_N = n + 1
        factorials = [1] * (MAX_N)
        inv_factorials = [1] * (MAX_N)

        for i in range(1, MAX_N):
            factorials[i] = (factorials[i - 1] * i) % mod

        inv_factorials[MAX_N - 1] = pow(factorials[MAX_N - 1], mod - 2, mod)
        for i in range(MAX_N - 2, -1, -1):
            inv_factorials[i] = (inv_factorials[i + 1] * (i + 1)) % mod

        # Initialize DP array
        dp = [ [0] * (n_even + 1) for _ in range(half_sum + 1) ]
        dp[0][0] = 1  # Base case

        # Fill DP array
        for d in range(10):
            c_d = total_counts[d]
            if c_d == 0:
                continue
            # Precompute combinations C(c_d, k_d)
            comb = [1]  # C(c_d, 0)
            for k_d in range(1, c_d + 1):
                comb.append((comb[-1] * (c_d - k_d + 1) * pow(k_d, mod - 2, mod)) % mod)
            # Update DP array
            for s in range(half_sum, -1, -1):
                for k in range(n_even, -1, -1):
                    val = dp[s][k]
                    if val == 0:
                        continue
                    for count in range(1, min(c_d, n_even - k) + 1):
                        new_s = s + count * d
                        new_k = k + count
                        if new_s > half_sum or new_k > n_even:
                            break
                        dp[new_s][new_k] = (dp[new_s][new_k] + val * comb[count]) % mod

        ways = dp[half_sum][n_even]

        if ways == 0:
            return 0

        perm_even = factorials[n_even]
        perm_odd = factorials[n_odd]

        total_counts_product = 1
        for cnt in total_counts:
            total_counts_product = (total_counts_product * inv_factorials[cnt]) % mod

        answer = (ways * factorials[n_even] * factorials[n_odd]) % mod
        answer = (answer * total_counts_product) % mod

        return answer

",1441347489
Jie Chen,JustJie,282,3627,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<i64, int, int>;

constexpr i64 inf = i64(1e18) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({encode(i, j), t + p, p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -1, 1);
        while (!h.empty()) {
            auto [cur, t, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441324013
Jie Chen,JustJie,282,3628,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<int, int, int>;

constexpr int inf = int(2e9) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({t + p, encode(i, j), 1 ^ 2 ^ p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -2, 2);
        while (!h.empty()) {
            auto [t, cur, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441326480
Jie Chen,JustJie,282,3636,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < s.size(); i++) {
            if (i % 2 == 0) {
                sum += (s[i] - '0');
            } else {
                sum -= (s[i] - '0');
            }
        }
        return (sum == 0);
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441323288
Jie Chen,JustJie,282,3637,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

constexpr int D = 10;
constexpr int N = 81;
constexpr int LIM = 800;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();

        vector<int> cnt(D);
        vector<int> pre(D + 1);
        vector<int> pre2(D + 1);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            int d = s[i] - '0';
            sum += d;
            cnt[d]++;
        }
        for (int d = 0; d < D; d++) {
            pre[d + 1] = pre[d] + cnt[d];
            pre2[d + 1] = pre2[d] + cnt[d] * d;
        }

        if (sum & 1) {
            return 0;
        }

        int w = sum / 2;
        int e = (n + 1) / 2;
        vector dp(e + 1, vector<Z>(w + 1));
        dp[0][0] = 1;

        int o = n - e;
        for (int d = 0; d < D; d++) {
            if (cnt[d] == 0) {
                continue;
            }
            vector ndp(n, vector<Z>(w + 1));
            for (int ec = 0; ec <= e; ec++) {
                int oc = pre[d] - ec;
                for (int eps = 0; eps <= w; eps++) {
                    int ops = pre2[d] - eps;
                    if (dp[ec][eps].val() == 0) {
                        continue;
                    }
                    // cout << ""DP GOOD: "" << ec << "" "" << eps << "" "" << ops << ""\n"";
                    for (int euse = 0; euse <= cnt[d]; euse++) {
                        int ouse = cnt[d] - euse;
                        if (ec + euse > e) {
                            // cout << ""1\n"";
                            break;
                        }
                        if (eps + euse * d > w) {
                            // cout << ""2\n"";
                            break;
                        }
                        if (oc + ouse > o) {
                            // cout << ""3\n"";
                            continue;
                        }
                        if (ops + ouse * d > w) {
                            // cout << ""4\n"";
                            continue;
                        }
                        // cout << ec + euse << "" "" << eps + euse * d << "" "" << ops + ouse * d << ""\n"";
                        ndp[ec + euse][eps + euse * d] += (dp[ec][eps] * comb.binom(e - ec, euse) * comb.binom(o - oc, ouse));
                    }
                }
            }
            dp = std::move(ndp);
        }

        return dp[e][w].val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441380513
kavascg,kavascgjmd39,283,3627,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                 
                    ll val = max((ll)a[ni][nj]+1 , abs(top.first) + 1);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441328219
kavascg,kavascgjmd39,283,3628,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                    ll x = ((top.first >= 0 )? 1: 2);
                    ll val = max((ll)a[ni][nj]+x , abs(top.first) + x);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441327440
kavascg,kavascgjmd39,283,3636,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
class Solution {
public:
    bool isBalanced(string s) {
        ll sum1 = 0, sum2 = 0;
     for(int i = 0 ; i<s.size() ; i++ ){
         if(i & 1){
             sum1 += s[i]-'0';
         }
         else {
             sum2 += s[i]-'0';
         }
     }
        return sum1 == sum2;
    }
};",1441282187
kavascg,kavascgjmd39,283,3637,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
int dp[10][81][721];
vector<ll> fac, inv_fac;
ll binexpo(ll x, ll y, ll mod) {
    ll res = 1;
    while (y > 0) {
        if (y & 1)
            res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
void precompute_factorials(ll n, ll mod) {
    fac.resize(n + 1);
    inv_fac.resize(n + 1);
    fac[0] = fac[1] = 1;
    for (ll i = 2; i <= n; i++) {
        fac[i] = fac[i - 1] * i % mod;
    }
    inv_fac[n] = binexpo(fac[n], mod - 2, mod);
    for (ll i = n - 1; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
    }
}

class Solution {
    int count(vt<int>&a, int i , int len , int sum , int n, int s){
        if(i == 10){
            if(len == n/2 && sum == s){
                return (fac[n/2]*fac[n-n/2])%mod;
            }
            return 0;
        }
        if(dp[i][len][sum] != -1){
            return dp[i][len][sum];
        }
        ll res = 0;
        for(int j = 0  ; j<a[i]+1 ; j++){
            res += (ll)count(a, i+1 , len+j , sum + j*i, n, s) * (ll)(((ll)inv_fac[j] * (ll)inv_fac[a[i]-j]) % mod); res %= mod;
        }
        return dp[i][len][sum] = res;
    }
public:
    int countBalancedPermutations(string a) {
        memset(dp, -1 , sizeof(dp));
        precompute_factorials(81, mod);
        vt<int>v(10, 0);
        ll sum = 0;
        rep(i , 0 , a.size()){
           v[a[i]-'0']++;
            sum += (a[i]-'0');
        }
        if(sum & 1){return 0;}
        sum /= 2;
        ll res = count(v, 0 , 0 ,0 , a.size(), sum  );
       
        return res;
    }
};",1441382036
leetcode_3604,leetcode_3604,284,3627,cpp,"class Solution {
public:
       typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 1;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441387316
leetcode_3604,leetcode_3604,284,3628,cpp,"class Solution {
public:
   typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 2;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441386429
leetcode_3604,leetcode_3604,284,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd(0), even(0);
        for(int i = 0; i < num.size(); ++i) {
            if(i&1) odd += num[i]-'0';
            else even += num[i]-'0';
        }
        return odd == even;
    }
};",1441389379
leetcode_3604,leetcode_3604,284,3637,cpp,"class Solution {
public:
    typedef long long LL;
    LL dp[11][81][810];
    LL mod = 1000000007;
    LL C[90][90];
    int cnt[10];
    int countBalancedPermutations(string s) {
        memset(cnt, 0, sizeof(cnt));
        int sum(0);
        for(auto ch: s) {
            ++cnt[ch - '0'];
            sum += ch - '0';
        }
        if(sum % 2 == 1) return 0;
        memset(C, 0, sizeof(C));
        C[0][0] = 1;
        for(int i = 1; i <= 80; ++i) {
            C[i][0] = 1;
            for(int j = 1; j <= 80; ++j) {
                C[i][j] = C[i-1][j] + C[i-1][j-1];
                C[i][j]  %= mod;
            }
        }
        memset(dp, 0, sizeof(dp));
        //printf(""%lld %lld\n"", C[4][2], C[5][2]);
        int n = s.size();
        dp[0][0][0] = 1;
        int t(0);
        for(int i = 0; i < 10; ++i) {
            for(int j = 0; j <= cnt[i]; ++j) {
                //printf(""%d %d %d\n"", i, j, cnt[i]);
                for(int l = 0; j + l <= n/2; ++l) {
                    for(int k = 0; k + j * i <= sum/2; ++k) {
                        if(n-n/2 - (t - l) < 0) continue;
                        // 
                        dp[i+1][l+j][k+j*i] += C[n/2 - l][j] * C[n-n/2 - (t - l)][cnt[i]-j] % mod * dp[i][l][k] % mod;
                        dp[i+1][l+j][k+j*i] %= mod;
                        //printf(""%d %d %d %d %lld %lld\n"", i, j, l, k, dp[i+1][l+j][k+j*i], dp[i][l][k]);
                    }// 1254, 2145, 5214, 5412, 
                    // 2 * 2 * 2
                }
            }
            t += cnt[i];
        }
        LL ans = dp[10][n/2][sum/2] % mod;
        int f(0);
        for(int i = 0;i < 10; ++i) if (cnt[i] > 0) ++f;
        //if (n % 2 == 0 && f > 1) ans = ans * 2 % mod;
        return ans;
    }
};",1441356783
Sk Najir,Najir581,285,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        set<pair<int, pair<int, int>>> st;
        st.insert({0, {0, 0}});
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;
        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());
            int x = it.first;
            int i = it.second.first;
            int j = it.second.second;
            if (i == n - 1 and j == m - 1)
                return max(x , v[n - 1][m - 1]);
            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 and b >= 0 and a < n and b < m and vis[a][b] == 0) {
                    st.insert({max(x + 1, v[a][b]+1), {a, b}});
                    vis[a][b] = 1;
                }
            }
        }
        return 1;
    }
};",1441318252
Sk Najir,Najir581,285,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        
        set<pair<int, pair<int, pair<int, int>>>> st;
        st.insert({0, {1, {0, 0}}});
        
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;

        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());

            int x = it.first;
            int op = it.second.first;
            int i = it.second.second.first;
            int j = it.second.second.second;

            if (i == n - 1 && j == m - 1) {
                return max(x, v[n - 1][m - 1]);
            }

            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 && b >= 0 && a < n && b < m && vis[a][b] == 0) {
                    vis[a][b] = 1;
                    if (op == 1) {
                        st.insert({max(x + 1, v[a][b] + 1), {2, {a, b}}});
                    } else {
                        st.insert({max(x + 2, v[a][b] + 2), {1, {a, b}}});
                    }
                }
            }
        }
        // Add return statement for when no path is found to the destination.
        return -1;
    }
};
",1441335699
Sk Najir,Najir581,285,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n=s.size();
        int sm1=0,sm2=0;
        for(int i=0;i<n;i++){
            if(i%2)sm1+=(s[i]-'0');
            else sm2+=(s[i]-'0');
        }
        return sm1==sm2;
    }
};",1441283378
Sk Najir,Najir581,285,3637,cpp,"const int MOD = 1e9 + 7;
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
template<const int mod>
struct mint {
    int val;
    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}
    explicit operator int() const { return val; }
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }
    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }
    mint operator-() const { return val == 0 ? 0 : mod - val; }
    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }
    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }
    mint operator++(int32_t) { mint before = *this; ++*this; return before; }
    mint operator--(int32_t) { mint before = *this; --*this; return before; }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
};
using Mint = mint<MOD>;
 
namespace comb {
    int n(0);
    vector<Mint> _fac{1}, _invfac{1}, _inv{0};
    void init(int m) {
        m = min (m, MOD - 1);
        if (m <= n) return;
        _fac.resize(m + 1); _invfac.resize(m + 1); _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) _fac[i] = _fac[i - 1] * i;
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) _invfac[i - 1] = _invfac[i] * i, _inv[i] = _invfac[i] * _fac[i - 1];
        n = m;
    }
    Mint fac(int m) { if (m > n) init(2 * m); return _fac[m]; }
    Mint invfac(int m) { if (m > n) init(2 * m); return _invfac[m]; }
    Mint inv(int m) { if (m > n) init(2 * m); return _inv[m]; }
    Mint ncr(int n, int r) { if (n < r || r < 0) return 0; return fac(n) * invfac(r) * invfac(n - r); }
}
using comb::fac;
using comb::inv;
using comb::invfac;
using comb::ncr;
// shortcut type
typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<ll> vl;
typedef vector<vl> vll;
typedef pair<int, int> pi;
typedef pair<ll, ll> pl;

// Constants
class Solution {
int dp[82][1600][60];
string s;
int odd;
int f(int i,int sm,int odnum){
    if(odnum>odd)return 0;
    if(i<0){
        if(odd==odnum){
            return sm==0;
        }
        return 0;
    }
if(dp[i][sm+1000][odnum]!=-1)return dp[i][sm+1000][odnum];
    int x=f(i-1,sm+(s[i]-'0'),odnum+1);
    int y=f(i-1,sm-(s[i]-'0'),odnum);

    return dp[i][sm+1000][odnum]=((0LL+x+y)%MOD);
    
}
vi fact;
void pre(){
    fact.resize(90);
    fact[0]=1;
    for(int i=1;i<=89;i++){
        fact[i]=(1LL*fact[i-1]*i)%MOD;
    }
}
public:

    int countBalancedPermutations(string num) {
        pre();
        s=num;
        memset(dp,-1,sizeof(dp));
        int n=s.size();
        odd=n/2;
     map<int,int>m;
        for(auto it:s){
            m[it-'0']++;
        }
      int ans= f(n-1,0,0);
        ans=max(ans,0);
        //cout<<ans<<endl;
        Mint a=ans;
        a=(a*fact[odd]*fact[n-odd]);
        for(auto it:m){
            a=(a/(Mint)fact[it.second]);
        }
        return (int)a;
        
        
    }
};",1441395990
Michael Bao,tcmmichaelb139,286,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, -1));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            ans[v.first][v.second] = dist;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                q.push({max(dist + 1, moveTime[x][y]+1), {x, y}});
            }
        }
        for (int i= 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << ans[i][j] << "" \n""[j+1 == m];
            }
        }
        return ans[n-1][m-1];
    }
};",1441313231
Michael Bao,tcmmichaelb139,286,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, 2e9));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            if (v.first == n && v.second == m) break;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                int add = v.first+v.second;
                int ndist = max(dist, moveTime[x][y]) + 1+(add&1);
                if (ans[x][y] <= ndist) continue;
                ans[x][y] = ndist;
                q.push({ndist, {x, y}});
            }
        }
        return ans[n-1][m-1];
    }
};",1441328073
Michael Bao,tcmmichaelb139,286,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int osum = 0;
        int esum = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i&1) osum += num[i]-'0';
            else esum += num[i]-'0';
        }
        return osum == esum;
    }
};",1441284864
Michael Bao,tcmmichaelb139,286,3637,cpp,"class Solution {
public:
    long long MOD = 1e9+7;
    long long add(long long a, long long b) { return (a+b)%MOD;}
    long long mult(long long a, long long b) { return a*b%MOD; }

    long long binpow(long long a, long long b) {
        long long ret = 1;
        while (b) {
            if (b & 1) ret = mult(ret, a);
            a = mult(a, a);
            b >>=1;
        }
        return ret;
    }
    long long fac[50], inv[50];
    void init() {
        fac[0] = 1;
        fac[1] = 1;
        inv[0] = 1;
        inv[1] = 1;
        for (int i = 2; i < 50; i++) {
            fac[i] = mult(i, fac[i-1]);
            inv[i] = binpow(fac[i], MOD-2);
        }
    }
    long long nCr(long long a, long long b) {
        return mult(fac[a], mult(inv[b], inv[a-b]));
    }
    int countBalancedPermutations(string num) {
        init();
        int n = num.length();
        int sum = 0;
        map<int, int> cnt;
        for (int i = 0; i < n; i++) {
            sum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        int halfsum = sum/2+1;
        if (sum & 1) return 0;
        long long dp[11][halfsum][n/2+1];
        memset(dp, 0ll, sizeof dp);
        dp[0][0][0] = 1;
        int rem = 0;
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < halfsum;j++) {
                for (int k = 0; k <= n/2; k++) {
                    for (int a = 0; a <= cnt[i]; a++) {  
                        if (j + a*i >= halfsum) break;
                        if (k + a > n/2) break;
                        int kalt = rem - k;
                        if (kalt < 0) continue;
                        if ((n+1)/2 < cnt[i]-a + kalt) continue;
                        assert(n/2-k >= a);
                        assert((n+1)/2-kalt >= cnt[i]-a);
                        // cout << i << ' ' << j << ' ' << k << ' ' << kalt << ' ' << a << ' ' << dp[i][j][k] << '\n';
                        dp[i+1][j+a*i][k+a] = add(dp[i+1][j+a*i][k+a], 
                            mult(dp[i][j][k], 
                            mult(nCr(n/2-k, a), nCr(((n+1)/2)-kalt, cnt[i]-a))));
                    }
                }
            }
            rem += cnt[i];
        }
        return dp[10][halfsum-1][n/2];
    }
};",1441389966
quynhit,quynhit,287,3627,cpp,"#include <vector>
#include <queue>
#include <limits>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int R = moveTime.size();
        int C = moveTime[0].size();
        
        vector<vector<int>> dist(R, vector<int>(C, numeric_limits<int>::max()));
        auto cmp = [](const array<int, 3>& a, const array<int, 3>& b) { return a[0] > b[0]; };
        priority_queue<array<int, 3>, vector<array<int, 3>>, decltype(cmp)> pq(cmp);
        
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        auto inside = [&](int r, int c) -> bool{
            return r >= 0 && r < R && c >= 0 && c < C;
        };
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0], row = curr[1], col = curr[2];
            if (time > dist[row][col]) continue;
            for(int dir = 0; dir < 4; dir++){
                int newRow = row + dx[dir];
                int newCol = col + dy[dir];
                
                if (inside(newRow, newCol)) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[R - 1][C - 1];
    }
};",1441329395
quynhit,quynhit,287,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size(), m = moveTime[0].size();
        auto inside = [&](int r, int c){
            return r >= 0 && r < n && c >= 0 && c < m;
        };
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, LLONG_MAX)));
        d[0][0][0] = 0;
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> q;
        q.push({0, {0, 0, 0}});
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        while (!q.empty()) {
            auto [t, v] = q. top();
            q.pop();
            int i = v[0], j = v[1], p = v[2];
            if (t > d[i][j][p]) continue;
            for(int dir = 0; dir < 4; dir++){
                int ni = i + dx[dir], nj = j + dy[dir];
                if (inside(ni, nj)) {
                    int nt = max(t, 1LL * moveTime[ni][nj]) + (p ? 2 : 1);
                    if (nt < d[ni][nj][!p]) {
                        d[ni][nj][!p] = nt;
                        q.push({nt, {ni, nj, !p}});
                    }
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
        #undef int
    }
};",1441347079
quynhit,quynhit,287,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i = 0; i < size(num); i++){
            if(i & 1){
                odd += num[i] - '0';
            } else {
                even += num[i] - '0';
            }
        }
        return even == odd;
    }
};",1441280930
quynhit,quynhit,287,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
#define int long long

int power_mod(int base, int exponent) {
    int result = 1;
    base %= MOD;
    while (exponent > 0) {
        if (exponent & 1) {
            result = result * base % MOD;
        }
        base = base * base % MOD;
        exponent >>= 1;
    }
    return result;
}

class Solution {
public:
    #undef int
    int countBalancedPermutations(string num) {
        #define int long long 
        int total_sum = 0;
        vector<int> frequency(10, 0);
        for (auto c : num) {
            frequency[c - '0']++;
            total_sum += (c - '0');
        }
        if (total_sum & 1) return 0;
        int n = size(num);
        int half_sum = total_sum / 2, half_length = (n + 1) / 2;
        vector<int> factorial(n + 1, 1);
        for (int i = 1; i <= n; i++)
            factorial[i] = factorial[i - 1] * i % MOD;
        vector<int> inverse_factorial(n + 1, 1);
        inverse_factorial[n] = power_mod(factorial[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
            inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % MOD;
        vector<vector<int>> dp(half_length + 1, vector<int>(half_sum + 1, 0));
        dp[0][0] = 1;
        for (int digit = 0; digit <= 9; digit++) {
            if (frequency[digit] == 0) continue;
            for (int count = half_length; count >= 0; count--)
                for (int sum = half_sum; sum >= 0; sum--) {
                    if (dp[count][sum] == 0) continue;
                    for (int times = 1; times <= min(frequency[digit], half_length - count); times++) {
                        if (sum + digit * times > half_sum) break;
                        int combinations = (factorial[frequency[digit]] * inverse_factorial[times] % MOD) * inverse_factorial[frequency[digit] - times] % MOD;
                        dp[count + times][sum + digit * times] = (dp[count + times][sum + digit * times] + dp[count][sum] * combinations) % MOD;
                    }
                }
        }

        int valid_assignments = dp[half_length][half_sum];
        if (valid_assignments == 0) return 0;
        int product_factorials = 1;
        for (int digit = 0; digit <= 9; digit++)
            product_factorials = product_factorials * factorial[frequency[digit]] % MOD;
        int fk_fnk = (factorial[half_length] * factorial[n - half_length]) % MOD;
        int inv_product_factorials = power_mod(product_factorials, MOD - 2);
        return (((fk_fnk * valid_assignments) % MOD) * inv_product_factorials) % MOD;
        #undef int
    }
};",1441385400
Abhi7527,Abhi7527,288,3627,cpp,"class Solution {
public:
int dirr[4]={-1,0,1,0};
int dirc[4]={0,-1,0,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>>dp(moveTime.size(),vector<int>(moveTime[0].size(),INT_MAX));
        queue<pair<int,int>>q;
        dp[0][0]=0;
        q.push({0,0});
        while(!q.empty()){
            int row=q.front().first;
            int col=q.front().second;
            q.pop();
            for(int k=0;k<4;k++){
                int rowi=row+dirr[k];
                int coli=col+dirc[k];
                if(rowi<n && coli<m && rowi>=0 && coli>=0){
                    int l=dp[row][col];
                    int b=moveTime[rowi][coli];
                    int y=max(l,b);
                    if(dp[rowi][coli]>y+1){
                        dp[rowi][coli]=y+1;
                        q.push({rowi,coli});
                    }
                }
            }
        }
        return dp[n-1][m-1];
        
    }
};",1441298215
Abhi7527,Abhi7527,288,3628,cpp,"#include <vector>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

class Solution {
public:
    int dirr[4] = {-1, 0, 1, 0};
    int dirc[4] = {0, -1, 0, 1};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, pair<int,int>>>, vector<pair<int, pair<int, pair<int,int>>>>, greater<pair<int, pair<int, pair<int,int>>>>> pq;
        
        dp[0][0] = 0;
        pq.push({0, {0, {0,1}}}); // {time, {row, col}}

        while (!pq.empty()) {
           int dis=pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second.first;
            int step=pq.top().second.second.second;
            pq.pop();

            if (row == n - 1 && col == m - 1) {
                return dis;
            }

            for (int k = 0; k < 4; ++k) {
                int newRow = row + dirr[k];
                int newCol = col + dirc[k];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(dis, moveTime[newRow][newCol]);
                    if (dp[newRow][newCol] > newTime+step) {
                        dp[newRow][newCol] = newTime+step;
                        if(step==1){
                        pq.push({ dp[newRow][newCol], {newRow, {newCol,2}}});
                        }
                        else{
                            pq.push({ dp[newRow][newCol], {newRow, {newCol,1}}});
                            
                        }
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
",1441319049
Abhi7527,Abhi7527,288,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0;
        int b=0;
        for(int i=0;i<num.size();i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        if(a==b){
            return true;
        }
        return false;
    }
};",1441283773
Abhi7527,Abhi7527,288,3637,cpp,"class Solution {
public:
int mod=1e9+7;
int l;
int lena,lenb;
vector<vector<long long>>pnc;
int yi(vector<vector<long long>>&pn,int n,int r){
    if(n==r || r==0){
        return 1;
    }
    if(pn[n][r]!=-1){
        return pn[n][r];
    }
    return pn[n][r]=(yi(pn,n-1,r)+yi(pn,n-1,r-1))%mod;
}

long long y(vector<vector<vector<long long>>>&dp,int i,int sum,int len,vector<pair<int,int>>&vec,vector<int>&p){
    
    if(i==vec.size()){
        if(sum==0){
       return 1;
    }
        return 0;
    }
    if(dp[i][sum][len]!=-1){
        return dp[i][sum][len];
    }
    long long ans=0;
    int gh=p[i]-len;
    for(int k=0;k<=vec[i].second;k++){
        
        if(len>=k && gh>=vec[i].second-k && sum>=k*vec[i].first){
            
            long long h=(pnc[len][k]*pnc[gh][vec[i].second-k])%mod;
            ans=(ans+h*(y(dp,i+1,sum-k*vec[i].first,len-k,vec,p)%mod))%mod;
        }
    }
    return dp[i][sum][len]=ans%mod;
}

    int countBalancedPermutations(string num) {
        pnc=vector<vector<long long>>(41,vector<long long>(41,-1));
        for(int i=0;i<=40;i++){
            for(int j=0;j<=40;j++){
                if(i>=j){
                     pnc[i][j]=yi(pnc,i,j);
                }
               
            }
        }
        l=num.length();
        unordered_map<int,int>mp;
        int l=0;
        for(auto it:num){
           mp[it-'0']++;
            l+=it-'0';
        }
        vector<pair<int,int>>vec;
        vector<int>p;
        int li=num.length();
        for(auto it:mp){
            p.push_back(li);
            vec.push_back({it.first,it.second});
            li-=it.second;
        }
        
        if(l%2){
            return 0;
        }
        vector<vector<vector<long long>>>dp(vec.size(),vector<vector<long long>>(l/2+1,vector<long long>(num.length()/2+1,-1)));
        return y(dp,0,l/2,num.length()/2,vec,p);
        
    }
};",1441396105
Anshuman Kanungo,PeacefulGuy,291,3627,cpp,"#include <vector>
#include <queue>
#include <climits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        vector<vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.empty()) {
            vector<int> curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};
",1441372568
Anshuman Kanungo,PeacefulGuy,291,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        // 3D array to store minimum time
        int[][][] d = new int[n][m][2];
        for (int[][] layer : d) {
            for (int[] row : layer) {
                java.util.Arrays.fill(row, Integer.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        // Priority queue stores {time, x, y, p}
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        q.offer(new int[]{0, 0, 0, 0}); // {time, x, y, p}

        // Directions for movement (down, right, up, left)
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!q.isEmpty()) {
            int[] current = q.poll();
            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (int[] dir : directions) {
                int ni = i + dir[0];
                int nj = j + dir[1];

                // Check bounds
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 1 ? 2 : 1);

                    // Update minimum time if found a better path
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        q.offer(new int[]{nt, ni, nj, 1 - p}); // Update state
                    }
                }
            }
        }

        // Return the minimum time to reach the bottom-right corner
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441345048
Anshuman Kanungo,PeacefulGuy,291,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0'; // Convert char to integer

            if (i % 2 == 0) { // Even index
                evenSum += digit;
            } else { // Odd index
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}
",1441292483
Anshuman Kanungo,PeacefulGuy,291,3637,java,"import java.util.Arrays;

class Solution {
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;

    private long powerMod(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerMod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        long totalSum = 0;
        int[] freq = new int[10];

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;

        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;

        return (int) answer;
    }
}
",1441381843
Titas,ads3k,294,3627,python3,"from heapq import heappush, heappop
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        # Array to store minimum time to reach each cell
        dp = [[float('inf')] * m for _ in range(n)]
        dp[0][0] = 0

        # Priority queue to store (current_time, row, col)
        pq = [(0, 0, 0)]

        # Directions: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while pq:
            curr_time, row, col = heappop(pq)

            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return curr_time

            # Skip if we've found a better path
            if curr_time > dp[row][col]:
                continue

            # Try all possible directions
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy

                # Check if new position is within bounds
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate waiting time if needed
                    wait_time = max(0, moveTime[new_row][new_col] - curr_time)
                    next_time = curr_time + wait_time + 1  # Add 1 for movement

                    # Update if we found a better path
                    if next_time < dp[new_row][new_col]:
                        dp[new_row][new_col] = next_time
                        heappush(pq, (next_time, new_row, new_col))

        return dp[n - 1][m - 1]
",1441303344
Titas,ads3k,294,3628,python3,"import heapq

class Solution(object):
    # Dummy functions
    def dummyFunc1(self): pass
    def dummyFunc2(self): pass
    def dummyFunc3(self): pass
    def dummyFunc4(self): pass
    def dummyFunc5(self): pass
    def dummyFunc6(self): pass
    def dummyFunc7(self): pass
    def dummyFunc8(self): pass
    def dummyFunc9(self): pass
    def dummyFunc10(self): pass

    def minTimeToReach(self, mt):
        # Dummy variables
        a1, a2, a3, a4, a5, a6, a7, a8, a9, a0 = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        n = len(mt)
        m = len(mt[0])
        
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        pq = [(0, (0, 0, 0))]

        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            if t > d[i][j][p]:
                continue

            d_idx = 0  # Loop variable for direction indexing
            while d_idx < len(directions):
                di, dj = directions[d_idx]
                ni, nj = i + di, j + dj

                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, mt[ni][nj]) + (2 if p else 1)
                    
                    if nt < d[ni][nj][1 - p]:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))

                d_idx += 1  # Increment direction index

        return min(d[n-1][m-1][0], d[n-1][m-1][1])
",1441376394
Titas,ads3k,294,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Dummy variables
        a, b, c, d, e, f, g, h, i, j = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        
        # Dummy functions
        def dummy_func1(): pass
        def dummy_func2(): pass
        def dummy_func3(): pass
        def dummy_func4(): pass
        def dummy_func5(): pass
        def dummy_func6(): pass
        def dummy_func7(): pass
        def dummy_func8(): pass
        def dummy_func9(): pass
        def dummy_func10(): pass
        
        # Actual solution
        even_sum, odd_sum = 0, 0
        idx = 0
        length = len(num)
        
        while idx < length:
            digit = int(num[idx])
            if idx % 2 == 0:
                even_sum += digit
            else:
                odd_sum += digit
            idx += 1
            
        return even_sum == odd_sum
",1441293345
Titas,ads3k,294,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact;
vector<ll> inv_fact;

// Dummy variables
ll a1, a2, a3, a4, a5, a6, a7, a8, a9, a0;

ll power_mod_func(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    int i = 1; // Loop variable for while loop
    while (i <= n) {
        fact[i] = fact[i - 1] * i % MOD;
        i++;
    }
    inv_fact.assign(n + 1, 1);
    inv_fact[n] = power_mod_func(fact[n], MOD - 2);
    i = n - 1; // Reset loop variable for another while loop
    while (i >= 0) {
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        i--;
    }
}

class Solution {
public:
    // Dummy functions
    void dummyFunc1() {}
    void dummyFunc2() {}
    void dummyFunc3() {}
    void dummyFunc4() {}
    void dummyFunc5() {}
    void dummyFunc6() {}
    void dummyFunc7() {}
    void dummyFunc8() {}
    void dummyFunc9() {}
    void dummyFunc10() {}

    int countBalancedPermutations(string num) {
        int n = num.size();
        string s1 = num; // Replacing variable names with single-character ones
        string s2 = num;

        int freq[10] = {0};
        ll total_sum = 0;
        for (char c : num) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        ll sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(sum_half + 1, 0));
        dp[0][0] = 1;

        int d = 0; // Loop variable for the outer loop
        while (d <= 9) {
            if (freq[d] == 0) {
                d++;
                continue;
            }
            int c = k; // Loop variable for the next loop
            while (c >= 0) {
                ll s = sum_half; // Reset loop variable for the innermost loop
                while (s >= 0) {
                    if (dp[c][s] == 0) {
                        s--;
                        continue;
                    }
                    int t = 1; // Loop variable for the combination
                    while (t <= min(freq[d], k - c)) {
                        if (s + (ll)d * t > sum_half) break;
                        ll comb = (fact[freq[d]] * inv_fact[t] % MOD) * inv_fact[freq[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                c--;
            }
            d++;
        }

        ll valid_assignments = dp[k][sum_half];
        if (valid_assignments == 0) return 0;

        ll prod_fact_fd = 1;
        int f = 0; // Loop variable for the product calculation
        while (f <= 9) {
            prod_fact_fd = prod_fact_fd * fact[freq[f]] % MOD;
            f++;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_prod_fact_fd = power_mod_func(prod_fact_fd, MOD - 2);
        ll answer = (fk_fnk * valid_assignments) % MOD;
        answer = (answer * inv_prod_fact_fd) % MOD;

        return (int)answer;
    }
};
",1441375573
Sagnik Goswami,sagi_1523,295,3627,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<ppi, vector<ppi>, greater<ppi>> pq;  // {time, {row, col}}

        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it.first;
            int row = it.second.first;
            int col = it.second.second;

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);
                    
                    int newTime = waitTime + 1;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, {adjRow, adjCol}});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441339781
Sagnik Goswami,sagi_1523,295,3628,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;  // {time, row, col, prevMovePt (1 or 2)}

        pq.push({0, 0, 0, 2});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it[0];
            int row = it[1];
            int col = it[2];
            int prevMoveTime = it[3];

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);

                    int timeMove = (prevMoveTime == 1) ? 2 : 1;
                    int newTime = waitTime + timeMove;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, adjRow, adjCol, timeMove});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441338982
Sagnik Goswami,sagi_1523,295,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sumEven = 0, sumOdd = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sumOdd += num[i] - '0';
            else sumEven += num[i] - '0';
        }

        return sumEven == sumOdd;
    }
};",1441281467
Sagnik Goswami,sagi_1523,295,3637,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    vector<long long> fact;
    
    void precomputeFactorials(int n) {
        fact.resize(n + 1);
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
    }
    
    long long modPow(long long base, int exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp & 1) result = (result * base) % MOD;
            base = (base * base) % MOD;
            exp >>= 1;
        }
        return result;
    }
    
    vector<vector<vector<int>>> dp;
    vector<int> freq, remFreq;
    string num;
    int n;
    
    int solve(int pos, int sumNeeded, int remLen) {
        if (sumNeeded < 0 || remLen < 0) return 0;
        if (pos == n) return (remLen == 0 && sumNeeded == 0);
        
        if (dp[pos][sumNeeded][remLen] != -1) 
            return dp[pos][sumNeeded][remLen];
        
        long long res = solve(pos + 1, sumNeeded, remLen);
        
        int digit = num[pos] - '0';
        if (remFreq[digit] > 0) {
            remFreq[digit]--;
            freq[digit]++;
            
            res = (res + solve(pos + 1, sumNeeded - digit, remLen - 1)) % MOD;
            
            freq[digit]--;
            remFreq[digit]++;
        }
        
        return dp[pos][sumNeeded][remLen] = res;
    }
    
    long long getPermutations() {
        long long evenDenominator = 1, oddDenominator = 1;
        
        for (int i = 0; i < 10; i++) {
            if (freq[i]) evenDenominator = (evenDenominator * fact[freq[i]]) % MOD;
            if (remFreq[i]) oddDenominator = (oddDenominator * fact[remFreq[i]]) % MOD;
        }
        
        long long evenWays = (fact[(n + 1) / 2] * modPow(evenDenominator, MOD - 2)) % MOD;
        long long oddWays = (fact[n / 2] * modPow(oddDenominator, MOD - 2)) % MOD;
        return (evenWays * oddWays) % MOD;
    }
    
public:
    int countBalancedPermutations(string s) {
        num = s;
        n = num.length();
        
        int sum = 0;
        freq.assign(10, 0);
        remFreq.assign(10, 0);
        
        for (char c : num) {
            sum += c - '0';
            remFreq[c - '0']++;
        }
        
        if (sum & 1) return 0;
        
        int halfSum = sum / 2;
        int evenPos = (n + 1) / 2;
        
        dp.assign(n + 1, vector<vector<int>>(halfSum + 1, vector<int>(evenPos + 1, -1)));
        precomputeFactorials(n);
        
        int ways = solve(0, halfSum, evenPos);
        if (ways == 0) return 0;
        
        return (ways * getPermutations()) % MOD;
    }
};",1441389799
Jaeha Yi,jaehayi1,296,3627,python3,"from heapq import heapify, heappush, heappop

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        '''
        greedy, sort by moveTime
        '''

        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[2e9] * m for _ in range(n)]
        dp[0][0] = 0
        heappush(pq, (0, 0, 0))

        vis = set()

        while pq:
            t, i, j = heappop(pq)

            if (i, j) in vis: continue
            vis.add((i, j))

            if i + 1 < n: 
                dp[i + 1][j] = min(dp[i + 1][j], max(dp[i][j] + 1, moveTime[i + 1][j] + 1))
                heappush(pq, (dp[i + 1][j], i + 1, j))
                
            if j + 1 < m: 
                dp[i][j + 1] = min(dp[i][j + 1], max(dp[i][j] + 1, moveTime[i][j + 1] + 1))
                heappush(pq, (dp[i][j + 1], i, j + 1))

            if i - 1 >= 0: 
                dp[i - 1][j] = min(dp[i - 1][j], max(dp[i][j] + 1, moveTime[i - 1][j] + 1))
                heappush(pq, (dp[i - 1][j], i - 1, j))

            if j - 1 >= 0: 
                dp[i][j - 1] = min(dp[i][j - 1], max(dp[i][j] + 1, moveTime[i][j - 1] + 1))
                heappush(pq, (dp[i][j - 1], i, j - 1))

            # print(pq)

        # print(dp)

        return dp[n - 1][m - 1]
                ",1441311233
Jaeha Yi,jaehayi1,296,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[[2e9] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        heappush(pq, (0, 0, 0, 0))

        vis = set()

        while pq:
            t, i, j, mode = heappop(pq)

            if (i, j, mode) in vis: continue
            vis.add((i, j, mode))
            mode2 = (mode + 1) % 2
            add = (1 if mode == 0 else 2)

            for i2, j2 in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]: 
                if i2 < 0 or j2 < 0 or i2 >= n or j2 >= m: continue
                    
                dp[i2][j2][mode2] = min(dp[i2][j2][mode2], max(dp[i][j][mode] + add, moveTime[i2][j2] + add))
                heappush(pq, (dp[i2][j2][mode2], i2, j2, mode2))

        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]) ",1441324275
Jaeha Yi,jaehayi1,296,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)): 
            x = int(num[i])
            if i % 2 == 0: 
                # print(""even"", x)
                even += x
            else: 
                odd += x

        if even == odd: 
            return True
        return False",1441282985
Jaeha Yi,jaehayi1,296,3637,python3,"import math
from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        '''
        max sum = 80 * 9 / 2 = ~ 360

        dp[sum1][i] = num ways to achieve sums1 with i numbers used in sum1

        Two options: 
            keep number i in sum1, or throw away (put in sum2)

        Space complexity: 360 * 360 * 80 = 10^7
        '''

        mod = int(1e9 + 7)
        n = len(num)
        sn = sum([int(num[i]) for i in range(n)])
        if sn % 2 != 0: return 0
        
        goal = sn // 2

        dp = [[0] * (n // 2 + 1) for _ in range(goal + 1)]
        dp[0][0] = 1
        if int(num[0]) <= goal: dp[int(num[0])][1] = 1
        
        for i in range(1, n): 
            d = int(num[i])
            for x in range(goal, -1, -1): 
                for j in range(i + 1, -1, -1): 
                    if x - d >= 0 and j - 1 >= 0 and j < (n // 2 + 1): 
                        dp[x][j] = (dp[x][j] + dp[x - d][j - 1]) 
        
        factor = (math.factorial(n // 2) * math.factorial(n - n // 2))
        res = dp[goal][n // 2] * factor
        
        c = Counter(num)
        for d in c: 
            res = res // math.factorial(c[d])
        
        return res % mod
                
                

        ",1441391166
Edwin Chen,echen5503,297,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0] = 0
        while pq:
            time, i, j = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+1
                if dist[x, y] > t:
                    dist[x, y] = t
                    heapq.heappush(pq, (t, x, y))

        return dist[n-1, m-1]
                ",1441293027
Edwin Chen,echen5503,297,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0,0] = 0
        while pq:
            time, i, j, state = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+state+1
                if dist[x, y, state^1] > t:
                    dist[x, y, state^1] = t
                    heapq.heappush(pq, (t, x, y, state^1))

        return min(dist[n-1, m-1, 0], dist[n-1, m-1, 1])
                ",1441295224
Edwin Chen,echen5503,297,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = sum(int(x) for x in num[0:n:2])
        b = sum(int(x) for x in num[1:n:2])

        return a == b",1441281001
Edwin Chen,echen5503,297,3637,python3,"M = int(1e9+7)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(int(x) for x in num)
        n = len(num)
        cnt = Counter(num)
        tot = sum(num)

        if tot % 2 != 0:
            return 0

        @cache
        def fact(n):
            return 1 if n == 0 else n*fact(n-1)

        def inv(x):
            return pow(x, M-2, M)
            
        @cache
        def dp(i, s, used):
            if i == 10:
                if s == tot//2 and (used == n//2 or used == ceil(n/2)):
                    return (fact(used) * fact(n-used)) % M
                return 0

            if used > ceil(n/2):
                return 0
            if s > tot//2:
                return 0
            if sum(cnt[x] for x in range(i, 10)) + used < n//2:
                return 0
            ans = 0
            for amt in range(0, cnt[i]+1):
                ans += dp(i+1, s+amt*i, used+amt) * inv(fact(amt)) * inv(fact(cnt[i]-amt))
                ans %= M
            return ans
            
        ans = dp(0, 0, 0)
        if n % 2 == 1:
            ans *= inv(2)
            ans %= M
        return ans",1441392050
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3627,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] travelTime) { // Renamed to match the call
        int rows = travelTime.length;
        int cols = travelTime[0].length;
        int[][] minTime = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(minTime[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));

        queue.offer(new int[]{0, 0, 0});
        minTime[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int currentTime = current[0];
            int x = current[1];
            int y = current[2];

            if (currentTime > minTime[x][y]) continue;

            for (int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int updatedTime = Math.max(currentTime, travelTime[newX][newY]) + 1;

                    if (updatedTime < minTime[newX][newY]) {
                        minTime[newX][newY] = updatedTime;
                        queue.offer(new int[]{updatedTime, newX, newY});
                    }
                }
            }
        }

        return minTime[rows - 1][cols - 1];
    }
}
",1441324048
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3628,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        // 3D dp table to store minimum time to reach each cell with both parities (0 and 1)
        int[][][] minTime = new int[rows][cols][2];
        for (int[][] row : minTime) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        minTime[0][0][0] = 0;

        // Deque for BFS-like traversal with time-based ordering
        Deque<int[]> deque = new ArrayDeque<>();
        deque.offerFirst(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        // Directions for moving up, down, left, and right
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!deque.isEmpty()) {
            int[] state = deque.pollFirst();
            int currTime = state[0];
            int row = state[1];
            int col = state[2];
            int parity = state[3];

            if (currTime > minTime[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int nextTime = Math.max(currTime, moveTime[newRow][newCol]) + (parity == 1 ? 2 : 1);

                    if (nextTime < minTime[newRow][newCol][1 - parity]) {
                        minTime[newRow][newCol][1 - parity] = nextTime;
                        if (parity == 0) {
                            deque.offerFirst(new int[]{nextTime, newRow, newCol, 1 - parity});
                        } else {
                            deque.offerLast(new int[]{nextTime, newRow, newCol, 1 - parity});
                        }
                    }
                }
            }
        }

        return Math.min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }
}
",1441312124
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';  // Convert character to integer
            
            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }
        
        return evenSum == oddSum;
    }
}
",1441283653
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3637,java,"import java.util.*;

public class Solution {
    static final int MOD = 1000000007;
    long[] fact;
    long[] invFact;

    private long powerModFunc(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerModFunc(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long totalSum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;

        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = fact[freq[d]] * invFact[t] % MOD * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = fact[k] * fact[n - k] % MOD;
        long invProdFactFd = powerModFunc(prodFactFd, MOD - 2);
        long answer = fkFnk * validAssignments % MOD * invProdFactFd % MOD;

        return (int) answer;
    }
}
",1441391551
choudharykritik,choudharykritik,299,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 1: 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441390056
choudharykritik,choudharykritik,299,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 2 : 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441388976
choudharykritik,choudharykritik,299,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sm1=0,sm2=0;
        for(int i=0;i<num.size();i+=2){
            sm1+=(num[i]-'0');
        }
        for(int i=1;i<num.size();i+=2){
            sm2+=(num[i]-'0');
        }
        if(sm1==sm2){
            return true;
        }
        return false;
    }
};",1441285033
choudharykritik,choudharykritik,299,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact, inv_fact;

ll mod_pow(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;

    inv_fact.assign(n + 1, 1);
    inv_fact[n] = mod_pow(fact[n], MOD - 2);
    for (int i = n - 1; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> f(10, 0);
        ll sum = 0;

        for (char c : num) {
            int d = c - '0';
            f[d]++;
            sum += d;
        }

        if (sum % 2 != 0) return 0;
        ll half = sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (f[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (ll s = half; s >= 0; s--) {
                    if (dp[c][s] == 0) continue;
                    for (int t = 1; t <= min(f[d], k - c); t++) {
                        if (s + (ll)d * t > half) break;
                        ll comb = (fact[f[d]] * inv_fact[t] % MOD) * inv_fact[f[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                    }
                }
            }
        }

        ll valid = dp[k][half];
        if (valid == 0) return 0;

        ll fact_prod = 1;
        for (int d = 0; d <= 9; d++) {
            fact_prod = fact_prod * fact[f[d]] % MOD;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_fact_prod = mod_pow(fact_prod, MOD - 2);
        ll ans = (fk_fnk * valid % MOD) * inv_fact_prod % MOD;

        return (int)ans;
    }
};
",1441386306
GoIsTheBestLang,__golang__,300,3627,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    dis[v] = max(d + w, moveTime[i][j] + 1)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441326693
GoIsTheBestLang,__golang__,300,3628,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    if (i + j) & 1:
                        dis[v] = max(d + w, moveTime[i][j] + 1)
                    else:
                        dis[v] = max(d + w + 1, moveTime[i][j] + 2)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441329752
GoIsTheBestLang,__golang__,300,3637,python3,"MOD = 10 ** 9 + 7

MAX = 100

fac = [0] * MAX
inv = [0] * MAX

fac[0] = 1
inv[0] = 1
for i in range(1, MAX):
    fac[i] = fac[i - 1] * i % MOD
    inv[i] = pow(fac[i], MOD-2, MOD)

def comb(n, k):
    return fac[n] * inv[k] % MOD * inv[n - k] % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        cnt = Counter(list(map(int, num)))
        tot = sum(int(ch) for ch in num)
        if tot & 1:
            return 0
        @cache
        def dfs(i, s, c):
            if s > tot // 2:
                return 0
            if i == 10:
                if s != tot // 2:
                    return 0
                if c == len(num) // 2:
                    return fac[len(num) // 2] * fac[(len(num) + 1) // 2] % MOD
                return 0
            ans = 0
            for j in range(cnt[i] + 1):
                ans += dfs(i + 1, s + j * i, c + j) * inv[j] * inv[cnt[i] - j] % MOD
                ans %= MOD
            return ans
        return dfs(0, 0, 0)
            
        
        ",1441302966
forwarding7,forwarding7,301,3627,cpp,"
class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + 1, x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + 1, x, y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + 1, x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + 1, x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441303584
forwarding7,forwarding7,301,3628,cpp,"class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 1, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, next, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + next, 3 - next,
                              x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + next, 3 - next, x,
                              y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + +next, 3 - next,
                              x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + +next, 3 - next,
                              x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441305751
forwarding7,forwarding7,301,3637,cpp,"class Solution {
  public:
    using ll = long long;
    int countBalancedPermutations(std::string num) {
        constexpr int mod = 1e9 + 7;

        int n = (int)num.size();
        ll res;

        std::vector<int> nums;
        int sum = 0;
        for (auto c : num) {
            nums.emplace_back(c - '0');
            sum += (c - '0');
        }
        if (sum % 2 == 1) {
            return 0;
        }

        int target = sum / 2;
        int target_size = (int)nums.size() / 2;
        std::vector<std::vector<int>> dp(target_size + 1,
                                         std::vector<int>(target + 1, 0));
        dp[0][0] = 1;
        for (auto number : nums) {
            for (int i = target_size; i >= 1; --i) {
                for (int j = target; j >= number; --j) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - number]) % mod;
                }
            }
        }

        auto factorialMod = [](ll n) -> ll {
            ll result = 1;
            for (ll i = 2; i <= n; ++i) {
                result = (result * i) % mod;
            }
            return result;
        };

        // 
        std::unordered_map<int, int> freq;
        for (auto number : nums) {
            freq[number]++;
        }

        // 
        ll duplicateFactor = 1;
        for (const auto &[key, value] : freq) {
            duplicateFactor = (duplicateFactor * factorialMod(value)) % mod;
        }

        auto f = dp[target_size][target];
        if (nums.size() % 2 == 0) {
            auto a = factorialMod(target_size);
            res = ((a * a) % mod * f) % mod;
        } else {
            auto a = factorialMod(target_size);
            auto b = factorialMod(target_size + 1);
            res = ((a * b) % mod * f) % mod;
        }

        res = (res * modInverse(duplicateFactor, mod)) % mod;
        return (int)(res);
    }

  private:
    // 
    ll modInverse(ll a, ll m) {
        ll m0 = m, t, q;
        ll x0 = 0, x1 = 1;
        if (m == 1)
            return 0;
        while (a > 1) {
            q = a / m;
            t = m;
            m = a % m, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0)
            x1 += m0;
        return x1;
    }
};",1441330435
arunkumar saranga,arunkumarsaranga,302,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] a) {
        int x = a.length;
        int y = a[0].length;
        int[][][] b = f(x, y);
        b[0][0][0] = 0;
        PriorityQueue<int[]> c = new PriorityQueue<>((d, e) -> Integer.compare(d[0], e[0]));
        c.offer(new int[]{0, 0, 0, 0});
        int[][] g = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!c.isEmpty()) {
            h(c, b, g, a, x, y);
        }
        
        return Math.min(b[x - 1][y - 1][0], b[x - 1][y - 1][1]);
    }
    
    private int[][][] f(int x, int y) {
        int[][][] b = new int[x][y][2];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                b[i][j][0] = Integer.MAX_VALUE;
                b[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return b;
    }
    
    private void h(PriorityQueue<int[]> c, int[][][] b, int[][] g, int[][] a, int x, int y) {
        int[] i = c.poll();
        int j = i[0];
        int k = i[1];
        int l = i[2];
        int m = i[3];
        
        if (j > b[k][l][m]) return;
        
        for (int[] n : g) {
            int o = k + n[0];
            int p = l + n[1];
            if (o >= 0 && o < x && p >= 0 && p < y) {
                int q = Math.max(j, a[o][p]) + (m == 0 ? 1 : 2);
                int r = 1 - m;
                
                if (q < b[o][p][r]) {
                    b[o][p][r] = q;
                    c.offer(new int[]{q, o, p, r});
                }
            }
        }
    }
}
",1441377032
arunkumar saranga,arunkumarsaranga,302,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        l=list(map(int,s))
        x=l[0::2]
        # print(x)
        y=l[1::2]
        # print(y)
        return sum(x)==sum(y)",1441349852
arunkumar saranga,arunkumarsaranga,302,3637,python3,"MOD = 1000000007

def p(x, y):
    z = 1
    x %= MOD
    while y > 0:
        if y & 1:
            z = z * x % MOD
        x = x * x % MOD
        y >>= 1
    return z

a = []
b = []

def b_init(m):
    global a, b
    a = [1] * (m + 1)
    for c in range(1, m + 1):
        a[c] = a[c - 1] * c % MOD
    b = [1] * (m + 1)
    b[m] = p(a[m], MOD - 2)
    for c in range(m - 1, -1, -1):
        b[c] = b[c + 1] * (c + 1) % MOD

class Solution:
    def countBalancedPermutations(self, q: str) -> int:
        m = len(q)
        n = [0] * 10
        r = 0
        for x in q:
            s = int(x)
            n[s] += 1
            r += s

        if r % 2 != 0:
            return 0
        g = r // 2
        h = (m + 1) // 2
        b_init(m)
        
        dp = [[0] * (g + 1) for _ in range(h + 1)]
        dp[0][0] = 1
        
        for s in range(10):
            if n[s] == 0:
                continue
            for t in range(h, -1, -1):
                for u in range(g, -1, -1):
                    if dp[t][u] == 0:
                        continue
                    for v in range(1, min(n[s], h - t) + 1):
                        if u + s * v > g:
                            break
                        w = (a[n[s]] * b[v] % MOD) * b[n[s] - v] % MOD
                        dp[t + v][u + s * v] = (dp[t + v][u + s * v] + dp[t][u] * w) % MOD

        x = dp[h][g]
        if x == 0:
            return 0

        y = 1
        for s in range(10):
            y = y * a[n[s]] % MOD

        z = a[h] * a[m - h] % MOD
        i_y = p(y, MOD - 2)

        result = (z * x % MOD) * i_y % MOD
        return result
",1441386739
klu2200031955,klu2200031955,303,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] d = initializeDistanceMatrix(n, m);
        PriorityQueue<Node> queue = initializeQueue();

        queue.offer(new Node(0, 0, 0, 0));

        return processQueue(queue, d, moveTime, n, m);
    }

    private int[][][] initializeDistanceMatrix(int rows, int cols) {
        int[][][] distanceMatrix = new int[rows][cols][2];
        for (int[][] row : distanceMatrix) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        distanceMatrix[0][0][0] = 0;  // Starting point
        return distanceMatrix;
    }

    private PriorityQueue<Node> initializeQueue() {
        return new PriorityQueue<>();
    }

    private int[][] getDirections() {
        return new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    }

    private int processQueue(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, int n, int m) {
        int[][] directions = getDirections();

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.time > distance[node.x][node.y][node.parity]) continue;

            updateDistances(queue, distance, moveTime, node, directions, n, m);
        }

        return Math.min(distance[n - 1][m - 1][0], distance[n - 1][m - 1][1]);
    }

    private void updateDistances(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, Node node, int[][] directions, int n, int m) {
        for (int[] dir : directions) {
            int ni = node.x + dir[0];
            int nj = node.y + dir[1];

            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                // Calculate the new time with corrected parity handling
                int newTime = Math.max(node.time, moveTime[ni][nj]) + ((node.parity == 1) ? 2 : 1);

                if (newTime < distance[ni][nj][1 - node.parity]) {
                    distance[ni][nj][1 - node.parity] = newTime;
                    queue.offer(new Node(newTime, ni, nj, 1 - node.parity));
                }
            }
        }
    }

    private static class Node implements Comparable<Node> {
        int time, x, y, parity;

        Node(int time, int x, int y, int parity) {
            this.time = time;
            this.x = x;
            this.y = y;
            this.parity = parity;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.time, other.time);
        }
    }
}
",1441331711
klu2200031955,klu2200031955,303,3636,java,"class SumCalculator {
    public int calculateEvenSum(String num) {
        int evenSum = 0;
        for (int i = 0; i < num.length(); i += 2) {
            evenSum += num.charAt(i) - '0';
        }
        return evenSum;
    }

    public int calculateOddSum(String num) {
        int oddSum = 0;
        for (int i = 1; i < num.length(); i += 2) {
            oddSum += num.charAt(i) - '0';
        }
        return oddSum;
    }
}

class Solution {
    private SumCalculator calculator = new SumCalculator();

    public boolean isBalanced(String num) {
        int evenSum = calculator.calculateEvenSum(num);
        int oddSum = calculator.calculateOddSum(num);
        return evenSum == oddSum;
    }
}
",1441335004
klu2200031955,klu2200031955,303,3637,java,"import java.util.Arrays;

class MathUtils {
    static final int MOD = 1000000007;

    static long power_mod_func(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    static class FactorialResult {
        long[] fact;
        long[] inv_fact;

        FactorialResult(long[] fact, long[] inv_fact) {
            this.fact = fact;
            this.inv_fact = inv_fact;
        }
    }

    static FactorialResult initializeFactorials(int n) {
        long[] fact = new long[n + 1];
        long[] inv_fact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        inv_fact[n] = power_mod_func(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        }
        return new FactorialResult(fact, inv_fact);
    }
}

class Solution {
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long total_sum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        long sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        MathUtils.FactorialResult factorials = MathUtils.initializeFactorials(n);
        long[] fact = factorials.fact;
        long[] inv_fact = factorials.inv_fact;

        long[][] dp = new long[k + 1][(int) (sum_half + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sum_half; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + (long) d * t > sum_half) break;
                        long comb = (fact[freq[d]] * inv_fact[t] % MathUtils.MOD) * inv_fact[freq[d] - t] % MathUtils.MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MathUtils.MOD;
                    }
                }
            }
        }

        long valid_assignments = dp[k][(int) sum_half];
        if (valid_assignments == 0) return 0;

        long prod_fact_fd = 1;
        for (int d = 0; d <= 9; d++) {
            prod_fact_fd = prod_fact_fd * fact[freq[d]] % MathUtils.MOD;
        }

        long fk_fnk = (fact[k] * fact[n - k]) % MathUtils.MOD;
        long inv_prod_fact_fd = MathUtils.power_mod_func(prod_fact_fd, MathUtils.MOD - 2);
        long answer = (fk_fnk * valid_assignments) % MathUtils.MOD;
        answer = (answer * inv_prod_fact_fd) % MathUtils.MOD;

        return (int) answer;
    }
}
",1441380869
Ratnakar Gautam,ratnakarg,304,3627,cpp,"#define ll long long
class Solution {
public:
    vector<vector<int>> dir = {{1,0} , {0,1} , {0,-1} , {-1,0}};
    bool coords(int r, int c, int n, int m){
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool check(int mid , vector<vector<int>>& mvt) {
        int n = mvt.size() , m = mvt[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        dis[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cst = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cst <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + dir[i][0], ncol = c + dir[i][1];
                if (coords(nrow, ncol, n, m)) {
                    long long tmp = max(cst + 1, 1LL*mvt[nrow][ncol] + 1);
                    if (tmp < dis[nrow][ncol] && tmp <= mid) {
                        dis[nrow][ncol] = tmp;
                        q.push({tmp , nrow , ncol});
                    }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& mvt) {
        int n = mvt.size(), m = mvt[0].size();
        long long low = 0 , high = 1e13;
        long long ans = -1;
        while(low <= high) {
            long long mid = low + (high-low) / 2;

            if(check(mid , mvt)) {
                ans = mid;
                high = mid-1;
            }
            else low = mid+1;
        } 

        return ans;
    }
};",1441369613
Ratnakar Gautam,ratnakarg,304,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441292383
Ratnakar Gautam,ratnakarg,304,3637,cpp,"#define ll long long
const int mod = 1e9+7;

class Solution {
public:
    ll modPow(ll base, ll exp, ll mod) {
        ll res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    ll inv(ll num) {
        return modPow(num, mod - 2, mod);
    }

    // int solve(vector<int>& num, int k){
    //     int n = num.size();
    
    //     vector<int> prev(k + 1, 0);
    
    //     prev[0] = 1;
    
    //     if (num[0] <= k) {
    //         prev[num[0]] = 1;
    //     }
    
    //     for (int ind = 1; ind < n; ind++) {
    //         vector<int> cur(k + 1, 0);
    
    //         cur[0] = 1;
    
    //         for (int target = 1; target <= k; target++) {
    //             int notTaken = prev[target];
    //             int taken = 0;
    //             if (num[ind] <= target) {
    //                 taken = prev[target - num[ind]];
    //             }
    
    //             cur[target] = notTaken + taken;
    //         }
    
    //         prev = cur;
    //     }
    
    //     return prev[k];
    // }

    int countBalancedPermutations(string num){
        vector<int> v;
        int n = num.size();
        map<int,int> freq;
        for(char x:num){
            v.push_back((int)x-'0');
            freq[v.back()]++;
            
        }
        int tot = accumulate(v.begin(),v.end(),0ll);
        int mod = 1e9+7;
        // vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (9*n , vector<int> (n,-1)));
        // function<int(int,int,int)> rec = [&](int i,int sum,int k){
        //     if(i==n)return (int)(k==n/2 && sum*2==tot);
        //     if(dp[i][sum][k]!=-1)return dp[i][sum][k];
        //     ll ans = 0;
        //     ans+=rec(i+1,sum,k);
        //     ans%=mod;
        //     ans+=rec(i+1,sum+v[i],k+1);
        //     ans%=mod;
        //     return dp[i][sum][k]=(int)ans;
        // };
        // ll cnt=rec(0,0,0);

        if (tot % 2 != 0) return 0;
        int halfSum = tot / 2;
         vector<vector<int>> dp(halfSum + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> next = dp;
            for (int sum = 0; sum <= halfSum; sum++){
                for (int k=0;k<=n/2;k++){
                    if(dp[sum][k]>0){
                        // next[sum][k]=(next[sum][k]+dp[sum][k])%mod;
                        if (k + 1 <= n / 2 && sum + v[i] <= halfSum){
                            next[sum + v[i]][k + 1] = (next[sum + v[i]][k + 1] + dp[sum][k]) % mod;
                        }
                    }
                }
            }
            dp = next;
        }

        ll cnt = dp[halfSum][n/2];

        // cout<<cnt<<endl;

        vector<ll> f(100);
        f[0]=1;
        for(int i=1;i<100;i++){
            f[i]=f[i-1]*i;
            f[i]%=mod;
        }
        int a = n/2 , b = n - a;
        ll ans = (((f[a]*f[b])%mod)*cnt)%mod;

        for(int i=0;i<=9;i++){
            ans*=inv(f[freq[i]]);
            ans%=mod;
        }
        return ans;
    }
};",1441357011
Sean,shaun001280,305,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        // Distance matrix to store minimum times
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        // Priority queue to store {time, {row, col}}
        priority_queue<pair<int, pair<int, int>>, 
                      vector<pair<int, pair<int, int>>>,
                      greater<pair<int, pair<int, int>>>> pq;
        
        // Directions: right, down, left, up
        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        // Start from (0,0)
        dist[0][0] = moveTime[0][0];
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            int currTime = pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second;
            pq.pop();
            
            if (currTime > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir.first;
                int newCol = col + dir.second;
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(currTime + 1, moveTime[newRow][newCol] + 1);
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};",1441395871
Sean,shaun001280,305,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum0 = 0, sum1 = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sum1 += num[i] - '0';
            else sum0 += num[i] - '0';
        }
        return sum0 == sum1;
    }
};",1441371592
Sean,shaun001280,305,3637,cpp,"class Solution {
private:
    static constexpr int MOD = 1000000007;
    vector<vector<int>> C;
    vector<int> cnt;
    int target_sum;
    unordered_map<string, int> memo;
    
    string getKey(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        return to_string(pos) + "","" + to_string(sum_odd) + "","" + 
               to_string(sum_even) + "","" + to_string(odd_spots) + "","" + 
               to_string(even_spots);
    }
    
    int dfs(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        if (pos == 10) {
            return (sum_odd == target_sum && sum_even == target_sum) ? 1 : 0;
        }
        
        string key = getKey(pos, sum_odd, sum_even, odd_spots, even_spots);
        if (memo.count(key)) {
            return memo[key];
        }
        
        if (sum_odd > target_sum || sum_even > target_sum) {
            return 0;
        }
        
        if (cnt[pos] == 0) {
            int result = dfs(pos + 1, sum_odd, sum_even, odd_spots, even_spots);
            memo[key] = result;
            return result;
        }
        
        int result = 0;
        for (int i = 0; i <= cnt[pos]; i++) {
            if (i <= odd_spots && (cnt[pos] - i) <= even_spots) {
                long long new_sum_odd = sum_odd + (long long)i * pos;
                long long new_sum_even = sum_even + (long long)(cnt[pos] - i) * pos;
                
                if (new_sum_odd <= target_sum && new_sum_even <= target_sum) {
                    long long ways = 1;
                    ways = ((long long)C[odd_spots][i] * C[even_spots][cnt[pos] - i]) % MOD;
                    ways = (ways * dfs(pos + 1, new_sum_odd, new_sum_even, 
                            odd_spots - i, even_spots - (cnt[pos] - i))) % MOD;
                    result = (result + ways) % MOD;
                }
            }
        }
        
        memo[key] = result;
        return result;
    }
    
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int n_odd = (n + 1) / 2;
        int n_even = n / 2;
        
        cnt.resize(10);
        int total_sum = 0;
        
        for (char x : num) {
            total_sum += x - '0';
            cnt[x - '0']++;
        }
        
        if (total_sum % 2 == 1) {
            return 0;
        }
        
        target_sum = total_sum / 2;
        
        C.resize(n + 1, vector<int>(n + 1));
        for (int i = 0; i <= n; i++) {
            C[i][0] = 1;
            C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        
        memo.clear();
        return dfs(0, 0, 0, n_odd, n_even);
    }
};",1441367965
roush_70700,roush_70700,306,3627,cpp,"class Solution {
public:
    vector <pair<int,int>> rc = {{1,0} , {0,1} , {0,-1} , {-1,0}};

    bool IsValid(int r, int c, int n, int m) {
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool IsPossible(int mid , vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        vector<vector<long long>> minTime(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        minTime[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cost = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cost <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + rc[i].first, ncol = c + rc[i].second;
                if (IsValid(nrow, ncol, n, m)) {
                    long long newCost = max(cost + 1, 1LL*moveTime[nrow][ncol] + 1);
                    if (newCost < minTime[nrow][ncol] && newCost <= mid) {
                        minTime[nrow][ncol] = newCost;
                        q.push({newCost , nrow , ncol});
                    }

                    // if(newCost <= mid && !vis[nrow][ncol]) {
                    //     vis[nrow][ncol] = 1;
                    //     // minTime[nrow][ncol] = newCost;
                    //     q.push({newCost , nrow , ncol});
                    // }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        long long l = 0 , r = 1e13;
        long long ans = -1;
        while(l <= r) {
            long long mid = l + (r-l) / 2;

            if(IsPossible(mid , moveTime)) {
                ans = mid;
                r = mid-1;
            }
            else l = mid+1;
        } 

        return ans;
    }
};
",1441345035
roush_70700,roush_70700,306,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441282228
roush_70700,roush_70700,306,3637,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    long long modular_power(long long base, long long exp, long long mod) {
        long long res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    long long fun(long long num) {
        return modular_power(num, mod - 2, mod);
    }

    long long solve(int sum, int n, vector<int>& temp) {
        int req = sum / 2;
        vector<vector<int>> dp(req + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> dp_next = dp;
            for (int s = 0; s <= req; s++) {
                for (int k = 0; k <= n / 2; k++) {
                    if (dp[s][k] > 0) {
                        if (k + 1 <= n / 2 && s + temp[i] <= req) {
                            dp_next[s + temp[i]][k + 1] = (dp_next[s + temp[i]][k + 1] + dp[s][k]) % mod;
                        }
                    }
                }
            }
            dp = dp_next;
        }
        return dp[req][n / 2];
    }
    int countBalancedPermutations(string num) {
        vector<int> temp;
        int n = num.size();
        unordered_map<int, int> mp;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            temp.push_back(num[i] - '0');
            mp[temp.back()]++;
            sum += temp[i];
        }

        if (sum % 2 != 0)
            return 0;

        long long cnt = solve(sum, n, temp);
        vector<long long> res(100);
        res[0] = 1;
        for (int i = 1; i < 100; i++) {
            res[i] = (res[i - 1] * i) % mod;
        }
        
        int a = n / 2, b = n - a;
        long long ans = (((res[a] * res[b]) % mod) * cnt) % mod;
        for (int i = 0; i <= 9; i++) {
            ans = (ans * fun(res[mp[i]])) % mod;
        }
        return ans;
    }
};
",1441389790
xy-li,xy-li,307,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # for i in range(len(moveTime)):
        #     for j in range(len(moveTime[0])):
        #         if i!=0 or j!=0:
        #             moveTime[i][j] += 1
        # moveTime[0][0] = 0
        
        n, m = len(moveTime), len(moveTime[0])
        start = (0, 0)
        seen = [[False] * m for _ in range(n)]
        dist = [[float('inf')] * m for _ in range(n)]
        h = [(0, 0, 0)]
        dist[0][0] = 0
        
        while h:
            d, i, j = heapq.heappop(h)
            if d > dist[i][j]:
                continue
            if i == n - 1 and j == m - 1:
                return d
            seen[i][j] = True
            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
                if 0 <= x < n and 0 <= y < m and not seen[x][y]:
                    new_dist = min(max(d, moveTime[x][y])+1, dist[x][y])
                    if new_dist < dist[x][y]:
                        dist[x][y] = new_dist
                        heapq.heappush(h, (new_dist, x, y))
            
        return dist[n - 1][m - 1]

                ",1441384467
xy-li,xy-li,307,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        digits = [int(x) for x in num]
        odd_sum = sum(digits[::2])
        even_sum = sum(digits[1::2])
        return odd_sum == even_sum
        ",1441281451
xy-li,xy-li,307,3637,python3,"M = 10**9 + 7

fraq = [1]

for i in range(80):
    fraq.append((fraq[-1] * (i+1)) % M)

fraq_inv = [pow(i, M - 2, M) for i in fraq]

# print(fraq_inv[:10])

from collections import Counter
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = [int(i) for i in num]
        cnt = Counter(nums)
        s = sum(nums)
        if s % 2 != 0:
            return 0
        n = len(nums)
        k = n // 2
        target_sum = s // 2
        
        dp = [[0] * (target_sum + 1) for _ in range(k + 1)]
        dp[0][0] = 1  # Base case: one way to get sum 0 with 0 elements

        # Fill the DP table
        for num in nums:
            # Update dp table in reverse to avoid reusing elements in the same iteration
            for j in range(k, 0, -1):
                for s in range(target_sum, num - 1, -1):
                    dp[j][s] = (dp[j][s] + dp[j - 1][s - num]) % M
                    
        res = dp[-1][-1] * fraq[n - k] * fraq[k] % M
        # print(dp[-1][-1], fraq[n - k])
        for num in cnt:
            res = (res * fraq_inv[cnt[num]]) % M
        return res
                
        
        ",1441365474
lucasomee006,lucasomee006,308,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #dijkstra's?
        distances = [[float('inf') for i in range(len(moveTime[0]))] for j in range(len(moveTime))]
        # distances[0][0] = 0
        queue = [((0, 0), 0)]
        def neighbors(i, j):
            ans = []
            if i < len(moveTime)-1:
                ans.append((i+1, j))
            if j < len(moveTime[0])-1:
                ans.append((i, j+1))
            if i > 0:
                ans.append((i-1, j))
            if j > 0:
                ans.append((i, j-1))
            return ans
            
        while len(queue):
            coords, weight = heapq.heappop(queue)
            i, j = coords
            if weight >= distances[i][j]:
                continue
            distances[i][j] = weight
            for n in neighbors(i, j):
                heapq.heappush(queue, (n, max(weight+1, moveTime[n[0]][n[1]]+1)))
        # print(neighbors(1, 1))
        # print(distances)
        return distances[-1][-1]
            
            ",1441313817
lucasomee006,lucasomee006,308,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(num[i]) for i in range(1, len(num), 2)]) == sum([int(num[i]) for i in range(0, len(num), 2)])",1441281675
lucasomee006,lucasomee006,308,3637,python3,"from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        #basically we're dividing it into 2 equal sized groups (max diff of 1)
        #and those two groups have to have the same sum
        d = defaultdict(int)
        for char in num:
            d[int(char)] += 1
        x = [factorial(d[y]) for y in d]
        a = 1
        for i in range(len(x)):
            a *= x[i]
        if len(num) % 2 == 1:
            a *= 2
        #so for each number we can put it into one of the two groups
        #so total number of permutations assuming each char is distinct, but divided by num of each char
        #factorial
        mod = 10**9 + 7
        ans = 0
        finalAns = 0
        #dp(i, curSumDif, numOneGroup) returns
        s = sum([int(char) for char in num])
        @cache
        def dp(i, curSumDif, numOneGroup):
            
            if i == len(num) and curSumDif == 0 and abs(numOneGroup) <= 1:
                return 1
            if i == len(num):
                return 0
            if abs(curSumDif) > s//2+2:
                return 0
            if abs(numOneGroup) > len(num)//2+2:
                return 0
            return dp(i+1, curSumDif+int(num[i]), numOneGroup + 1) + dp(i+1, curSumDif-int(num[i]), numOneGroup-1)
        x = dp(0, 0, 0)
        dp.cache_clear()
        perm = factorial(len(num)//2)*factorial(len(num)-len(num)//2)
        return perm * x // a % mod
        
        ",1441385645
bramar2,bramar2,310,3627,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dp(n, vector<ll>(m));
        dp[0][0] = 0;
        for(int i = 1; i < n; i++) {
            dp[i][0] = max((ll)moveTime[i][0] + 1, dp[i - 1][0] + 1);
        }
        for(int i = 1; i < m; i++) {
            dp[0][i] = max((ll)moveTime[0][i] + 1, dp[0][i - 1] + 1);
        }

        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                dp[i][j] = max({
                    (ll)moveTime[i][j] + 1,
                    min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
                });
            }
        }
        auto cmax = [&](int i, int j, ll val) {
            if(i == 0 && j == 0) return false;
            ll prev = dp[i][j];
            dp[i][j] = min((ll)moveTime[i][j] + 1, val);
            return (dp[i][j] != prev);
        };
        bool change = true;
        while(change) {
            change = false;
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < m; j++) {
                    if(i == 0 && j == 0) continue;
                    ll prev = dp[i][j];
                    ll mn = 1e16;
                    if(i > 0) {
                        mn = min(mn, dp[i-1][j] + 1);
                    }
                    if(j > 0) {
                        mn = min(mn, dp[i][j-1] + 1);
                    }
                    if(i+1 < n) {
                        mn = min(mn, dp[i+1][j] + 1);
                    }
                    if(j+1 < m) {
                        mn = min(mn, dp[i][j+1] + 1);
                    }
                    dp[i][j] = max((ll)moveTime[i][j] + 1, mn);
                    if(prev != dp[i][j]) change = true;
                }
            }
        }
        return dp.back().back();
    }
};

int main1() {
    fastio;
    return 0;
}",1441302783
bramar2,bramar2,310,3636,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                sum1 += num[i]-'0';
            }else {
                sum2 += num[i]-'0';
            }
        }
        return sum1 == sum2;
    }
};

int main1() {
    fastio;
    return 0;
}",1441290674
bramar2,bramar2,310,3637,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

vector<ll> memoFactorial {1,1,2};
long long modfactorial(long long n) {
    if(n < (ll)memoFactorial.size()) return memoFactorial[n];
    for(ll i = memoFactorial.size(); i <= n; i++) {
        memoFactorial.push_back((i * memoFactorial[i - 1]) % MOD);
    }
    return memoFactorial[n];
}

bool init() {
    fastio;
    modfactorial(210);
    return true;
}
bool y = init();

ll dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(const string& numStr) {
        int n = numStr.size();
        int freq[10] {};
        ll targetSum = 0;
        for(char c : numStr) {
            freq[c-'0']++;
            targetSum += (c-'0');
        }
        if(targetSum % 2 == 1) return 0;
        targetSum /= 2;
        
        ll targetLen = n/2;
        ll ways = (memoFactorial[targetLen] * memoFactorial[n-targetLen]) % MOD;

        vector<vector<vector<ll>>> dp(10, vector<vector<ll>>(n+1, vector<ll>(targetSum+1, -1)));
        function<ll(ll,ll,ll)> go = [&](ll i, ll len1, ll sum1) {
            if(i >= 10) {
                if(len1 == targetLen && sum1 == targetSum) {
                    // dbg(len1, sum1);
                    return ways;
                }
                return 0LL;
            }
            if(sum1 > targetSum) {
                return 0LL;
            }
            if(dp[i][len1][sum1] >= 0) return dp[i][len1][sum1];
            ll ans = 0;
            for(ll take = 0; take <= freq[i]; take++) {
                ll w = (go(i + 1, len1 + take, sum1 + take*i) * mod_exp(memoFactorial[take], MOD-2, MOD)) % MOD;
                w = (w * mod_exp(memoFactorial[freq[i]-take], MOD-2, MOD)) % MOD;
                ans = (ans + w) % MOD;
            }
            return dp[i][len1][sum1] = ans;
        };
        return go(0, 0, 0);
    }
};

int main1() {
    fastio;
    return 0;
}",1441380016
Kumar sai,E22CSEU0567,311,3627,python3,"class Solution:
    def minTimeToReach(self, alpha: List[List[int]]) -> int:
        n, m = len(alpha), len(alpha[0])
        beta = [[float('inf')] * m for _ in range(n)]
        beta[0][0] = 0
        import heapq
        gamma = [(0, 0, 0)]
        delta = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while gamma:
            theta, iota, kappa = heapq.heappop(gamma)
            if theta > beta[iota][kappa]:
                continue
            for dx, dy in delta:
                lambda_, mu = iota + dx, kappa + dy
                if 0 <= lambda_ < n and 0 <= mu < m:
                    nu = max(0, alpha[lambda_][mu] - theta)
                    xi = theta + nu + 1
                    if xi < beta[lambda_][mu]:
                        beta[lambda_][mu] = xi
                        heapq.heappush(gamma, (xi, lambda_, mu))
        
        return beta[n-1][m-1]
",1441290681
Kumar sai,E22CSEU0567,311,3628,python3,"class Solution:
    def minTimeToReach(self, sai: List[List[int]]) -> int:
        n, m = len(sai), len(sai[0])
        preksha = [[[float('inf'), 0] for _ in range(m)] for _ in range(n)]
        preksha[0][0] = [0, 0]
        gamma = [row[:] for row in sai]
        import heapq
        delta = [(0, 0, 0, 0)]
        epsilon = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while delta:
            zeta, eta, theta, iota = heapq.heappop(delta)
            if zeta > preksha[theta][iota][0]:
                continue
            for dx, dy in epsilon:
                kappa, lambda_ = theta + dx, iota + dy
                if 0 <= kappa < n and 0 <= lambda_ < m:
                    xi = 1 if eta % 2 == 0 else 2
                    nu = max(0, gamma[kappa][lambda_] - zeta)
                    omicron = zeta + nu + xi
                    rho = eta + 1
                    if omicron < preksha[kappa][lambda_][0]:
                        preksha[kappa][lambda_] = [omicron, rho]
                        heapq.heappush(delta, (omicron, rho, kappa, lambda_))
        
        return preksha[n-1][m-1][0]
",1441293005
Kumar sai,E22CSEU0567,311,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sai = sum(int(num[i]) for i in range(0, len(num), 2))
        preksha = sum(int(num[i]) for i in range(1, len(num), 2))
        
        return sai == preksha
",1441286642
beaaan,beaaan,312,3627,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 3>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + 1;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441291244
beaaan,beaaan,312,3628,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 4>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0, 1});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y, cost_to_move] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + cost_to_move;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny, cost_to_move == 1 ? 2 : 1});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441293138
beaaan,beaaan,312,3636,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  bool isBalanced(string num) {
    int n = (int)num.size();
    int sum = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        sum -= num[i] - '0';
      } else {
        sum += num[i] - '0';
      }
    }
    return sum == 0;
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441281844
Manyu,ManyuD,313,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j

                if not (0 <= x < m and 0 <= y < n) or ((x, y) in vis and vis[(x, y)] <= max(t + 1, 1 + moveTime[x][y])):
                    continue

                vis[(x, y)] = max(t + 1, 1 + moveTime[x][y])
                heapq.heappush(h, (max(t + 1, 1 + moveTime[x][y]), x, y))
            

",1441289870
Manyu,ManyuD,313,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0, True)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j, dur = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j
                
                if not (0 <= x < m and 0 <= y < n):
                    continue
                    
                next_time = max(t + (1 if dur else 2), (1 if dur else 2) + moveTime[x][y])

                if ((x, y) in vis and vis[(x, y)] <= next_time):
                    continue

                vis[(x, y)] = next_time
                heapq.heappush(h, (next_time, x, y, not dur))
                
            

",1441293154
Manyu,ManyuD,313,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:

        l = r = 0
        bit = False
        
        for i in num:
            if bit:
                l += int(i)
            else:
                r += int(i)
            bit = not bit

        return l == r
            ",1441281031
mmb L,mammothb,314,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0)]
        while h:
            time, i, j = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j))
",1441292192
mmb L,mammothb,314,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0, 0)]
        while h:
            time, i, j, move = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1 + move
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j, (move + 1) % 2))
",1441294258
mmb L,mammothb,314,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281209
David Yee,yeedaKing,315,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+1
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l))

        return 0",1441293091
David Yee,yeedaKing,315,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 1)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j, flag = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+flag
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l, 2 if flag == 1 else 1))

        return 0",1441294688
David Yee,yeedaKing,315,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sum1 = sum2 = 0
        for i in range(len(num)):
            if i%2:
                sum1 += int(num[i])

            else:
                sum2 += int(num[i])

        return sum1 == sum2",1441280847
killer-whale,killer-whale,316,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start)]
        dist = defaultdict(lambda: inf, {start: 0})
        while h:
            cost, node = heappop(h)
            if dist[node] != cost:
                continue
            if node == target:
                return cost
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx] + 1
                    nw = max(w, cost + 1)
                    if dist[ny, nx] > nw:
                        dist[ny, nx] = nw
                        heappush(h, (nw, (ny, nx)))",1441290248
killer-whale,killer-whale,316,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start, 1)]
        dist = defaultdict(lambda: inf, {(start, 1): 0})
        while h:
            cost, node, cnt = heappop(h)
            if dist[node, cnt] != cost:
                continue
            if node == target:
                return cost
            cnt += 1
            cnt %= 2
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx]
                    nw = max(w, cost) + cnt + 1
                    #print(cnt, nw)
                    if dist[(ny, nx), cnt] > nw:
                        dist[(ny, nx), cnt] = nw
                        heappush(h, (nw, (ny, nx), cnt))",1441294773
killer-whale,killer-whale,316,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o=e=0
        for i, x in enumerate(num):
            if i % 2:
                o += int(x)
            else:
                e += int(x)
        return o==e",1441290328
SirTechnical,SirTechnical,317,3627,cpp,"struct State {
    int i;
    int j;
    int t;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, 0x3f3f3f3f));
        dist[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0});
        while (!pq.empty()) {
            auto [i,j,t] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+1;
                if (tt < dist[ti][tj]) {
                    dist[ti][tj] = tt;
                    pq.push({ti,tj,tt});
                }
            }
        }
        return dist[N-1][M-1];
    }
};",1441291831
SirTechnical,SirTechnical,317,3628,cpp,"struct State {
    int i;
    int j;
    int t;
    int d;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

inline int alt(int d) {
    if (d == 1) return 2;
    return 1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist1(N, vector<int>(M, 0x3f3f3f3f));
        vector<vector<int>> dist2(N, vector<int>(M, 0x3f3f3f3f));
        dist1[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0,1});
        while (!pq.empty()) {
            auto [i,j,t,d] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+d;
                if (d == 1) {
                    if (tt < dist2[ti][tj]) {
                        dist2[ti][tj] = tt;
                        pq.push({ti,tj,tt,2});
                    }
                } else {
                    if (tt < dist1[ti][tj]) {
                        dist1[ti][tj] = tt;
                        pq.push({ti,tj,tt,1});
                    }
                }
                
            }
        }
        return min(dist1[N-1][M-1], dist2[N-1][M-1]);
    }
};",1441294968
SirTechnical,SirTechnical,317,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sa = 0;
        int sb = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i%2 == 0) sa += num[i]-'0';
            else sb += num[i]-'0';
        }
        return sa == sb;
    }
};",1441280907
Sanjay Grover,SanjayGrover,318,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0)]
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + 1 + waitTime
                    
                    if newTime < visited[nx][ny]:
                        visited[nx][ny] = newTime
                        heapq.heappush(pq, (newTime, nx, ny))
        
        return -1",1441289381
Sanjay Grover,SanjayGrover,318,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0, 1)]
        visited = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        visited[0][0][1] = 0
        
        while pq:
            time, x, y, nextMoveTime = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + nextMoveTime + waitTime
                    
                    alter = 2 if nextMoveTime == 1 else 1
                    
                    if newTime < visited[nx][ny][alter - 1]:
                        visited[nx][ny][alter - 1] = newTime
                        heapq.heappush(pq, (newTime, nx, ny, alter))
        
        return -1",1441295001
Sanjay Grover,SanjayGrover,318,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int even = 0;
        int odd = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i % 2 == 0) even += num.charAt(i) - '0';
            else odd += num.charAt(i) - '0';
        }
        return odd == even;
    }
}",1441283075
Andwerp,Andwerp,319,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> q;
        q.push({0, {0, 0}});
        vector<vector<bool>> v(n, vector<bool>(m, false));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.first;
            int c = q.top().second.second;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c] || d[r][c] != cur_t) {
                continue;
            }
            v[r][c] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int next_t = max(mt[nr][nc] + 1, cur_t + 1);
                if(next_t < d[nr][nc] && !v[nr][nc]) {
                    d[nr][nc] = next_t;
                    q.push({-next_t, {nr, nc}});
                }
            }
        }
        return d[n - 1][m - 1];
    }
};",1441291525
Andwerp,Andwerp,319,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        //i, j, move parity
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2e9)));
        d[0][0][0] = 0;
        priority_queue<pair<int, pair<int, pair<int, int>>>> q;
        q.push({0, {0, {0, 0}}});
        vector<vector<vector<bool>>> v(n, vector<vector<bool>>(m, vector<bool>(2, false)));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.second.first;
            int c = q.top().second.second.second;
            int p = q.top().second.first;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c][p] || d[r][c][p] != cur_t) {
                continue;
            }
            v[r][c][p] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                int np = p == 1? 0 : 1;
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int inc = p == 0? 1 : 2;
                int next_t = max(mt[nr][nc] + inc, cur_t + inc);
                if(next_t < d[nr][nc][np] && !v[nr][nc][np]) {
                    d[nr][nc][np] = next_t;
                    q.push({-next_t, {np, {nr, nc}}});
                }
            }
        }
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};",1441295219
Andwerp,Andwerp,319,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.size(); i++){
            sum += (num[i] - '0') * (i % 2 == 0? 1 : -1);
        }
        return sum == 0;
    }
};",1441281071
Raymond Jones Jr.,TheRealRaymondJones,320,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    heapq.heappush(heap,(waitTime,nr,nc))
        return -1
            ",1441293065
Raymond Jones Jr.,TheRealRaymondJones,320,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0, False))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c, has_extra_step = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    if has_extra_step:
                        waitTime += 1
                    heapq.heappush(heap,(waitTime,nr,nc, not has_extra_step))
        return -1",1441295429
Raymond Jones Jr.,TheRealRaymondJones,320,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                evens += int(digit)
            else:
                odds += int(digit)
        return evens == odds",1441281456
IvanHugh,ivanc-e,324,3627,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0)]
        
        while heap:  
            current_time, x, y = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + 1  
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny))  
        
        return -1",1441293828
IvanHugh,ivanc-e,324,3628,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0, 0)]
        
        while heap:  
            current_time, x, y, cnt = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + (1 if cnt % 2 == 0 else 2)
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny, cnt+1))  
        
        return -1",1441296218
IvanHugh,ivanc-e,324,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
        ",1441281390
Wilsano,Wilsano,325,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;
        pq.push({0, 0, 0});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441294111
Wilsano,Wilsano,325,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>>> pq;
        pq.push({0, 0, 0, 1});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c, cost] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + cost;
                    int next_cost = (cost == 1) ? 2 : 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc, next_cost});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441296324
Wilsano,Wilsano,325,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int weight = 1;
        for(int i = 0; i < num.length(); ++i){
            sum += (num[i] - '0') * weight;
            weight *= -1;
        }
        return sum == 0;
    }
};",1441281006
Fuad Qarayev,fuad720,326,3627,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m];
        bool vis[n][m];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j] = 2e9;
                vis[i][j] = 0;
            }
        }
        dist[0][0] = 0;
        pq.push({0,{0,0}});
        while(pq.size()) {
            auto [x,y] = pq.top().second;
            pq.pop();
            if(vis[x][y])continue;
            vis[x][y] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny] > max(moveTime[nx][ny]+1, dist[x][y]+1)) {
                        dist[nx][ny] = max(moveTime[nx][ny]+1, dist[x][y]+1);
                        pq.push({-dist[nx][ny], {nx, ny}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441293590
Fuad Qarayev,fuad720,326,3628,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, array<int,3>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m][2];
        bool vis[n][m][2];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j][0] = dist[i][j][1] =  2e9;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }
        dist[0][0][0] = 0;
        pq.push({0,{0,0,0}});
        while(pq.size()) {
            auto [x,y,w] = pq.top().second;
            pq.pop();
            if(vis[x][y][w])continue;
            vis[x][y][w] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny][w^1] > max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w)) {
                        dist[nx][ny][w^1] = max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w);
                        pq.push({-dist[nx][ny][w^1], {nx, ny, w^1}});
                    }
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441296391
Fuad Qarayev,fuad720,326,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0;i<num.size();i+=2) {
            sum+=num[i]-'0';
        }
        for(int i = 1;i<num.size();i+=2) {
            sum-=num[i]-'0';
        }
        return (sum==0);
    }
};",1441282333
Roushan Kumar Singh,r-tron19,327,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0)))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1, moveTime[x][y]+1)
                s.add((T, (x, y)))
        
        return -1",1441294937
Roushan Kumar Singh,r-tron19,327,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0), 0))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord, ext = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1 + ext, moveTime[x][y]+1+ext)
                s.add((T, (x, y), ext ^ 1))
        
        return -1",1441296682
Roushan Kumar Singh,r-tron19,327,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o, e = 0, 0
        for i,el in enumerate(num):
            if i%2:
                o += int(el)
            else:
                e += int(el)
        return o == e",1441281649
cro_poder,cro_poder,328,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX));
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        
        while (!pq.empty()) {
            auto [curr, i, j] = pq.top();
            pq.pop();
            if (i == n - 1 && j == m - 1) return curr;  
            
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = max(curr + 1, 1+moveTime[ni][nj]);
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj);
                    }
                }
            }
        }
        return -1;
    }
};
",1441292077
cro_poder,cro_poder,328,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX)); 
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0, 1); 
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!pq.empty()) {
            auto [curr, i, j, moveCost] = pq.top();
            pq.pop();
            
            if (i == n - 1 && j == m - 1) return curr;  
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = moveCost+max(curr, moveTime[ni][nj]);
                    int nextMoveCost = (moveCost == 1) ? 2 : 1;  
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj, nextMoveCost);
                    }
                }
            }
        }
        
        return -1;   
    }
};
",1441296768
cro_poder,cro_poder,328,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s1 = 0, s2 = 0;
        
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s1 += num[i] - '0';  
            } else {
                s2 += num[i] - '0';   
            }
        }
        
        return s1 == s2;
    }
};
",1441281358
Leonyhenn,leonyhenn,329,3627,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+1 if moveTime[dx][dy] > time else time+1
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy))
        return
                
                    
            
        
        ",1441294685
Leonyhenn,leonyhenn,329,3628,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0,1),(0,0,0,2)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y,step) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+step if moveTime[dx][dy] > time else time+step
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy,2 if step == 1 else 1))
        return
                
                    
            
        
        ",1441296987
Leonyhenn,leonyhenn,329,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281088
Jeel27,Jeel27,330,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0)]
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            current_time, x, y = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    next_time = arrival_time + 1
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny))
        
        return -1",1441289971
Jeel27,Jeel27,330,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0, 0)]  # (time, x, y, step)
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while heap:
            current_time, x, y, step = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    move_cost = 1 if step % 2 == 0 else 2
                    next_time = arrival_time + move_cost
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny, step + 1))

        return -1",1441291277
Jeel27,Jeel27,330,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum",1441281450
Burger Monstah,WRWRW,331,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0)]
        v = {}
        while h:
            t, r, c = heapq.heappop(h)
            # print(t, r, c)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + 1, rr, cc))",1441291563
Burger Monstah,WRWRW,331,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0, 1)]
        v = {}
        while h:
            
            # print(h)
            t, r, c, cost = heapq.heappop(h)
            # print(t, r, c, cost)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + cost, rr, cc, 1 if cost == 2 else 2))",1441297068
Burger Monstah,WRWRW,331,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        
        for i, c in enumerate(num):
            if i % 2 == 0:
                a += int(c)
            else:
                a -= int(c)
        return a == 0
                
        ",1441281726
uwi,uwi,1,3627,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur] + 1, moveTime[nr][nc]+1);
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441290571
uwi,uwi,1,3628,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur], moveTime[nr][nc]) + (r+c)%2+1;
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441292405
uwi,uwi,1,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        long bal = 0;
        for(int i = 0;i < num.length();i++){
            bal = -bal + num.charAt(i) - '0';
        }
        return bal == 0;
    }
}",1441280931
uwi,uwi,1,3637,java,"	class Solution {
		public int countBalancedPermutations(String num) {
			int[] f = new int[10];
			int s = 0;
			for(char c : num.toCharArray()){
				f[c-'0']++;
				s += c-'0';
			}
			if(s % 2 != 0)return 0;
			final int mod = 1000000007;
			s /= 2;

			int n = num.length();
			long[][] dp = new long[n/2+1][s+1];
			int[][] fif = enumFIF(1000, mod);
			dp[0][0] = (long)fif[0][n/2] * fif[0][n-n/2] % mod;
			for(int i = 0;i <= 9;i++){
				long[][] ndp = new long[n/2+1][s+1];
				for(int j = n/2;j >= 0;j--){
					for(int k = s;k >= 0;k--){
						if(dp[j][k] == 0)continue;
						for(int t = 0;t <= f[i] && k+i*t <= s && j+t <= n/2;t++){
							ndp[j+t][k+i*t] += dp[j][k] * fif[1][t] % mod * fif[1][f[i]-t];
							ndp[j+t][k+i*t] %= mod;
						}
					}
				}
				dp = ndp;
			}
			return (int)dp[n/2][s];
		}

		public static int[][] enumFIF(int n, int mod) {
			int[] f = new int[n + 1];
			int[] invf = new int[n + 1];
			f[0] = 1;
			for (int i = 1; i <= n; i++) {
				f[i] = (int) ((long) f[i - 1] * i % mod);
			}
			long a = f[n];
			long b = mod;
			long p = 1, q = 0;
			while (b > 0) {
				long c = a / b;
				long d;
				d = a;
				a = b;
				b = d % b;
				d = p;
				p = q;
				q = d - c * q;
			}
			invf[n] = (int) (p < 0 ? p + mod : p);
			for (int i = n - 1; i >= 0; i--) {
				invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);
			}
			return new int[][]{f, invf};
		}

	}
",1441300564
green_pig,green_pig,2,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291673
green_pig,green_pig,2,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + k + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291255
green_pig,green_pig,2,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280737
green_pig,green_pig,2,3637,python3,"M = 10**9+7
F = [1] * 100
for i in range(1, len(F)):
    F[i] = F[i-1]*i%M
I = [pow(x, -1, M) for x in F]
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        a = [0] * 10
        for n in map(int, num):
            a[n] += 1
        s, t = len(num[::2]), len(num[1::2])
        @cache
        def f(i, d, m, n):
            if m > s or n > t: return 0
            if i == 10:
                return int(d == 0)
            r = 0
            for j in range(a[i]+1):
                k = a[i] - j
                r += I[j] * I[k] * f(i+1, d+i*(j-k), m+j, n+k) % M
            return r % M
        return F[s] * F[t] * f(0, 0, 0, 0) % M
",1441305429
Chris Ho,Chris_ho,3,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        pq = [(0, 0, 0)]
        
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            curr_time, row, col = heapq.heappop(pq)
            
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(moveTime[new_row][new_col] - curr_time, 0)
                    next_time = curr_time + 1 + wait_time
                    
                    if next_time < visited[new_row][new_col]:
                        visited[new_row][new_col] = next_time
                        heapq.heappush(pq, (next_time, new_row, new_col))
        
        return -1",1441299988
Chris Ho,Chris_ho,3,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        min_time = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        min_time[0][0][0] = 0
        heap = [(0, 0, 0, 0)]
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
        while heap:
            current_time, i, j, parity = heapq.heappop(heap)
            
            if current_time > min_time[i][j][parity]:
                continue
            
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < m:
                    move_duration = 1 if parity == 0 else 2
                    start_time = max(current_time, moveTime[ni][nj])
                    arrival_time = start_time + move_duration
                    new_parity = 1 - parity
                    if arrival_time < min_time[ni][nj][new_parity]:
                        min_time[ni][nj][new_parity] = arrival_time
                        heapq.heappush(heap, (arrival_time, ni, nj, new_parity))
                            
        return min(min_time[n - 1][m - 1][0], min_time[n - 1][m - 1][1])
",1441307226
Chris Ho,Chris_ho,3,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = sum(int(x) for x in num[0::2])
        y = sum(int(x) for x in num[1::2])
        return x==y
        
        ",1441280968
Chris Ho,Chris_ho,3,3637,python3,"MOD = 10**9 + 7
from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        cnt_d = [0] * 10
        total_sum = sum(map(int, num))
        for ch in num:
            cnt_d[int(ch)] += 1
        if total_sum % 2 != 0:
            return 0
        S = total_sum // 2
        NE = (N + 1) // 2
        NO = N // 2
        fac = [1] * (N + 1)
        for i in range(1, N + 1):
            fac[i] = fac[i - 1] * i % MOD
        inv_fac = [1] * (N + 1)
        inv_fac[N] = pow(fac[N], MOD - 2, MOD)
        for i in range(N, 0, -1):
            inv_fac[i - 1] = inv_fac[i] * i % MOD
        def C(n, k):
            if k < 0 or k > n:
                return 0
            return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD
        dp = defaultdict(int)
        dp[(0, 0)] = 1
        for d in range(10):
            cnt = cnt_d[d]
            if cnt == 0:
                continue
            dp_new = dp.copy()
            for (s1, c1), ways1 in dp.items():
                max_k = min(cnt, NE - c1)
                for k in range(1, max_k + 1):
                    s = s1 + k * d
                    c = c1 + k
                    ways = ways1 * C(cnt, k) % MOD
                    dp_new[(s, c)] = (dp_new.get((s, c), 0) + ways) % MOD
            dp = dp_new
        total_ways = 0
        for (s, c), ways in dp.items():
            if c == NE and s == S:
                total_ways = (total_ways + ways) % MOD
        total_permutations = total_ways * fac[NE] % MOD * fac[NO] % MOD
        for d in range(10):
            total_permutations = total_permutations * inv_fac[cnt_d[d]] % MOD
        return total_permutations
",1441302114
superfearless,superfearless,4,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        import heapq
        n, m = len(moveTime), len(moveTime[0])
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if t > dist[x][y]:
                continue
            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    t_move = max(t, moveTime[nx][ny])
                    t_neighbor = t_move + 1
                    if dist[nx][ny] > t_neighbor:
                        dist[nx][ny] = t_neighbor
                        heapq.heappush(heap, (t_neighbor, nx, ny))
        return dist[n-1][m-1]        ",1441288089
superfearless,superfearless,4,3628,python3,"class Solution:
	def minTimeToReach(S,moveTime):
		D=moveTime;E,F=len(D),len(D[0]);N=float('inf');A=[[[N]*2 for A in range(F)]for A in range(E)];G=[(0,0,0,0)];A[0][0][0]=0
		while G:
			K,L,M,H=heapq.heappop(G)
			if A[L][M][H]<K:continue
			for(O,P)in[(-1,0),(1,0),(0,-1),(0,1)]:
				B,C=L+O,M+P
				if 0<=B<E and 0<=C<F:
					Q=1 if H==0 else 2;R=max(K,D[B][C]);I=R+Q;J=(H+1)%2
					if I<A[B][C][J]:A[B][C][J]=I;heapq.heappush(G,(I,B,C,J))
		return min(A[E-1][F-1])      ",1441295837
superfearless,superfearless,4,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                even_sum += int(d)
            else:
                odd_sum += int(d)
        return even_sum == odd_sum       ",1441287048
superfearless,superfearless,4,3637,python3,"class Solution:
	def countBalancedPermutations(c,num):
		A=10**9+7;from math import comb;from collections import defaultdict as S;I=[0]*10;J=0;C=len(num);B=C//2;V=C-B
		for W in num:D=int(W);I[D]+=1;J+=D
		if J%2!=0:return 0
		X=J//2;Y=B*9;G=[S(int)for A in range(B+1)];G[0][0]=1;F=[1]*(C+1);K=[1]*(C+1)
		for E in range(1,C+1):F[E]=F[E-1]*E%A
		K[C]=pow(F[C],A-2,A)
		for E in range(C-1,-1,-1):K[E]=K[E+1]*(E+1)%A
		for D in range(10):
			L=I[D]
			if L==0:continue
			M=[S(int)for A in range(B+1)]
			for H in range(B+1):
				for T in G[H]:
					Z=G[H][T]
					for N in range(0,min(L,B-H)+1):
						O=H+N;P=T+N*D
						if O<=B and P<=Y:a=comb(L,N);M[O][P]=(M[O][P]+Z*a)%A
			G=M
		U=G[B].get(X,0)
		if U==0:return 0
		b=F[V]*F[B]%A;Q=1
		for D in range(10):Q=Q*F[I[D]]%A
		R=U*b%A;R=R*pow(Q,A-2,A)%A;return R        ",1441292392
LayCurse,LayCurse,5,3627,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441295459
LayCurse,LayCurse,5,3628,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1 + t;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1 + t;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441294873
LayCurse,LayCurse,5,3636,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  bool isBalanced(string A){
    int i;
    int N = A.size();
    int res = 0;
    for(i=(0);i<(N);i+=(2)){
      res += A[i] - '0';
    }
    for(i=(1);i<(N);i+=(2)){
      res -= A[i] - '0';
    }
    return res == 0;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   bool isBalanced(string A) {
//     int N = A.size(), res = 0;
//     rep(i,0,N,2) res += A[i] - '0';
//     rep(i,1,N,2) res -= A[i] - '0';
//     return res == 0;
//   }
// };
",1441281284
LayCurse,LayCurse,5,3637,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
template<class T> struct Comb{
  int mem_fact;
  T*factri;
  T*ifactri;
  int mem_dfact;
  T*dfactri;
  int mem_pw2;
  int mem_pw3;
  int mem_pw10;
  int mem_rep1;
  T*pw2c;
  T*pw3c;
  T*pw10c;
  T*rep1c;
  int mem_ipw2;
  int mem_ipw3;
  int mem_ipw10;
  T*ipw2c;
  T*ipw3c;
  T*ipw10c;
  Comb(){
    mem_fact = 0;
    mem_dfact = 0;
    mem_pw2 = mem_pw3 = mem_pw10 = mem_rep1 = 0;
    mem_ipw2 = mem_ipw3 = mem_ipw10 = 0;
  }
  inline void expand_fact(int k){
    int i;
    if(k <= mem_fact){
      return;
    }
    chmax(k, 2 * mem_fact);
    if(mem_fact == 0){
      factri = (T*)malloc(k * sizeof(T));
      ifactri = (T*)malloc(k * sizeof(T));
      factri[0] = 1;
      for(i=(1);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(0);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    else{
      factri = (T*)realloc(factri, k * sizeof(T));
      ifactri = (T*)realloc(ifactri, k * sizeof(T));
      for(i=(mem_fact);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(mem_fact);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    mem_fact = k;
  }
  inline T fac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return factri[k];
  }
  inline T ifac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return ifactri[k];
  }
  inline T C(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[b] * ifactri[a-b];
  }
  inline T P(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[a-b];
  }
  inline T H(int a, int b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    if(mem_fact < a+b){
      expand_fact(a+b);
    }
    return C(a+b-1, b);
  }
  inline T Multinomial(int sz, int a[]){
    int i;
    int s = 0;
    T res;
    for(i=(0);i<(sz);i++){
      s += a[i];
    }
    if(mem_fact < s+1){
      expand_fact(s+1);
    }
    res = factri[s];
    for(i=(0);i<(sz);i++){
      res *= ifactri[a[i]];
    }
    return res;
  }
  inline T Multinomial(int a){
    return 1;
  }
  inline T Multinomial(int a, int b){
    if(mem_fact < a+b+1){
      expand_fact(a+b+1);
    }
    return factri[a+b] * ifactri[a] * ifactri[b];
  }
  inline T Multinomial(int a, int b, int c){
    if(mem_fact < a+b+c+1){
      expand_fact(a+b+c+1);
    }
    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];
  }
  inline T Multinomial(int a, int b, int c, int d){
    if(mem_fact < a+b+c+d+1){
      expand_fact(a+b+c+d+1);
    }
    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];
  }
  inline T Catalan(int n){
    if(n < 0){
      return 0;
    }
    if(mem_fact < 2*n+1){
      expand_fact(2*n+1);
    }
    return factri[2*n] * ifactri[n] * ifactri[n+1];
  }
  inline T Catalan(int n, int m, int k){
    if(k <= 0){
      return C(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C(n+m, m) - C(n+m, k-1);
  }
  inline T Catalan_s(long long n, long long m, long long k){
    if(k <= 0){
      return C_s(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C_s(n+m, m) - C_s(n+m, k-1);
  }
  inline T C_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    if(b > a - b){
      b = a - b;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
      res /= i + 1;
    }
    return res;
  }
  inline T P_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
    }
    return res;
  }
  inline T H_s(long long a, long long b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    return C_s(a+b-1, b);
  }
  inline T per_s(long long n, long long k){
    T d;
    int m;
    if(n < 0 || k < 0){
      return 0;
    }
    if(n == k  &&  k == 0){
      return 1;
    }
    if(n == 0 || k == 0){
      return 0;
    }
    if(k==1){
      return 1;
    }
    if(k==2){
      d = n / 2;
      return d;
    }
    if(k==3){
      d = (n-1) / 6;
      m = (n-1) % 6;
      if(m==0){
        return 3 * d * d + d;
      }
      if(m==1){
        return 3 * d * d + 2 * d;
      }
      if(m==2){
        return 3 * d * d + 3 * d + 1;
      }
      if(m==3){
        return 3 * d * d + 4 * d + 1;
      }
      if(m==4){
        return 3 * d * d + 5 * d + 2;
      }
      if(m==5){
        return 3 * d * d + 6 * d + 3;
      }
    }
    assert(0 && ""per_s should be k <= 3"");
    return -1;
  }
  inline void expand_dfact(int k){
    int i;
    if(k <= mem_dfact){
      return;
    }
    chmax(k, 3);
    chmax(k, 2 * mem_dfact);
    if(mem_dfact==0){
      dfactri = (T*)malloc(k * sizeof(T));
      dfactri[0] = dfactri[1] = 1;
      for(i=(2);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    else{
      dfactri = (T*)realloc(dfactri, k * sizeof(T));
      for(i=(mem_dfact);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    mem_dfact = k;
  }
  inline void expand_pw2(int k){
    int i;
    if(k <= mem_pw2){
      return;
    }
    chmax(k, 2 * mem_pw2);
    if(mem_pw2==0){
      pw2c = (T*)malloc(k * sizeof(T));
      pw2c[0] = 1;
      for(i=(1);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    else{
      pw2c = (T*)realloc(pw2c, k * sizeof(T));
      for(i=(mem_pw2);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    mem_pw2 = k;
  }
  inline void expand_ipw2(int k){
    int i;
    if(k <= mem_ipw2){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw2);
    if(mem_ipw2==0){
      ipw2c = (T*)malloc(k * sizeof(T));
      ipw2c[0] = 1;
      ipw2c[1] = ipw2c[0] / 2;
      for(i=(1);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    else{
      ipw2c = (T*)realloc(ipw2c, k * sizeof(T));
      for(i=(mem_ipw2);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    mem_ipw2 = k;
  }
  inline void expand_pw3(int k){
    int i;
    if(k <= mem_pw3){
      return;
    }
    chmax(k, 2 * mem_pw3);
    if(mem_pw3==0){
      pw3c = (T*)malloc(k * sizeof(T));
      pw3c[0] = 1;
      for(i=(1);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    else{
      pw3c = (T*)realloc(pw3c, k * sizeof(T));
      for(i=(mem_pw3);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    mem_pw3 = k;
  }
  inline void expand_ipw3(int k){
    int i;
    if(k <= mem_ipw3){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw3);
    if(mem_ipw3==0){
      ipw3c = (T*)malloc(k * sizeof(T));
      ipw3c[0] = 1;
      ipw3c[1] = ipw3c[0] / 3;
      for(i=(1);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    else{
      ipw3c = (T*)realloc(ipw3c, k * sizeof(T));
      for(i=(mem_ipw3);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    mem_ipw3 = k;
  }
  inline void expand_pw10(int k){
    int i;
    if(k <= mem_pw10){
      return;
    }
    chmax(k, 2 * mem_pw10);
    if(mem_pw10==0){
      pw10c = (T*)malloc(k * sizeof(T));
      pw10c[0] = 1;
      for(i=(1);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    else{
      pw10c = (T*)realloc(pw10c, k * sizeof(T));
      for(i=(mem_pw10);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    mem_pw10 = k;
  }
  inline void expand_ipw10(int k){
    int i;
    if(k <= mem_ipw10){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw10);
    if(mem_ipw10==0){
      ipw10c = (T*)malloc(k * sizeof(T));
      ipw10c[0] = 1;
      ipw10c[1] = ipw10c[0] / 10;
      for(i=(1);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    else{
      ipw10c = (T*)realloc(ipw10c, k * sizeof(T));
      for(i=(mem_ipw10);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    mem_ipw10 = k;
  }
  inline void expand_rep1(int k){
    int i;
    if(k <= mem_rep1){
      return;
    }
    chmax(k, 2 * mem_rep1);
    if(mem_rep1==0){
      rep1c = (T*)malloc(k * sizeof(T));
      rep1c[0] = 0;
      for(i=(1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    else{
      rep1c = (T*)realloc(rep1c, k * sizeof(T));
      for(i=(mem_rep1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    mem_rep1 = k;
  }
  inline T dfac(int k){
    if(k >= 0){
      if(mem_dfact < k+1){
        expand_dfact(k+1);
      }
      return dfactri[k];
    }
    if(k==-1){
      return 1;
    }
    k = - k - 2;
    if(k % 4 == 1){
      return 1 / (-dfac(k));
    }
    return 1 / dfac(k);
  }
  inline T pw2(int k){
    if(k >= 0){
      if(mem_pw2 < k+1){
        expand_pw2(k+1);
      }
      return pw2c[k];
    }
    else{
      k = -k;
      if(mem_ipw2 < k+1){
        expand_ipw2(k+1);
      }
      return ipw2c[k];
    }
  }
  inline T pw3(int k){
    if(k >= 0){
      if(mem_pw3 < k+1){
        expand_pw3(k+1);
      }
      return pw3c[k];
    }
    else{
      k = -k;
      if(mem_ipw3 < k+1){
        expand_ipw3(k+1);
      }
      return ipw3c[k];
    }
  }
  inline T pw10(int k){
    if(k >= 0){
      if(mem_pw10 < k+1){
        expand_pw10(k+1);
      }
      return pw10c[k];
    }
    else{
      k = -k;
      if(mem_ipw10 < k+1){
        expand_ipw10(k+1);
      }
      return ipw10c[k];
    }
  }
  inline T repunit(int k){
    if(mem_rep1 < k+1){
      expand_rep1(k+1);
    }
    return rep1c[k];
  }
}
;
template<> inline Modint Comb<Modint>::C_s(long long a, long long b){
  long long i;
  Modint res;
  Modint d;
  if(b < 0 || b > a){
    return 0;
  }
  if(b > a - b){
    b = a - b;
  }
  res = d = 1;
  for(i=(0);i<(b);i++){
    res *= a - i;
    d *= i + 1;
  }
  return res / d;
}
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
Modint dp[50][2000];
Modint nx[50][2000];
Comb<Modint> comb;
class Solution{
  public:
  int countBalancedPermutations(string A){
    int i, k;
    int N = A.size();
    int x;
    int y;
    int mx;
    int g;
    int c;
    int u;
    int xx;
    int yy;
    x = N / 2;
    y = N - x;
    u = 0;
    g =max_L(x, y)* 9 + 4;
    mx = g * 2 + 1;
    int h[10] = {};
    for(i=(0);i<(N);i++){
      h[A[i]-'0']++;
    }
    for(i=(0);i<(x+1);i++){
      int j;
      for(j=(0);j<(mx);j++){
        dp[i][j] = 0;
      }
    }
    dp[x][g] = 1;
    for(k=(0);k<(10);k++){
      if(h[k]){
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            nx[i][j] = 0;
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            if(dp[i][j]){
              int m;
              for(m=(0);m<(h[k]+1);m++){
                xx = i;
                yy = N - u - i;
                if(xx < m || yy < h[k]-m){
                  continue;
                }
                nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
              }
            }
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            dp[i][j] = nx[i][j];
          }
        }
        u += h[k];
      }
    }
    return dp[0][g];
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// Modint dp[50][2000], nx[50][2000];
// Comb<Modint> comb;
// 
// class Solution {
// public:
//   int countBalancedPermutations(string A) {
//     int N = A.size();
//     int x, y, mx, g, c, u, xx, yy;
//     x = N / 2;
//     y = N - x;
//     u = 0;
//     g = max(x,y) * 9 + 4;
//     mx = g * 2 + 1;
// 
//     int h[10] = {};
//     rep(i,N) h[A[i]-'0']++;
// 
//     rep(i,x+1) rep(j,mx) dp[i][j] = 0;
//     dp[x][g] = 1;
// 
//     rep(k,10) if(h[k]){
//       rep(i,x+1) rep(j,mx) nx[i][j] = 0;
// 
//       rep(i,x+1) rep(j,mx) if(dp[i][j]) rep(m,h[k]+1){
//         xx = i;
//         yy = N - u - i;
//         if(xx < m || yy < h[k]-m) continue;
//         nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
//       }
// 
//       rep(i,x+1) rep(j,mx) dp[i][j] = nx[i][j];
//       u += h[k];
//     }
// 
//     return dp[0][g];
//   }
// };
",1441310437
Yiming Li,lympanda,7,3627,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295795
Yiming Li,lympanda,7,3628,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+z+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295250
Yiming Li,lympanda,7,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1,sum2,i;
        sum1=0;sum2=0;
        for (i=0;i<num.length();i++)
            {
                if (i%2==0) sum1+=num[i]-'0';
                else sum2+=num[i]-'0';
            }
        if (sum1==sum2) return true;
        else return false;
    }
};",1441281135
Yiming Li,lympanda,7,3637,cpp,"#define _int64 long long
#define mo 1000000007

int inited=0;

#define faclim 310000

_int64 fac[faclim];
_int64 invfac[faclim];

_int64 pow1(int x,int y)
{
	int i;
	_int64 ret;
	ret=1;
	for (i=30;i>=0;i--)
	{
		ret=ret*ret%mo;
		if (((1<<i)&y)!=0) ret=ret*x%mo;
	}
	return ret;
}
_int64 inv(int x)
{
	return pow1(x,mo-2);
}
_int64 c(int x,int y)
{
	return fac[x]*invfac[y]%mo*invfac[x-y]%mo;
}
void init()
{
	int i;
	fac[0]=1;
	for (i=1;i<faclim;i++)
		fac[i]=fac[i-1]*i%mo;
	invfac[faclim-1]=inv(fac[faclim-1]);
	for (i=faclim-1;i>0;i--)
		invfac[i-1]=invfac[i]*i%mo;
}

_int64 d[2][2100][50];

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (inited==0)
        {
            init();
            inited=1;
        }
        int cnt[10];
        int i,j,k,o,rem,nn,now,n1,n2;
        memset(cnt,0,sizeof(cnt));
        for (i=0;i<num.length();i++)
            cnt[num[i]-'0']++;
        memset(d[0],0,sizeof(d[0]));
        nn=(num.length()+1)/2;
        d[0][1000][nn]=1;
        rem=num.length();
        now=0;
        for (i=0;i<10;i++) {
            memset(d[1-now],0,sizeof(d[1-now]));
            for (j=0;j<2100;j++)
                for (k=0;k<=nn;k++) {
                    if (d[now][j][k]==0) continue;
                    //cout<<""i,j,k:""<<i<<"" ""<<j<<"" ""<<k<<"" ""<<d[now][j][k]<<endl;
                    n1=k;n2=rem-k;
                    for (o=0;o<=cnt[i];o++) {
                        if (o>n1) continue;
                        if (cnt[i]-o>n2) continue;
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]+=d[now][j][k]*c(n1,o)%mo*c(n2,cnt[i]-o);
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]%=mo;
                    }
                }
            rem-=cnt[i];
            now=1-now;
        }
        return d[now][1000][0];
    }
};",1441310647
Rakesh_Reddy7,Naruto_x,8,3627,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0: return -1
        m = len(moveTime[0])
        if m == 0: return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[float('inf')] * m for i in range(n)]
        t2[0][0] = 0
        pq = [(0, 0, 0)] 
        while pq:
            curt, x, y = heapq.heappop(pq)
            
            if x == n - 1 and y == m - 1:
                return int(curt)
            
            if curt > t2[x][y]:
                continue
            
            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    at = max(curt, moveTime[nx][ny]) + 1

                    if at < t2[nx][ny]:
                        t2[nx][ny] = at
                        heapq.heappush(pq, (at, nx, ny))
        
        return -1
",1441309684
Rakesh_Reddy7,Naruto_x,8,3628,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0:
            return -1
        m = len(moveTime[0])
        if m == 0:
            return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[[float('inf')] * 2 for i in range(m)] for j in range(n)]
        t2[0][0][0] = 0
        pq = [(0, 0, 0, 0)]  

        while pq:
            curt, x, y, z = heapq.heappop(pq)

            if x == n - 1 and y == m - 1:
                return int(curt)

            if curt > t2[x][y][z]:
                continue

            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    m1 = 1 if z == 0 else 2
                    t1 = max(curt, moveTime[nx][ny]) + m1
                    pp = 1 - z

                    if t1 < t2[nx][ny][pp]:
                        t2[nx][ny][pp] = t1
                        heapq.heappush(pq, (t1, nx, ny, pp))

        return -1
",1441310581
Rakesh_Reddy7,Naruto_x,8,3636,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        
        for i in range(len(num)):
            k = int(num[i])
            
            if i % 2 == 0:
                evens += k
            else:
                odds += k
                
        return evens == odds
",1441311289
Rakesh_Reddy7,Naruto_x,8,3637,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

mod = 10**9 + 7

def pow_mod(a, b):
    res = 1
    a %= mod
    while b > 0:
        if b & 1:
            res = res * a % mod
        a = a * a % mod
        b >>= 1
    return res

class Factorials:
    def __init__(self, n):
        self.fact = [1] * (n + 1)
        for i in range(1, n + 1):
            self.fact[i] = self.fact[i - 1] * i % mod
        self.invf = [1] * (n + 1)
        self.invf[n] = pow_mod(self.fact[n], mod - 2)
        for i in range(n - 1, -1, -1):
            self.invf[i] = self.invf[i + 1] * (i + 1) % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        tot = 0
        for ch in num:
            freq[int(ch)] += 1
            tot += int(ch)

        if tot % 2 != 0:
            return 0

        tsum = tot // 2
        k = (n + 1) // 2
        l = n // 2
        factorial = Factorials(n)
        fact = factorial.fact
        invf = factorial.invf

        dp = [[0] * (k + 1) for i in range(tsum + 1)]
        dp[0][0] = 1

        for d in range(10):
            if freq[d] == 0:
                continue
            for s in range(tsum, -1, -1):
                for c in range(k, -1, -1):
                    if dp[s][c] == 0:
                        continue
                    for t in range(1, freq[d] + 1):
                        if s + t * d > tsum or c + t > k:
                            break
                        dp[s + t * d][c + t] = (dp[s + t * d][c + t] + dp[s][c] * ((fact[freq[d]] * invf[t] % mod) * invf[freq[d] - t] % mod)) % mod

        validx = dp[tsum][k]
        if validx == 0:
            return 0

        ifreq = 1
        for d in range(10):
            if freq[d] > 0:
                ifreq = ifreq * invf[freq[d]] % mod

        ans = validx * fact[k] % mod
        ans = ans * fact[l] % mod
        ans = ans * ifreq % mod

        return ans
",1441308446
arignote,arignote,10,3627,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[3]);;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + 1, poll[1] - 1, poll[2] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + 1, poll[1], poll[2] - 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + 1, poll[1], poll[2] + 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + 1, poll[1] + 1, poll[2] });
            }
        }
    }
}",1441307297
arignote,arignote,10,3628,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[] { 0, 0, 0, 1 });;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + poll[3], poll[1] - 1, poll[2], 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + poll[3], poll[1], poll[2] - 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + poll[3], poll[1], poll[2] + 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + poll[3], poll[1] + 1, poll[2], 3 - poll[3] });
            }
        }
    }
}",1441307185
arignote,arignote,10,3636,java,"class Solution {

    public boolean isBalanced(String num) {
        int sum = 0;
        for (int i = 0; i < num.length(); i++) {
            sum += (i % 2 > 0 ? 1 : -1) * (num.charAt(i) - '0');
        }
        return sum == 0;
    }
}",1441307472
arignote,arignote,10,3637,java,"class Solution {

    public int countBalancedPermutations(String num) {
        int count[] = new int[10], sum = 0, f[][] = new int[num.length() + 1][num.length() + 1], dp[][][] = new int[11][num.length() / 2 + 1][361];
        for (char c : num.toCharArray()) {
            count[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 0) {
            for (int i = 0; i <= num.length(); i++) {
                for (int j = f[i][0] = f[i][i] = dp[0][0][0] = 1; j < i; j++) {
                    f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % 1000000007;
                }
            }
            for (int i = 0, s = 0, t = 0; i < 10; s += i * count[i], t += count[i++]) {
                for (int j = 0; j <= t && j <= num.length() / 2; j++) {
                    for (int k = 0; k <= s && k <= sum / 2; k++) {
                        for (int l = 0; dp[i][j][k] > 0 && l <= count[i] && l + j <= num.length() / 2 && l * i + k <= sum / 2; l++) {
                            dp[i + 1][j + l][l * i + k] = (int) ((dp[i + 1][j + l][l * i + k] + (long) dp[i][j][k] * f[num.length() / 2 - j][l] % 1000000007 * f[num.length() - num.length() / 2 - t + j][count[i] - l] % 1000000007) % 1000000007);
                        }
                    }
                }
            }
        }
        return dp[10][num.length() / 2][sum / 2];
    }
}",1441307111
Nguyen Quang Long,mbfibat,11,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 1), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441295120
Nguyen Quang Long,mbfibat,11,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 3 - t), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441294784
Nguyen Quang Long,mbfibat,11,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum_0 = 0, sum_1 = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = (num[i] - '0');
            if (i % 2) sum_1 += d;
            else sum_0 += d;
        }
        return (sum_0 == sum_1);
    }
};",1441280868
Nguyen Quang Long,mbfibat,11,3637,cpp,"const int mod = 1e9 + 7;

int fact[101], re_fact[101];

int qp(int a, int b) {
    if (b == 0) return 1;
    int tmp = qp(a, b / 2);
    if (b % 2 == 0) return 1LL * tmp * tmp % mod;
    return 1LL * a * tmp % mod * tmp % mod;
}

int f[11][81][721];
bool g[11][81][721];

class Solution {
private:
    int tot_cnt = 0;
    int occ[10];
    int tot_sum = 0;
    int sz1 = 0, sz2 = 0;
public:
    int dp(int pos, int cnt1, int sum1) {
        if (pos >= 10) {
            int sum2 = tot_sum - sum1;            
            int cnt2 = tot_cnt - cnt1;
            if (cnt1 == sz1 && cnt2 == sz2 && sum1 == sum2)
                return 1LL * fact[cnt1] * fact[cnt2] % mod;
            return 0;
        }

        if (g[pos][cnt1][sum1])
            return f[pos][cnt1][sum1];

        int ans = 0;
        for (int i = 0; i <= occ[pos]; i++) {
            int val = 1LL * dp(pos + 1, cnt1 + i, sum1 + pos * i) * re_fact[i] % mod * re_fact[occ[pos] - i] % mod;
            ans = (ans + val) % mod;
        }
        g[pos][cnt1][sum1] = true;
        return f[pos][cnt1][sum1] = ans;
    }

    int countBalancedPermutations(string num) {
        fact[0] = 1;
        for (int i = 1; i <= 100; i++)
            fact[i] = 1LL * fact[i - 1] * i % mod;
        re_fact[100] = qp(fact[100], mod - 2);
        for (int i = 100; i >= 1; i--)
            re_fact[i - 1] = 1LL * re_fact[i] * i % mod;

        for (int i = 0; i <= 9; i++) occ[i] = 0;
        
        for (char c : num) {
            occ[c - '0']++;
            tot_sum += (c - '0');
        }
        tot_cnt = num.size();
        sz1 = (tot_cnt + 1) / 2;
        sz2 = tot_cnt /2;
        
        for (int i = 0; i <= 9; i++)
            for (int j = 0; j <= tot_cnt; j++)
                for (int l = 0; l <= tot_sum; l++)
                    g[i][j][l] = false;
        return dp(0, 0, 0);
    }
};",1441314636
BERNARD BRAHIMCHA,BERNARB01,12,3627,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441315189
BERNARD BRAHIMCHA,BERNARB01,12,3628,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p ^ 1;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441314619
BERNARD BRAHIMCHA,BERNARB01,12,3636,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  bool isBalanced(string s) {
    int n = int(s.length());
    int se = 0, so = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        so += int(s[i] - '0');
      } else {
        se += int(s[i] - '0');
      }
    }
    return (se == so);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441307439
BERNARD BRAHIMCHA,BERNARB01,12,3637,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int N = 102;
const int md = int(1e9) + 7;

int iv[N], f1[N], f2[N], p2[N], ip2[N];

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

inline int C(int n, int k) {
  if (k < 0 || n < k) return 0;
  return mul(f1[n], mul(f2[k], f2[n - k]));
}

inline int nck(int n, int k) {
  int r = 1;
  for (int i = 1; i <= k; i++) {
    r = mul(r, mul(n - i + 1, inv(i)));
  }
  return r;
}

void bldmd() {
  iv[1] = 1;
  for (int i = 2; i < N; i++) {
    iv[i] = md - mul(md / i, iv[md % i]);
  }
  f1[0] = f2[0] = p2[0] = ip2[0] = 1;
  for (int i = 1; i < N; i++) {
    f1[i] = mul(f1[i - 1], i);
    f2[i] = mul(f2[i - 1], iv[i]);
    p2[i] = (p2[i - 1] << 1);
    if (p2[i] >= md) p2[i] -= md;
    ip2[i] = mul(ip2[i - 1], iv[2]);
  }
}

int ne, f;
int sum;
int cnt[10];
int dp[10][402][41];

int sol(int i, int j, int k) {
  if (i == 10) {
    if (j != sum || k != ne) {
      return 0;
    }
    return f;
  }
  int& ret = dp[i][j][k];
  if (ret != -1) {
    return ret;
  }
  ret = 0;
  for (int u = 0; u <= cnt[i]; u++) {
    if (j + u * i <= sum && k + u <= ne) {
      add(ret, mul(mul(f2[u], f2[cnt[i] - u]), sol(i + 1, j + u * i, k + u)));
    }
  }
  return ret;
}

class Solution {
 public:
  int countBalancedPermutations(string s) {
    bldmd();
    for (int i = 0; i < 10; i++) {
      cnt[i] = 0;
    }
    int n = int(s.length());
    sum = 0;
    for (char c : s) {
      sum += int(c - '0');
      ++cnt[int(c - '0')];
    }
    if (sum & 1) {
      return 0;
    }
    sum /= 2;
    ne = n / 2;
    int no = n - ne;
    f = mul(f1[ne], f1[no]);
    memset(dp, -1, sizeof dp);
    return sol(0, 0, 0);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441305879
LucasLyu,Lucas595,13,3627,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0) ]
    
        while heap:
            t, x, y = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 1
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny))
    
        return -1
        
        ",1441291623
LucasLyu,Lucas595,13,3628,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0, 1) ]
    
        while heap:
            t, x, y, odd = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 2 - odd
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny, 1 - odd))
    
        return -1
        
        ",1441307713
LucasLyu,Lucas595,13,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        diff = 0
        for i, k in enumerate(num):
            if i & 1:
                diff += int(k)
            else:
                diff -= int(k)
        return not diff
        ",1441282133
LucasLyu,Lucas595,13,3637,python3,"from math import comb
from collections import defaultdict


MOD = int(1e9 + 7)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        counts = [0] * 10
        N = len(num)
        for ch in num:
            counts[int(ch)] += 1

        total_sum = sum(d * counts[d] for d in range(10))
        if total_sum & 1:
            return 0

        target_sum = total_sum // 2
        N_even = (N + 1) // 2
        N_odd = N // 2

        max_N = N + 1
        factorials = [1] * max_N
        inv_factorials = [1] * max_N
        for i in range(1, max_N):
            factorials[i] = factorials[i - 1] * i % MOD

        inv_factorials[-1] = pow(factorials[-1], MOD - 2, MOD)
        for i in range(max_N - 2, -1, -1):
            inv_factorials[i] = inv_factorials[i + 1] * (i + 1) % MOD

        total_counts_fact = 1
        for c in counts:
            total_counts_fact = total_counts_fact * factorials[c] % MOD

        memo = {}

        def dp(d, s, c):
            key = (d, s, c)
            if key in memo:
                return memo[key]
            if s > target_sum or c > N_even:
                return 0
            if d == 10:
                if s == target_sum and c == N_even:
                    return 1
                else:
                    return 0
            res = 0
            for k in range(counts[d] + 1):
                s_new = s + k * d
                c_new = c + k
                if s_new > target_sum or c_new > N_even:
                    break
                ways = comb(counts[d], k)
                res = (res + dp(d + 1, s_new, c_new) * ways) % MOD
            memo[key] = res
            return res

        total_ways = dp(0, 0, 0) * factorials[N_even] % MOD
        total_ways = total_ways * factorials[N_odd] % MOD
        total_ways = total_ways * pow(total_counts_fact, MOD - 2, MOD) % MOD
        return total_ways
        ",1441315468
Ma Lin,Ma_Lin,14,3627,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f;
    int m, n, res, MAX = 2000000000;
    bool done[100][100];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d;
        set<pair<int, pair<int, int>>> S;
        f = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[i][j] = MAX;
                done[i][j] = false;
            }
                
        f[0][0] = 0;
        S.insert({0, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[i][j] || f[i][j] == MAX) continue;
            if (f[i][j] != d) continue;
            done[i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[nx][ny]){
                    v = max(a[nx][ny] + 1, f[i][j] + 1);
                    if (v < f[nx][ny]){
                        f[nx][ny] = v;
                        S.insert({v, {nx, ny}});
                    }
                }
            }
        }

        return f[m - 1][n - 1];
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441293809
Ma Lin,Ma_Lin,14,3628,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f[2];
    int m, n, res, MAX = 2000000000;
    bool done[2][800][800];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d, q;
        set<pair<pair<int, int>, pair<int, int> > > S;
        f[0] = a;
        f[1] = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[0][i][j] = f[1][i][j] = MAX;
                done[0][i][j] = done[1][i][j] = false;
            }
                
        f[0][0][0] = 0;
        S.insert({{0, 0}, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first.first;
            q = S.begin()->first.second;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[q][i][j] || f[q][i][j] == MAX) continue;
            if (f[q][i][j] != d) continue;
            done[q][i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[1 - q][nx][ny]){
                    v = max(a[nx][ny] + (q + 1), f[q][i][j] + (q + 1));
                    if (v < f[1 - q][nx][ny]){
                        f[1 - q][nx][ny] = v;
                        S.insert({{v, 1 - q}, {nx, ny}});
                    }
                }
            }
        }

        return min(f[0][m - 1][n - 1], f[1][m - 1][n - 1]);
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441299307
Ma Lin,Ma_Lin,14,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int x = 0, i;
        for (i = 0; i < s.size(); ++i)
            if (i % 2 == 0) x += s[i] - '0';
            else x -= s[i] - '0';
        
        return x == 0;
    }
};",1441280955
Ma Lin,Ma_Lin,14,3637,cpp,"class Solution {
public:
    int f[2][90][1600];
    int countBalancedPermutations(string s) {
        int mo = 1000000007;
        int C[100][100], n = s.size(), i, j, k, mid, yj, p[2], ge[10], old, now = 0, d, t, nk;
        C[0][0] = 1;
        for (i = 1; i <= n; ++i){
            C[i][0] = C[i][i] = 1;
            for (j = 1; j < i; ++j)
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mo;
        }
        
        p[0] = p[1] = 0;
        for (i = 0; i < 10; ++i) ge[i] = 0;
        for (i = 0; i < n; ++i){
            ++p[i % 2];
            ++ge[s[i] - '0'];
        }
        
        mid = n * 9;
        for (j = 0; j <= p[0]; ++j)
            for (k = 0; k <= mid + mid; ++k)
                f[now][j][k] = 0;
        f[now][0][mid] = 1;
        yj = 0;
        for (i = 0; i < 10; ++i){
            old = now;
            now = 1 - now;
            for (j = 0; j <= p[0]; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    f[now][j][k] = 0;
            for (j = 0; j <= p[0] && j <= yj; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    if (f[old][j][k] > 0){
                        for (d = 0; d <= ge[i]; ++d)
                            if (j + d <= p[0] && yj - j + (ge[i] - d) <= p[1]){
                                t = (1LL * C[p[0] - j][d] * C[p[1] - (yj - j)][ge[i] - d]) % mo;
                                t = (1LL * t * f[old][j][k]) % mo;
                                nk = k + d * i - (ge[i] - d) * i;
                                f[now][j + d][nk] = (f[now][j + d][nk] + t) % mo;
                            }
                    }
            yj += ge[i];
        }
        
        return f[now][p[0]][mid];
    }
};",1441316423
plevande,plevande,15,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time = [[float('inf') for j in range(m)] for i in range(n)]
        true_time[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0])
        while len(H) > 0:
            t, x, y = heapq.heappop(H)
            if true_time[x][y]==t:
                for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                    if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                        t2 = max(t+1, moveTime[x2][y2]+1)
                        if t2 < true_time[x2][y2]:
                            true_time[x2][y2] = t2 
                            heapq.heappush(H, [t2, x2, y2])
        return true_time[n-1][m-1]",1441290714
plevande,plevande,15,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time1 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0, 2])
        while len(H) > 0:
            t, x, y, my_case = heapq.heappop(H)
            if my_case==1:
                if true_time1[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+2, moveTime[x2][y2]+2)
                            if t2 < true_time2[x2][y2]:
                                true_time2[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 2])
            else:
                if true_time2[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+1, moveTime[x2][y2]+1)
                            if t2 < true_time1[x2][y2]:
                                true_time1[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 1])
        return min(true_time1[n-1][m-1], true_time2[n-1][m-1])",1441296393
plevande,plevande,15,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a1 = 0 
        a2 = 0 
        n = len(num)
        for i in range(n):
            if i % 2==0:
                a1+=int(num[i])
            else:
                a2+=int(num[i])
        return a1==a2",1441281094
plevande,plevande,15,3637,python3,"p = 10**9+7
binom = [[1], [1, 1]]
for i in range(81):
    row = binom[-1]
    new_row = [1]
    for j in range(len(row)-1):
        new_row.append((row[j]+row[j+1]) % p)
    new_row.append(1)
    binom.append(new_row)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int, num))
        if s % 2==1:
            return 0
        my_count = [0 for i in range(10)]
        for x in num:
            my_count[int(x)]+=1
        target = s//2
        poss = {(0, n//2, n-n//2): 1}
        for i in range(10):
            new_poss = {}
            c = my_count[i]
            for a, b, b2 in poss:
                for x in range(c+1):
                    if b2-(c-x) >=0 and b-x >= 0 and a+x*i <= target:
                        new_a = a+x*i
                        new_b = b-x
                        new_b2 = b2-(c-x)
                        new_ways = (poss[(a, b, b2)]*binom[b][x]*binom[b2][c-x]) % p
                        if (new_a, new_b, new_b2) not in new_poss:
                            new_poss[(new_a, new_b, new_b2)] = 0
                        new_poss[(new_a, new_b, new_b2)]+=new_ways 
                        new_poss[(new_a, new_b, new_b2)]%=p 
            poss = new_poss
        if (target, 0, 0) not in poss:
            return 0
        return poss[(target, 0, 0)]
        """"""
        how many ways are there
        to get target in n
        """"""",1441310112
BarryBondsOfLC,BarryBondsOfLC,19,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310608
BarryBondsOfLC,BarryBondsOfLC,19,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt == 1 ? 2 : 1});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310295
BarryBondsOfLC,BarryBondsOfLC,19,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for (int i = 0; i < num.size(); ++i) {
            (i % 2 ? o : e) += num[i] - '0';
        }
        return e == o;
    }
};",1441305906
BarryBondsOfLC,BarryBondsOfLC,19,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int MOD = 1e9 + 7;

ll mul(ll a, ll b) { return a * b % MOD; }

ll power(ll base, ll exp = MOD - 2) {
    ll res = 1, y = base;
    while (exp) {
        if (exp & 1)
            res = mul(res, y);
        y = mul(y, y);
        exp >>= 1;
    }
    return res;
}

struct Math {
    vector<ll> fact, inv;

    Math(int n = 1) {
        fact.resize(n + 1);
        inv.resize(n + 1);
        fact[0] = inv[0] = 1;
        for (int i = 1; i <= n; i++)
            fact[i] = mul(fact[i - 1], i);
        inv[n] = power(fact[n]);
        for (int i = n; i > 1; i--)
            inv[i - 1] = mul(inv[i], i);
    }

    ll comb(int n, int k) {
        if (n < k)
            return 0;
        return mul(mul(fact[n], inv[k]), inv[n - k]);
    }

    ll perm(int n, int k) {
        if (n < k)
            return 0;
        return mul(fact[n], inv[n - k]);
    }

    ll multi(vector<int> v) {
        ll res = fact[accumulate(v.begin(), v.end(), 0)];
        for (int i : v)
            res = mul(res, inv[i]);
        return res;
    }

} math(100005);

class Solution {
public:
    int countBalancedPermutations(string S) {
        int n = S.size();
        vector<int> fm(10);
        int total = 0;
        for (auto c : S) {
            ++fm[c - '0'];
            total += c - '0';
        }
        if (total % 2)
            return 0;
        int T = total / 2;
        int E = (n + 1) / 2, O = n - E;
        vector p_dp(T + 1, vector(E + 1, 0LL));
        p_dp[0][0] = 1;
        for (int d = 0; d < 10; ++d) {
            vector c_dp(T + 1, vector(E + 1, 0LL));
            for (int s = 0; s <= T; ++s) {
                for (int c = 0; c <= E; ++c) {
                    if (p_dp[s][c] == 0)
                        continue;
                    for (int k = 0; k <= fm[d] && k <= E - c && s + k * d <= T;  ++k) {
                        c_dp[s + k * d][c + k] += p_dp[s][c] * math.inv[k] % MOD * math.inv[fm[d] - k] % MOD % MOD;
                        c_dp[s + k * d][c + k] %= MOD;
                    }
                }
            }
            p_dp = move(c_dp);
        }
        return p_dp[T][E] * math.fact[E] % MOD * math.fact[O] % MOD;
    }
};",1441305590
dirigibility,dirigibility,20,3627,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,0,0)]
        visited = set()
        while True:
            t,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (i0,j0) in visited:
                continue
            visited.add((i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+1,i,j))",1441294813
dirigibility,dirigibility,20,3628,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,1,0,0)]
        visited = set()
        while True:
            t,dt,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (dt,i0,j0) in visited:
                continue
            visited.add((dt,i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (3-dt,i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+dt,3-dt,i,j))",1441296704
dirigibility,dirigibility,20,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])",1441281104
dirigibility,dirigibility,20,3637,python3,"mod = 10**9+7
@cache
def fac(n):
    return (n*fac(n-1))%mod if n else 1
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if (s := sum(map(int,num)))%2:
            return 0
        c = Counter(map(int,num))
        @cache
        def f(d,need,need_sum):
            if need < 0 or need_sum < 0:
                return 0
            if d == 10:
                return int(need == need_sum == 0)
            return sum(pow(fac(take)*fac(c[d]-take),-1,mod)*f(d+1,need-take,need_sum-d*take) for take in range(0,c[d]+1))%mod
        try:
            l = len(num)
            return (f(0,l//2,s//2)*fac(l//2)*fac(l-l//2))%mod
        finally:
            f.cache_clear()",1441317496
physics0523,physics0523,21,3627,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int clk=max(od.first,moveTime[nx][ny])+1;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441292885
physics0523,physics0523,21,3628,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int dlt;
                if((x+y)%2==0){dlt=1;}
                else{dlt=2;}
                int clk=max(od.first,moveTime[nx][ny])+dlt;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441295080
physics0523,physics0523,21,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int h=0;
        for(int i=0;i<num.size();i++){
            if(i%2){h+=(num[i]-'0');}
            else{h-=(num[i]-'0');}
        }
        return (h==0);
    }
};",1441281668
physics0523,physics0523,21,3637,cpp,"#define mod 1000000007

int md(int x){
    if(x>=mod){return x-mod;}
    return x;
}

int mul(long long x,long long y){
    return (x*y)%mod;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<vector<int>> nCr(105,vector<int>(105,0));
        nCr[0][0]=1;
        for(int i=1;i<105;i++){
            for(int j=0;j<=i;j++){
                if(j>0){nCr[i][j]+=nCr[i-1][j-1];}
                nCr[i][j]=md(nCr[i][j]);
                if(j<i){nCr[i][j]+=nCr[i-1][j];}
                nCr[i][j]=md(nCr[i][j]);
            }
        }
        // for(int i=0;i<5;i++){
        //     for(int j=0;j<5;j++){cout << nCr[i][j] << "" "";}
        //     cout << ""\n"";
        // }
        
        vector<int> bk(10,0);
        for(auto &nx : num){
            bk[nx-'0']++;
        }
        int rem=num.size();
        int ofs=400;
        int n=num.size();
        int x=(n+1)/2;
        int y=n/2;
        vector<vector<vector<int>>> dp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
        dp[x][y][ofs]=1;
        for(int tr=0;tr<10;tr++){
            vector<vector<vector<int>>> ndp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
            for(int cx=0;cx<=x;cx++){
                int cy=rem-cx;
                if(!(0<=cy && cy<=y)){continue;}
                for(int i=0;i<800;i++){
                    if(dp[cx][cy][i]==0){continue;}
                    for(int sx=0;sx<=bk[tr];sx++){
                        int sy=bk[tr]-sx;
                        int nx=cx-sx;
                        int ny=cy-sy;
                        if(!(0<=nx && nx<=x)){continue;}
                        if(!(0<=ny && ny<=y)){continue;}
                        int dlt=tr*(sx-sy);
                        int mv=dp[cx][cy][i];
                        // cout << x << "" "" << y << "" "" << i << "" -> "" << nx << "" "" << ny << "" "" << i+dlt << ""\n"";
                        // cout << mv << "" "" << nCr[cx][sx] << "" "" << nCr[cy][sy] << ""\n"";
                        mv=mul(mv,nCr[cx][sx]);
                        mv=mul(mv,nCr[cy][sy]);
                        ndp[nx][ny][i+dlt]=md(ndp[nx][ny][i+dlt]+mv);
                    }
                }
            }
            rem-=bk[tr];
            dp=ndp;
        }
        
        return dp[0][0][ofs]%mod;
    }
};",1441310947
ssk4988,ssk4988,22,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, i, j = heappop(heap)
            # print(i, j, t)
            if i == n-1 and j == m-1: return t
            if (i, j) in seen: continue
            seen.add((i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, (1 + max(moveTime[i1][j1], t), i1, j1))",1441295578
ssk4988,ssk4988,22,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, p, i, j = heappop(heap)
            # print(i, j, p, t)
            if i == n-1 and j == m-1: return t
            if (p, i, j) in seen: continue
            seen.add((p, i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, ((2 if p == 1 else 1) + max(moveTime[i1][j1], t), 1-p, i1, j1))",1441298603
ssk4988,ssk4988,22,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(v) for i,v in enumerate(num) if i % 2 == 0]) == sum([int(v) for i,v in enumerate(num) if i % 2 == 1])",1441281276
ssk4988,ssk4988,22,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        freq = [0] * 10
        for d in num:
            freq[int(d)] += 1
        mod = 1000000007
        @cache
        def combmod(n, k):
            return comb(n, k) % mod
        @cache
        def dp(dig, lefteven, leftodd, evmodd):
            if dig == 10:
                return 1 if evmodd == 0 and lefteven == 0 and leftodd == 0 else 0
            ans = 0
            for toeven in range(0, 1 + min(lefteven, freq[dig])):
                toodd = freq[dig] - toeven
                if toodd > leftodd: continue
                res = dp(dig+1, lefteven - toeven, leftodd - toodd, evmodd + (toeven - toodd) * dig)
                ways = (combmod(lefteven, toeven) * combmod(leftodd, toodd)) % mod
                ans = (ans + res * ways) % mod
            return ans
        n = len(num)
        return dp(0, n // 2, n - n // 2, 0)",1441311262
Balakrishnan Varadarajan,balakrishnan_v,23,3627,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> min_times(n,vector<int>(m,-1));
        vector<vector<bool>> done(n,vector<bool>(m,false));
        set<vector<int>> Q;
        Q.insert({0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j]) continue;
            done[i][j]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj]!=-1 && min_times[ni][nj]<=nt) continue;
                if (min_times[ni][nj]!=-1) {
                    Q.erase({min_times[ni][nj],ni,nj});
                }
                min_times[ni][nj]=nt;
                Q.insert({nt,ni,nj});
            }
        }
        return ans;
    }
};",1441317168
Balakrishnan Varadarajan,balakrishnan_v,23,3628,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<vector<int>>> min_times(n,vector<vector<int>>(m,vector<int>(2,-1)));
        vector<vector<vector<bool>>> done(n,vector<vector<bool>>(m,vector<bool>(2,false)));
        set<vector<int>> Q;
        Q.insert({0,0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            int p = it->at(3);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j][p]) continue;
            done[i][j][p]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+p+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj][1-p]!=-1 && min_times[ni][nj][1-p]<=nt) continue;
                if (min_times[ni][nj][1-p]!=-1) {
                    Q.erase({min_times[ni][nj][1-p],ni,nj,1-p});
                }
                min_times[ni][nj][1-p]=nt;
                Q.insert({nt,ni,nj,1-p});
            }
        }
        return ans;
    }
};",1441314130
Balakrishnan Varadarajan,balakrishnan_v,23,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0=0;
        int s1=0;
        int n=num.size();
        for(int i=0;i<n;i++) {
            int d=num[i]-'0';
            if (i%2==0) s0+=d;
            else s1+=d;
        }
        return s0==s1;
    }
};",1441318653
Balakrishnan Varadarajan,balakrishnan_v,23,3637,cpp,"#define MODD 1000000007
#define NUM_DIGS 10
#define MAXN 80
#define ll long long
class Solution {
public:
    
    ll fact[MAXN+2];
    ll factinv[MAXN+2];
    
    int dp[NUM_DIGS+1][MAXN+2][MAXN*9];
    
    int Solve(const vector<int>& counts, int d, int num_even_left, int sum_even_left) {
        if (d==NUM_DIGS) {
            return num_even_left==0 && sum_even_left==0;
        }
        
        if (dp[d][num_even_left][sum_even_left]!=-1) return dp[d][num_even_left][sum_even_left];
        
        ll ans = 0;
        for(int x=0;x<=min(num_even_left,counts[d]);x++) {
            if (sum_even_left-x*d<0) break;
            ans += Solve(counts, d+1, num_even_left-x,sum_even_left-x*d) * factinv[x]%MODD*factinv[counts[d]-x]%MODD;
            ans %= MODD;
        }
        return dp[d][num_even_left][sum_even_left]=ans;
    }
    
    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }

    

    int countBalancedPermutations(string num) {
        
        
        int n=num.size();
        fact[0]=factinv[0]=1;
        for(int i=1;i<=n;i++) {
            fact[i]=fact[i-1]*i%MODD;
            factinv[i]=modpow(fact[i],MODD-2);
        }
        vector<int> counts(10,0);
        int s=0;
        for(char c : num) {
            counts[c-'0']++;
            s += c-'0';
        }
        if (s&1) return 0;
        
        int num_odd_pos=0;
        int num_even_pos=0;
        for(int i=0;i<n;i++) {
            if (i%2) num_odd_pos++;
            else num_even_pos++;
        }
        
        for(int d=0;d<=NUM_DIGS;d++) {
            for(int num_even_left=0;num_even_left<=num_even_pos;num_even_left++) {
                for(int sum_even_left=0;sum_even_left<=s/2;sum_even_left++) {
                    dp[d][num_even_left][sum_even_left]=-1;
                }
            }
        }
        
        ll ans = Solve(counts, 0, num_even_pos, s/2);
        ans = ans*fact[num_odd_pos]%MODD*fact[num_even_pos]%MODD;
        
        // split each digit
        
        return ans;
        
    }
};",1441298327
leetgoat_dot_dev,leetgoat_dot_dev,26,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c to min time
        heap = [(0, 0, 0)] # time, r, c
        while heap:
            time, r, c = heapq.heappop(heap)
            if minDists[(r, c)] <= time:
                continue
            minDists[(r, c)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newTime = max(time + 1, moveTime[newR][newC] + 1)
                if newTime >= minDists[(newR, newC)]:
                    continue
                heapq.heappush(heap, (newTime, newR, newC))
        return minDists[(len(moveTime) - 1, len(moveTime[0]) - 1)]
            ",1441293052
leetgoat_dot_dev,leetgoat_dot_dev,26,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c, parity to min time
        heap = [(0, 0, 0, 0)] # time, r, c, parity
        while heap:
            time, r, c, parity = heapq.heappop(heap)
            if minDists[(r, c, parity)] <= time:
                continue
            minDists[(r, c, parity)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newDelta = 1 if parity == 0 else 2
                newTime = max(time + newDelta, moveTime[newR][newC] + newDelta)
                # if newTime >= minDists[(newR, newC)]:
                #     continue
                heapq.heappush(heap, (newTime, newR, newC, parity^1))
        return min(
            minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 0)],
             minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 1)],
        )
            ",1441295559
leetgoat_dot_dev,leetgoat_dot_dev,26,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i in range(len(num)):
            if i % 2 == 0:
                evens += int(num[i])
            else:
                odds += int(num[i])
        return evens == odds",1441280912
leetgoat_dot_dev,leetgoat_dot_dev,26,3637,python3,"# template by: https://github.com/agrawalishaan/leetcode

# n in the constructor is basically the biggest number we will operate on. So for instance finding n! % MOD. But also things like interleaving two sequences of length 500 and length 700 would require n=1200. To be safe, can always just put a big number like 1e5.
class ModCalc:
    def __init__(self, n, primeMod):
        self.n = n
        self.mod = primeMod # If this is not prime, anything using modInv may break (fermat's little theorem)
        # O(n) time to build a factorial mod array
        self.factorialsWithMod = self._buildFactorialsWithMod()
        # O(n) time to build an inverse factorial mod array
        self.inverseFactorialsWithMod = self._buildInverseFactorialsWithMod()

    # ********** STUFF WITH FACTORIALS **********

    # O(n) time to build a factorial mod array
    def _buildFactorialsWithMod(self):
        factorialsWithMod = [1] # 0 factorial is 1
        for factorial in range(1, self.n + 1):
            factorialsWithMod.append(factorialsWithMod[-1] * factorial % self.mod)
        return factorialsWithMod

    # O(n) time to build an inverse factorial mod array
    def _buildInverseFactorialsWithMod(self):
        inverseFactorialsWithMod = [1] * (self.n + 1)
        inverseFactorialsWithMod[self.n] = self.modInv(self.factorialsWithMod[self.n])
        for i in range(self.n - 1, 0, -1):
            inverseFactorialsWithMod[i] = inverseFactorialsWithMod[i + 1] * (i + 1) % self.mod
        return inverseFactorialsWithMod

    # Gets (x! % MOD)
    # O(1) time
    def getFactorialWithMod(self, factorial):
        return self.factorialsWithMod[factorial]

    # Gets (1/x! % MOD)
    # O(1) time
    def getInverseFactorialWithMod(self, inverseFactorial):
        return self.inverseFactorialsWithMod[inverseFactorial]

    # Given two sequences of length X and Y, such as ""123"" and ""4567"", find the # of ways to interleave them.  Note we don't care about the actual items in each sequence, we just care about the # of ways we can interleave the two. We don't even get the actual sequences themselves, just their lengths.
    # O(1) time
    def interleaveTwoSequencesWithMod(self, length1, length2):
        # Interleaving a sequence of length 3 and 4 would be like 7!/(3!4!), which is 7! * (1/3!) * (1/4!)
        combinedLength = length1 + length2
        if combinedLength >= len(self.factorialsWithMod):
            raise ValueError(f""To interleave {length1} and {length2} items, we need at least {combinedLength + 1} items in the factorial array."")
        numerator = self.getFactorialWithMod(combinedLength)
        denominator1 = self.getInverseFactorialWithMod(length1)
        denominator2 = self.getInverseFactorialWithMod(length2)
        return self.modMultiply(numerator, denominator1, denominator2)


    # Calculates the # of ways to select k items from n unique items. Order does not matter.
    # Formula for C(n, k) = n! / (k!(n-k)!)
    # Denominator is 1/k! * 1/(n-k)!
    # O(1) time
    def nChooseKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator1 = self.getInverseFactorialWithMod(k)
        denominator2 = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator1, denominator2)

    # Calculates the # of ways to select k items from n unique items. Order matters.
    # Formula for P(n, k) = n! / (n-k)!
    # Denominator is 1/(n-k)!
    # O(1) time
    def nPermuteKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator)

    # Calculate the # of ways to distribute n identical items into k distinct buckets (relates to stars and bars)
    # Formula for allowing empty buckets is C(n+k-1, k-1), which is: (n+k-1)! * 1/(n-1)! * 1/k!
    # Formula for NOT allowing empty buckets is C(n-1, k-1), which is: (n-1)! * 1/(n-k)! * 1/k!
    # O(1) time
    def waysToPutIdenticalItemsIntoDistinctBucketsWithMod(self, items, buckets, allowEmptyBuckets=True):
        if allowEmptyBuckets:
            return self.nChooseKWithMod(items + buckets - 1, buckets - 1)
        return self.nChooseKWithMod(items - 1, buckets - 1)

    # Putting n distinct items into k distinct buckets is just k options for the first item, k for the second, etc, so k^n. This is if we allow empty buckets. If we don't allow empty buckets, we need Stirling numbers of the second kind.
    # O(log items) time due to modPow, but modPow can be cached
    def waysToPutDistinctItemsIntoDistinctBucketsAllowingEmptyWithMod(self, items, buckets):
        return self.modPow(buckets, items)

    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        # need to figure out how to do this in O(1) if it is possible lol
        pass

    # ********** NO FACTORIALS NEEDED **********

    # Multiples k numbers together
    # O(k) time
    def modMultiply(self, *args):
        result = 1
        for num in args:
            result = (result * num) % self.mod
        return result

    # Calculates base^exponent % MOD
    # Can add caching if we are using the same base a lot. But if we are using one instance of the ModCalc class across all test cases, maybe that would MLE? I think no cache by default is better, since it is very fast already.
    # O(log exponent) time (even without caching)
    # @cache # uncomment to cache
    def modPow(self, base, exponent):
        return pow(base, exponent, self.mod)

    # Gets 1/x % MOD
    # Could cache this, if we are calling the same range of numbers a lot. If this class is created once across all test cases, could maybe MLE? Also num needs to be coprime to MOD.
    # O(log MOD) time
    # @cache # uncomment to cache
    def modInv(self, num):
        return self.modPow(num, self.mod - 2)


class MoreAdvancedStirlingStuff:
    def __init__(self, maxPossibleDistinctItemCount, maxPossibleBucketCount, mod):
        self.maxPossibleDistinctItemCount = maxPossibleDistinctItemCount
        self.maxPossibleBucketCount = maxPossibleBucketCount
        self.mod = mod

        # # Build a basic modCalc so we can get factorial mods
        self.modCalc = ModCalc(maxPossibleBucketCount, mod)

        # O(maxPossibleDistinctItemCount * maxPossibleBucketCount) build time
        self.stirling2Dp = self._buildStirling2Dp()

    def _buildStirling2Dp(self):
        dp = [[0] * (self.maxPossibleBucketCount + 1) for _ in range(self.maxPossibleDistinctItemCount + 1)]
        dp[0][0] = 1
        for i in range(1, self.maxPossibleDistinctItemCount + 1):
            for j in range(1, self.maxPossibleBucketCount + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % self.mod
        return dp

    # Calculate the # of ways to distribute n distinct items into k identical non-empty buckets. For instance with items 'A' and 'B' and 2 buckets, there's only one way, since the buckets are identical.
    # This is stirling2 numbers.
    # O(1) time
    def waysToPutDistinctItemsIntoIdenticalNonemptyBucketsWithMod(self, items, buckets):
        return self.stirling2Dp[items][buckets]

    # Calculate the # of ways to distribute n distinct items into k distinct non-empty buckets.
    # O(1) time
    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        waysAssumingIdenticalBuckets = self.stirling2Dp[items][buckets]
        bucketOrderings = self.modCalc.getFactorialWithMod(buckets)
        return self.modCalc.modMultiply(waysAssumingIdenticalBuckets, bucketOrderings)

    
calc = ModCalc(10000, 10**9 + 7)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        c = Counter(int(l) for l in num)
        
        evens = len(num) // 2
        odds = len(num) - evens
        
        M = 10**9 + 7
        
        @cache
        def dp(digit, evenSurplus, evensUsed, oddsUsed):
            if digit == 10:
                return 1 if not evenSurplus else 0
            
            resHere = 0
            for distributeToOdds in range(c[digit] + 1):
                newOdds = oddsUsed + distributeToOdds
                if newOdds > odds:
                    break
                distributeToEvens = c[digit] - distributeToOdds
                newEvens = evensUsed + distributeToEvens
                if newEvens > evens:
                    continue
                oddGain = distributeToOdds * digit
                evenGain = distributeToEvens * digit
                evenNet = evenGain - oddGain
                
                oddSpotsLeft = odds - oddsUsed
                evenSpotsLeft = evens - evensUsed
                
                waysToDistributeOdds = calc.nChooseKWithMod(oddSpotsLeft, distributeToOdds)
                waysToDistEvens = calc.nChooseKWithMod(evenSpotsLeft, distributeToEvens)
                resHere += calc.modMultiply(dp(digit + 1, evenSurplus + evenNet, newEvens, newOdds), waysToDistributeOdds, waysToDistEvens)
            return resHere % M
        
        a = dp(0,0,0,0)
        dp.cache_clear()
        return a
            
            
            ",1441306558
Chinnu,chinnu11,27,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&t){
        int n=t.size(),m=t[0].size();
        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};
        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));
        dist[0][0]=0;
        
        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<>>q;
        q.emplace(0,0,0);
        
        while(!q.empty()){
            auto[ct,i,j]=q.top();q.pop();
            if(i==n-1&&j==m-1)return ct;
            if(ct>dist[i][j])continue;
            
            for(auto[di,dj]:d){
                int ni=i+di,nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m){
                    int ns=max(ct,t[ni][nj]);
                    int at=ns+1;
                    if(at<dist[ni][nj]){
                        dist[ni][nj]=at;
                        q.emplace(at,ni,nj);
                    }
                }
            }
        }
        return -1;
    }
};",1441287083
Chinnu,chinnu11,27,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n=t.size(), m=t[0].size();
        vector<pair<int,int>> d={{-1,0},{1,0},{0,-1},{0,1}};
        const int inf=INT_MAX;
        vector<int> dist(n*m*2,inf);
        dist[0]=0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;
        q.emplace(0,0);
        
        while(!q.empty()) {
            auto [c,s]=q.top(); q.pop();
            int p=s%2, pos=s/2, i=pos/m, j=pos%m;
            if(i==n-1&&j==m-1) return c;
            if(c>dist[s]) continue;
            
            for(auto &[di,dj]:d) {
                int ni=i+di, nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m) {
                    int st=max(c,t[ni][nj]), dur=p==0?1:2, nt=st+dur, np=1-p;
                    int ns=(ni*m+nj)*2+np;
                    if(nt<dist[ns]) {
                        dist[ns]=nt;
                        q.emplace(nt,ns);
                    }
                }
            }
        }
        return -1;
    }
};",1441290452
Chinnu,chinnu11,27,3636,cpp,"class Solution{
public:
    bool isBalanced(string n){
        int e=0,o=0;
        for(int i=0;i<n.size();++i){
            int d=n[i]-'0';
            if(i%2==0)e+=d;
            else o+=d;
        }
        return e==o;
    }
};
",1441281159
Chinnu,chinnu11,27,3637,cpp,"typedef long long ll;
const int M=1'000'000'007;

ll pmod(ll x,ll y,ll m){
    ll r=1;
    x%=m;
    while(y>0){
        if(y&1)r=r*x%m;
        x=x*x%m;
        y>>=1;
    }
    return r;
}

ll inv(ll x,ll m){
    return pmod(x,m-2,m);
}

int cBalPerms(string num){
    int n=num.size();
    vector<ll>f(n+1,1),invf(n+1,1);
    for(int i=1;i<=n;i++)f[i]=f[i-1]*i%M;
    invf[n]=inv(f[n],M);
    for(int i=n-1;i>=0;i--)invf[i]=invf[i+1]*(i+1)%M;

    int fr[10]={0};
    ll ts=0;
    for(char c:num)fr[c-'0']++,ts+=(c-'0');
    if(ts%2!=0)return 0;
    ll tgt=ts/2;
    int k=(n+1)/2,m=n-k;

    vector<vector<ll>>dp(tgt+1,vector<ll>(k+1,0));
    dp[0][0]=1;

    for(int d=0;d<=9;d++){
        if(fr[d]==0)continue;
        vector<vector<ll>>d2(tgt+1,vector<ll>(k+1,0));
        for(int s=0;s<=tgt;s++){
            for(int c=0;c<=k;c++){
                if(dp[s][c]==0)continue;
                for(int a=0;a<=fr[d]&&a+c<=k;a++){
                    if(s+d*a>tgt)break;
                    ll comb=f[fr[d]]*invf[a]%M*invf[fr[d]-a]%M;
                    d2[s+d*a][c+a]=(d2[s+d*a][c+a]+dp[s][c]*comb)%M;
                }
            }
        }
        dp=d2;
    }

    ll assign=dp[tgt][k];
    if(assign==0)return 0;

    ll prod_f=1;
    for(int d=0;d<=9;d++)prod_f=prod_f*f[fr[d]]%M;

    ll fk=f[k],fm=f[m],invp=inv(prod_f,M);
    ll tot=assign*fk%M*fm%M*invp%M;

    return (int)tot;
}

class Solution{
public:
    int countBalancedPermutations(string num){
        return cBalPerms(num);
    }
};
",1441313189
Larry,LarryNY,28,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + 1:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + 1
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441290449
Larry,LarryNY,28,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                p = 2 - ((nx + ny) % 2)
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + p:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + p
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441293459
Larry,LarryNY,28,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        N = len(num)
        
        a = [0] * 2
        for i in range(N):
            a[i % 2] += int(num[i])
            
        return a[0] == a[1]",1441280862
Larry,LarryNY,28,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        arr = [int(x) for x in num]
        N = len(arr)
        f = [0] * 10
        for x in arr:
            f[x] += 1

        fact = [1]
        ifact = [pow(1, -1, MOD)]
        for i in range(1, N + 1):
            fact.append((fact[-1] * i) % MOD)
            ifact.append(pow(fact[-1], -1, MOD))

        numer = 1
        if N % 2 == 0:
            numer = (fact[(N // 2)] * fact[(N // 2)]) % MOD
        else:
            numer = (fact[((N + 1) // 2)] * fact[(N // 2)]) % MOD
            
        @cache
        def go(index, delta_count, delta_sum):
            if index == len(f):
                if delta_sum != 0:
                    return 0

                if N % 2 == 0:
                    if delta_count != 0:
                        return 0
                    return 1
                else:
                    if delta_count == 1:
                        return 1
                    return 0
        
            total = 0
            for i in range(f[index] + 1):
                left = i
                right = f[index] - i
                total += go(index + 1, delta_count + (left - right), delta_sum + (left - right) * index) * ifact[left] * ifact[right]
                total %= MOD
            return total % MOD
        
        return (go(0, 0, 0) * numer) % MOD",1441320693
Nguyn Tho,nguyenquocthao00,30,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + 1, i2,j2))
            
        ",1441292016
Nguyn Tho,nguyenquocthao00,30,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            added = 1 if (i+j)%2==0 else 2
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + added, i2,j2))
            
        
        ",1441294941
Nguyn Tho,nguyenquocthao00,30,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x,y = 0,0
        for i,ch in enumerate(num):
            if i%2==0: x+=int(ch)
            else: y+=int(ch)
        return x==y
        ",1441281098
Nguyn Tho,nguyenquocthao00,30,3637,python3,"MOD = 10**9 + 7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        count=[0]*10
        for ch in num: count[int(ch)]+=1
        s= sum(i*v for i,v in enumerate(count))
        if s%2==1: return 0
        # target=s//2
        @lru_cache(None)
        def dp(v,n,t):
            if v<0: return 0 if (n!=0 or t!=0) else 1
            if count[v]==0: return dp(v-1,n,t)
            n2,s2 = len(num)-n, s-t
            for v2 in range(9, v,-1):
                n2-=count[v2]
                s2-=count[v2]*v2
            if n<0 or t<0 or n2<0 or s2<0: return 0
            res=0
            for i in range(count[v]+1):
                res += math.comb(n, i) * math.comb(n2, count[v]-i) * dp(v-1, n-i, t-i*v)
            return res%MOD
        return dp(9, len(num)//2, s//2)
            
        ",1441321719
hxu10,hxu10,31,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                newt = max(t, moveTime[newi][newj]) + 1
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]
            
        
        
        ",1441293045
hxu10,hxu10,31,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                    
                
                newt = max(t, moveTime[newi][newj]) + 2 - (i+j+1) % 2 
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]",1441298013
hxu10,hxu10,31,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s1 = num[::2]
        s2 = num[1::2]
        
        tot1 = 0
        for c in s1:
            tot1 += int(c)
            
        tot2 = 0
        for c in s2:
            tot2 += int(c)
            
        return tot1==tot2
    ",1441281054
hxu10,hxu10,31,3637,python,"

M = 10**9 + 7

def fastfrac(a,b):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M


factor = [1]
invfactor = [1]

for _ in range(100):
    factor.append(factor[-1]*len(factor)%M)
    invfactor.append(fastfrac(1,factor[-1])%M)
    

                     
    
    
    
    
    
    

class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        
        
        fre = [0]*10
        
        s = 0
        
        for c in num:
            fre[int(c)] += 1
            s += int(c) 
            
            
        if s%2==1:
            return 0
        
        

        
        
        
            
            
            
        target = len(num) // 2
        
        tsum = s // 2
        
        
    
        
        
        dic = {}
        
        def getnext(index,totc,totnum):
            
            
            if index==10:
                if totc==target and totnum==tsum:
                    return 1
                return 0
            
            if totc > target or totnum > tsum:
                return 0
            
            
            #print(index,totc,totnum)
            
            if (index,totc,totnum) in dic:  
                return dic[(index,totc,totnum)]
            
            
            res = 0
            for d in range(fre[index]+1):
                xi = invfactor[d] * invfactor[fre[index]-d] 
                res += getnext(index+1, totc+d, totnum+d*index) * xi % M
                res %= M
                
            dic[(index,totc,totnum)] = res
            return res
        
        ans = getnext(0,0,0) * factor[target] * factor[len(num)-target] % M
        
        
        

        
        return ans 
                
            
             
            
            
        
                
            
            
            ",1441322214
kzyKT,kzyKT,32,3627,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<ll,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m];
    rep(i,n)rep(j,m) d[i][j]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(0,P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F;
      if(d[x][y]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+1;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1);
          if(d[xx][yy]>cc) {
            d[xx][yy]=cc;
            que.push(PP(cc,P(xx,yy)));
          }
        }
      }
    }
    return d[n-1][m-1];
  }
};
",1441291418
kzyKT,kzyKT,32,3628,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<P,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m][2];
    rep(i,n)rep(j,m)rep(k,2) d[i][j][k]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(P(0,0),P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F.F,k=p.F.S;
      if(d[x][y][k]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+k+1,kk=(k+1)%2;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1+k);
          if(d[xx][yy][kk]>cc) {
            d[xx][yy][kk]=cc;
            que.push(PP(P(cc,kk),P(xx,yy)));
          }
        }
      }
    }
    return min(d[n-1][m-1][0],d[n-1][m-1][1]);
  }
};
",1441293902
kzyKT,kzyKT,32,3636,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  bool isBalanced(string s) {
    ll c[2];mem(c);
    rep(i,s.size()) c[i%2]+=s[i]-'0';
    return c[0]==c[1];
  }
};
",1441281289
kzyKT,kzyKT,32,3637,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;


void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;
  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}
  *c=r0;*a=a0;*b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll fact[2100],fact_inv[2100];

void init() {
  fact[0]=1;
  REP(i,1,2100) fact[i]=fact[i-1]*i%MAX;
  fact_inv[2050]=get_inv(fact[2050],MAX);
  rrep(i,2050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;
}

ll nCr(ll N,ll K){
  if(K<0||K>N)return 0;
  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;
}

ll dp[11][44][444];
class Solution {
public:
  int countBalancedPermutations(string s) {
    init();
    ll n=s.size();
    ll c[26],sum=0;
    mem(c);
    rep(i,n) c[s[i]-'0']++;
    rep(i,10) sum+=i*c[i];
    if(sum%2) return 0;
    ll n1=n/2+n%2,n2=n/2,e=0;
    rep(i,11)rep(j,n1+1)rep(k,400) dp[i][j][k]=0;
    dp[0][0][0]=1;
    rep(i,10) {
      rep(j,n1+1) {
        rep(k,400) {
          rep(l,c[i]+1) {
            if(j+l>n1||k+l*i>400) break;
            ll nn=e-j;
            if(n2-nn<0) continue;
            dp[i+1][j+l][k+l*i]+=dp[i][j][k]*nCr(n1-j,l)%MAX*nCr(n2-nn,c[i]-l);
            dp[i+1][j+l][k+l*i]%=MAX;
          }
        }
      }
      e+=c[i];
    }
    return dp[10][n1][sum/2];
  }
};",1441309238
nimish7866,nimish7866,33,3627,cpp,"
    
    class Solution {
public:


int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = moveTime.size();
        int m = moveTime[0].size();
        

        vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        

        vector<vector<long long>> arrival(n, vector<long long>(m, LLONG_MAX));
        arrival[0][0] = 0; 
        

        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>, 
                      greater<>> pq;
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            auto [currentTime, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            

            if (currentTime > arrival[row][col]) continue;
            

            for (const auto& [dx, dy] : directions) {
                int newRow = row + dx;
                int newCol = col + dy;
                

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {

                    long long nextTime = max(currentTime, (long long)moveTime[newRow][newCol]);
                    nextTime += 1;  
                    

                    if (nextTime < arrival[newRow][newCol]) {
                        arrival[newRow][newCol] = nextTime;
                        pq.push({nextTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return (int)arrival[n-1][m-1];
}
    };
        
    
",1441297861
nimish7866,nimish7866,33,3628,cpp,"class Solution {
public:
    typedef pair<long long, pair<int, int>> P;

    long long minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        vector<pair<int, int>> dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(m, vector<long long>(2, LLONG_MAX)));

        dp[0][0][0] = 0;

        priority_queue<pair<long long, tuple<int, int, int>>, vector<pair<long long, tuple<int, int, int>>>, greater<>> pq;
        pq.push({0, {0, 0, 0}});

        while (!pq.empty()) {
            auto [curT, state] = pq.top();
            auto [r, c, mv] = state;
            pq.pop();

            if (curT > dp[r][c][mv % 2]) continue;

            for (const auto& [dx, dy] : dir) {
                int nr = r + dx;
                int nc = c + dy;

                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int mvTime = (mv % 2 == 0) ? 1 : 2;
                    long long nextT = max(curT, (long long)mt[nr][nc]);
                    nextT += mvTime;

                    if (nextT < dp[nr][nc][(mv + 1) % 2]) {
                        dp[nr][nc][(mv + 1) % 2] = nextT;
                        pq.push({nextT, {nr, nc, (mv + 1) % 2}});
                    }
                }
            }
        }

        return (int)min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441300894
nimish7866,nimish7866,33,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

    for (size_t i = 0; i < num.length(); ++i) {
        int digit = num[i] - '0';  
        if (i % 2 == 0) {
            es += digit;  
        } else {
            os += digit;  
        }
    }

    return es == os;
    }
};",1441281030
nimish7866,nimish7866,33,3637,cpp,"using ll = long long;
using vll = vector<ll>;
using vvll = vector<vll>; 

class Solution {
public:
    const int MOD = 1'000'000'007; 

    int countBalancedPermutations(string n) {
        int L = n.size();
        int E = (L + 1) / 2;
        int O = L / 2;

        string v = n;
        int cnt[10] = {0};
        countDigits(n, cnt);

        ll total = calcTotal(cnt);
        if (total % 2 != 0) return 0;

        ll target = total / 2;

        vll fact = preFact();
        vll invFact = preInvFact(fact);

        vvll dp = initDP(E, target); 
        fillDP(dp, cnt, fact, invFact, E, target); 

        return calcAns(dp, E, target, cnt, L); 
    }

private:
    void countDigits(const string& n, int* cnt) {
        for (char ch : n) cnt[ch - '0']++;
    }

    ll calcTotal(int* cnt) {
        ll sum = 0;
        for (int d = 0; d < 10; d++) {
            sum += (ll)d * cnt[d];
        }
        return sum;
    }

    vll preFact() {
        const int MAX = 80;
        vll fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    vll preInvFact(const vll& fact) {
        const int MAX = 80;
        vll invFact(MAX + 1, 1);
        invFact[MAX] = power(fact[MAX], MOD - 2, MOD);
        for (int i = MAX - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
        return invFact;
    }

    ll comb(int a, int b, const vll& fact, const vll& invFact) {
        if (b > a) return 0;
        return fact[a] * invFact[b] % MOD * invFact[a - b] % MOD;
    }

    vvll initDP(int E, ll target) {
        vvll dp(E + 1, vll(target + 1, 0));
        dp[0][0] = 1;
        return dp;
    }

    void fillDP(vvll& dp, int* cnt, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            updateDP(dp, cnt[d], d, fact, invFact, E, target); 
        }
    }

    void updateDP(vvll& dp, int digitCount, int digit, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int t = E; t >= 0; t--) {
            for (ll s = target; s >= 0; s--) {
                if (dp[t][s] == 0) continue;
                for (int k = 1; k <= digitCount && t + k <= E && s + (ll)digit * k <= target; k++) {
                    dp[t + k][s + (ll)digit * k] = (dp[t + k][s + (ll)digit * k] + dp[t][s] * comb(digitCount, k, fact, invFact)) % MOD;
                }
            }
        }
    }

    int calcAns(const vvll& dp, int E, ll target, int* cnt, int L) { 
        ll valid = dp[E][target];
        ll prodFact = calcProductFact(cnt);
        ll ans = (valid * preFact()[E] % MOD * preFact()[L / 2] % MOD) * power(prodFact, MOD - 2, MOD) % MOD;
        return (int)ans;
    }

    ll calcProductFact(int* cnt) {
        ll prodFact = 1;
        for (int d = 0; d < 10; d++) {
            prodFact = prodFact * preFact()[cnt[d]] % MOD;
        }
        return prodFact;
    }

    ll power(ll b, ll e, ll m) {
        ll r = 1; 
        b %= m;
        while (e > 0) {
            if (e & 1) r = r * b % m;
            b = b * b % m; 
            e >>= 1;
        }
        return r;
    }
};",1441316156
Zejun Wu,watashi,34,3627,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 1;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441293776
Zejun Wu,watashi,34,3628,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 2 - (xx + yy) % 2;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441298622
Zejun Wu,watashi,34,3636,cpp,"class Solution {
public:
  bool isBalanced(string num) {
    int s = 0, f = 1;
    for (char c : num) {
      s += (c - '0') * f;
      f *= -1;
    }
    return s == 0;
  }
};",1441281479
Zejun Wu,watashi,34,3637,cpp,"class Solution {
  static constexpr int64_t MOD = 1000000007;

  // a * x + b * y = gcd(a, b) >= 0
  long long extGcd(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
      x = a >= 0 ? 1 : -1;
      y = 0;
      return abs(a);
    }
    else {
      int g = extGcd(b, a % b, y, x);
      y -= a / b * x;
      return g;
    }
  }

  // ASSUME: gcd(a, m) == 1
  long long modInv(long long a, long long m) {
    long long x, y;
    extGcd(a, m, x, y);
    return (x % m + m) % m;
  }

public:
  int countBalancedPermutations(string num) {
    vector<int64_t> fac(800), inv(800);
    fac[0] = inv[0] = 1;
    for (int i = 1; i < inv.size(); ++i) {
      fac[i] = fac[i - 1] * i % MOD;
      inv[i] = modInv(fac[i], MOD);
    }

    int s = 0;
    vector<int> c(10, 0);
    for (char ch : num) {
      ++c[ch - '0'];
      s += ch - '0';
    }
    if (s % 2 != 0) {
      return 0;
    }

    int n = num.length();
    int m = n / 2;
    int z = 0;
    s /= 2;
    vector<vector<int64_t>> dp(m + 1, vector<int64_t>(s + 1, 0));
    dp[0][0] = 1;
    for (int x = 0; x < 10; ++x) {
      vector<vector<int64_t>> pre(m + 1, vector<int64_t>(s + 1, 0));
      pre.swap(dp);
      for (int y = 0; y <= c[x]; ++y) { // 80
        for (int i = y; i <= m; ++i) {
          for (int j = x * y; j <= s; ++j) {
            dp[i][j] += pre[i - y][j - x * y] * inv[y] % MOD * inv[c[x] - y] % MOD;
          }
        }
      }
      for (auto& i : dp) {
        for (auto& j : i) {
          j %= MOD;
        }
      }
    }

    int64_t ret = dp[m][s];
    for (int i = 1; i <= m; ++i) {
      ret = ret * i % MOD;
    }
    for (int i = 1; i <= n - m; ++i) {
      ret = ret * i % MOD;
    }
    return (int)ret;
  }
};",1441316290
SayA,usaya,36,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        dist = [[float('inf') for _ in range(m)] for _ in range(n)]
        dist[0][0] = 0
        
        hp = [(0, 0, 0)] # (time, x, y)
        while hp:
            t, x, y = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(hp, (nt, nx, ny))
        return -1",1441293531
SayA,usaya,36,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        
        dp = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        hp = [(0, 0, 0, 0)] # (time, x, y, z)
        
        while hp:
            t, x, y, z = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dp[x][y][z]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + (1 if z == 0 else 2)
                    nz = 1 - z
                    if nt < dp[nx][ny][nz]:
                        dp[nx][ny][nz] = nt
                        heappush(hp, (nt, nx, ny, nz))
        return -1",1441301029
SayA,usaya,36,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = s2 = 0
        for idx, d in enumerate(num):
            if idx % 2 == 0:
                s1 += ord(d) - ord('0')
            else:
                s2 += ord(d) - ord('0')
        return s1 == s2",1441288801
SayA,usaya,36,3637,python3,"MOD = 10**9 + 7
MAXN = 85

fact = [1] * (MAXN + 1)
for i in range(1, MAXN + 1):
    fact[i] = fact[i-1] * i % MOD

inv = [1] * (MAXN + 1)
inv[MAXN] = pow(fact[MAXN], MOD-2, MOD)
for i in range(MAXN, 0, -1):
    inv[i-1] = inv[i] * i % MOD

comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for i in range(MAXN + 1):
    comb[i][0] = 1
    for j in range(1, i + 1):
        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for d in num:
            cnt[int(d)] += 1
        cnt_e, cnt_o = (n + 1) // 2, n // 2

        s = sum(int(ch) for ch in num)
        if s & 1:
            return 0
        hs = s // 2

        @cache
        def dfs(d, r_e, r_s):
            if d == 10:
                if r_e ==0 and r_s ==0:
                    return 1
                else:
                    return 0
            res = 0
            for t in range(0, min(cnt[d], r_e) + 1):
                if t * d > r_s:
                    continue
                res = (res + dfs(d + 1, r_e - t, r_s - t * d) * comb[cnt[d]][t]) % MOD
            return res

        ans = dfs(0, cnt_e, hs) * fact[cnt_e] * fact[cnt_o] % MOD
        for d in range(10):
            ans = ans * inv[cnt[d]] % MOD
        return ans",1441323871
funsquared,funsquared,37,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))
        
            ",1441323726
funsquared,funsquared,37,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1 + (r + c) % 2
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))",1441323530
funsquared,funsquared,37,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))",1441323951
funsquared,funsquared,37,3637,python3,"MAX = 80
MOD = 10 ** 9 + 7

fact = [1]
for x in range(1, MAX + 1):
    fact.append(fact[-1] * x % MOD)
inv_fact = [None] * (MAX + 1)
inv_fact[MAX] = pow(fact[MAX], -1, MOD)
for x in range(MAX - 1, -1, -1):
    inv_fact[x] = inv_fact[x + 1] * (x + 1) % MOD

def choose(n, k):
    if n < k:
        return 0
    return fact[n] * inv_fact[n - k] % MOD * inv_fact[k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        S = sum(map(int, num))
        if S % 2 == 1:
            return 0
        cnt = [0] * 10
        for d in map(int, num):
            cnt[d] += 1
        target = S // 2
        @cache
        def count(d, o, e, s):
            if d == 10:
                return int(s == target)
            res = 0
            for c in range(min(cnt[d], o) + 1):
                if cnt[d] - c > e:
                    continue
                res = (res + choose(o, c) * choose(e, cnt[d] - c) % MOD * count(d + 1, o - c, e - (cnt[d] - c), s + c * d) % MOD) % MOD
            return res
        return count(0, n // 2, (n + 1) // 2, 0)",1441323285
Ethan,ethanrao,38,3627,cpp,"#include<bits/stdc++.h>>
using namespace std;

class Solution {
public:
    int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    queue<tuple<int, int, int>> q;
    
    int bfs(vector<vector<int>>& cost) {
        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 1e9+3000));
        dp[0][0] = 0;
        
        while (!q.empty()) {
            auto [x, y, t] = q.front();
            q.pop();
            for (int i=0;i<4;i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
                    int tt = max(cost[xx][yy], t);
                    if (tt + 1 < dp[xx][yy]) {
                        q.push({xx, yy, tt + 1});
                        dp[xx][yy] = tt + 1;
                    }
                    else continue;
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        q.push({0, 0, 0});
        return bfs(moveTime);
    }
};
",1441315400
Ethan,ethanrao,38,3628,cpp,"class Solution {
public:
    int a[755][755], n, m, dis[755][755][2];
    struct node{
        int x, y, z, d;
    };
    struct cmp{
        bool operator()(node x, node y){
            return x.d > y.d;      
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        m = moveTime[0].size();
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                a[i][j] = moveTime[i - 1][j - 1];
        priority_queue <node, std::vector <node>, cmp> q;
        q.push((node){1, 1, 0, 0});
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                dis[i][j][0] = dis[i][j][1] = 1.5e9;
        dis[1][1][0] = 0;
        while(q.size()){
            node u = q.top(); q.pop();
            if(u.d > dis[u.x][u.y][u.z]) continue;
            if(u.x > 1){
                int d = std::max(u.d, a[u.x - 1][u.y]) + u.z + 1;
                if(d < dis[u.x - 1][u.y][u.z ^ 1]){
                    dis[u.x - 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x - 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.x < n){
                int d = std::max(u.d, a[u.x + 1][u.y]) + u.z + 1;
                if(d < dis[u.x + 1][u.y][u.z ^ 1]){
                    dis[u.x + 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x + 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.y > 1){
                int d = std::max(u.d, a[u.x][u.y - 1]) + u.z + 1;
                if(d < dis[u.x][u.y - 1][u.z ^ 1]){
                    dis[u.x][u.y - 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y - 1, u.z ^ 1, d});
                }
            }
            if(u.y < m){
                int d = std::max(u.d, a[u.x][u.y + 1]) + u.z + 1;
                if(d < dis[u.x][u.y + 1][u.z ^ 1]){
                    dis[u.x][u.y + 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y + 1, u.z ^ 1, d});
                }
            }
        }
        return std::min(dis[n][m][0], dis[n][m][1]);
    }
};",1441324125
Ethan,ethanrao,38,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ct1 = 0, ct2 = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                ct1 += digit;
            } else {
                ct2 += digit;
            }
        }
        
        return ct1 == ct2;
    }
};
",1441310208
Ethan,ethanrao,38,3637,cpp,"class Solution {
public:
    int n, n1, n2;
    const int mod = 1e9 + 7;
    int c[10];
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    int C[85][85], f[11][85][361];
    int countBalancedPermutations(string num) {
        n = num.size();
        n1 = n2 = 0;
        int S = 0;
        for(int i = 0; i < n; ++i){
            if(i % 2 == 0) ++n1;
            else ++n2;
            ++c[num[i] - '0'];
            S += num[i] - '0';
        }
        if(S % 2){
            return 0;
        }
        C[0][0] = 1;
        for(int i = 1; i <= n; ++i)
            for(int j = 0; j <= i; ++j){
                if(j == 0) C[i][j] = 1;
                else C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
            }
        f[0][0][0] = 1;
        int s = 0;
        for(int i = 1; i <= 10; ++i){
            int t = c[i - 1];
            for(int sum = 0; sum <= 360; ++sum){
                for(int j = 0; j <= n1; ++j){
                    for(int k = 0; k <= j && k <= t; ++k){
                        int pn1 = j - k, pn2 = s - pn1, sa = k * (i - 1);
                        if(pn2 < 0 || pn2 > n2 || sa > sum) continue;
                        f[i][j][sum] = add(f[i][j][sum], mul(f[i - 1][pn1][sum - sa], mul(C[n1 - pn1][k], C[n2 - pn2][t - k])));
                    } 
                }
            }
            s += t;
        }
        return f[10][n1][S / 2];
    }
};",1441309618
zaneyu2005,zaneyu2005,41,3627,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int x=z/m,y=z%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[a*m+b]<=max(arr[a][b],dist[z])+1){
                    continue;
                }
                dist[a*m+b]=max(arr[a][b],dist[z])+1;
                pq.push({dist[a*m+b],a*m+b});
            }
        }
        return dist[n*m-1];
    }
    
};",1441292757
zaneyu2005,zaneyu2005,41,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(2*n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int st=z%2;
            int x=(z/2)/m,y=(z/2)%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[(a*m+b)*2+1-st]<=max(arr[a][b],dist[z])+(st+1)){
                    continue;
                }
                dist[(a*m+b)*2+1-st]=max(arr[a][b],dist[z])+st+1;
                pq.push({dist[(a*m+b)*2+1-st],(a*m+b)*2+1-st});
            }
        }
        return min(dist[2*(n*m-1)],dist[2*n*m-1]);
    }
    
};",1441296463
zaneyu2005,zaneyu2005,41,3636,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
class Solution {
public:
    bool isBalanced(string s) {
        int n=sz(s);
        int sum=0;
        REP(i,n){
            if(i%2) sum+=s[i]-'0';
            else sum-=s[i]-'0';
        }
        return (sum==0);
    }
};",1441280925
zaneyu2005,zaneyu2005,41,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dp[100][1000],ndp[100][1000];
int c[100][100];
class Solution {
public:
    int countBalancedPermutations(string num) {
        REP(i,50) REP(j,1000) dp[i][j]=ndp[i][j]=0;
        REP(i,100){
            c[i][0]=1;
            REP1(j,i){
                c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;
            }
        }
        dp[0][0]=1;
        int cnt[10];
        REP(i,10) cnt[i]=0;
        int s=0;
        for(auto x:num){
            cnt[x-'0']++;
            s+=(x-'0');
        }
        if(s%2){
            return 0;
        }
        s/=2;
        int o=sz(num)/2;
        int e=sz(num)-o;
        int pf=0;
        REP(i,10){
            REP(a,o+1) REP(b,s+1) ndp[a][b]=0;
            REP(a,o+1){
                REP(b,s+1){
                    if(!dp[a][b]) continue;
                    REP(j,cnt[i]+1){
                        if(a+j>o or b+j*i>s) continue;
                        ndp[a+j][b+j*i]+=1LL*dp[a][b]*c[o-a][j]%MOD*c[e-(pf-a)][cnt[i]-j]%MOD;
                        if(ndp[a+j][b+j*i]>=MOD) ndp[a+j][b+j*i]-=MOD;
                    }
                }
            }
            pf+=cnt[i];
            REP(a,o+1) REP(b,s+1) dp[a][b]=ndp[a][b];
        }
        return dp[o][s];
    }
};",1441312046
Ayush,as_313,42,3627,python3,"import heapq

class Solution:
    def is_valid(self, i, j, n, m):
        return 0 <= i < n and 0 <= j < m
    
    def get_neighbors(self, r, c, n, m):
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if self.is_valid(nr, nc, n, m):
                yield nr, nc
    
    def init_distance(self, n, m):
        return [[float('inf')]*m for _ in range(n)]
    
    def process_node(self, t, r, c, g, d, q):
        if t > d[r][c]:
            return
        
        n, m = len(g), len(g[0])
        for nr, nc in self.get_neighbors(r, c, n, m):
            new_time = max(t, g[nr][nc]) + 1
            if new_time < d[nr][nc]:
                d[nr][nc] = new_time
                heapq.heappush(q, (new_time, nr, nc))
    
    def minTimeToReach(self, g):
        n, m = len(g), len(g[0])
        d = self.init_distance(n, m)
        q = [(0, 0, 0)]
        d[0][0] = 0
        
        while q:
            t, r, c = heapq.heappop(q)
            self.process_node(t, r, c, g, d, q)
            
        return d[n-1][m-1]",1441325790
Ayush,as_313,42,3628,python3,"class Solution:
    def minTimeToReach(self, t: List[List[int]]) -> int:
        n, m = len(t), len(t[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        q = [(0, 0, 0, 2)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def is_within_bounds(a, b): return 0 <= a < n and 0 <= b < m
        
        def calculate_next_time(x, a, b, nv): return max(x, t[a][b]) + nv
        
        def explore_neighbors(x, r, c, v):
            for i, j in dirs:
                a, b = r + i, c + j
                if is_within_bounds(a, b):
                    nv = 1 if v == 2 else 2
                    y = calculate_next_time(x, a, b, nv)
                    if y < d[a][b]: 
                        d[a][b] = y
                        heappush(q, (y, a, b, nv))
        
        while q:
            x, r, c, v = heappop(q)
            if r == n - 1 and c == m - 1: return x
            if x > d[r][c]: continue
            explore_neighbors(x, r, c, v)
        
        return d[n-1][m-1]
",1441301088
Ayush,as_313,42,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i, d in enumerate(num):
            if i % 2 == 0: e += int(d)
            else: o += int(d)
        return e == o
",1441284192
Ayush,as_313,42,3637,python3,"class Solution:
    def countBalancedPermutations(self, s):
        MOD = 10**9 + 7
        
        def power_mod(x, y):
            r, x = 1, x % MOD
            while y:
                if y & 1: r = r * x % MOD
                x, y = x * x % MOD, y >> 1
            return r
        
        n = len(s)
        f = [1] + [0] * n
        v = [1] + [0] * n
        for i in range(1, n + 1): f[i] = f[i-1] * i % MOD
        v[n] = power_mod(f[n], MOD - 2)
        for i in range(n-1, -1, -1): v[i] = v[i+1] * (i+1) % MOD
        
        c = [s.count(str(i)) for i in range(10)]
        total = sum(int(ch) for ch in s)
        if total % 2: return 0
        
        k, target = (n + 1) // 2, total // 2
        dp = [[0] * (target + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d, cnt in enumerate(c):
            new_dp = [[0] * (target + 1) for _ in range(k + 1)]
            for i in range(k + 1):
                for j in range(target + 1):
                    if dp[i][j]:
                        for x in range(min(cnt, k - i) + 1):
                            if j + d * x <= target:
                                new_dp[i + x][j + d * x] = (
                                    new_dp[i + x][j + d * x] + 
                                    dp[i][j] * v[x] % MOD * v[cnt - x]
                                ) % MOD
            dp = new_dp
        
        return f[k] * f[n-k] % MOD * dp[k][target] % MOD
",1441319728
scanhex,scanhex,45,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441295664
scanhex,scanhex,45,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + t + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441294951
scanhex,scanhex,45,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(i) for i in str(num)[::2]]) == sum([int(i) for i in str(num)[1::2]])",1441296619
scanhex,scanhex,45,3637,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int countBalancedPermutations(string num) {
    int ceven = num.size() / 2, codd = num.size() - ceven;
    int n = num.size();
    vector<vector<int>> c(n + 1, vector<int>(n + 1));
    c[0][0] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 0; j <= i; ++j)
        c[i][j] = ((j == 0 ? 0 : c[i - 1][j - 1]) + c[i - 1][j]) % mod;
    const int MX = 2 * 100 * 9;
    const int ZERO = MX / 2;
    vector<vector<int>> dp(ceven + 1, vector<int>(MX));
    dp[0][ZERO] = 1;
    int totcnt = 0;
    for (int i = 0; i < 10; ++i) {
      int cnt = 0;
      for (char ch : num)
        if (ch - '0' == i)
          ++cnt;
      auto dpp = vector<vector<int>>(ceven + 1, vector<int>(MX));
      for (int j = ceven; j >= 0; --j) {
        for (int k = ceven; k >= 0; --k) {
          if (j + k > ceven || k > cnt)
            continue;
          for (int l = 0; l < MX; ++l) {
            if (dp[j][l] == 0)
              continue;
            int nodd = cnt - k;
            int totodd = totcnt - j;
            int nl = l + (k - nodd) * i;
            if (nl < 0 || nl >= MX)
              continue;
            dpp[j + k][nl] += 1LL * dp[j][l] * c[j + k][k] % mod *
                             c[totodd + nodd][nodd] % mod;
            if (dpp[j + k][nl] >= mod)
              dpp[j + k][nl] -= mod;
          }
        }
      }
      dp = dpp;
      totcnt += cnt;
    }
    return dp[ceven][ZERO];
  }
};
",1441314395
Shuqi Shang,sshang,46,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        seen = set()
        
        while q:
            t, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1, ni, nj))",1441291881
Shuqi Shang,sshang,46,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0, 0)]
        seen = set()
        
        while q:
            t, state, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1 + state, 1 - state, ni, nj))",1441294899
Shuqi Shang,sshang,46,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        odd, even = 0, 0
        for i, c in enumerate(num):
            if i % 2:
                odd += int(c)
            else:
                even += int(c)
        return odd == even",1441281285
Shuqi Shang,sshang,46,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        mod = 10 ** 9 + 7
        
        n = len(num)
        size = n // 2
        
        total = 0
        cnter = {}
        l = []
        for c in num:
            digit = int(c)
            total += digit
            
            if digit in cnter:
                cnter[digit] += 1
            else:
                cnter[digit] = 1
                bisect.insort(l, digit)
                
        l.reverse()
        presum = [0]
        precnt = [0]
        for num in l:
            cnt = cnter[num]
            precnt.append(precnt[-1] + cnt)
            presum.append(presum[-1] + num * cnt)
            
        if total % 2:
            return 0
        
        target = total // 2
        
        @lru_cache(None)
        def dfs(i, cur_size, cur):
            if i == len(l):
                if cur_size == size and cur == target:
                    return 1
                else:
                    return 0
                
            op_size = precnt[i] - cur_size
                
            num = l[i]
            cnt = cnter[num]
            res = 0
            for j in range(cnt + 1):
                ncur_size = cur_size + j
                ncur = cur + j * num
                nop_size = precnt[i+1] - ncur_size
                nop_sum = presum[i+1] - ncur
                
                if ncur_size <= size and nop_size <= n - size and ncur <= target and nop_sum <= target:
                    mul = (math.comb(size - cur_size, j) % mod) * (math.comb(n - size - op_size, cnt - j) % mod) % mod
                    res += dfs(i+1, ncur_size, ncur) * mul % mod
            return res % mod
            
        return dfs(0, 0, 0)",1441327864
Milind Gupta,milind0110,48,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + 1;
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny});
                }
            }
        }
        return -1;
    }
};",1441298834
Milind Gupta,milind0110,48,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,4>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y,turn] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + (turn == 0 ? 1 : 2);
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny,turn ^ 1});
                }
            }
        }
        return -1;
    }
};",1441297775
Milind Gupta,milind0110,48,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int ans = 0;
        int n = (int)s.size();
        for(int i = 0; i < n; i++){
            if(i & 1){
                ans += s[i] - '0';
            } else {
                ans -= s[i] - '0';
            }
        }
        return (ans == 0);
    }
};",1441281507
Milind Gupta,milind0110,48,3637,cpp,"const int N = 100;
const int mod = 1e9 + 7;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }
template <class T> using V = vector<T>;
template <class T> using VV = V<V<T>>;

template <uint MD> struct ModInt {
    using M = ModInt;
    const static M G;
    uint v;
    ModInt(ll _v = 0) { set_v(_v % MD + MD); }
    M& set_v(uint _v) {
        v = (_v < MD) ? _v : _v - MD;
        return *this;
    }
    explicit operator bool() const { return v != 0; }
    M operator-() const { return M() - *this; }
    M operator+(const M& r) const { return M().set_v(v + r.v); }
    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }
    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }
    M operator/(const M& r) const { return *this * r.inv(); }
    M& operator+=(const M& r) { return *this = *this + r; }
    M& operator-=(const M& r) { return *this = *this - r; }
    M& operator*=(const M& r) { return *this = *this * r; }
    M& operator/=(const M& r) { return *this = *this / r; }
    bool operator==(const M& r) const { return v == r.v; }
    M pow(ll n) const {
        M x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    M inv() const { return pow(MD - 2); }
    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }
};
using Mint = ModInt<mod>;
template<> const Mint Mint::G = Mint(3);

// template <class Mint> void nft(bool type, V<Mint>& a) {
//     int n = int(a.size()), s = 0;
//     while ((1 << s) < n) s++;
//     assert(1 << s == n);

//     static V<Mint> ep, iep;
//     while (int(ep.size()) <= s) {
//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));
//         iep.push_back(ep.back().inv());
//     }
//     V<Mint> b(n);
//     for (int i = 1; i <= s; i++) {
//         int w = 1 << (s - i);
//         Mint base = type ? iep[i] : ep[i], now = 1;
//         for (int y = 0; y < n / 2; y += w) {
//             for (int x = 0; x < w; x++) {
//                 auto l = a[y << 1 | x];
//                 auto r = now * a[y << 1 | x | w];
//                 b[y | x] = l + r;
//                 b[y | x | n >> 1] = l - r;
//             }
//             now *= base;
//         }
//         swap(a, b);
//     }
// }

// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {
//     assert(false);
//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer
//     int n = int(a.size()), m = int(b.size());
//     if (!n || !m) return {};
//     int lg = 0;
//     while ((1 << lg) < n + m - 1) lg++;
//     int z = 1 << lg;
//     auto a2 = a, b2 = b;
//     a2.resize(z);
//     b2.resize(z);
//     nft(false, a2);
//     nft(false, b2);
//     for (int i = 0; i < z; i++) a2[i] *= b2[i];
//     nft(true, a2);
//     a2.resize(n + m - 1);
//     Mint iz = Mint(z).inv();
//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;
//     return a2;
// }

Mint fact[N];
Mint inv[N];
void precalc(){
    fact[0] = 1;
    for(int i = 1; i < N; i++){
        fact[i] = fact[i - 1];
        fact[i] *= i;
    }
    for(int i = 0; i < N; i++){
        inv[i] = 1;
        inv[i] /= fact[i];
    }
}
Mint ncrmodp(int n,int r){
    if(n < 0 || n < r)
        return 0;
    return fact[n]*inv[n-r]*inv[r];
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        precalc();
        int n = (int)s.length();
        const int mx = 10;
        vector<int> cnt(mx);
        int sum = 0;
        for(auto i : s){
            cnt[i - '0']++;
            sum += (i - '0');
        }
        if(sum & 1) return 0;
        sum /= 2;
        int len = n / 2;
        vector<vector<Mint>> dp(len + 1,vector<Mint>(sum + 1));
        dp[0][0] = fact[len] * fact[n - len];
        for(int i = 0; i < mx; i++){
            vector<vector<Mint>> ndp(len + 1,vector<Mint>(sum + 1));
            for(int clen = 0; clen <= len; clen++){
                for(int csum = 0; csum <= sum; csum++){
                    for(int take = 0; take <= cnt[i]; take++){
                        if(take + clen > len) break;
                        int nsum = csum + take * i;
                        if(nsum > sum) break;
                        ndp[clen + take][nsum] += dp[clen][csum] * inv[take] * inv[cnt[i] - take];
                    }
                }
            }
            swap(dp,ndp);
        }
        // for(int i = 0; i <= len; i++){
        //     for(int j = 0; j <= sum; j++){
        //         cout << i << "" "" << j << "" "" << dp[i][j].v << ""\n"";
        //     }
        // }
        return dp[len][sum].v;

    }
};",1441328324
07dishwasherbob8,07dishwasherbob8,50,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1, moveTime[tx][ty] + 1), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441328119
07dishwasherbob8,07dishwasherbob8,50,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1 + ((x + y) & 1), moveTime[tx][ty] + 1 + ((x + y) & 1)), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441327239
07dishwasherbob8,07dishwasherbob8,50,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for(int i = 1; i < num.size(); i+=2) {
            s0 += num[i] - '0';
        }
        for(int i = 0; i < num.size(); i+=2) {
            s1 += num[i] - '0';
        }
        return s0 == s1;
    }
};",1441329956
07dishwasherbob8,07dishwasherbob8,50,3637,cpp,"typedef long long ll;
typedef long double ld;

template<class T>
constexpr T power(T a, ll b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

//Modular Division currently uses Little Fermat's Theorem, so won't work for nonprime p. 
template<int P>
struct Mint {
    int x;
    constexpr Mint(): x{} {}
    constexpr Mint(ll x): x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if(P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if(x < 0) {
            x += getMod();
        }
        if(x >= getMod()) { //not sure why this is needed
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    constexpr Mint operator-() const {
        Mint res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr Mint inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr Mint &operator*=(Mint rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr Mint &operator+=(Mint rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr Mint &operator-=(Mint rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr Mint &operator/=(Mint rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr Mint operator*(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr Mint operator+(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr Mint operator-(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr Mint operator/(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, Mint &a) {
        ll v;
        is >> v;
        a = Mint(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const Mint &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(Mint lhs, Mint rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(Mint lhs, Mint rhs) {
        return lhs.val() != rhs.val();
    }
};

constexpr int P = 1000000007;
using Z = Mint<P>;

class Solution {

public:
    int countBalancedPermutations(string num) {
        vector<Z> factorials(800);
        vector<Z> ifactorials(800);
        factorials[0] = 1;
        ifactorials[0] = 1;
        for(int i = 1; i < 800; i++) {
            factorials[i] = factorials[i-1] * i;
            ifactorials[i] = 1 / factorials[i];
        }

        vector<int> cnts(10);
        int sum = 0;
        for(char c : num) {
            cnts[c - '0']++;
            sum += c - '0';
        }

        
        if(sum & 1) {
            return 0;
        }
        
        // cout << ""sum : "" << sum << '\n';

        vector<vector<Z>> dp(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));
        vector<vector<Z>> next(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));

        dp[0][0] = 1;

        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    next[j][k] = 0;
                }
            }
            
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    for(int l = 0; l + j <= num.size() / 2 && k + (i * l) <= sum / 2 && l <= cnts[i]; l++) {
                        next[l+j][k + i * l] += dp[j][k] * ifactorials[l] * ifactorials[cnts[i] - l];
                    }
                }
            }
            // cout << ""i : "" << i << '\n';
            // for(int j = 0; j <= num.size() / 2; j++) {
            //     for(int k = 0; k <= sum / 2; k++) {
            //         // cout << ""i : "" << i << "" j : "" << j << "" k : "" << k << "" val : "" << dp[j][k] << '\n';
            //         cout << next[j][k] << "" "";
            //     }
            //     cout << '\n';
            // }
            swap(dp,next);
        }
        return (dp[num.size() / 2][sum / 2] * factorials[num.size() / 2] * factorials[(num.size() + 1) / 2]).x;
    }
};",1441315453
wuaws,wuaws,51,3627,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int>,vector<tuple<ll,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        vpi dirs={{-1,0},{1,0},{0,-1},{0,1}};
        const ll INF=1e18;
        mll d(n,vll(m,INF));
        d[0][0]=0;
        pq pq;
        pq.emplace(0,0,0);
        
        while(!pq.empty()){
            auto[t,i,j]=pq.top();
            pq.pop();
            
            if(i==n-1&&j==m-1)return(int)t;
            
            if(t>d[i][j])continue;
            
            for(auto&[di,dj]:dirs){
                int ni=i+di,nj=j+dj;
                
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                
                ll at=max(t,(ll)mt[ni][nj])+1;
                if(at<d[ni][nj]){
                    d[ni][nj]=at;
                    pq.emplace(at,ni,nj);
                }
            }
        }
        return -1;
    }
};",1441329816
wuaws,wuaws,51,3628,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int,int>,vector<tuple<ll,int,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        mll d0(n,vll(m,1e18)),d1(n,vll(m,1e18));
        d0[0][0]=0;
        pq pq;
        pq.emplace(0,0,0,0);
        vector<pair<int,int>> dirs={{-1,0},{1,0},{0,-1},{0,1}};
        
        while(!pq.empty()){
            auto[t,i,j,p]=pq.top(); pq.pop();
            if(i==n-1&&j==m-1)return t;
            if((p==0&&t>d0[i][j])||(p==1&&t>d1[i][j]))continue;

            for(auto& d:dirs){
                int ni=i+d.first,nj=j+d.second;
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                ll ts=max((ll)t,(ll)mt[ni][nj]),at=ts+(p==0?1:2);
                int np=1-p;
                if((np==0&&at<d0[ni][nj])||(np==1&&at<d1[ni][nj])){
                    (np==0?d0[ni][nj]:d1[ni][nj])=at;
                    pq.emplace(at,ni,nj,np);
                }
            }
        }
        return -1;
    }
};",1441329602
wuaws,wuaws,51,3636,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

class Solution {
public:
    bool isBalanced(string num) {
        int e=0,o=0;
        FOR(i,0,num.length()){
            int d=num[i]-'0';
            if(i%2==0) e+=d;
            else o+=d;
        }
        return e==o;
    }
};",1441330062
wuaws,wuaws,51,3637,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// 
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1: __builtin_popcount(i), __builtin_popcountll(i)
// 0: __builtin_clz(i), __builtin_clzll(i) // i=0
// 0: __builtin_ctz(i), __builtin_ctzll(i) // i=0

istringstream debug_iss(R""(

)"");
// #define cin debug_iss

const int MOD=1e9+7;

ll fast_power(ll x,ll y,ll mod){
    ll r=1; x%=mod;
    while(y>0){
        if(y&1)r=r*x%mod;
        x=x*x%mod; y>>=1;
    }
    return r;
}

class Solution {
public:
    int countBalancedPermutations(string n){
        int c[10]={0}; ll s=0;
        for(char d:n){c[d-'0']++; s+=d-'0';}
        if(s&1)return 0;
        ll t=s/2; int sz=n.size(),e=(sz+1)/2,o=sz/2;
        
        vector<ll> f(sz+1,1),ivf(sz+1,1);
        FOR(i,1,sz+1)f[i]=f[i-1]*i%MOD;
        ivf[sz]=fast_power(f[sz],MOD-2,MOD);
        FORD(i,sz,0)ivf[i]=ivf[i+1]*(i+1)%MOD;
        
        vector<pair<int,int>>d;
        FOR(dg,0,10)if(c[dg])d.PB({dg,c[dg]});
        
        mll dp(t+1,vector<ll>(e+1,0));
        dp[0][0]=1;
        
        FORE(dg,d){
            mll ndp(t+1,vector<ll>(e+1,0));
            FOR(k,0,t+1)FOR(m,0,e+1)if(dp[k][m]){
                int mx=min(dg.S,e-m);
                FOR(x,0,mx+1){
                    ll nk=k+x*dg.F; if(nk>t)continue;
                    int nm=m+x;
                    ndp[nk][nm]=(ndp[nk][nm]+dp[k][m]*ivf[x]%MOD*ivf[dg.S-x]%MOD)%MOD;
                }
            }
            dp=ndp;
        }
        
        ll a=(t<=t&&e<=e)?dp[t][e]:0;
        
        return (int)(f[e]*f[o]%MOD*a%MOD);
    }
};",1441329386
Meng-Hsuan Wu,meng-hsuan,55,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + 1, tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441305853
Meng-Hsuan Wu,meng-hsuan,55,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + (1 if (tr + tc) % 2 else 2), tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441307123
Meng-Hsuan Wu,meng-hsuan,55,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) * (1 if i % 2 else -1) for i in range(n)) == 0",1441282661
Meng-Hsuan Wu,meng-hsuan,55,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(ch) for ch in num) % 2:
            return 0
        
        MODULI = 10 ** 9 + 7
        n = len(num)
        no = n >> 1
        ne = n - no
        C = Counter(num)
        
        choose = [[1]]
        for n_ in range(1, n + 1):
            choose.append([1])
            for r in range(1, n_):
                choose[-1].append((choose[-2][r - 1] + choose[-2][r]) % MODULI)
            choose[-1].append(1)
        #for i in choose:
        #    print(i)
        
        curr = {(ne, no, 0): 1}
        for i in range(10):
            prev = curr
            curr = collections.defaultdict(int)
            qty = C[str(i)]
            
            for ce in range(qty + 1):
                co = qty - ce
                dbal = (ce - co) * i
                
                for pe, po, pbal in prev:
                    if pe >= ce and po >= co:
                        curr[key := (pe - ce, po - co, pbal + dbal)] += prev[(pe, po, pbal)] * choose[pe][ce] % MODULI * choose[po][co] % MODULI
                        curr[key] %= MODULI
        
        return curr[(0, 0, 0)]
    ",1441331806
haohao,cchao,56,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 3>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        vector<vector<int>> d(n, vector<int>(m, inf));
        d[0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2];
            if (dis != d[x][y]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir];
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + 1;
                if (nd < d[tx][ty]) {
                    d[tx][ty] = nd;
                    q.push({nd, tx, ty});
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441295427
haohao,cchao,56,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 4>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0, 0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        int d[n][m][2];
        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {
            d[i][j][0] = d[i][j][1] = inf;
        }
        d[0][0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2], z = t[3];
            if (dis != d[x][y][z]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir], tz = z ^ 1;
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + (z + 1);
                if (nd < d[tx][ty][tz]) {
                    d[tx][ty][tz] = nd;
                    q.push({nd, tx, ty, tz});
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441301451
haohao,cchao,56,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        return sum(int(x) for x in num[0::2]) == sum(int(x) for x in num[1::2])",1441283080
haohao,cchao,56,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for c in num:
            cnt[ord(c) - ord('0')] += 1

        mod = 10 ** 9 + 7
        inv = lambda x : pow(x, mod - 2, mod)
        fac = [1] * 100
        ifac = [1] * 100
        for i in range(1, len(fac)):
            fac[i] = fac[i-1] * i % mod
            ifac[i] = inv(fac[i])
        
        @cache
        def f(cap1, cap2, diff, index):
            if cap1 < 0 or cap2 < 0:
                return 0
            if cap1 == 0 and cap2 == 0:
                return diff == 0
            ans = 0
            for i in range(cnt[index] + 1):
                j = cnt[index] - i
                if cap1 >= i and cap2 >= j:
                    m1 = fac[cap1] * ifac[i] * ifac[cap1 - i]
                    m2 = fac[cap2] * ifac[j] * ifac[cap2 - j]
                    r = f(cap1 - i, cap2 - j, diff + index * (i - j), index + 1)
                    r = r * m1 % mod
                    r = r * m2 % mod
                    ans = (ans + r) % mod
            return ans % mod
        return f(n//2, n-n//2, 0, 0)",1441332143
Ernest Lu,ernestlu,57,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 1);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441318385
Ernest Lu,ernestlu,57,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 2);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441317334
Ernest Lu,ernestlu,57,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = (int)num.size();
        vector<int> a(n);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
            if (i % 2 == 0)
                sum += a[i];
        }
        const int sum_2 = accumulate(a.begin(), a.end(), 0);
        if (sum + sum == sum_2)
            return true;
        return false;
    }
};",1441319837
Ernest Lu,ernestlu,57,3637,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        // * even! * odd!
        // divide by how many we choose at each level?
        // maintain sum

        int n = (int)num.size();
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
        }

        const int tot = accumulate(a.begin(), a.end(), 0);
        if (tot % 2 == 1) {
            return 0;
        }
        const int target = tot / 2;

 

        vector<int> f(10);
        for (auto u : a)
            f[u]++;

        const int B = n + 101;
        vector<mint> fac(B, 1), inv(B, 1);
        for (int i = 1; i < B; i++)
            fac[i] = fac[i - 1] * i;
        inv[B - 1] = fac[B - 1].pow();
        for (int i = B - 2; i >= 0; i--)
            inv[i] = inv[i + 1] * (i + 1);

        const int even = n / 2, odd = n - even;
        vector dp(even + 1, vector<mint>(target + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            vector new_dp(even + 1, vector<mint>(target + 1, 0));
            for (int num_vals = 0; num_vals <= even; num_vals++) {
                for (int val = 0; val <= target; val++) {
                    for (int fc = 0; fc <= f[i]; fc++) {
                        mint ways_t = inv[fc] * inv[f[i] - fc];
                        const int new_val = val + fc * i;
                        if (num_vals + fc <= even and new_val <= target) {
                            new_dp[num_vals + fc][new_val] += dp[num_vals][val] * ways_t;
                        }
                    }
                }
            }
            swap(dp, new_dp);
        }
        
        const mint ans = dp[even][target] * fac[even] * fac[odd];
        return ans.x;
    }
};",1441299220
Xiaomeng Yang,yangxm,58,3627,cpp,"#define X first
#define Y second

constexpr int MAX = 64;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti3 = tuple<int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX];
priority_queue<Ti3, vector<Ti3>, greater<Ti3>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y] = 0;
  que.emplace(0, src.X, src.Y);
  while (!que.empty()) {
    auto [d, x, y] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y];
    }
    if (d > dis[dst.X][dst.Y]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y]) + 1;
      if (dis[xx][yy] > dis[x][y] + w) {
        dis[xx][yy] = dis[x][y] + w;
        que.emplace(dis[xx][yy], xx, yy);
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441295829
Xiaomeng Yang,yangxm,58,3628,cpp,"#define X first
#define Y second

constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti4 = tuple<int, int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX][2];
priority_queue<Ti4, vector<Ti4>, greater<Ti4>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y][0] = 0;
  que.emplace(0, src.X, src.Y, 0);
  while (!que.empty()) {
    auto [d, x, y, k] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y][k];
    }
    if (d > dis[dst.X][dst.Y][k]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y][k]) + k + 1;
      if (dis[xx][yy][k ^ 1] > dis[x][y][k] + w) {
        dis[xx][yy][k ^ 1] = dis[x][y][k] + w;
        que.emplace(dis[xx][yy][k ^ 1], xx, yy, (k ^ 1));
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441299693
Xiaomeng Yang,yangxm,58,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      int n = num.length(), x = 0, y = 0;
      for (int i = 0; i < n; ++i) {
        int v = num[i] - '0';
        if (i & 1) {
          x += v;
        } else {
          y += v;
        }
      }
      return x == y;
    }
};",1441281670
Xiaomeng Yang,yangxm,58,3637,cpp,"constexpr int MAXM = 128;
constexpr int MAXN = 1024;
constexpr int MOD = 1000000007;

using i64 = long long;

int cnt[16];
i64 c[MAXM][MAXM], dp[MAXM][MAXN];

void Init() {
  memset(c, 0, sizeof(c));
  for (int i = 0; i < MAXM; ++i) {
    c[i][0] = 1;
    for (int j = 1; j <= i; ++j) {
      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
    }
  }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
      static bool init = []() {
        Init();
        return true;
      }();
      
      int n = num.length(), m = 0;
      memset(cnt, 0, sizeof(cnt));
      for (char ch : num) {
        int x = ch - '0';
        m += x;
        ++cnt[x];
      }
      
      if (m & 1) {
        return false;
      }
      
      memset(dp, 0, sizeof(dp));
      for (int i = 0; i <= cnt[0]; ++i) {
        dp[i][0] = 1;
      }
      int v = cnt[0], w = 0;
      for (int i = 1; i < 10; ++i) {
        if (cnt[i] == 0) {
          continue;
        }
        v += cnt[i];
        w += cnt[i] * i;
        for (int j = v; j >= 0; --j) {
          for (int k = w; k >= 0; --k) {
            i64 sum = 0;
            for (int d = 0; d <= j && d <= cnt[i] && d * i <= k; ++d) {
              int p = j, q = v - j;
              i64 cur = c[p][d] * c[q][cnt[i] - d] % MOD;
              sum = (sum + dp[j - d][k - d * i] * cur) % MOD;
            }
            dp[j][k] = sum;
          }
        }
      }
      return dp[(n + 1) / 2][m / 2];
    }
};",1441327081
raincoat911,raincoat911,60,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<int>> dp(r, vector<int>(c, INT_MAX));
        dp[0][0] = 0;
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq;
        pq.push({0,0,0});
        vector<vector<bool>> seen(r, vector<bool>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2];
            if (seen[i][j]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j] = true;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y]) continue;
                int nt = max(t, moveTime[x][y]) + 1;
                if (dp[x][y] > nt) {
                    dp[x][y] = nt;
                    pq.push({nt, x, y});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441294180
raincoat911,raincoat911,60,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<array<int, 2>>> dp(r, vector<array<int, 2>>(c, {INT_MAX, INT_MAX}));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> pq;
        pq.push({0,0,0,0});
        vector<vector<array<bool, 2>>> seen(r, vector<array<bool, 2>>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2], z = p[3];
            if (seen[i][j][z]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j][z] = true;
            int nz = z ^ 1;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y][nz]) continue;
                int nt = max(t, moveTime[x][y]) + (z == 0 ? 1 : 2);
                if (dp[x][y][nz] > nt) {
                    dp[x][y][nz] = nt;
                    pq.push({nt, x, y, nz});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441298517
raincoat911,raincoat911,60,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0,  e = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return o == e;
    }
};",1441281089
raincoat911,raincoat911,60,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int l = num.size(), o = (l + 1) / 2, e = l - o, s = 0;
        vector<int> arr(10);
        for (char c : num) {
            arr[c - '0']++;
            s += c - '0';
        }
        if (s & 1) return 0;
        int n = 0;
        vector<vector<int>> dp(s / 2 + 1, vector<int>(o + 1));
        arr2.resize(o + 1, vector<int>(o + 1));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            // cout << i << endl;
            if (arr[i] == 0) continue;
            vector<vector<int>> dp2(s / 2 + 1, vector<int>(o + 1));
            for (int j = 0; j < dp.size(); j++) {
                for (int d = 0; d <= o; d++) {
                    if (dp[j][d] == 0) continue;
                    for (int k = 0; k <= arr[i] && d + k <= o && j + k * i < dp.size(); k++) {
                        if (e - (n - d) < arr[i] - k) continue;
                        // cout << i << "" "" << j << "" "" << k << "" "" << d << endl;
                        // cout << j + k * i << "" "" << d + k << "" "" << o - d << "" "" << k << "" "" << e - (n - d) << "" "" << arr[i] - k << endl;
                        dp2[j + k * i][d + k] += (((long)dp[j][d] * cnk(o - d, k)) % M * cnk(e - (n - d), arr[i] - k)) % M;
                        dp2[j + k * i][d + k] %= M;
                        // cout << ""done"" << endl;
                    }
                }
            }
            swap(dp, dp2);
            n += arr[i];
        }
        // cout << ""aaa"" << endl;
        return dp.back().back();
    }
    
private:
    int M = 1e9 + 7;
    vector<vector<int>> arr2;
    
    int cnk(int n, int k) {
        // cout << n << "" "" << k << endl;
        if (n == k || k == 0) return 1;
        if (arr2[n][k]) return arr2[n][k];
        return arr2[n][k] = (cnk(n - 1, k - 1) + cnk(n - 1, k)) % M;
    }
};",1441328822
OTTFF,OTTFF,62,3627,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

class Solution {
public:
typedef array<int, 3> A3;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        vector<vector<int>> dis(n, vector<int>(m, INF));
        vector<vector<int>> vis(n, vector<int>(m, 0));

        priority_queue<A3, vector<A3>, greater<A3>> qu;
        dis[0][0] = 0;
        qu.push({0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny] = qu.top(); qu.pop();
            if (vis[nx][ny]) continue;
            vis[nx][ny] = 1;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny]) + 1;
                if (dis[x][y] <= nd) {
                    continue;
                }
                dis[x][y] = nd;
                qu.push({nd, x, y});
            }
        }

        return dis[n - 1][m - 1];
    }
};",1441298205
OTTFF,OTTFF,62,3628,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

const int M = 755;
int dis[M][M][2];
int vis[M][M][2];

class Solution {
public:
typedef array<int, 4> A4;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        // vector<vector<int>> dis(n, vector<int>(m, INF));
        // vector<vector<int>> vis(n, vector<int>(m, 0));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dis[i][j][0] = dis[i][j][1] = INF;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }

        priority_queue<A4, vector<A4>, greater<A4>> qu;
        dis[0][0][0] = 0;
        qu.push({0, 0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny, nt] = qu.top(); qu.pop();
            if (vis[nx][ny][nt]) continue;
            vis[nx][ny][nt] = 1;

            // cout << nx << ' ' << ny << ' ' << nt << ' ' << dis[nx][ny][nt] << endl;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y][nt]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny][nt]) + (nt ? 2 : 1);
                if (dis[x][y][nt ^ 1] <= nd) {
                    continue;
                }
                dis[x][y][nt ^ 1] = nd;
                qu.push({nd, x, y, nt ^ 1});
            }
        }

        return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441304611
OTTFF,OTTFF,62,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int i = 0;
        for (char c : num) {
            if (i & 1) {
                sum += c - '0';
            } else {
                sum -= c - '0';
            }
            i++;
        }
        return sum == 0;
    }
};",1441281671
OTTFF,OTTFF,62,3637,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

vector<Mint> inv, fa, ifa;
void init_mod(int n) {
    inv.assign(n + 1, Mint(1));
    fa.assign(n + 1, Mint(1));
    ifa.assign(n + 1, Mint(1));
    for(int i = 2; i <= n; i++) {
        fa[i] = fa[i-1] * i;
        inv[i] = Mint(Mint::MO - Mint::MO / i) * inv[Mint::MO % i];
        ifa[i] = inv[i] * ifa[i-1];
    }
}
inline Mint C(int n,int m) {
  return (m<0 || n<m) ? Mint(0) : fa[n]*ifa[m]*ifa[n-m]; }
inline Mint A(int n,int m) { return fa[n]*ifa[n-m]; }

const int M = 85;
int f = 0;
void init() {
    if (f) return;
    f = 1;
    init_mod(M);
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        
        int n = s.length();
        int sum = 0;
        vector<int> cnt(10);
        for (int i = 0; i < n; i++) {
            sum += s[i] - '0';
            cnt[s[i] - '0']++;
        }
        if (sum & 1) {
            return 0;
        } 

        int m = n / 2;
        int tar = sum / 2;

        vector<vector<Mint>> dp(m + 1, vector<Mint>(tar + 1)), tmp(m + 1, vector<Mint>(tar + 1));
        dp[0][0] = 1;

        int tot = 0;
        for (int v = 0; v < 10; v++) {
            swap(dp, tmp);
            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= tar; j++) {
                    dp[i][j] = 0;
                }
            }

            for (int sel = 0; sel <= cnt[v]; sel++) {
                for (int i = 0; i + sel <= m; i++) {
                    for (int j = 0; j + v * sel <= tar; j++) {
                        dp[i + sel][j + v * sel] += tmp[i][j] * C(m - i, sel) * C(n - m - (tot - i), cnt[v] - sel);
                    }
                }
            }

            tot += cnt[v];
        }

        return dp[m][tar].x;
    }
};",1441322604
Wanjun Li,wjli,63,3627,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					tt = max(moveTime[xx][yy] + 1, t + 1);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};",1441291066
Wanjun Li,wjli,63,3628,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt, dt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					if ((xx + yy) & 1) dt = 1;
					else dt = 2;
					tt = max(moveTime[xx][yy] + dt, t + dt);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};

",1441292925
Wanjun Li,wjli,63,3636,cpp,"


// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	bool isBalanced(string num) {
		int n = num.size(), i, j, k;
		VI s(2, 0);
		FOR(i, n) s[i & 1] += num[i] - '0';
		return s[0] == s[1];
	}
};
",1441281367
Wanjun Li,wjli,63,3637,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class factorial {
public:
    LL MAXX, MOD;
    VL f, ff;

    factorial(LL maxx = 200010, LL mod = 998244353) {
        MAXX = maxx;
        MOD = mod;

        f.RSZ(MAXX);
        ff.RSZ(MAXX);

        f[0] = 1;
        for (int i = 1; i < MAXX; i++) f[i] = (f[i - 1] * i) % MOD;
        for (int i = 0; i < MAXX; i++) ff[i] = mul_inv(f[i], MOD);
    }

    long long mul_inv(long long a, long long b)
    {
        long long b0 = b, t, q;
        long long x0 = 0, x1 = 1;
        if (b == 1) return 1;
        while (a > 1) {
            q = a / b;
            t = b, b = a % b, a = t;
            t = x0, x0 = x1 - q * x0, x1 = t;
        }
        if (x1 < 0) x1 += b0;
        return x1;
    }

    long long division(long long a, long long b) {		// (a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p
        long long ans, inv;
        inv = mul_inv(b, MOD);
        ans = ((a % MOD) * inv) % MOD;
        return ans;
    }

    LL calcc(LL n, LL a) {
        if (n == a) return 1;
        if (n == 0) return 0;
        if (n < a) return 0;
        LL ans = (f[n] * ff[a]) % MOD;
        ans = (ans * ff[n - a]) % MOD;
        return ans;
    }

    LL calcp(LL n, LL a) {
        LL ans = (f[n] * ff[n - a]) % MOD;
        return ans;
    }

    LL ball_in_box(LL box, LL ball) {    // # of ways of putting k balls to n boxes; boxes can be empty
        if (box == 0) return (ball == 0);
        LL ans = calcc(ball + box - 1, ball);
        return ans;
    }


    LL exp(LL base, LL n, LL MODD = -1) {
        LL mod;
        if (MODD == -1) mod = MOD;
        else mod = MODD;

        base %= mod;
        LL ans = 1, x = base, MAXLEVEL = 60, i;

        for (i = 0; i < MAXLEVEL; i++) {
            if ((1LL << i) > n) break;
            if ((1LL << i) & n) ans = (ans * x) % mod;
            x = (x * x) % mod;
        }
        return ans;
    }

    LL exp_abc(LL a, LL b, LL c) {  // a ^ (b ^ c) $ MOD where b and c can be very big
        // https://www.geeksforgeeks.org/find-power-power-mod-prime/#
        // Fermat's Little: a ^ (MOD - 1) = 1 % MOD
        // a ^ (b ^ c) % MOD = a ^ (b ^ c % (MOD - 1)) % MOD

        LL bc = exp(b, c, MOD - 1);
        LL ans = exp(a, bc);
        return ans;
    }


    LL sum_arithmetic_sequence(LL first_item, LL difference, LL n) {
        LL ans, last = (first_item + difference * (n - 1)) % MOD;
        ans = ((first_item + last) * n / 2) % MOD;

        return ans;
    }

    LL sum_geometry_sequence(LL first_item, LL ratio, LL n) {
        LL ans;

        if (ratio == 1) ans = (first_item * n) % MOD;
        else if (n == 1) ans = first_item;
        else {
        https://www.mathsisfun.com/algebra/sequences-sums-geometric.html
            LL rn = exp(ratio, n);
            ans = (first_item * (1 - rn + MOD)) % MOD;
            ans = division(ans, 1 - ratio + MOD) % MOD;
        }
        return ans;
    }
};

class Solution {
public:
	int countBalancedPermutations(string num) {
		LL n = num.length(), i, j, k, ans = 0, MOD = 1000000007, s, m, ss, sss, cc;
		VL ct(10, 0);
		s = 0;
		FOR(i, n) {
			ct[num[i] - '0']++;
			s += num[i] - '0';
		}
        factorial f(n + 100, MOD);

		if (s & 1) return 0;
        ss = s / 2;

		m = n / 2;

		// dp[digit][ct][sum] = # of ways
        VVL dp(m + 1, VL(ss + 1, 0)), dp2 = dp; 
        cc = 0;
        dp[0][0] = 1;
        FOR(i, 10) {
            if (ct[i] == 0) continue;
            cc += ct[i];
            swap(dp, dp2);
            dp.assign(m + 1, VL(ss + 1, 0));

            FOR(j, m + 1) {
                FOR(k, ss + 1) {
                    if (dp2[j][k] == 0) continue;

                    sss = k;
                    FOR(v, ct[i] + 1) {
                        if ((v + j > m) || (sss > ss)) break;
                        
                        LL x = (f.calcc(j + v, v) * f.calcc(cc - (j + v), (ct[i] - v))) % MOD;
						dp[j + v][sss] = (dp[j + v][sss] + dp2[j][k] * x) % MOD;
                        sss += i;
                    }
                }
            }

            k = 0;
        }

        ans = dp[m][ss];

		ans %= MOD;
		return ans;
	}
};

",1441316234
Kishan Jaiswal,kishan_jaiswal,64,3627,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) { return {dx, dy}; }

    vector<pair<int, int>> getDirections() {
        return {addDirection(-1, 0), addDirection(1, 0), addDirection(0, -1),
                addDirection(0, 1)};
    }

    int maxSum(int a, int b) { return max(a, b) + 1; }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();

        vector<vector<int>> minTime(
            rows, vector<int>(cols, numeric_limits<int>::max()));
        minTime[0][0] = 0;

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            queue;
        queue.push({0, 0, 0});

        auto directions = getDirections();

        while (!queue.empty()) {
            auto [currentTime, x, y] = queue.top();
            queue.pop();

            if (x == rows - 1 && y == cols - 1) {
                return currentTime;
            }

            if (currentTime > minTime[x][y]) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int newX = x + dx;
                int newY = y + dy;

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int newTime = maxSum(currentTime, moveTime[newX][newY]);

                    if (newTime < minTime[newX][newY]) {
                        minTime[newX][newY] = newTime;
                        queue.push({newTime, newX, newY});
                    }
                }
            }
        }

        return -1;
    }
};",1441321018
Kishan Jaiswal,kishan_jaiswal,64,3628,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) {
    return {dx, dy};
}

vector<pair<int, int>> getDirections() {
    return {addDirection(1, 0), addDirection(-1, 0), addDirection(0, 1), addDirection(0, -1)};
}

int calculateNextTime(int time, int moveTime, int moveDuration) {
    return max(time, moveTime) + moveDuration;
}

int minTimeToReach(vector<vector<int>>& moveGrid) {
    int rows = moveGrid.size(), cols = moveGrid[0].size();
    vector<vector<array<int, 2>>> minDist(rows, vector<array<int, 2>>(cols, {numeric_limits<int>::max(), numeric_limits<int>::max()}));
    
    minDist[0][0][0] = 0;
    
    priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> queue;
    queue.push({0, 0, 0, 0});

    auto directions = getDirections();

    while (!queue.empty()) {
        auto [time, x, y, parity] = queue.top();
        queue.pop();

        if (x == rows - 1 && y == cols - 1) {
            return time;
        }

        if (time > minDist[x][y][parity]) {
            continue;
        }

        int moveDuration = (parity == 0) ? 1 : 2;

        for (auto [dx, dy] : directions) {
            int newX = x + dx;
            int newY = y + dy;

            if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                int nextTime = calculateNextTime(time, moveGrid[newX][newY], moveDuration);
                int nextParity = 1 - parity;

                if (nextTime < minDist[newX][newY][nextParity]) {
                    minDist[newX][newY][nextParity] = nextTime;
                    queue.push({nextTime, newX, newY, nextParity});
                }
            }
        }
    }

    return -1;
}
};",1441322853
Kishan Jaiswal,kishan_jaiswal,64,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long  cnt=1;
        int n=num.size();
        long long  sum1=0;
        long long  sum2=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                sum1+=(num[i]-'0')%10;
            }else{
                sum2+=(num[i]-'0')%10;
            }
        }
        return sum1==sum2?true:false;
    }
};",1441301786
Kishan Jaiswal,kishan_jaiswal,64,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

using namespace std;

class Solution {
public:
    int countBalancedPermutations(string n) {
        const int MOD = 1000000007;
        int length = n.length();
        int totalSum = 0;
        vector<int> digitCount(10, 0);
        
        for (char digit : n) {
            digitCount[digit - '0']++;
            totalSum += (digit - '0');
        }
        if (totalSum % 2 != 0) return 0;
        
        int halfSum = totalSum / 2;
        int halfLength = (length + 1) / 2;
        vector<long> factorials(length + 1);
        factorials[0] = 1;
        
        for (int i = 1; i <= length; i++) 
            factorials[i] = multiply(factorials[i - 1], i, MOD);
        
        vector<long> inverseFactorials(length + 1);
        inverseFactorials[length] = calculateModInverse(factorials[length], MOD);
        
        for (int i = length - 1; i >= 0; i--) 
            inverseFactorials[i] = multiply(inverseFactorials[i + 1], (i + 1), MOD);
        
        vector<vector<long>> dpTable(halfLength + 1, vector<long>(halfSum + 1, 0));
        dpTable[0][0] = 1;

        for (int digit = 0; digit <= 9; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int k = halfLength; k >= 0; k--) {
                for (int s = halfSum; s >= 0; s--) {
                    if (dpTable[k][s] == 0) continue;
                    for (int t = 1; t <= digitCount[digit] && k + t <= halfLength && s + digit * t <= halfSum; t++) {
                        dpTable[k + t][s + digit * t] = add(dpTable[k + t][s + digit * t], multiply(dpTable[k][s], computeCombination(digitCount[digit], t, factorials, inverseFactorials, MOD), MOD), MOD);
                    }
                }
            }
        }

        long ways = dpTable[halfLength][halfSum];
        long result = multiply(factorials[halfLength], factorials[length - halfLength], MOD);
        
        for (int digit = 0; digit <= 9; digit++) {
            result = multiply(result, inverseFactorials[digitCount[digit]], MOD);
        }
        
        result = multiply(result, ways, MOD);
        return static_cast<int>(result);
    }

private:
    long add(long a, long b, int mod) {
        return (a + b) % mod;
    }

    long multiply(long a, long b, int mod) {
        return (a * b) % mod;
    }

    long calculateModInverse(long a, int mod) {
        long result = 1;
        long exponent = mod - 2;
        long base = a;
        while (exponent > 0) {
            if ((exponent & 1) == 1) {
                result = multiply(result, base, mod);
            }
            base = multiply(base, base, mod);
            exponent >>= 1;
        }
        return result;
    }

    long computeCombination(int n, int k, const vector<long>& factorials, const vector<long>& invFactorials, int mod) {
        if (k > n) return 0;
        return multiply(factorials[n], multiply(invFactorials[k], invFactorials[n - k], mod), mod);
    }
};
",1441329757
SheenYangYun,SheenYangYun,65,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vvi dp = init(n, m);
        dp[0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(stateStart(0, 0, 0));
        vector<int> directions = { -1, 0, 1, 0, -1 };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (ff(current, n, m)) return current.time;
            if (fff(current, dp)) continue;
            children(current, moveTime, dp, pq, directions, n, m);
        }
        return -1;
    }

private:
    vvi init(int n, int m) {
        return vvi(n, vector<int>(m, INT32_MAX));
    }

    State stateStart(int time, int x, int y) {
        return State{ time, x, y };
    }

    bool ff(const State& state, int n, int m) {
        return state.x == n - 1 && state.y == m - 1;
    }

    bool fff(const State& state, const vvi& dp) {
        return state.time > dp[state.x][state.y];
    }

    bool chek(int x, int y, int n, int m) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    void children(const State& current, const vvi& moveTime, 
                         vvi& dp, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vector<int>& directions, int n, int m) {
        for(int k = 0; k < 4; ++k){
            int newX = current.x + directions[k];
            int newY = current.y + directions[k + 1];
            if(chek(newX, newY, n, m)){
                int newTime = max(current.time, moveTime[newX][newY]) + 1;
                if(newTime < dp[newX][newY]){
                    dp[newX][newY] = newTime;
                    pq.push(stateStart(newTime, newX, newY));
                }
            }
        }
    }
};

",1441321118
SheenYangYun,SheenYangYun,65,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
    int p;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vvi> dist = init(n, m);
        dist[0][0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(start(0, 0, 0, 0));
        vvi dirs = { {1,0},{-1,0},{0,1},{0,-1} };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (solved(current, n, m)) return current.time;
            if (possible(current, dist)) continue;
            chuildren(current, moveTime, dist, pq, dirs, n, m);
        }
        return -1;
    }

private:
    vector<vvi> init(int n, int m) {
        return vector<vvi>(n, vvi(m, vector<int>(2, INT32_MAX)));
    }

    State start(int time, int x, int y, int p) {
        return State{ time, x, y, p };
    }

    bool solved(const State& state, int n, int m) {
        return state.x == n -1 && state.y == m -1;
    }

    bool possible(const State& state, const vector<vvi>& dist) {
        return state.time > dist[state.x][state.y][state.p];
    }

    bool check(int x, int y, int n, int m) {
        return x >=0 && x <n && y >=0 && y <m;
    }

    void chuildren(const State& current, const vvi& moveTime, 
                         vector<vvi>& dist, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vvi& dirs, int n, int m) {
        int moveDuration = current.p == 0 ? 1 : 2;
        for(auto &d : dirs){
            int nx = current.x + d[0];
            int ny = current.y + d[1];
            if(check(nx, ny, n, m)){
                int nextTime = max(current.time, moveTime[nx][ny]) + moveDuration;
                int nextP = current.p == 0 ? 1 : 0;
                if(nextTime < dist[nx][ny][nextP]){
                    dist[nx][ny][nextP] = nextTime;
                    pq.push(start(nextTime, nx, ny, nextP));
                }
            }
        }
    }
};
",1441314554
SheenYangYun,SheenYangYun,65,3636,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    bool isBalanced(const string &num)
    {
        int cnt1 = 0;
        int cnt2 = 0;

        for (int i = 0; i < num.size(); ++i)
        {
            int digit = num[i] - '0';
            if (i & 1)
            {
                cnt2 += digit;
                continue;
            }

            cnt1 += digit;
        }

        return cnt1 == cnt2;
    }
};
",1441323172
SheenYangYun,SheenYangYun,65,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int freq[10] = {0};
        for (char c : num)
        {
            freq[c - '0']++;
        }

        int n = num.size();
        int nEven = (n + 1) / 2;
        int nOdd = n / 2;

        ll sum = 0;
        for (int d = 0; d < 10; d++)
        {
            sum += (ll)d * freq[d];
        }

        if (sum & 1)
        {
            return 0;
        }

        ll des = sum / 2;

        vector<vector<ll>> dp(nEven + 1, vector<ll>(des + 1, 0));
        dp[0][0] = 1;

        vector<ll> fact(n + 1, 1);
        for (int i = 1; i <= n; i++)
        {
            fact[i] = fact[i - 1] * i % MOD;
        }

        auto pow_mod = [&](ll a, ll b) -> ll
        {
            ll res = 1;
            a %= MOD;
            while (b > 0)
            {
                if (b & 1)
                {
                    res = res * a % MOD;
                }
                a = a * a % MOD;
                b >>= 1;
            }
            return res;
        };

        vector<ll> invFact(n + 1, 1);
        invFact[n] = pow_mod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
        {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }

        ll inFact = 1;
        for (int d = 0; d < 10; d++)
        {
            inFact = inFact * invFact[freq[d]] % MOD;
        }

        for (int d = 0; d < 10; d++)
        {
            int c = freq[d];
            if (c == 0)
                continue;

            for (int k = nEven; k >= 0; k--)
            {
                for (ll s = des; s >= 0; s--)
                {
                    if (dp[k][s] == 0)
                    {
                        continue;
                    }

                    int max_m = min(c, nEven - k);
                    for (int m = 1; m <= max_m; m++)
                    {
                        ll newK = k + m;
                        ll newS = s + (ll)d * m;
                        if (newS > des)
                        {
                            break;
                        }

                        ll comb_val = fact[c] * invFact[m] % MOD;
                        comb_val = comb_val * invFact[c - m] % MOD;

                        dp[newK][newS] = (dp[newK][newS] + dp[k][s] * comb_val) % MOD;
                    }
                }
            }
        }

        ll ans = dp[nEven][des];
        if (ans != 0)
        {

            ans = ans * fact[nEven] % MOD;
            ans = ans * fact[nOdd] % MOD;
            ans = ans * inFact % MOD;

            return (int)(ans);
        }

        return 0;
    }
};
",1441307925
Tin,tin_le,67,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, std::greater<array<ll, 3>>> minHeap;
        minHeap.push({0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<ll>> dp(n, vector<ll>(m, INF));
        dp[0][0] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)(cost + 1), (ll)moveTime[row][col] + 1);
                if(newCost < dp[row][col]) {
                    dp[row][col] = newCost;
                    minHeap.push({newCost, row, col});
                }
            }
        }
        return -1;
    }
};",1441296900
Tin,tin_le,67,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, std::greater<array<ll, 4>>> minHeap;
        minHeap.push({0, 0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        dp[0][0][0] = dp[0][0][1] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j, k] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j][k]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)cost, (ll)moveTime[row][col]) + (k == 0 ? 1 : 2);
                if(newCost < dp[row][col][!k]) {
                    dp[row][col][!k] = newCost;
                    minHeap.push({newCost, row, col, !k});
                }
            }
        }
        return -1;
    }
};",1441301018
Tin,tin_le,67,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        int n = num.size();
        for(int i = 0; i < n; i++) {
            if(i & 1) odd += num[i] - '0';
            else even += num[i] - '0';
        }
        return odd == even;
    }
};",1441280985
Tin,tin_le,67,3637,cpp,"//
//
//
//
//
//
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vvpll vt<vpll>
#define vvvll vt<vvll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
class Combinatoric {    
    public: 
    int n;  
    vll fact, inv;   
    Combinatoric(int n) {   
        this->n = n;    
        fact.rsz(n + 1), inv.rsz(n + 1);
        init();
    }
        
    void init() {   
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {   
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        inv[n] = modExpo(fact[n], MOD - 2, MOD);
        for(int i = n - 1; i >= 0; i--) {   
            inv[i] = (inv[i + 1] * (i + 1)) % MOD;
        }
    }
    
    ll choose(ll a, ll b) {  
		if(a < b) return 0;
        return fact[a] * inv[b] % MOD * inv[a - b] % MOD;
    }
};
class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        int freq[10] = {};
        for(auto& x : s) {
            freq[x - '0']++;
        }
        ll sm = 0;
        for(int i = 0; i <= 9; i++) {
            sm += (ll)i * freq[i];
        }
        if(sm % 2) return 0;
        ll target = sm / 2;
        int k = (n + 1) / 2, l = n / 2;
        Combinatoric comb(n + 1);
        vector<vector<ll>> dp(k + 1, vector<ll>(target + 1));
        dp[0][0] = 1;
        for(int d = 0; d <= 9; d++) {
            if(freq[d] == 0) continue;
            for(int c = k; c >= 0; c--) {
                for(ll S = target; S >= 0; S--) {
                    if(dp[c][S] == 0) continue;
                    for(int cnt = 1; cnt <= freq[d] && cnt <= k - c; cnt++) {
                        if(S + d * cnt > target) break;
                        auto& A = dp[c + cnt][S + d * cnt];
                        A = (A + dp[c][S] * comb.choose(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        ll prod = 1;
        for(int d = 0; d <= 9; d++) {
            prod = prod * comb.fact[freq[d]] % MOD;
        }
        return (dp[k][target]) * comb.fact[k] % MOD * comb.fact[l] % MOD * modExpo(prod, MOD - 2, MOD) % MOD;
    }
};",1441323448
despair of athkatla,nibbas,68,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        vis = [[math.inf] * m for _ in range(n)]
        heap = [(0, 0, 0)]
        vis[0][0] = 0
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if x == n-1 and y == m-1:
                return t
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(heap, (nt, nx, ny))",1441292174
despair of athkatla,nibbas,68,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        INF = math.inf
        dist = [[INF]*m for _ in range(n)]
        dist[0][0] = 0
        heap = []
        heappush(heap, (0, 0, 0, 0))
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y, p = heappop(heap)
            if x == n-1 and y == m-1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0<=nx<n and 0<=ny<m:
                    d = 1 if p ==0 else 2
                    nt = max(t, moveTime[nx][ny]) + d
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(heap, (nt, nx, ny, 1 - p))
        return -1",1441298863
despair of athkatla,nibbas,68,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441282709
despair of athkatla,nibbas,68,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
  
  const long long INF = 9223372036854775807;

  #ifndef ONLINE_JUDGE
  #define WATCH(key, val)                                                        \
    printf(""Watched %s ->  %s \n"", key, std::to_string(val).c_str());
  #define WATCH_CONTAINER(key, val)                                              \
    printf(""Watched %s : "", key);                                                \
    for (auto e : val)                                                           \
      printf("" %s"", std::to_string(e).c_str());                                  \
    printf(""\n"");
  #define WATCH_MAP(map)                                                         \
    printf(""Watching Map\n"");                                                    \
    for (auto e : map)                                                           \
      printf(""%s -> %s\n"", std::to_string(e.first).c_str(),                      \
            std::to_string(e.second).c_str());                                  \
    printf(""\n"");
  #else
  #define WATCH(key, val)                                                        \
    do {                                                                         \
    } while (false);
  #define WATCH_CONTAINER(key, val)                                              \
    do {                                                                         \
    } while (false);
  #define WATCH_MAP(map)                                                         \
    do {                                                                         \
    } while (false);
  #endif

  #ifdef FAST_EXECUTION
  #pragma GCC optimize(""O3"")
  #pragma comment(linker, ""/stack:247474112"")
  #endif

  #define REP(n) for(int t=0; t<n; t++)
  #define FOR(i, n) for (i = 0; i < n; i++)
  #define FFOR(i, j, n) for(i = j; j < n; j++)
  #define FOR_S(i, n, k) for (i = 0; i < n; i += k)
  #define RFOR(i, n) for (i = n - 1; i >= 0; i--)
  #define RFOR_S(i, n, k) for (i = n - 1; i >= 0; i -= k)
  #define MAX_OF(x, y) ((x > y) ? x : y)
  #define MIN_OF(x, y) ((x > y) ? y : x)
  #define MIN_IN(A) *(std::min_element(A.begin(), A.end()));
  #define MAX_IN(A) *(std::max_element(A.begin(), A.end()));
  #define MAX_AT(A) (std::max_element(A.begin(), A.end()) - A.begin());
  #define MIN_AT(A) (std::min_element(A.begin(), A.end()) - A.begin());
  #define TESTCASE                                                              \
    int testcase;                                                               \
    std::cin>>testcase;                                                         \
    while(testcase--)
  #define GCD(a,b) std::__gcd(a,b);
  #define LCM(a,b) (a)*((b)/std::__gcd(a,b));
  #define SORT(A) std::sort(A.begin(), A.end());
  #define RSORT(A) std::sort(A.rbegin(), A.rend());
  #define REVERSE(A) std::reverse(A.begin(), A.end());
  #define ANY(container, result, condition)                                      \
    result = false;                                                              \
    for (const auto &e : container)                                              \
      if (condition(e)) {                                                        \
        result = true;                                                           \
        break;                                                                   \
      }
  #define ALL(container, result, condition)                                      \
    result = true;                                                               \
    for (const auto &e : container)                                              \
      if (!condition(e)) {                                                       \
        result = false;                                                          \
        break;                                                                   \
      }
  #ifdef INTERACTIVE_MODE
  #define iprint(...)                                                            \
    printf(__VA_ARGS__);                                                         \
    fflush(stdout);
  #else
  #define iprint(...) printf(__VA_ARGS__);
  #endif

  #define LL long long
  #define L long
  #define ULL unsigned long long
  #define I int
  #define D double
  #define UI unsigned int
  #define VEC(i) std::vector<i>
  #define MAP(a, b) std::map<a, b>
  #define UMAP(a, b) std::unordered_map<a, b>
  #define SET(a) std::set<a>
  #define USET(a) std::unordered_set<a>
  #define MSET(a) std::multiset<a>
  #define STR std::string
  #define PAIR(a,b) std::pair<a,b>
  #define PAIRI std::pair<int, int>
  #define READ_INT(var) scanf(""%d"", &var)
  #define READ_STR(var) std::cin >> var
  #define READ_LONG(var) scanf(""%lld"", &var)
  #define WRITE_INT(var) printf(""%d"", var)
  #define WRITE_LONG(var) printf(""%lld"", var)
  #define WRITE_STR(var) std::cout << var
  #define WRITE_VEC_LL(val)                                                      \
    for (auto e : val)                                                           \
      printf(""%lld "", e);
  #define WRITE_VEC_I(val)                                                       \
    for (auto e : val)                                                           \
      printf(""%d "", e);
      
  #define pb push_back
  #define eb emplace_back


class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> cnt(10, 0);
        int S = 0;
        for (char ch : s) {
            cnt[ch - '0']++;
            S += (ch - '0');
        }
        
        if (S % 2 != 0) return 0;
        
        int T = S / 2;
        int K = (n + 1) / 2;
    
        vector<long long> F(n + 1, 1), IF(n + 1, 1);
        for (int i = 1; i <= n; i++) F[i] = F[i - 1] * i % MOD;

        auto pw = [&](ll a, ll b) -> ll {
            ll R = 1;
            a %= MOD;
            while (b > 0) {
                if (b & 1) R = R * a % MOD;
                a = a * a % MOD;
                b >>= 1;
            }
            return R;
        };
        
        IF[n] = pw(F[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) IF[i] = IF[i + 1] * (i + 1) % MOD;
        
        vector<vector<long long>> dp(K + 1, vector<long long>(T + 1, 0));
        dp[0][0] = 1;
        
        for (int d = 0; d <= 9; d++) {
            if (cnt[d] == 0) continue;
            for (int t = K; t >= 0; t--) {
                for (int s = T; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int x = 1; x <= min(cnt[d], K - t) && s + x * d <= T; x++) {
                        dp[t + x][s + x * d] = (dp[t + x][s + x * d] + dp[t][s] * F[cnt[d]] % MOD * IF[x] % MOD * IF[cnt[d] - x] % MOD) % MOD;
                    }
                }
            }
        }
        
        ll R = dp[K][T] * F[K] % MOD * F[n - K] % MOD;
        for (int d = 0; d <= 9; d++) {
            R = R * IF[cnt[d]] % MOD;
        }
        
        return (int)R;
    }
};
",1441316716
Lucky Orb,megurine,69,3627,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + 1, xx, yy))
        # print(f)
        return f[n - 1][m - 1]
        ",1441300238
Lucky Orb,megurine,69,3628,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + (x + y) % 2 + 1, xx, yy))
        print(f)
        return f[n - 1][m - 1]
""""""
[[0,58],[27,69]]
71
""""""",1441304557
Lucky Orb,megurine,69,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        return sum(map(int, s[::2])) == sum(map(int, s[1::2]))",1441281574
Lucky Orb,megurine,69,3637,cpp,"#include <bits/stdc++.h>

#ifdef MEGURINE
#include ""algo/debug.h""
#include ""algo/debug_lc.h""
#else
#define debug(...) 42
#endif

using namespace std;

auto __fast_io__ = [] {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

#define itr(it) begin(it), end(it)

// @formatter:off
template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a;
        swap(a, m);
        u -= t * v;
        swap(u, v);
    }
    assert(m == 1);
    return u;
}

template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() :
        value() {}

    template <typename U>
    Modular(const U &x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U &x) {
        Type v;
        if (-mod() <= x && x < mod())
            v = static_cast<Type>(x);
        else
            v = static_cast<Type>(x % mod());
        if (v < 0)
            v += mod();
        return v;
    }

    const Type &operator()() const { return value; }

    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }

    constexpr static Type mod() { return T::value; }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= mod())
            value -= mod();
        return *this;
    }

    Modular &operator-=(const Modular &other) {
        if ((value -= other.value) < 0)
            value += mod();
        return *this;
    }

    template <typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template <typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }
    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(
        const Modular &rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }

    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type &abs(const Modular &x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename U>
    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename V, typename U>
    friend V &operator>>(V &stream, Modular<U> &number);

    template <typename V>
    operator V() { return (V)value; }

private:
    Type value;
};

template <typename T>
bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }

template <typename T, typename U>
bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }

template <typename T, typename U>
bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }

template <typename T>
bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T>
bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }

template <typename T>
Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T>
Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T>
Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T>
Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> power(const Modular<T> &a, const U &b) {
    if (b < 0)
        return 1 / power(a, -b);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1)
            res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}

template <typename T>
bool IsZero(const Modular<T> &number) {
    return number() == 0;
}

template <typename T>
string to_string(const Modular<T> &number) {
    return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U &operator<<(U &stream, const Modular<T> &number) {
    return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U &operator>>(U &stream, Modular<T> &number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}

//using ModType = int;
//
//struct VarMod { static ModType value; };
//ModType VarMod::value;
//ModType &md = VarMod::value;
//using Mint = Modular<VarMod>;

// constexpr int md = 998244353;
constexpr int md = 1e9 + 7;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
// @formatter:on

vector<Mint> fact;
vector<Mint> inv_fact;

Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int)fact.size() < n + 1) {
        if (fact.empty()) {
            fact = inv_fact = {1};
            continue;
        }
        fact.push_back(fact.back() * (int)fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        int m = 0, k1 = (s.size() + 1) / 2, k2 = s.size() - k1;
        vector<int> cnt(10);
        for (char x : s)
            m += x - '0', cnt[x - '0']++;
        if (m % 2)
            return 0;
        m /= 2;
        if (m == 0)
            return 1;
        vector f(k2 + 1, vector<Mint>(m + 1));
        f[0][0] = 1;
        int p = 0, q = 0;
        for (int x = 0; x < 10; ++x) {
            if (!cnt[x]) continue;
            vector h(k2 + 1, vector<Mint>(m + 1));
            p += cnt[x], q += cnt[x] * x;
            for (int i = 0; i <= k2 && i + cnt[x] <= p; ++i) {
                for (int j = 0; j <= m; ++j) {
                    for (int k = 0; k <= cnt[x]; ++k) {
                        int ii = i + k, jj = j + x * k;
                        if (ii <= k2 && jj <= m && p - ii <= k1 && q - jj <= m) {
                            h[ii][jj] += f[i][j] * C(k2 - i, k) * C(k1 - (p - cnt[x] - i), cnt[x] - k);
                        }
                    }
                }
            }
            h.swap(f);
        }
        return f[k2][m];
    }
};

#ifdef MEGURINE

int main() {
    freopen(""../input.txt"", ""r"", stdin);
    freopen(""../output.txt"", ""w"", stdout);
    clock_t start_time = clock();
    int T;
    cin >> T;
    getchar();
    while (T--) {
        Solution sol;
        test<string>(sol, &Solution::countBalancedPermutations);
    }
    cout << ""\nExecution Time: "" << static_cast<double>(clock() - start_time) / CLOCKS_PER_SEC * 1000 << ""ms"" << endl;
    return 0;
}

#endif
",1441330841
4dalols,4dalols,70,3627,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441317045
4dalols,4dalols,70,3628,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1+(cx+cy)%2; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441316390
4dalols,4dalols,70,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int t=0,i=1;
        for (auto r:s) {
            t+=i*(r-'0');
            i=-i;
        }
        return t==0;
    }
};",1441318720
4dalols,4dalols,70,3637,cpp,"class Solution {
public:
    const int MX = 100;
    long long F[101], Fi[101], mod=1e9+7;
     
    long long pw(long long b, long long e) {
    	int x=1;
    	while (e) {
    		if (e%2) x=x*b%mod; 
    		b=b*b%mod; 
    		e/=2; 
    	}
    	return x;
    }
     
    long long nCk(int n, int k) {
        if (k>n||k<0) return 0;
        return F[n]*Fi[k]%mod*Fi[n-k]%mod;
    }
     
    void initC() {
    	F[0]=1;
    	for (int i = 1; i <= MX; i++) F[i]=F[i-1]*i%mod;
        Fi[MX]=pw(F[MX],mod-2);
    	for (int i = MX; i; i--) Fi[i-1]=Fi[i]*i%mod;
    }
     
    int countBalancedPermutations(string s) {
        int n= s.size(); 
        initC();
        int t=0;
        map<int,int> m; 
        for (auto r:s) {
            m[r-'0']++;
            t+=r-'0'; 
        }
        if (t%2) return 0;
        vector<vector<long long>> dp(n+1,vector<long long>(t+1)); dp[0][0]=1; 
        int x=0;
        for (auto [a,b]:m) {
            x+=b;
        vector<vector<long long>> dp2(n+1,vector<long long>(t+1));
            // cout << a << "" "" << b << endl; 
            for (int i = 0; i <= b; i++) {
                for (int j = n; j>=i; j--) {
                    for (int k=t;k>=a*i;k--) {
                        (dp2[j][k]+=dp[j-i][k-a*i]*nCk(j,i)%mod*nCk(x-j,b-i))%=mod;
                    }
                }
            }
            dp=dp2;
        // for (auto r:dp) {
        //     for (int j:r) cout << j << "" ""; cout << ""\n"";
        // } cout << ""\n"";
        }
        return dp[(n+1)/2][t/2]; 
    }
};",1441307470
Brijesh Siwach,Dhongee,71,3627,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 1 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};",1441337879
Brijesh Siwach,Dhongee,71,3628,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 2 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};
",1441336728
Brijesh Siwach,Dhongee,71,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int s1 = 0,s2=0;
        for(int i = 0 ; i < n; i++){
            if(i%2) s1+=(s[i]-'0');
            else s2+=(s[i]-'0');
        }
        return s1==s2;
    }
};",1441339150
Brijesh Siwach,Dhongee,71,3637,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:

    ll binpow(ll a,ll b,const int mod){
        ll res=1;
        while(b>0) {
            if(b&1) res=res*a%mod;
            b>>=1;
            a=a*a%mod;
        }
        return res;
    }

    int countBalancedPermutations(string s) {
        int n = s.size();
        const int mod=1e9+7;
        vector<ll> fact(n+1,1);
        vector<ll> inv(n+1);
        for(int i = 1; i <= n; i++){
            fact[i] = fact[i-1] * i % mod;
        }
        for(int i = 0; i <= n; i++){
            inv[i] = binpow(fact[i], mod-2, mod);
        }   

        auto mul = [&](ll x,ll y)->ll{
            return (x%mod * y%mod)%mod;
        };
        auto add = [&](ll x,ll y)->ll{
            return (x%mod + y%mod)%mod;
        };

        vector<ll>f(10);
        int sum = 0;
        for(auto x: s) {
            f[x-'0']++;
            sum += (x-'0');
        }
        const int M = 8e2;
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (n+1, vector<ll> (M, -1)));

        function<ll(int,int,int)>go=[&](int pos,int ot, int ost) -> ll{
            if(pos==10) {
                if(ot != (n+1)/2) return 0;
                if(ost != sum - ost) return 0;
                return mul(fact[ot], fact[n-ot]);
            }

            if(dp[pos][ot][ost] == -1) {
                ll ans = 0;
                for(int i = 0; i <= f[pos]; i++){
                    ll val = mul(inv[i], inv[f[pos]-i]);

                    ans = add(ans, mul(go(pos+1,ot+i,ost+i*pos),val));
                }
                dp[pos][ot][ost]=ans;
            }
            return dp[pos][ot][ost];
        };

        ll ans = go(0, 0, 0);

        return ans;

    }
};
",1441315427
Rastsislau Matusevich,rastsislau,72,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int move_time = max(t, moveTime[new_x][new_y]) + 1;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441301173
Rastsislau Matusevich,rastsislau,72,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int cost = (x + y) % 2 + 1;
                        int move_time = max(t, moveTime[new_x][new_y]) + cost;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441305087
Rastsislau Matusevich,rastsislau,72,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector <int> sum(2,0);
        int i=0;
        for (auto x: num)
            {
                sum[i%2]+=(x-'0');
                i++;
            }
        return sum[0] == sum[1];
    }
};",1441281746
Rastsislau Matusevich,rastsislau,72,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10**9 + 7
        counts = [0] * 10
        total_sum = 0
    
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total_sum += d
    
        if total_sum % 2 != 0:
            return 0
    
        n_even = (n + 1) // 2 
        n_odd = n // 2 
    
        max_s = n_even * 9
    
        max_fact = n + 1
        fact = [1] * (max_fact)
        inv_fact = [1] * (max_fact)
        for i in range(1, max_fact):
            fact[i] = (fact[i - 1] * i) % MOD
        inv_fact[max_fact - 1] = pow(fact[max_fact - 1], MOD - 2, MOD)
        for i in range(max_fact - 2, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
    
        comb_cache = {}
        def nCk(n, k):
            if k < 0 or k > n:
                return 0
            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD
    
        dp = [ [0] * (n_even + 1) for _ in range(total_sum // 2 + 1) ]
        dp[0][0] = 1
    
        for d in range(10):
            c_d = counts[d]
            if c_d == 0:
                continue
            dp_new = [row[:] for row in dp]
            for c in range(1, c_d + 1):
                comb_cd_c = nCk(c_d, c)
                delta_s = c * d
                for s in range(total_sum // 2 - delta_s + 1):
                    for k in range(n_even - c +1):
                        dp_new[s + delta_s][k + c] = (dp_new[s + delta_s][k + c] + dp[s][k] * comb_cd_c) % MOD
            dp = dp_new
    
        total_ways = dp[total_sum // 2][n_even]
        if total_ways == 0:
            return 0
    
        numerator = (total_ways * fact[n_even] % MOD) * fact[n_odd] % MOD
        denom = 1
        for c in counts:
            denom = (denom * fact[c]) % MOD
    
        answer = numerator * pow(denom, MOD - 2, MOD) % MOD
        return answer
        ",1441332810
PyIsTheBestLang,PyIsTheBestLang,76,3627,python3,"
def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        dis = [[math.inf] * n for _ in range(m)]
        dis[0][0] = 0
        stack = [(0, 0, 0)]
        while stack:
            d, i, j = heappop(stack)
            
            if dis[i][j] < d:
                continue
            
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0<=a+i<m and 0<=b+j<n:
                    dj = max(d + 1, moveTime[i+a][j+b]+1)
                    if dj < dis[a+i][b+j]:
                        dis[a+i][b+j] = dj
                        heappush(stack, (dj, a+i, j+b))
        ans = dis[-1][-1]
        return ans ",1441302684
PyIsTheBestLang,PyIsTheBestLang,76,3628,python3,"
def max(a, b):
    return a if a > b else b




class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        k = 2
        dis = [[[math.inf] * k for _ in range(n)] for _ in range(m)]
        dis[0][0][0] = 0
        stack = [(0, 0, 0, 0)]
        while stack:
            d, s, i, j = heappop(stack)

            if dis[i][j][s] < d:
                continue
   
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0 <= a + i < m and 0 <= b + j < n:
                    if s == 0:
                        dj = max(d+s+1, moveTime[i + a][j + b]+1)
                    else:
                        dj = max(d+ s + 1, moveTime[i + a][j + b]+2)  
                        
                    if dj < dis[a + i][b + j][(s+1)%2]:
                        dis[a + i][b + j][(s+1)%2] = dj
                        heappush(stack, (dj, (s+1)%2, a + i, j + b))
        ans = min(dis[-1][-1])
        return ans ",1441309881
PyIsTheBestLang,PyIsTheBestLang,76,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) for i in range(1, n, 2)) ==  sum(int(num[i]) for i in range(0, n, 2))",1441302566
PyIsTheBestLang,PyIsTheBestLang,76,3637,python3,"import math
from functools import lru_cache
from itertools import accumulate


# from sortedcontainers import SortedList
# sys.set_int_max_str_digits(0)  # for big number in leet code


def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


mod = 10 ** 9 + 7


class Combinatorics:
    def __init__(self, n, mod):
        assert mod > n
        self.n = n + 10
        self.mod = mod

        self.perm = [1]
        self.rev = [1]
        self.inv = [0]
        self.fault = [0]

        self.build_perm()
        self.build_rev()
        self.build_inv()
        self.build_fault()
        return

    def build_perm(self):
        self.perm = [1] * (self.n + 1)  # (i!) % mod
        for i in range(1, self.n + 1):
            self.perm[i] = self.perm[i - 1] * i % self.mod
        return

    def build_rev(self):
        self.rev = [1] * (self.n + 1)  # pow(i!, -1, mod)
        self.rev[-1] = pow(self.perm[-1], -1, self.mod)  # GcdLike().mod_reverse(self.perm[-1], self.mod)
        for i in range(self.n - 1, 0, -1):
            self.rev[i] = (self.rev[i + 1] * (i + 1) % self.mod)  # pow(i!, -1, mod)
        return

    def build_inv(self):
        self.inv = [0] * (self.n + 1)  # pow(i, -1, mod)
        self.inv[1] = 1
        for i in range(2, self.n + 1):
            self.inv[i] = (self.mod - self.mod // i) * self.inv[self.mod % i] % self.mod
        return

    def build_fault(self):
        self.fault = [0] * (self.n + 1)  # fault permutation
        self.fault[0] = 1
        self.fault[2] = 1
        for i in range(3, self.n + 1):
            self.fault[i] = (i - 1) * (self.fault[i - 1] + self.fault[i - 2])
            self.fault[i] %= self.mod
        return

    def comb(self, a, b):
        if a < b:
            return 0
        res = self.perm[a] * self.rev[b] * self.rev[a - b]  # comb(a, b) % mod = (a!/(b!(a-b)!)) % mod
        return res % self.mod

    def factorial(self, a):
        res = self.perm[a]  # (a!) % mod
        return res % self.mod

    def inverse(self, n):
        res = self.perm[n - 1] * self.rev[n] % self.mod  # pow(n, -1, mod)
        return res

    def catalan(self, n):
        res = (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod
        return res


cb = Combinatorics(200, mod)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        @lru_cache(None)
        def dfs(i, k, pre):
            if k > odd or (m - odd) > even:
                return 0
            if i == 10:
                return pre == 0
            
            
            res = 0
            rest_odd = odd-k
            rest_even = post[-1] - post[i]-rest_odd
            for xx in range(cnt[i] + 1):
                res += dfs(i + 1, k + xx, pre + xx * i - (cnt[i] - xx) * i)*cb.comb(rest_odd, xx)*cb.comb(rest_even, cnt[i]-xx)
            return res % mod

        num = sorted(num)
        m = len(num)
  
        cnt = [0] * 10
        odd = m // 2 + m % 2
        even = m - odd
        for x in num:
            cnt[int(x)] += 1
        post = list(accumulate(cnt, initial=0))
        ans = dfs(0, 0, 0)
        return ans
",1441320219
Xiong_Jiangkai,xlyy,77,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y = q[0]
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n and visited[x_new][y_new] == -1:
                    t_max = max(t, moveTime[x_new][y_new]) + 1
                    visited[x_new][y_new] = t_max
                    heapq.heappush(q, (t_max, x_new, y_new))
        return visited[-1][-1] ",1441316739
Xiong_Jiangkai,xlyy,77,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0, 1)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y, dt = q[0]
            dt_new = 2 if dt == 1 else 1
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n:
                    t_max = max(t, moveTime[x_new][y_new])
                    if (visited[x_new][y_new] == -1 or visited[x_new][y_new] > t_max + dt):
                        visited[x_new][y_new] = t_max + dt
                        heapq.heappush(q, (t_max + dt, x_new, y_new, dt_new))
        return visited[-1][-1] ",1441313622
Xiong_Jiangkai,xlyy,77,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        n = len(num)
        sum1 = sum2 = 0
        for i in range(0, n, 2):
            sum1 += int(num[i])
        for i in range(1, n, 2):
            sum2 += int(num[i])
        return sum1 == sum2",1441281965
Xiong_Jiangkai,xlyy,77,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = int(1e9)+ 7
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
    
        counts = [0] * 10
        total = 0
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total += d
    
        if total %2 != 0:
            return 0
        S = total // 2
    
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] *i % MOD
    
        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


        
        dp_prev = [[0] * (n_even + 1) for _ in range(S + 1)]
        dp_prev[0][0] = 1
        for d in range(10):
            c_d = counts[d]
            if c_d ==0:
                dp_curr = [row[:] for row in dp_prev]
            else:
                dp_curr = [[0] * (n_even + 1) for _ in range(S + 1)]
                k_min = max(0, c_d - n_odd)
                for s in range(S + 1):
                    for c in range(n_even + 1):
                        val = dp_prev[s][c]
                        if val == 0:
                            continue
                        for k in range(k_min, min(c_d, n_even - c) + 1):
                            new_s = s + d * k
                            if new_s > S:
                                continue
                            new_c = c + k
                            if new_c > n_even:
                                continue
                            add_val = val * inv_fact[k] % MOD
                            add_val = add_val * inv_fact[c_d - k] % MOD
                            dp_curr[new_s][new_c] = (dp_curr[new_s][new_c] + add_val) % MOD
                dp_prev = dp_curr
    
        dp_final = dp_prev[S][n_even]
        res = fact[n_even] * fact[n_odd] % MOD
        res = res * dp_final % MOD
        return res",1441334143
Meet Brahmbhatt,MeetBrahmbhatt,78,3627,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 1;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334615
Meet Brahmbhatt,MeetBrahmbhatt,78,3628,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 2;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334276
Meet Brahmbhatt,MeetBrahmbhatt,78,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < (int) s.size(); i++) {
            sum += (s[i] - '0') * (i & 1 ? -1 : 1);
        }
        return !sum;
    }
};",1441322261
Meet Brahmbhatt,MeetBrahmbhatt,78,3637,cpp,"constexpr int32_t MOD = 1e9 + 7;
// constexpr int32_t MOD = 998244353;

struct Mint {
    int val;
    Mint(long long v = 0) {
        if (v < 0) {
            v = v % MOD + MOD;
        }
        if (v >= MOD) {
            v %= MOD;
        }
        val = v;
    }
    static int mod_inv(int a, int m = MOD) {
        int g = m, r = a, x = 0, y = 1;
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
        return x < 0 ? x + m : x;
    }
    explicit operator int() const {
        return val;
    }
    Mint& operator+=(const Mint &other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    Mint& operator-=(const Mint &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    typedef unsigned long long ull;
    ull fast_mod(ull a, ull b, ull M = MOD) {
        long long ret = a * b - M * ull(1.L / M * a * b);
        return ret + M * (ret < 0) - M * (ret >= (long long)M);
    }
    Mint& operator*=(const Mint &other) {
        val = fast_mod((ull) val, other.val);
        return *this;
    }
    Mint& operator/=(const Mint &other) {
        return *this *= other.inv();
    }
    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }
    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }
    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }
    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }
    Mint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
    Mint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }
    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }
    Mint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
    bool operator==(const Mint &other) const { return val == other.val; }
    bool operator!=(const Mint &other) const { return val != other.val; }
    Mint inv() const {
        return mod_inv(val);
    }
    Mint pow(long long p) const {
        assert(p >= 0);
        Mint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            a *= a;
            p >>= 1;
        }
        return result;
    }
    friend ostream& operator<<(ostream &stream, const Mint &m) {
        return stream << m.val;
    }
    friend istream& operator >> (istream &stream, Mint &m) {
        return stream >> m.val;
    }
};

const int32_t N = 100;
bool done = false;
Mint FAC[N + 1], INV[N + 1];

void calc() {
    if (done) {
        return;
    }
    done = true;
    FAC[0] = 1;
    for (int i = 1; i <= N; i++) {
        FAC[i] = (FAC[i - 1] * i);
    }
    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);
    for (int i = N - 1; i >= 0; i--) {
        INV[i] = (INV[i + 1] * (i + 1));
    }
}
Mint ncr(int n, int r) {
    if (r < 0) return 0;
    if (n < r) return 0;
    if (r == 0) return 1;
    Mint a = FAC[n] * INV[r] * INV[n - r];
    return a;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        calc();
        int n = (int) s.size();
        
        vector<int> freq(10);
        for (auto i : s) {
            freq[i - '0']++;
        }
        
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += freq[i] * i;
        }
        
        if (sum & 1) {
            return 0;
        }
        
        sum /= 2;
        vector<vector<Mint>> dp((n / 2) + 1, vector<Mint>(sum + 1));
        dp[0][0] = 1;
        
        for (int i = 0; i < 10; i++) {
            vector<vector<Mint>> ndp(n / 2 + 1, vector<Mint>(sum + 1));
            for (int prev_take = 0; prev_take <= n / 2; prev_take++) {
                for (int take = 0; take <= freq[i] && prev_take + take <= n / 2; take++) {
                    for (int prev_sum = 0; prev_sum + take * i <= sum; prev_sum++) {
                        int new_sum = prev_sum + take * i;
                        int new_take = prev_take + take;
                        ndp[new_take][new_sum] += dp[prev_take][prev_sum] * INV[take] * INV[freq[i] - take];
                    }
                }
            }
            
            dp = ndp;
        }
        
        Mint ans = dp[n / 2][sum] * FAC[n / 2] * FAC[(n + 1) / 2];
        return ans.val;
    }
};",1441321938
Dylan Smith,DylanSmith,79,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + 1;
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441293304
Dylan Smith,DylanSmith,79,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + ((r + c) % 2 == 0 ? 1 : 2);
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441294311
Dylan Smith,DylanSmith,79,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0, o = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2 == 0) {
                e += num[i] - '0';
            } else {
                o += num[i] - '0';
            }
        }
        return e == o;
    }
};",1441281042
Dylan Smith,DylanSmith,79,3637,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

int mod = 1000000007;

ll exGCD(ll a, ll b, ll &x, ll &y) {
    if (a == 0) { x = 0; y = 1; return b; }
    ll g = exGCD(b % a, a, x, y);
    ll t = x; x = y - b / a * x; y = t;
    return g;
}

int mInv(int n) {
    ll x, y, g = exGCD(n, mod, x, y);
    if (g != 1) return 0;
    return (x % mod + mod) % mod;
}

vector<int> factArr = {1}, factInvArr = {1};
int fact(int n) {
    while (sz(factArr) <= n)
        factArr.pb((int)((ll)factArr[sz(factArr) - 1] * sz(factArr) % mod));
    return factArr[n];
}

int factInv(int n) {
    fact(n);
    while (sz(factInvArr) <= n)
        factInvArr.pb(mInv(factArr[sz(factInvArr)]));
    return factInvArr[n];
}

int choose(int n, int k) {
    if (k < 0 || k > n) return 0;
    return (int)((ll)fact(n) * factInv(k) % mod * factInv(n - k) % mod);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int sum = 0;
        for (char c : num) sum += c - '0';
        if (sum % 2 == 1) return 0;
        vector<vector<ll>> dp((int)num.size() / 2 + 1, vector<ll>(sum / 2 + 1, 0)), nxt = dp;
        dp[0][0] = 1;
        vector<int> freq(10, 0);
        for (char c : num) freq[c - '0']++;
        int pre = 0;
        for (int k = 0; k < 10; k++) {
            for (int i = 0; i <= num.size() / 2; i++) fill(all(nxt[i]), 0);
            for (int l = 0; l <= freq[k]; l++) {
                for (int i = 0; i + l <= (int)num.size() / 2; i++) {
                    int n = (ll)choose(i + l, l) * choose(pre - i + freq[k] - l, freq[k] - l) % mod;
                    for (int j = 0; j + k * l <= sum / 2; j++) {
                        nxt[i + l][j + k * l] += (ll)dp[i][j] * n % mod;
                    }
                }
            }
            for (int i = 0; i <= num.size() / 2; i++) {
                for (int j = 0; j <= sum / 2; j++) {
                    nxt[i][j] %= mod;
                }
            }
            pre += freq[k];
            swap(dp, nxt);
        }
        return dp[(int)num.size() / 2][sum / 2];
    }
};",1441327844
Liwei Cai,cai_lw,80,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m);
        pq.push({0,0,0});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=it.i*m+it.j;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it2.t,moveTime[it2.i][it2.j])+1;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441295706
Liwei Cai,cai_lw,80,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool p;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m*2);
        pq.push({0,0,0,false});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=(it.i*m+it.j)*2+it.p;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it.t,moveTime[it2.i][it2.j])+(it.p?2:1);
                it2.p=!it.p;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441297773
Liwei Cai,cai_lw,80,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s[2]{0,0};
        for(int i=0;i<num.size();i++)
            s[i%2]+=num[i]-'0';
        return s[0]==s[1];
    }
};",1441280960
Liwei Cai,cai_lw,80,3637,cpp,"class Solution {
    static constexpr int P=1'000'000'007;
    struct State{
        int n1,n2,step,diff;
        bool operator<(const State& rhs)const{
            return tuple(n1,n2,step,diff)<tuple(rhs.n1,rhs.n2,rhs.step,rhs.diff);
        }
    };
    int solve(const State& st,const int (&cnt)[10],const int (&rem)[10],const vector<vector<int>>& binom,map<State,int>& mem){
        if(st.step==10)
            return st.diff==0;
        if(abs(st.diff)>rem[st.step])
            return 0;
        auto [it,inserted]=mem.emplace(st,0);
        if(!inserted)
            return it->second;
        int& ans=it->second;
        for(int c1=0;c1<=cnt[st.step];c1++){
            int c2=cnt[st.step]-c1;
            if(c1>st.n1||c2>st.n2)
                continue;
            int coef=1ll*binom[st.n1][c1]*binom[st.n2][c2]%P;
            State nxt=st;
            nxt.n1-=c1;
            nxt.n2-=c2;
            nxt.step++;
            nxt.diff+=st.step*(c2-c1);
            ans+=1ll*coef*solve(nxt,cnt,rem,binom,mem)%P;
            if(ans>=P)
                ans-=P;
        }
        return ans;
    }
public:
    int countBalancedPermutations(string num) {
        int cnt[10]{};
        for(char c:num)
            cnt[c-'0']++;
        int rem[10];
        rem[9]=cnt[9]*9;
        for(int i=8;i>=0;i--)
            rem[i]=rem[i+1]+cnt[i]*i;
        int n=num.size();
        int n1=n/2,n2=n-n1;
        vector<vector<int>> binom(n2+1,vector<int>(n2+1));
        for(int i=0;i<=n2;i++){
            binom[i][0]=binom[i][i]=1;
            for(int j=1;j<i;j++){
                binom[i][j]=binom[i-1][j-1]+binom[i-1][j];
                if(binom[i][j]>=P)
                    binom[i][j]-=P;
            }
        }
        map<State,int> mem;
        return solve(State{n1,n2,0,0},cnt,rem,binom,mem);
    }
};",1441335423
ocavue,ocavue,81,3627,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        result = [[MAX_TIME] * n for _ in range(m)]

        result[0][0] = 0

        heap = [(0, 0, 0)]

        while heap:
            time, i, j = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    new_time = start_time + 1
                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        heapq.heappush(heap, (new_time, ii, jj))

        return result[m - 1][n - 1]
 ",1441296531
ocavue,ocavue,81,3628,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        # print(""m"", m, ""n"", n)
        result1 = [[MAX_TIME] * n for _ in range(m)]
        result2 = [[MAX_TIME] * n for _ in range(m)]

        result2[0][0] = 0

        heap = [(0, 0, 0, 1)]

        while heap:
            time, i, j, next_move = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    # assert next_move in [1, 2]
                    new_time = start_time + next_move

                    result = result1 if next_move == 1 else result2

                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        # print(f""result {ii} {jj} {new_time} -> {(next_move) % 2 + 1}"")
                        heapq.heappush(heap, (new_time, ii, jj, (next_move) % 2 + 1))

        # print(""result1"", result1)
        # print(""result2"", result2)

        return min(result1[m - 1][n - 1], result2[m - 1][n - 1])

 ",1441316045
ocavue,ocavue,81,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = 0
        o = 0
        for i, char in enumerate(num):
            dig = int(char)
            if i % 2 == 0:
                e += dig 
            else:
                o += dig 
        return e == o",1441281980
ocavue,ocavue,81,3637,python3,"from functools import cache
import math

MOD = 10**9 + 7


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        total_sum = sum(int(c) for c in num)
        if total_sum % 2 != 0:
            return 0

        counter = [0] * 10
        for c in num:
            d = int(c)
            counter[d] += 1

        assert sum(counter) == len(num)

        n = len(num)
        e = n // 2
        o = n - e

        @cache
        def dp(i: int, e_available: int, o_available: int, diff: int) -> int:
            if i == 10:
                assert e_available == 0 and o_available == 0, f""e_available: {e_available}, o_available: {o_available}""
                return 1 if diff == 0 else 0

            total_result = 0
            for e_pick in range(0, e_available + 1):
                o_pick = counter[i] - e_pick
                if 0 <= e_pick <= e_available and 0 <= o_pick <= o_available:
                    result = 1
                    result *= math.comb(e_available, e_pick)
                    result %= MOD
                    result *= math.comb(o_available, o_pick)
                    result %= MOD
                    result *= dp(i + 1, e_available - e_pick, o_available - o_pick, diff + (o_pick - e_pick) * i)
                    result %= MOD
                    total_result += result
            return total_result % MOD

        return dp(0, e, o, 0)

 ",1441342495
nemokwy,nemokwy,82,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        ret = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0))
        ret[0][0] = 0
        while h:
            t, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m and ret[u][v] > max(moveTime[u][v]+1, t+1):
                    ret[u][v] = max(moveTime[u][v]+1, t+1)
                    heappush(h, (ret[u][v], u, v))
        return ret[-1][-1]",1441292753
nemokwy,nemokwy,82,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        r0 = [[inf] * m for _ in range(n)]
        r1 = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0, 0))
        r0[0][0] = 0
        while h:
            t, p, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m:
                    if p == 0:
                        if r1[u][v] > max(moveTime[u][v]+1, t+1):
                            r1[u][v] = max(moveTime[u][v]+1, t+1)
                            heappush(h, (r1[u][v], 1, u, v))
                    else:
                        if r0[u][v] > max(moveTime[u][v]+2, t+2):
                            r0[u][v] = max(moveTime[u][v]+2, t+2)
                            heappush(h, (r0[u][v], 0, u, v))
        if r0[-1][-1] == inf:
            return r1[-1][-1]
        if r1[-1][-1] == inf:
            return r0[-1][-1]
        return max(r0[-1][-1], r1[-1][-1])",1441309614
nemokwy,nemokwy,82,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a, b = 0, 0
        for i,c in enumerate(num):
            if i & 1:
                a += int(c)
            else:
                b += int(c)
        return a == b",1441281344
nemokwy,nemokwy,82,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        ret = 0
        d = [0] * 10
        s = 0
        for i, c in enumerate(num):
            d[int(c)] += 1
            s += int(c)
        if s & 1:
            return 0
        v = s // 2
        @lru_cache(None)
        def C(n, m):
            a = 1
            for i in range(m):
                a = a * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD
            return a

        @lru_cache(None)
        def chk(tp, tq, p, q, t):
            if t == 0:
                if tp or tq:
                    return 0
                return 1
            ret = 0
            for i in range(d[t]+1):
                if tp < i * t or tq < (d[t]-i) * t:
                    continue
                ret += C(p, i) * C(q, d[t]-i) * chk(tp - i * t, tq - (d[t]-i) * t, p - i, q - (d[t]-i), t - 1) % MOD
            # print(tp, tq, p, q, t, ret)
            return ret % MOD
        return chk(v, s - v, len(num) // 2,len(num) - len(num) // 2, 9)",1441336421
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0):0}
        h = [(0,0,0)]
        while h:
            c,x,y = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and (nx,ny) not in dist:
                    dist[nx,ny] = max(1 + moveTime[nx][ny], 1 + c)
                    heapq.heappush(h, (dist[nx,ny], nx, ny))
                ",1441290546
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0,0):0}
        h = [(0,0,0,0)]
        while h:
            c,x,y,p = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            if dist[(x,y,p)] != c:
                continue
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and dist.get((nx,ny,1-p), inf) > p + 1 + max(moveTime[nx][ny], c):
                    dist[nx,ny,1-p] = p + 1 + max(moveTime[nx][ny], c)
                    heapq.heappush(h, (dist[nx,ny,1-p], nx, ny, 1-p))
                ",1441294236
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ret = 0
        for i in range(len(num)):
            x = int(num[i])
            if i % 2:
                ret += x
            else:
                ret -= x
        return ret == 0",1441280896
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3637,python3,"MOD = 10**9+7

@cache
def comb(x, y):
    if y == 0 or y == x:
        return 1
    return (comb(x-1, y-1) + comb(x-1, y)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        SM = 0
        l = [0] * 10
        tot = [0] * 10
        tc = [0] * 10
        for x in num:
            l[int(x)] += 1
            SM += int(x)
        if SM % 2:
            return 0
        for i in range(10):
            tot[i] = (0 if i == 0 else tot[i-1]) + l[i] * i
            tc[i] = (0 if i == 0 else tc[i-1]) + l[i]
        # print(tot)
        # print(tc)
        # print(l)
        
        @cache
        def dp(idx, ct, sm):
            # print(idx, ct, sm)
            if idx == -1:
                # print(idx, ct, sm)
                return int(ct == 0 and sm == 0)
            ct2 = tc[idx] - ct
            sm2 = tot[idx] - sm
            # print(idx, ct, sm, ct2, sm2)
            ret = 0
            for t in range(l[idx] + 1):
                # print(t, l[idx] - t > ct2, sm > (idx) * t, sm2 > (idx) * (l[idx] - t))
                if t > ct or l[idx] - t > ct2 or sm < (idx) * t or sm2 < (idx) * (l[idx] - t):
                    continue
                v = dp(idx-1, ct - t, sm - (idx) * t)
                ret += comb(ct, t) * comb(ct2, l[idx] - t) * v % MOD
                ret %= MOD
                # print(idx, ct, sm, ret)
            return ret

        return dp(9, (len(num)+1)//2, SM//2)
                
                ",1441343521
thedude7181,thedude7181,85,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, row, col = heappop(q)
            if (row, col) in vis:
                continue
            vis.add((row, col))
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1, moveTime[nrow][ncol] + 1), nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441297537
thedude7181,thedude7181,85,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, movecost, row, col = heappop(q)
            if (row, col, movecost) in vis:
                continue
            vis.add((row, col, movecost))
            new_movecost = (movecost + 1) % 2 
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1 + movecost, moveTime[nrow][ncol] + 1 + movecost), new_movecost, nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441305265
thedude7181,thedude7181,85,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0 
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return odd == even",1441287722
thedude7181,thedude7181,85,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def helper(d, s, ecnt, ocnt):
            if s < 0:
                return 0
            if ecnt < 0:
                return 0
            if ocnt < 0:
                return 0
            if d > 9:
                return s == 0
            res = 0
            for i in range(digit_cnts[d] + 1):
                res += comb(ecnt, i) * helper(d + 1, s - (d * i), ecnt - i, ocnt - (digit_cnts[d] - i)) * comb(ocnt, digit_cnts[d] - i)
            return res % mod

        target_cnt = len(num) // 2
        mod = 1_000_000_007
        num = [int(n) for n in num]
        sum_ = sum(num)
        if sum_ % 2 != 0:
            return 0
        target_s = sum_ // 2
        digit_cnts = Counter(num)
        res = helper(0, target_s, (len(num) + 1) // 2, len(num) // 2)
        helper.cache_clear()
        return res",1441343532
Ethan,Ethan038,86,3627,cpp,"
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    int minTimeToReach(vector<vi>& mvtm) {
        return [](vector<vi>& mvtm) -> int {
            int n = mvtm.size();
            int m = mvtm[0].size();
            
            vector<vll> dis(n, vll(m, LLONG_MAX));
            dis[0][0] = 0;
            
            priority_queue<pair<ll, pi>, 
                          vector<pair<long long, pair<int, int>>>, 
                          greater<>> pq;
            pq.push({0, {0, 0}});
            
            vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            
            while (!pq.empty()) {
                auto [currtm, cor] = pq.top();
                auto [x, y] = cor;
                pq.pop();
                
                if (currtm > dis[x][y]) continue;
                
                for (auto [dx, dy] : dirs) {
                    int nex = x + dx;
                    int ny = y + dy;
                    
                    if (nex >= 0 && nex < n && ny >= 0 && ny < m) {
                        long long waitTime = max(0LL, mvtm[nex][ny] - currtm);
                        long long ntm = currtm + waitTime + 1;
                        
                        if (ntm < dis[nex][ny]) {
                            dis[nex][ny] = ntm;
                            pq.push({ntm, {nex, ny}});
                        }
                    }
                }
            }
            
            return dis[n-1][m-1];
        }(mvtm);
    }
};",1441292430
Ethan,Ethan038,86,3628,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;
int a[N]; 
bool c[N]; 

class Solution {
public:
   int minTimeToReach(vector<vi>& mt) {
       int n = mt.size();
       int m = mt[0].size();
       
       vector<vll> ans(n, vll(m, LLONG_MAX));
       ans[0][0] = 0;
       
       priority_queue<pair<ll, vi>, vector<pair<ll, vi>>, greater<>> pq;
       pq.push({0, {0, 0, 0}});
       
       auto chk = mt;
       
       vector<pi> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
       
       auto isValid = [&](int x, int y) -> bool {
           return x >= 0 && x < n && y >= 0 && y < m;
       };
       
       auto nxtmv = [](int mvtyp) -> int {
           return 1 - mvtyp; 
       };
       
       auto gcst = [](int mvtyp) -> int {
           return (mvtyp == 0) ? 1 : 2;
       };
       
       auto getm = [](long long xrrtm, int tartime, int mvcst) -> long long {
           return max((long long)tartime, xrrtm) + mvcst;
       };
       
       while(!pq.empty()) {
           auto [time, pos] = pq.top();
           auto x = pos[0], y = pos[1], mvtyp = pos[2];
           pq.pop();
           
           if(time > ans[x][y]) continue;
           
           for(auto [dx, dy] : dirs) {
               int nx = x + dx;
               int ny = y + dy;
               
               if(isValid(nx, ny)) {
                   int mvcst = gcst(mvtyp);
                   ll ntm = getm(time, chk[nx][ny], mvcst);
                   
                   if(ntm < ans[nx][ny]) {
                       ans[nx][ny] = ntm;
                       pq.push({ntm, {nx, ny, nxtmv(mvtyp)}});
                   }
               }
           }
       }
       
       return ans[n-1][m-1];
   }
};
",1441302877
Ethan,Ethan038,86,3636,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    bool isBalanced(string num) {
        return [](string num) -> bool {
            int evenSum = 0, oddSum = 0;
            rep(i, 0, num.length()) {
                (i % 2 == 0) ? evenSum += num[i] - '0' : oddSum += num[i] - '0';
            }
            return evenSum == oddSum;
        }(num);
    }
};",1441288482
Ethan,Ethan038,86,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;

class Solution { 
public: 
   const int MOD = 1e9 + 7;

   ll countBalancedPermutations(string num) {
       auto solv4 = [](ll x, ll y, ll mod) -> ll {
           ll res = 1;
           x %= mod;
           while(y > 0) {
               if(y & 1) res = res * x % mod;  x = x * x % mod;   y >>= 1;
           }
           return res;
       };
       
       auto solv2 = [&](vll& fc, vll& kp, int maxN) {
           fc.resize(maxN + 1, 1);
           rep(i,1,maxN+1) fc[i] = fc[i-1] * i % MOD;
           kp.resize(maxN + 1, 1);
           kp[maxN] = solv4(fc[maxN], MOD - 2, MOD);
           for(int i = maxN-1; i >= 0; --i) kp[i] = kp[i+1] * (i+1) % MOD; };auto km = num; auto sp = num;
       
       auto solv3 = [](const string& s) -> pair<array<int,10>, ll> {
           array<int,10> cnt{};
           ll sum = 0;
           for(char c : s) {
               cnt[c-'0']++;
               sum += (c-'0');
           }
           return {cnt, sum};
       };
       
       int L = num.length();
       auto [cnts, tsum] = solv3(num);
       
       if(tsum % 2) return 0;
       
       ll smevn = tsum / 2;
       int k = (L + 1) / 2;
       
       vll fc, kp;
       solv2(fc, kp, L);
       
       auto solvdp = [&](int d, const vector<vll>& pdp, int cntd) -> vector<vll> {
           vector<vll> tmdp(k + 1, vll(smevn + 1, 0));
           rep(c,0,k+1) {
               rep(s,0,smevn+1) {
                   if(pdp[c][s] == 0) continue;
                   int maxA = min(cntd, k - c);
                   rep(aD,0,maxA+1) {
                       ll nec = c + aD;   ll nws = s + (ll)d * aD;    if(nws > smevn) continue;
                       tmdp[nec][nws] = (tmdp[nec][nws] + 
                           pdp[c][s] * kp[aD] % MOD *   kp[cntd - aD] % MOD) % MOD;
                   }
               }
           }
           return tmdp;
       };

       vector<vll> pdp(k + 1, vll(smevn + 1, 0));  pdp[0][0] = 1;
       
       rep(d,0,10) {
           pdp = solvdp(d, pdp, cnts[d]);
       }
       
       ll vlid = pdp[k][smevn];
       ll anas = fc[k] * fc[L - k] % MOD;
       anas = anas * vlid % MOD;
       
       return (int)anas;
   }
};
",1441343539
Only My Railgun,Quar,89,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0)] # t, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1
                    yield tt, rr, cc
        
        while heap:
            t, ir, ic = heappop(heap)
            
            for tt, rr, cc in get_neighbor(t, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]

            ",1441293619
Only My Railgun,Quar,89,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0, 0)] # t, additional_time, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, dt, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1 + dt
                    yield tt, 1 - dt, rr, cc
        
        while heap:
            t, d, ir, ic = heappop(heap)
            
            for tt, dd, rr, cc in get_neighbor(t, d, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, dd, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]
",1441296911
Only My Railgun,Quar,89,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = str(num)
        even = sum(int(s[i]) for i in range(0, len(s), 2))
        odd = sum(int(s[i]) for i in range(1, len(s), 2))
        return even == odd
",1441281831
Only My Railgun,Quar,89,3637,python3,"from math import comb
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        cnt = [0] * 10
        for c in num:
            cnt[int(c)] += 1
            
        total_sum = sum(x * c for x, c in enumerate(cnt))
        
        if total_sum % 2 == 1:
            return 0
        
        target_sum = total_sum // 2
        
        MODULO = 10**9 + 7
        
        @cache
        def dp(i, rem_even, rem_odd, rem_even_sum):
            if rem_even == 0:
                if rem_even_sum != 0:
                    return 0
                ret = 1
                for j in range(i, 10):
                    ret = ret * comb(rem_odd, cnt[j]) % MODULO
                    rem_odd -= cnt[j]
                return ret
            
            if rem_even_sum > 0 and rem_even == 0:
                return 0
            
            if 0 < rem_even_sum < i:
                return 0
            
            ret = 0
            max_even_take = cnt[i] if i == 0 else min(cnt[i], rem_even_sum // i)
            max_even_take = min(max_even_take, rem_even)
            
            for even_take in range(0, max_even_take + 1):
                odd_take = cnt[i] - even_take
                if odd_take > rem_odd:
                    continue
                coeff = (comb(rem_even, even_take) % MODULO) * (comb(rem_odd, odd_take) % MODULO) % MODULO
                rest = dp(i + 1, rem_even - even_take, rem_odd - odd_take, rem_even_sum - i * even_take)
                ret += coeff * rest % MODULO
            
            return ret % MODULO
        
        n_odd = len(num) // 2
        n_even = len(num) - n_odd
        
        return dp(0, n_even, n_odd, target_sum)
                
            
                
        ",1441338510
carlostagosaku,carlostagosaku,90,3627,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 1
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441300648
carlostagosaku,carlostagosaku,90,3628,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 2
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441299342
carlostagosaku,carlostagosaku,90,3636,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

class Solution:
    def isBalanced(self, num: str) -> bool:
        X = list(num)
        X = [int(x) for x in X]
        if sum(x for x in X[1::2])==sum(x for x in X[0::2]):
            return True
        else:
            return False  ",1441302147
carlostagosaku,carlostagosaku,90,3637,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Mbius function value of x.

        Parameters:
        x (int): The number to find the Mbius function value for.

        Returns:
        int: The Mbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""O(logN)
    add: [l, r)val
    query: [l, r)
    l, r0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""[l, r)val""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""[l, r)""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

mod = 10**9 + 7
CC = combination(10**6,mod)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        S = list(num)
        S = [int(x) for x in S]
        W = sum(S)
        if W%2==1:
            return 0
        n = len(S)
        target = W//2
        m = n//2
        dp = [[0]*(target+2) for _ in range(m+1)]
        dp[0][0] = 1
        for s in S:
            for i in range(target,-1,-1):
                for j in range(m-1,-1,-1):
                    dp[j+1][min(i+s,target+1)] = (
                        dp[j+1][min(i+s,target+1)]
                        + dp[j][i]
                    )%mod
        ans = 1
        C = Counter(S)
        
        ans = dp[m][target]*CC.fact[m]*CC.fact[n-m]%mod
        # print(dp,C)
        for v in C.values():
            ans = (ans * CC.factinv[v])%mod

        return ans",1441325130
aqxa2k,aqxa2k,91,3627,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<int>> d(n, vector<int>(m, -1)); 
        d[0][0] = 0; 

        set<array<int, 3>> st; 
        st.insert({d[0][0], 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny] == -1) {
                        d[nx][ny] = max(t + 1, a[nx][ny] + 1); 
                        st.insert({d[nx][ny], nx, ny}); 
                    }
                }
            }
        }

        return d[n - 1][m - 1]; 
        
    }
};",1441296110
aqxa2k,aqxa2k,91,3628,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2000000000))); 
        d[0][0][0] = 0; 

        set<array<int, 4>> st; 
        st.insert({0, 0, 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0], z = c[3]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny][z ^ 1] == 2000000000) {
                        d[nx][ny][z ^ 1] = max(t + 1 + z, a[nx][ny] + 1 + z); 
                        st.insert({d[nx][ny][z ^ 1], nx, ny, z ^ 1}); 
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]); 
        
    }
};",1441300647
aqxa2k,aqxa2k,91,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> c(2, 0); 
        for (int i = 0; i < num.size(); ++i) {
            c[i % 2] += (num[i] - '0'); 
        }
        return c[0] == c[1]; 
    }
};",1441281197
aqxa2k,aqxa2k,91,3637,cpp,"template <typename T>
T inverse(T a, T m) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = m / a;
		m -= t * a; swap(a, m);
		u -= t * v; swap(u, v);
	}
	assert(m == 1);
	return u;
}

template<class T>
T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

template <typename T>
class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {

    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));

        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
            long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
            value = normalize(value * rhs.value - q * mod());
            return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
            value = normalize(value * rhs.value);
            return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
};
template <typename T> bool operator>(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value > rhs.value; }
template <typename T, typename U> bool operator>(const Modular<T>& lhs, U rhs) { return lhs > Modular<T>(rhs); }
template <typename T, typename U> bool operator>(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) > rhs; }

template <typename T> bool operator>=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value >= rhs.value; }
template <typename T, typename U> bool operator>=(const Modular<T>& lhs, U rhs) { return lhs >= Modular<T>(rhs); }
template <typename T, typename U> bool operator>=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) >= rhs; }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
template <typename T, typename U> bool operator<(const Modular<T>& lhs, U rhs) { return lhs < Modular<T>(rhs); }
template <typename T, typename U> bool operator<(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) < rhs; }

template <typename T> bool operator<=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value <= rhs.value; }
template <typename T, typename U> bool operator<=(const Modular<T>& lhs, U rhs) { return lhs <= Modular<T>(rhs); }
template <typename T, typename U> bool operator<=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) <= rhs; }

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string ss) {
        vector<int> a; 
        for (char c: ss) a.push_back(c - '0'); 

        int s = accumulate(a.begin(), a.end(), 0); 
        if (s % 2) return 0; 

        int n = a.size(); 
        vector<int> f(10, 0); 
        for (int i = 0; i < n; ++i) f[a[i]]++; 

        s /= 2;  
        
        vector<vector<Mint>> dp(n + 1, vector<Mint>(s + 1, Mint(0))); 
        dp[0][0] = 1; 

        int hv = 0; 
        for (int v = 0; v < 10; ++v) {
            vector<vector<Mint>> dp2(n + 1, vector<Mint>(s + 1, Mint(0))); 
            
            for (int c = 0; c <= f[v]; ++c) {
                for (int i = 0; i + c <= n; ++i) {
                    for (int j = 0; j + (c * v) <= s; ++j) {
                        dp2[i + c][j + (c * v)] += dp[i][j] * C(i + c, c) * C(hv - i + f[v] - c, f[v] - c); 
                    }
                }
            }

            hv += f[v]; 
            dp = dp2; 
        }

        int ans = (int)dp[n / 2][s]; 
        return ans; 
        // return (dp[n / 2][s]) % md; 
    }
};",1441333231
user5860c,user5860c,92,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 1;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441345728
user5860c,user5860c,92,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 2;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441344214
user5860c,user5860c,92,3636,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
class Solution {
public:
    bool isBalanced(string v) {
        int o1 = 0;
        int o2 = 0;
        FOR(i, sz(v)) {
            if (i%2) {
                o1 += v[i] - '0';
            } else {
                o2 += v[i] - '0';
            }
        }
        return o1 == o2;
    }
};",1441346769
user5860c,user5860c,92,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;


// N ~ 10^6
class Combinations {
public:
  vector<mint> inv, fact, ifact;

  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};

Combinations comb(1000);

mint best[11][82*10][82];

class Solution {
public:
    int countBalancedPermutations(string v) {
        int sum = 0;
        vi cnt(10);
        for (auto x : v) {
            sum += (x-'0');
            cnt[x-'0']++;
        }
        if (sum%2) return 0;
        for (int i=0;i<=10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    best[i][s][k] = 0;
                }
            }
        }
        best[0][0][0] = 1;
        int placed = 0;
        for (int i=0;i<10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    for (int j=0;j<=cnt[i] && s + j * i <= sum/2;++j) {
                        if (best[i][s][k].x == 0) continue;
                        //cout << i << "" "" << k << "" "" << j << "" "" << s << "" "" << endl;
                        //cout << i+1 << "" "" << s + j * (i) << "" "" << k + j << endl;
                        best[i+1][s + j * (i)][k+j] += 
                            best[i][s][k] * ( comb.comb(k+j,j) * comb.comb(placed-k+cnt[i]-j, cnt[i]-j));
                        //cout << best[i][s][k] * ( comb.comb(k+j,j) + comb.comb(placed-k+cnt[i]-j, cnt[i]-j)) << endl;
                    }
                }
            }
            placed += cnt[i];
        }
        mint ret = best[10][sum/2][(sz(v)+1)/2];
        return ret.x;
    }
};",1441318305
Abhishek Choudhary,theabbie,94,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441294424
Abhishek Choudhary,theabbie,94,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1 if even else 2
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441293690
Abhishek Choudhary,theabbie,94,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = [0, 0]
        for i in range(len(num)):
            s[i % 2] += int(num[i])
        return s[0] == s[1]",1441295519
Abhishek Choudhary,theabbie,94,3637,python3,"M = 10 ** 9 + 7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        f = [1] * (n + 1)
        rf = [1] * (n + 1)
        for i in range(1, n + 1):
            f[i] = i * f[i - 1]
            f[i] %= M
            rf[i] = pow(f[i], M - 2, M)
        ctr = [0] * 10
        s = 0
        for c in num:
            s += int(c)
            ctr[int(c)] += 1
        if s & 1:
            return 0
        cache = [[[-1] * ((s // 2) + 1) for _ in range(n + 1)] for _ in range(10)]
        def dp(d, l, rem):
            if d > 9:
                return int(l == 0 and rem == 0)
            if cache[d][l][rem] != -1:
                return cache[d][l][rem]
            res = 0
            for take in range(ctr[d] + 1):
                if take > l or d * take > rem:
                    continue
                res += rf[take] * rf[ctr[d] - take] * dp(d + 1, l - take, rem - d * take)
                res %= M
            cache[d][l][rem] = res
            return res
        return (f[n // 2] * f[n - (n // 2)] * dp(0, n // 2, s // 2)) % M",1441348952
furuyarei,furuyarei,95,3627,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            d, x, y = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny) not in dist or max(d, a[nx][ny]) + 1 < dist[(nx, ny)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + 1, nx, ny))
                        dist[(nx, ny)] = max(d, a[nx][ny]) + 1
        return dist[(m - 1, n - 1)]
        ",1441293432
furuyarei,furuyarei,95,3628,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0, 1)]
        dist = {(0, 0, 1): 0}
        while q:
            d, x, y, cost = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny, 3 - cost) not in dist or max(d, a[nx][ny]) + cost < dist[(nx, ny, 3 - cost)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + cost, nx, ny, 3 - cost))
                        dist[(nx, ny, 3 - cost)] = max(d, a[nx][ny]) + cost
        return min(dist.get((m - 1, n - 1, 1), inf), dist.get((m - 1, n - 1, 2), inf))",1441297122
furuyarei,furuyarei,95,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        p = q = 0
        for i, ch in enumerate(num):
            if i % 2 == 0:
                p += int(ch)
            else:
                q += int(ch)
        return p == q",1441286385
furuyarei,furuyarei,95,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        
        @cache
        def C(n, k):
            if n < k:
                return 0
            if k == 0:
                return 1
            return (C(n - 1, k - 1) + C(n - 1, k)) % MOD

        @cache
        def S2(n, k):
            # print(n + k - 1, k - 1)
            return C(n + k - 1, k - 1)

        c = Counter(int(d) for d in num)
        # print(c)
        
        @cache
        def f(x, p1, p2, diff):
            if x == 10:
                return int(p1 == p2 == diff == 0)

            alloc = c.get(x, 0)
            ans = 0
            for q1 in range(alloc + 1):
                q2 = alloc - q1
                if q1 > p1 or q2 > p2:
                    continue
                coef = S2(q1, p1 - q1 + 1) * S2(q2, p2 - q2 + 1) % MOD
                ans += coef * f(x + 1, p1 - q1, p2 - q2, diff + (q1 - q2) * x) % MOD
            #     print(f""coef = {q1} {p1 - q1 + 1} {q2} {p2 - q2 + 1} = {S2(q1, p1 - q1 + 1)} {S2(q2, p2 - q2 + 1)}"")
            #     print(f""from = {x + 1} {p1 - q1} {p2 - q2} {diff + (q1 - q2) * x}"")
            # print(f""{x} {p1} {p2} {diff} = {ans}"")
            return ans % MOD

        l = len(num)
        ans = f(0, (l + 1) // 2, l // 2, 0)
        C.cache_clear()
        S2.cache_clear()
        f.cache_clear()
        return ans",1441349069
Nicholas,nicholask_17,97,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
using pii=pair <int,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m];
        bool visited[n][m];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                dist[i][j]=2e9;
                visited[i][j]=0;
            }
        }
        priority_queue <pair <int,pii>,vector <pair <int,pii> >,greater <pair <int,pii> > > pq;
        dist[0][0]=0; pq.push({0,{0,0}});
        while (!pq.empty()){
            pair <int,pii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first][tp.second.second]) continue;
            visited[tp.second.first][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first+dx[dir],ny=tp.second.second+dy[dir];
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny]) continue;
                if (max(tp.first,moveTime[nx][ny])+1<dist[nx][ny]){
                    dist[nx][ny]=max(tp.first,moveTime[nx][ny])+1;
                    pq.push({dist[nx][ny],{nx,ny}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441298407
Nicholas,nicholask_17,97,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using pii=pair <int,int>;
        using tii=pair <pii,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m][2];
        bool visited[n][m][2];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                for (int k=0; k<2; k++){
                    dist[i][j][k]=2e9;
                    visited[i][j][k]=0;
                }
            }
        }
        priority_queue <pair <int,tii>,vector <pair <int,tii> >,greater <pair <int,tii> > > pq;
        dist[0][0][0]=0; pq.push({0,{{0,0},0}});
        while (!pq.empty()){
            pair <int,tii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first.first][tp.second.first.second][tp.second.second]) continue;
            visited[tp.second.first.first][tp.second.first.second][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first.first+dx[dir],ny=tp.second.first.second+dy[dir],nz=1-tp.second.second;
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny][nz]) continue;
                if (max(tp.first,moveTime[nx][ny])+(nz==1?1:2)<dist[nx][ny][nz]){
                    dist[nx][ny][nz]=max(tp.first,moveTime[nx][ny])+(nz==1?1:2);
                    pq.push({dist[nx][ny][nz],{{nx,ny},nz}});
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441303421
Nicholas,nicholask_17,97,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0,sum2=0;
        for (int i=0; i<num.size(); i++){
            if (i%2==0) sum1+=num[i]-'0';
            else sum2+=num[i]-'0';
        }
        return sum1==sum2;
    }
};",1441281077
Nicholas,nicholask_17,97,3637,cpp,"class Solution {
public:
    const long long mod=1e9+7LL;
    long long f[100],inv[100],finv[100];
    void init(){
        f[0]=f[1]=inv[0]=inv[1]=finv[0]=finv[1]=1;
        for (int i=2; i<100; i++){
            f[i]=f[i-1]*i%mod;
            inv[i]=inv[mod%i]*(mod-mod/i)%mod;
            finv[i]=finv[i-1]*inv[i]%mod;
        }
    }
    long long ncr(int n,int r){
        if (n<r||r<0) return 0;
        return f[n]*finv[n-r]%mod*finv[r]%mod;
    }
    int countBalancedPermutations(string num) {
        init();
        int n=num.size();
        int sum=0;
        for (char i:num) sum+=i-'0';
        if (sum%2) return 0;
        int cnt[10];
        for (int i=0; i<10; i++) cnt[i]=0;
        for (char i:num) cnt[(i-'0')]++;
        int dp[11][41][1500];
        for (int i=0; i<11; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++) dp[i][j][k]=0;
            }
        }
        dp[0][0][750]=1;
        int done=0;
        for (int i=0; i<10; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++){
                    if (!dp[i][j][k]) continue;
                    for (int l=0; l<=cnt[i]&&j+l<41; l++){
                        long long way=ncr((n+1)/2-j,l)*ncr(n/2-(done-j),cnt[i]-l)%mod;
                        if (k+i*l-(cnt[i]-l)*i>=0&&k+i*l-(cnt[i]-l)*i<1500){
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]+=way*dp[i][j][k]%mod;
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]%=mod;
                        }
                    }
                }
            }
            done+=cnt[i];
        }
        int ans=0;
        for (int i=0; i<41; i++) ans=(ans+dp[10][i][750])%mod;
        return ans;
    }
};",1441322955
Dhruv Pasricha,pasricha_dhruv,99,3627,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441317612
Dhruv Pasricha,pasricha_dhruv,99,3628,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = h == 1 ? 2 : 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441316521
Dhruv Pasricha,pasricha_dhruv,99,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i = 0; i < n; ++i)
        {
            num[i] -= '0';
            if(i % 2 == 0) sum1 += num[i];
            else sum2 += num[i];
        }
        return sum1 == sum2;
    }
};",1441281493
Dhruv Pasricha,pasricha_dhruv,99,3637,cpp,"#define int long long

const int N = 1e2 + 10, MOD = 1e9 + 7, mod = 1e9 + 7;
 
int fact[N + 1], invFact[N + 1];
 
// x^n % MOD
int power(int x, int n)
{
    if(n == 0)
    {
        return 1;
    }
 
    if(n % 2 == 0)
    {
        int ans = power(x, n / 2);
        ans = (ans * ans) % MOD;
        return ans;
    }
 
    return (x * power(x, n - 1)) % MOD;
}
 
// mod inverse
int modInverse(int x)
{
    return power(x, MOD - 2);
}
 
void pre()
{
    fact[0] = 1;
    for(int i = 1; i <= N; ++i)
    {
        fact[i] = (i * fact[i - 1]) % MOD;
    }
 
    for(int i = 0; i <= N; ++i)
    {
        invFact[i] = modInverse(fact[i]);
    }
}
 
int Binomial(int n, int r)
{
    if(r > n or n < 0 or r < 0) return 0;

    int ans = fact[n];
    ans *= invFact[n - r];
    ans %= MOD;
    ans *= invFact[r];
    ans %= MOD;
    return ans;
}
 
int freq[10], dp[10][42][410];

int solve(int cur, int remOddPlaces, int remEvenPlaces, int remOddSum, int remEvenSum)
{
    if(remOddPlaces < 0 or remEvenPlaces < 0 or remOddSum < 0 or remEvenSum < 0)
        return 0;
    
    if(cur == -1)
    {
        return 1;
    }

    if(dp[cur][remOddPlaces][remOddSum] != -1) return dp[cur][remOddPlaces][remOddSum]; 

    int ans = 0;
    for(int even = 0; even <= freq[cur]; ++even)
    {
        int odd = freq[cur] - even;

        int curAns = (Binomial(remOddPlaces, odd) * Binomial(remEvenPlaces, even)) % mod;
        curAns *= solve(cur - 1, remOddPlaces - odd, remEvenPlaces - even, remOddSum - odd * cur, remEvenSum - even * cur);
        curAns %= mod;

        ans += curAns;
        ans %= mod;
    }

    return dp[cur][remOddPlaces][remOddSum] = ans;
}

class Solution {
public:
    int countBalancedPermutations(string num) {

        pre();
        memset(freq, 0, sizeof(freq));
        memset(dp, -1, sizeof(dp));
    
        int sum = 0;
        for(auto it : num)
        {
            sum += it - '0';
            freq[it - '0']++;
        }
    
        if(sum % 2 == 1)
        {
            return 0;
        }

        int n = num.size();

        return solve(9, (n + 1) / 2, n / 2, sum / 2, sum / 2);
    }
};

#undef int",1441343833
Behrooz Sepehry,sepehry,100,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj

        node0 = (0, 0)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))

        return visited_dist[(n - 1, m - 1)]
",1441295828
Behrooz Sepehry,sepehry,100,3628,python3,"
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j, odd = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj, not odd

        node0 = (0, 0, True)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (node2[2] + max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))
        sol = float('inf')

        if (n - 1, m - 1, False) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, False)])
        if (n - 1, m - 1, True) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, True)])

        return sol
",1441311181
Behrooz Sepehry,sepehry,100,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])
",1441281738
Behrooz Sepehry,sepehry,100,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cc = collections.Counter(num)
        F = [cc[str(ii)] for ii in range(10)]

        mod = ((10 ** 9) + 7)

        @functools.lru_cache(None)
        def dp(d, rem_odd, rem_even, balance):
            if d == -1:
                return rem_odd == 0 and rem_even == 0 and balance == 0
            f = F[d]
            min_f_odd = max(0, f - rem_even)
            max_f_odd = min(rem_odd, f)
            vvv = 0
            for f_odd in range(min_f_odd, max_f_odd + 1):
                f_even = f - f_odd
                vvv += ((math.comb(rem_odd, f_odd) % mod) * (math.comb(rem_even, f_even) % mod) * dp(d - 1,
                                                                                                     rem_odd - f_odd,
                                                                                                     rem_even - f_even,
                                                                                                     balance + (
                                                                                                                 f_odd - f_even) * d)) % mod
                vvv %= mod

            return vvv

        n2 = n // 2
        sol = dp(9, n2, n - n2, 0)
        dp.cache_clear()
        return sol % mod
",1441343869
Aryan470,Aryan470,102,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, i, j = heapq.heappop(q)
            if i == n-1 and j == m-1:
                return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                # check the time at which we can reach this guy
                this_reach = max(curr_time + 1, moveTime[u][v] + 1)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, u, v))
    
                ",1441291107
Aryan470,Aryan470,102,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, True, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, first_move, i, j = heapq.heappop(q)
            # if i == n-1 and j == m-1:
                # return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                delta_time = 1 if first_move else 2
                # check the time at which we can reach this guy
                this_reach = max(curr_time + delta_time, moveTime[u][v] + delta_time)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, not first_move, u, v))
        
        return reach_time[(n-1,m-1)]
    
                ",1441294437
Aryan470,Aryan470,102,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            dig = int(num[i])
            if i % 2 == 0:
                es += dig
            else:
                os += dig
        return es == os",1441280972
Aryan470,Aryan470,102,3637,python3,"from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # sum of digs has to be 2k
        # how many ways can we choose n//2 digs with sum k
        # then how many ways can we permute those
        sum_digs = sum(int(c) for c in num)
        if sum_digs % 2 != 0:
            return 0
        
        target_sum = sum_digs // 2
        num_to_choose = len(num) // 2
        # first n digits with sum k
        # choose z digits with sum k
        # sum can be up to 80 * 9 and num digs can be up to 80
        # dp[i][k] = num sets of i digits with sum k

        max_sum = target_sum
        dp = [[0 for j in range(max_sum+1)] for i in range(num_to_choose + 1)]
        dp[0][0] = 1

        for i in range(len(num)):
            dig = int(num[i])
            for num_dig in range(num_to_choose, 0, -1):
                for k in range(dig, max_sum+1):
                    if k - dig >= 0:
                        dp[num_dig][k] += dp[num_dig - 1][k - dig]
        num_partitions = dp[num_to_choose][target_sum]
        # if 2 * num_to_choose == len(num):
            # num_partitions //= 2
        # print(dp)
        # print(num_partitions)
        # now given this, for each partition we can make some permutations
        # how many ways can we permute num_to_choose numbers * (n - num_to_choose) // (num 0! * num 1! * num 2!)
        def fact(x):
            prod = 1
            for u in range(2,x+1):
                prod *= u
            return prod
            
        ans = num_partitions * fact(num_to_choose) * fact(len(num) - num_to_choose)
        # print(ans)
        digcnt = Counter(int(c) for c in num)
        for dig, cnt in digcnt.items():
            if cnt > 1:
                ans //= fact(cnt)
        return ans % (10**9 + 7)",1441338715
Remineva,Remineva,103,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= di < m and 0 <= dj < n:
                    new = max(t, moveTime[di][dj]) + 1
                    if new < time[di][dj]:
                        time[di][dj] = new
                        heappush(h, (new, di, dj))

",1441301058
Remineva,Remineva,103,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0, True)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j, flag = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            if flag:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 1
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, False))
            else:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 2
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, True))
",1441309971
Remineva,Remineva,103,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        flag = True
        for c in num:
            if flag:
                s += int(c)
            else:
                s -= int(c)
            flag = not flag
        return s == 0",1441280982
Remineva,Remineva,103,3637,python3,"M = 10 ** 9 + 7
def ncr(n, r, p):
    num = den = 1 
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p
m = 100 + 1
fac = [1] * m
for i in range(2, m):
    fac[i] = fac[i-1] * i % M

inv = [1] * m
inv[-1] = pow(fac[-1], M - 2, M)
for i in range(m - 2, 1, -1):
    inv[i] = inv[i+1] * (i + 1) % M
    
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        s = 0
        cnt = [0] * 10
        for c in num:
            curr = int(c)
            s += curr
            cnt[curr] += 1
        if s & 1:
            return 0
        s //= 2
        n = len(num)
        m = (n + 1) // 2
        
        dp = [[0] * (s + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        for digit in range(10):
            temp = cnt[digit]
            if temp == 0:
                continue
            
            for i in range(m, -1, -1):
                for j in range(s, -1, -1):
                    if dp[i][j] == 0:
                        continue
                    for di in range(1, min(temp, m - i) + 1):
                        dj = di * digit
                        if j + dj > s:
                            break
                        dp[i + di][j + dj] += dp[i][j] * ncr(temp, di, M)
                        dp[i + di][j + dj] %= M
        res = dp[-1][-1]
        f = 1
        for digit in range(10):
            f = f * fac[cnt[digit]] % M
        inv_f = pow(f, M - 2, M)
        
        res *= fac[m] * fac[n - m]
        res %= M
        res *= inv_f
        res %= M
        return res

        ",1441345758
M Kawa,mkawa222,107,3627,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            nd=max(d+1,mt[ni][nj]+1)
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441297946
M Kawa,mkawa222,107,3628,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            cost=((i^j)&1)+1
            nd=max(d,mt[ni][nj])+cost
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441315942
M Kawa,mkawa222,107,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s=0
        p=1
        for c in num:
            s+=int(c)*p
            p=-p
        return s==0

",1441285811
M Kawa,mkawa222,107,3637,python3,"def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

md = 10**9+7
n_max = 200
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        aa = list(map(int, num))
        s = sum(aa)
        if s & 1: return 0
        s >>= 1
        n = len(aa)
        m = n//2
        em = n-m
        cnt = [0]*10
        for a in aa: cnt[a] += 1
        dp = [[0]*(s+1) for _ in range(m+1)]
        dp[0][0] = 1
        si = sj = 0
        for a in range(10):
            if cnt[a] == 0: continue
            ndp = [[0]*(s+1) for _ in range(m+1)]
            for i in range(m+1)[::-1]:
                ei = si-i
                for j in range(s+1):
                    pre = dp[i][j]
                    if pre == 0: continue
                    ej = sj-j
                    for c in range(cnt[a]+1):
                        ec = cnt[a]-c
                        if i+c > m or ei+ec > em or j+a*c > s or ej+a*ec > s: continue
                        ndp[i+c][j+a*c] += pre*nCr(m-i, c)%md*nCr(em-ei, ec)%md
                        ndp[i+c][j+a*c] %= md
            dp = ndp
            si += cnt[a]
            sj += cnt[a]*a
        return dp[-1][-1]%md
",1441353918
PankajGhodla,PankajGhodla,108,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c))

        return -1",1441291398
PankajGhodla,PankajGhodla,108,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c, move = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + move + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + move + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c, (move+1)%2 ))

        return -1",1441293810
PankajGhodla,PankajGhodla,108,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even = odd = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281353
PankajGhodla,PankajGhodla,108,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        counter = Counter()
        
        totalSum = 0
        for digit in num: 
            totalSum += int(digit)
            counter[int(digit)] += 1
        prefix = [0]*10
        prefix[0] = counter[0]
        for i in range(1, 10):
            prefix[i] = prefix[i-1] + counter[i] 
        # print(prefix)
        n = len(num)
        @cache
        def solve(digit, count, total):
            # print(digit, count, total)
            if digit == 10:
                # print(digit, count, total)
                return (count == n//2) and total*2 == totalSum
            ans = solve(digit+1, count, total) * math.comb(prefix[digit] - count, counter[digit])
            # print(math.comb(prefix[digit], counter[digit]), (prefix[digit], counter[digit]), digit)
            for i in range(counter[digit]):
                remaining = prefix[digit] - (count + i + 1)
                ans += solve(digit+1, count+i+1, total + digit*(i+1)) * math.comb(count+i+1, i+1) * math.comb(remaining, counter[digit] - (i+1))
                # print(math.comb(remaining, counter[digit] - (i+1)), math.comb(count+i+1, i+1), (count+i+1, i+1))
            return ans % MOD
        return solve(0, 0, 0)
            
            
            ",1441347745
cm_fast,cm_fast,109,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441297393
cm_fast,cm_fast,109,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    steps++;
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441296687
cm_fast,cm_fast,109,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0;
        int sum2=0;
        for(int i=0;i<(int)(num.size());i++)
        {
            if(i%2)
            {
                sum1+=(int)(num[i]-'0');
            }
            else
                
            {
                sum2+=(int)(num[i]-'0');
            }
            
        }
        return (sum1==sum2);
    }
};",1441282765
cm_fast,cm_fast,109,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
const int MAX_N = 80; // Maximum possible n as per constraints

ll gcd_custom(ll a, ll b)
{
    if (b == 0)
        return a;
    return gcd_custom(b, a % b);
}

ll add(ll x, ll y)
{
    x += y;
    while (x >= MOD)
        x -= MOD;
    while (x < 0)
        x += MOD;
    return x;
}

ll mul(ll x, ll y)
{
    return (x * y) % MOD;
}

ll binpow(ll x, ll y)
{
    ll z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

ll inv(ll x)
{
    return binpow(x, MOD - 2);
}

ll divide(ll x, ll y)
{
    return mul(x, inv(y));
}

ll fact_arr[81];
ll inv_fact_arr[81];

void precalc()
{
    fact_arr[0] = 1;
    for (ll i = 1; i <= 80; i++)
    {
        fact_arr[i] = mul(fact_arr[i - 1], i);
    }
    // Precompute inverse factorials
    inv_fact_arr[80] = divide(1, fact_arr[80]);
    for (ll i = 79; i >= 0; i--)
    {
        inv_fact_arr[i] = mul(inv_fact_arr[i + 1], i + 1);
    }
}

ll C(ll n, ll k)
{
    if (k > n || k < 0)
        return 0;
    return mul(fact_arr[n], mul(inv_fact_arr[k], inv_fact_arr[n - k]));
}

class Solution
{
public:
    
    ll memo_table[11][81][801]; 

    Solution()
    {
        for(int i=0;i<11;i++)
        {
            for(int j=0;j<81;j++)
            {
                 for(int k=0;k<801;k++)
                 {
                     memo_table[i][j][k] = -1;
                 }
            }
                
                    
        }
            
    }

    ll helper(int digit, int remaining_count, ll remaining_sum, const vector<ll> &original_freq)
    {
        if (remaining_count == 0 && remaining_sum == 0)
            return 1;
        if (digit > 9 || remaining_count < 0 || remaining_sum < 0)
            return 0;
        if (memo_table[digit][remaining_count][remaining_sum] != -1)
            return memo_table[digit][remaining_count][remaining_sum];
        ll total = 0;
        for (ll k = 0; k <= original_freq[digit] && k <= remaining_count && (ll)digit * k <= remaining_sum; k++)
        {
            total = add(total, mul(C(original_freq[digit], k), helper(digit + 1, remaining_count - k, remaining_sum - (ll)digit * k, original_freq)));
            total %= MOD;
        }
        return memo_table[digit][remaining_count][remaining_sum] = total;
    }

    ll countBalancedPermutations(string s)
    {
        precalc();
        ll n = s.size();
        if (n < 2)
            return 0;
        vector<ll> original_freq(10, 0);
        ll total_sum = 0;
        for (char c : s)
        {
            original_freq[c - '0']++;
            total_sum += (ll)(c - '0');
        }
        if (total_sum % 2 != 0)
            return 0;
        ll sum_p = total_sum / 2;
        int p = (n + 1) / 2;
        int q = n / 2;
        memset(memo_table, -1, sizeof(memo_table));
        ll ways = helper(0, p, sum_p, original_freq);
        if (ways == 0)
            return 0;
        ll fact_p = fact_arr[p];
        ll fact_q = fact_arr[q];
        ll denom = 1;
        for (int d = 0; d <= 9; d++)
        {
            denom = mul(denom, fact_arr[original_freq[d]]);
        }
        ll numerator = mul(mul(ways, fact_p), fact_q);
        ll denom_inv = inv(denom);
        ll result = mul(numerator, denom_inv);
        return result;
    }
};
",1441347789
Anupam Shah,user9218i,110,3627,cpp,"class Solution {
public:
    typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    vector<ll> dijkstra(vector<vector<pair<ll, ll>>> &G, ll v)
    {
        vector<ll> ans(G.size(), INF);
        ans[v] = 0;
        priority_queue<pair<ll, ll>> que;
        que.push({0, v});
        while (!que.empty())
        {
            auto [x, u] = que.top();
            que.pop();
            if (-x > ans[u])
                continue;
            for (auto [v, w] : G[u])
                if (ans[u] + w < ans[v])
                    ans[v] = ans[u] + w, que.push({-ans[v], v});
        }
        return ans;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        
        priority_queue<pair<ll, pair<ll,ll>>> que;
        que.push({0, {0, 0}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, ux = it.second.first, uy = it.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, {xx,yy}});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441301349
Anupam Shah,user9218i,110,3628,cpp,"class Solution {
public:
        typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<ll, pair<ll, pair<ll, ll>>>> que;
        que.push({0, {1, {0, 0}}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, p = it.second.first, ux = it.second.second.first, uy = it.second.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + p;
                    ll np = 1;
                    
                    if(p == 1)  np = 2;  
                    else np = 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, { np, {xx,yy} }});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441310479
Anupam Shah,user9218i,110,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for(int i = 0; i < num.length(); i ++)
            if(i % 2)   o += num[i] - '0';
            else e += num[i] - '0';
        return o == e;
    }
};",1441281198
Anupam Shah,user9218i,110,3637,cpp,"class Solution {
public:
    typedef long long ll;
    ll MOD = 1000000007;
    
    ll power(ll a, ll b, ll m) {
        ll ans = 1;
        while(b) {
            if(b & 1)
                ans = (ans * a) % m;
            b /= 2;
            a = (a * a) % m;
        }
        return ans;
    }
    
    ll go(ll ind, ll tk, ll csum, ll& sum, ll& req, ll& n, vector<ll>& f, vector<ll>& ff, vector<ll>& iff, vector<vector<vector<ll>>>& dp) {
        //cout << ind << "" "" << ind << "" ""<< tk << "" ""<< csum << endl;
        if(ind == 10) {
            if(tk == req and csum == sum) {
                //cout << ""YY"" << endl;
                return (ff[req] * ff[n-req]) % MOD;
            }
            return 0;
        }
        if(tk > req)    return 0;
        if(csum > sum)    return 0;
        
        if(dp[ind][tk][csum] != -1)     return dp[ind][tk][csum];
        
        ll ans = 0;
        for(ll i = 0; i <= f[ind]; i ++) {
            if(tk + i <= req and (csum + ( i * ind )) <= sum) {
                ll curr = (iff[i] * iff[f[ind] - i]) % MOD; 
                ans += curr * go(ind + 1, tk + i, csum + (i*ind), sum, req, n, f, ff, iff, dp);
                ans %= MOD;
            }
        }
        
        return dp[ind][tk][csum] = ans;
    }
    int countBalancedPermutations(string num) {
        ll sum = 0;
        vector<ll> f(10, 0);
        for(auto it : num) {
            //cout << it-'0' << endl;
            sum += (it - '0');
            f[it - '0'] ++;
        }
        if(sum % 2)     return 0;
        sum /= 2;
        
        vector<ll> ff(100, 1);
        vector<ll> iff(100, 1);
        
        for(int i = 0; i < 100; i ++)  {
            if(i)   ff[i] = ff[i-1] * i;
            ff[i] %= MOD;
            
            iff[i] = power(ff[i], MOD-2, MOD);
        }
        
        ll n = num.length();
        ll req = n/2;
        
        //cout << sum << "" -> "" << req << endl;
        
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (req+1, vector<ll> (sum+1, -1)));
        
        ll ans = go(0, 0, 0, sum, req, n, f, ff, iff, dp);
        return ans%MOD;
    }
};",1441354520
user5976fh,user5976fh,111,3627,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + 1, moveTime[newB][newC] + 1);
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC});
                        }
                }
            }
            
        }
        return -1;
    }
};",1441293815
user5976fh,user5976fh,111,3628,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,4>> q;
        q.push({0,0,0,1});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        vector<vector<int>> maxD2 = maxD;
        // let q[3] represent if move takes 1 or move takes 2
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c,d] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + d, moveTime[newB][newC] + d);
                    // based on D check which table to use
                    if (d == 1){
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                    else{
                        if (newT < maxD2[newB][newC]){
                            maxD2[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                        
                }
            }
            
        }
        return -1;
    }
};",1441297442
user5976fh,user5976fh,111,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); ++i){
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
            
        }

        return sum == 0;
    }
};",1441281034
user5976fh,user5976fh,111,3637,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;

    long long powerMod(long long x, long long y, long long modVal) {
        long long res = 1;
        x %= modVal;
        while (y > 0) {
            if (y & 1) res = res * x % modVal;
            x = x * x % modVal;
            y >>= 1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size();
        int freq[10] = {0};
        long long totalSum = 0;

        for (char c : num) {
            freq[c - '0']++;
            totalSum += (c - '0');
        }

        if (totalSum % 2 != 0) return 0;
        long long sumEven = totalSum / 2;
        int halfN = (n + 1) / 2;
        int maxLimit = 160;

        vector<long long> fact(maxLimit + 1, 1);
        for (int i = 1; i <= maxLimit; i++) fact[i] = fact[i - 1] * i % mod;

        vector<long long> invFact(maxLimit + 1, 1);
        invFact[maxLimit] = powerMod(fact[maxLimit], mod - 2, mod);
        for (int i = maxLimit - 1; i >= 0; i--) invFact[i] = invFact[i + 1] * (i + 1) % mod;

        vector<vector<long long>> comb(10, vector<long long>());
        for (int d = 0; d < 10; d++) {
            comb[d].resize(freq[d] + 1, 0);
            for (int x = 0; x <= freq[d]; x++) {
                comb[d][x] = (fact[freq[d]] * invFact[x] % mod) * invFact[freq[d] - x] % mod;
            }
        }

        long long productFreqFact = 1;
        for (int d = 0; d < 10; d++) {
            productFreqFact = productFreqFact * fact[freq[d]] % mod;
        }

        vector<vector<long long>> dpPrev(sumEven + 1, vector<long long>(halfN + 1, 0));
        dpPrev[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            vector<vector<long long>> dpNext(sumEven + 1, vector<long long>(halfN + 1, 0));
            for (long long s = 0; s <= sumEven; s++) {
                for (int c = 0; c <= halfN; c++) {
                    if (dpPrev[s][c] == 0) continue;
                    for (int x = 0; x <= freq[d]; x++) {
                        if (s + (long long)x * d > sumEven) break;
                        if (c + x > halfN) continue;
                        dpNext[s + x * d][c + x] = (dpNext[s + x * d][c + x] + dpPrev[s][c] * comb[d][x]) % mod;
                    }
                }
            }
            dpPrev = dpNext;
        }

        long long F = dpPrev[sumEven][halfN];
        long long invProductFreqFact = powerMod(productFreqFact, mod - 2, mod);
        long long totalPerms = fact[n] * invProductFreqFact % mod;
        long long answer = F * fact[halfN] % mod;
        answer = answer * fact[n - halfN] % mod;
        answer = answer * invProductFreqFact % mod;

        return (int)answer;
    }
};",1441356070
Harttle,harttle,112,3627,javascript,"/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(Infinity))
    while (heap.size()) {
        const [t, x, y] = heap.pop()
        if (dist[x][y] !== Infinity) continue
        dist[x][y] = t
        for (const [nx, ny] of [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]) {
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny] !== Infinity) continue
            const nt = Math.max(t + 1, moveTime[nx][ny] + 1)
            heap.push([nt, nx, ny])
        }
    }
    return dist[N - 1][M - 1]
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441297717
Harttle,harttle,112,3628,javascript,"const diffs = [0, 1, 0, -1, 0]
/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    const saw = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    while (heap.size()) {
        const [t, x, y, alt] = heap.pop()
        if (dist[x][y][alt] !== Infinity) continue
        dist[x][y][alt] = t
        const nalt = 1 - alt
        for (let i = 0; i < 4; i++) {
            const nx = x + diffs[i], ny = y + diffs[i + 1]
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny][nalt] !== Infinity) continue
            const nt = Math.max(t + 1 + alt, moveTime[nx][ny] + 1 + alt)
            if (nt < saw[nx][ny][nalt]) {
                saw[nx][ny][nalt] = nt
                heap.push([nt, nx, ny, nalt])
            }
        }
    }
    return Math.min(...dist[N - 1][M - 1])
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441315111
Harttle,harttle,112,3636,javascript,"/**
 * @param {string} num
 * @return {boolean}
 */
var isBalanced = function(nums) {
    const sums = [0, 0]
    for (let i = 0; i < nums.length; i++) sums[i % 2] += +nums[i]
    // console.log(sums)
    return sums[0] === sums[1]
};",1441284175
Harttle,harttle,112,3637,javascript,"const MOD = 1e9 + 7
var MODn = BigInt(MOD);
var _Ann = [1n];
/**
 * @param {string} num
 * @return {number}
 */
var countBalancedPermutations = function(num) {
    const digits = [...num].map(x => +x)
    const N = digits.length
    const EVEN = Math.ceil(N / 2)
    const ODD = N - EVEN
    const sum = digits.reduce((sum, d) => sum + d, 0)
    if (sum % 2) return 0
    const counts = Array(10).fill(0)
    for (const d of digits) counts[d]++
    const halfSum = sum / 2
    const memo = new Map()
    const comb = dfs(halfSum, 0, ODD)
    let ans = prod(comb, factorial(EVEN), factorial(ODD))
    // console.log('comb', comb, `fact(${EVEN})`, factorial(EVEN), `fact(${ODD})`, factorial(ODD))
    for (const count of counts) {
        if (count < 2) continue
        const fact = factorial(count)
        ans = prod(ans, modInverse(fact))
    }
    return ans
    function dfs(sum, begin, count) {
        if (sum < 0 || count < 0) return 0
        if (begin === N) return sum === 0 && count === 0 ? 1 : 0
        const key = sum * 10000 + begin * 100 + count
        if (memo.has(key)) return memo.get(key)
        let ans = 0
        ans += dfs(sum - digits[begin], begin + 1, count - 1)
        ans += dfs(sum, begin + 1, count)
        ans %= MOD
        memo.set(key, ans)
        return ans
    }
};
function prod(a, ...args) {
    if (!args.length) return a
    const prev = prod(...args)
    return Number(BigInt(a) * BigInt(prev) % MODn)
}
// src/euclidean.ts
function gcdExtended(a, b) {
  if (b === 0)
    return [a, 1, 0];
  const [gcd, x1, y1] = gcdExtended(b, a % b);
  return [gcd, y1, x1 - Math.floor(a / b) * y1];
}
function modInverse(a, M = MOD) {
  const [gcd, x] = gcdExtended(a, M);
  if (gcd !== 1)
    throw new Error(""inverse not exist"");
  return (x % M + M) % M;
}

// src/binomial.ts
function factorial(N) {
  const Nn = BigInt(N);
  for (let n = BigInt(_Ann.length); n <= Nn; n++)
    _Ann.push(_Ann[_Ann.length - 1] * n % MODn);
  return Number(_Ann[Number(N)]);
}
function factorialSeq(N) {
  factorial(N);
  return _Ann.slice(0, N + 1).map((x) => Number(x));
}
function pascalsTriangle(N) {
  const C = [[1n]];
  for (let n = 1; n <= N; ++n) {
    C.push(Array(n + 1));
    C[n][0] = C[n][n] = 1n;
    for (let k = 1; k < n; ++k) {
      C[n][k] = (C[n - 1][k - 1] + C[n - 1][k]) % MODn;
    }
  }
  for (let n = 0; n <= N; n++)
    for (let k = 0; k <= n; k++)
      C[n][k] = Number(C[n][k]);
  return C;
}
function combination(n, k) {
  const deno = modMultiply(factorial(k), factorial(n - k));
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function arrangement(n, k) {
  const deno = factorial(n - k);
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function modMultiply(a, b) {
  return Number(BigInt(a) * BigInt(b) % MODn);
}",1441343449
Dhruva N L,dhruva05,113,3627,cpp,"class Solution {
public:
     int n, m;
    const long long INF = 1e18;
    vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    
    void initArrival(vector<vector<long long>>& arr) {
        for (int i = 0; i < n; i++) {
            fill(arr[i].begin(), arr[i].end(), INF);
        }
        arr[0][0] = 0;
    }
    
    bool isValid(int x, int y) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return 0;
        m = moveTime[0].size();
        vector<vector<long long>> arr(n, vector<long long>(m));
        initArrival(arr);
        
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        while (!pq.empty()) {
            auto [curTime, x, y] = pq.top();
            pq.pop();
            
            if (x == n - 1 && y == m - 1) return (int)curTime;
            if (curTime > arr[x][y]) continue;

            for (auto &[dx, dy] : dirs) {
                int nx = x + dx, ny = y + dy;
                if (isValid(nx, ny)) {
                    long long newTime = max(curTime, (long long)moveTime[nx][ny]) + 1;
                    if (newTime < arr[nx][ny]) {
                        arr[nx][ny] = newTime;
                        pq.emplace(newTime, nx, ny);
                    }
                }
            }
        }
        return -1;
    }
};",1441318569
Dhruva N L,dhruva05,113,3628,cpp,"class Solution {
    typedef long long ll;
    const ll INF = 1e18;
    
    int n, m;

    int encode(int i, int j, int parity) {
        return (i * m + j) * 2 + parity;
    }

    tuple<int, int, int> decode(int id) {
        int p = id % 2;
        int temp = id / 2;
        int j = temp % m;
        int i = temp / m;
        return {i, j, p};
    }

    void updateTime(priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> &pq,
                    vector<vector<vector<ll>>> &arrTimes, int i, int j, int p, ll arr) {
        if (arr < arrTimes[i][j][p]) {
            arrTimes[i][j][p] = arr;
            pq.push({arr, encode(i, j, p)});
        }
    }

public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return -1;
        m = moveTime[0].size();
        if (m == 0) return -1;

        vector<vector<vector<ll>>> arrTimes(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;

        arrTimes[0][0][0] = 0;
        pq.push({0, encode(0, 0, 0)});
        
        vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!pq.empty()) {
            auto [currTime, id] = pq.top(); pq.pop();
            auto [i, j, p] = decode(id);
            
            if (i == n - 1 && j == m - 1) return (int)currTime;
            if (currTime > arrTimes[i][j][p]) continue;

            for (auto &[di, dj] : dirs) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    ll moveDur = (p == 0) ? 1 : 2;
                    ll startTime = max(currTime, (ll)moveTime[ni][nj]);
                    ll arr = startTime + moveDur;
                    int np = 1 - p;
                    updateTime(pq, arrTimes, ni, nj, np, arr);
                }
            }
        }
        
        return -1;
    }
};",1441335644
Dhruva N L,dhruva05,113,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

        for (int i = 0; i < num.length(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0)
                es += d;
            else
                os += d;
        }

        return es == os;
    }
};",1441291195
Dhruva N L,dhruva05,113,3637,java,"class Solution {
    private static final int MOD = 1_000_000_007;

    private long powerMod(long x, long y, long mod) {
        long res = 1;
        x %= mod;
        while (y > 0) {
            if ((y & 1) == 1) {
                res = res * x % mod;
            }
            x = x * x % mod;
            y >>= 1;
        }
        return res;
    }

    private void computeFactAndInvFact(long[] fact, long[] invFact, int maxN) {
        fact[0] = 1;
        for (int i = 1; i <= maxN; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[maxN] = powerMod(fact[maxN], MOD - 2, MOD);
        for (int i = maxN - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    private long calculateDigitCountsAndSum(String num, int[] digitCount) {
        long totalSum = 0;
        for (char ch : num.toCharArray()) {
            digitCount[ch - '0']++;
            totalSum += (ch - '0');
        }
        return totalSum;
    }

    private long[][] initializeDpArray(int halfLen, int halfSum) {
        long[][] dp = new long[halfLen + 1][halfSum + 1];
        dp[0][0] = 1;
        return dp;
    }

    private long processDp(int halfLen, int halfSum, int[] digitCount, long[] invFact, long[][] dp) {
        for (int d = 0; d < 10; d++) {
            int countD = digitCount[d];
            long[][] tempDp = new long[halfLen + 1][halfSum + 1];

            for (int c = 0; c <= halfLen; c++) {
                for (int s = 0; s <= halfSum; s++) {
                    if (dp[c][s] == 0) continue;
                    int maxA = Math.min(countD, halfLen - c);

                    for (int aD = 0; aD <= maxA; aD++) {
                        int newC = c + aD;
                        long newS = s + (long) d * aD;
                        if (newS > halfSum) continue;
                        tempDp[newC][(int) newS] = (tempDp[newC][(int) newS] + dp[c][s] * invFact[aD] % MOD * invFact[countD - aD] % MOD) % MOD;
                    }
                }
            }
            dp = tempDp;
        }
        return dp[halfLen][halfSum];
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] digitCount = new int[10];
        long totalSum = calculateDigitCountsAndSum(num, digitCount);

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int halfLen = (n + 1) / 2;

        long[] fact = new long[n + 1];
        long[] invFact = new long[n + 1];
        computeFactAndInvFact(fact, invFact, n);

        long[][] dp = initializeDpArray(halfLen, (int) halfSum);
        long validAssignments = processDp(halfLen, (int) halfSum, digitCount, invFact, dp);

        long answer = fact[halfLen] * fact[n - halfLen] % MOD;
        answer = answer * validAssignments % MOD;

        return (int) answer;
    }
}",1441356821
rarelytested,rarelytested,114,3627,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = 1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441356900
rarelytested,rarelytested,114,3628,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = (x+y)%2+1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441355901
rarelytested,rarelytested,114,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s0 += num[i] - '0';
            } else {
                s1 += num[i] - '0';
            }
        }
        return s0 == s1;
    }
};",1441282560
rarelytested,rarelytested,114,3637,cpp,"class Solution {
   public:
#define MOD 1000000007
    long long C[100][100];
    void init() {
        C[0][0] = 1;
        for (int i = 1; i < 100; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        vector<int> cnt(10, 0);
        for (int i = 0; i < num.size(); i++) {
            sum += num[i] - '0';
            cnt[num[i] - '0']++;
        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        init();

        int n0 = (num.size() + 1) / 2;
        int n1 = num.size() - n0;
        vector<vector<vector<long long>>> dp(
            10,
            vector<vector<long long>>(sum + 1, vector<long long>(n0 + 1, 0)));
        int tot = 0;
        for (int i = 0; i < 10; i++) {
            if (i == 0) {
                for (int j = 0; j <= cnt[i]; j++) {
                    if (j > n0) {
                        break;
                    }
                    dp[i][0][j] = C[n0][j] * C[n1][cnt[i] - j] % MOD;
                }
                tot += cnt[i];
                continue;
            }
            for (int j = 0; j <= sum; j++) {
                for (int k = 0; k <= n0; k++) {
                    if (dp[i - 1][j][k] == 0) {
                        continue;
                    }
                    for (int l = 0; l <= cnt[i]; l++) {
                        if (j + l * i > sum || k + l > n0) {
                            break;
                        }
                        if (n1 - (tot-k) < 0) {
                            continue;
                        }
                        if (tot < k) {
                            continue;
                        }
                        // if (i == 3) {
                        //     std::cout << i << "" "" << j << "" "" << k << "" "" << l
                        //               << "" "" << dp[i - 1][j][k] << "" ""
                        //               << C[n0 - k][l] << "" ""
                        //               << C[n1 - (tot-k)][cnt[i] - l]
                        //               << std::endl;
                        // }
                        dp[i][j + l * i][k + l] +=
                            dp[i - 1][j][k] * C[n0 - k][l] % MOD *
                            C[n1 - (tot-k)][cnt[i] - l] % MOD;
                        dp[i][j + l * i][k + l] %= MOD;
                    }
                }
            }
            tot += cnt[i];
        }
        // std::cout << dp[2][3][2] << std::endl;
        return dp[9][sum][n0];
    }
};",1441338543
Yucheng Dai,Rainingcity,115,3627,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(0, make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [d, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + 1;
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(-nt, make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441293574
Yucheng Dai,Rainingcity,115,3628,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(make_pair(0, 1), make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [dd, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            auto [d, step] = dd;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + (step ? 1 : 2);
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(make_pair(-nt, !step), make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441297044
Yucheng Dai,Rainingcity,115,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < num.length(); i++) {
            if (i & 1) {
                r += num[i] - '0';
            } else {
                l += num[i] - '0';
            }
        }
        return l == r;
    }
};",1441281589
Yucheng Dai,Rainingcity,115,3637,cpp,"typedef long long ll;
const ll MOD = 1000000007;
vector<ll> buildFact(ll n) {
    vector<ll> fact(n + 1, 0);
    fact[0] = fact[1] = 1;
    for(ll i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    return fact;
}
vector<vector<ll>> buildC(ll n) {
    vector<vector<ll>> C(n + 1, vector<ll>(n + 1, 0));
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(ll i = 2; i <= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(ll j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
    return C;
}
ll gcdExtended(ll a, ll b, ll& x, ll& y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    ll d = gcdExtended(b % a, a, x, y);
    ll t = x;
    x = y - (b / a) * x;
    y = t;
    return d;
}
ll modInverse(ll a) {
    ll x, y;
    ll g = gcdExtended(a, MOD, x, y);
    return (x % MOD + MOD) % MOD;
}
vector<ll> buildInv(vector<ll>& l) {
    vector<ll> res{};
    for(ll x: l) {
        res.push_back(modInverse(x));
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        int sum = 0;
        int cnt[10];
        memset(cnt, 0, sizeof(cnt));
        for(char c: num) {
            sum += c - '0';
            cnt[c - '0']++;
        }
        if (sum & 1) return 0;
        vector<vector<ll>> C = buildC(n);
        vector<ll> fact = buildFact(n);
        vector<ll> factInv = buildInv(fact);
        int m = (n + 1) / 2;
        sum /= 2;
        // cur_digit, left #digit, left sum
        vector<vector<vector<ll>>> dp(11, vector<vector<ll>>(m + 1, vector<ll>(sum + 1, 0)));
        dp[0][0][0] = 1;
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= m; j++) {
                for(int k = 0; k <= sum; k++) {
                    for(int t = 0; t <= cnt[i] && t <= j && i * t <= k; t++) {
                        dp[i + 1][j][k] = (dp[i + 1][j][k] + ((dp[i][j - t][k - i * t] * factInv[t]) % MOD) * factInv[cnt[i] - t]) % MOD;
                        // cout << i << "" "" << j << "" "" << k << "" "" << dp[i + 1][j][k] << endl;
                    }
                }
            }
        }
        return (((dp[10][m][sum] * fact[m]) % MOD) * fact[n - m]) % MOD;
    }
};",1441357030
Shashwat Tripathi,Fkaiser7,117,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,
            greater<pair<int,pair<int,int>>>>pq;
        pq.push({0,{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({t1,{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({t1,{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({t1,{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({t1,{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441296836
Shashwat Tripathi,Fkaiser7,117,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<pair<int,int>,pair<int,int>>,vector<pair<pair<int,int>,pair<int,int>>>,
            greater<pair<pair<int,int>,pair<int,int>>>>pq;
        pq.push({{0,0},{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first.first;
            int turn=it.first.second;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+turn+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+turn+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({{t1,1-turn},{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1+turn;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1+turn;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({{t1,1-turn},{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1+turn;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1+turn;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({{t1,1-turn},{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1+turn;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1+turn;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({{t1,1-turn},{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441304766
Shashwat Tripathi,Fkaiser7,117,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int a=0,b=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        return a==b;
    }
};",1441281257
Shashwat Tripathi,Fkaiser7,117,3637,cpp,"#define lli long long
lli mod=1e9+7;
vector<lli>fact(81);
void calc(){
    lli p=1;
    fact[0]=fact[1]=1;
    for(lli i=2;i<=80;i++){
        p=(p%mod*i%mod)%mod;
        fact[i]=p;
    }
}
long long power(long long i, int j) { return j ? j & 1 ? power(i * i % mod, j >> 1) * i % mod : power(i * i % mod, j >> 1) : 1; }
lli comb(lli n,lli r){
    lli t=fact[n];
    lli t1=(fact[r]%mod*fact[n-r]%mod)%mod;
    t1=power(t1,mod-2);
    t=(t%mod*t1%mod)%mod;
    return t;
}
class Solution {
public:
    lli fuc(lli i,lli o,lli sum,vector<lli>&freq,vector<vector<vector<lli>>>&dp
,lli &n){
        if(i==10){
            if(sum==0){
                return 1;
            }
            return 0;
        }
        if(dp[i][o][sum]!=-1){
            return dp[i][o][sum];
        }
        lli o1=n/2;
        if(n%2){
            o1++;
        }
        lli e=0;
        if(i!=0){
            e=freq[i-1]-o1+o;
        }
        e=n/2-e;
        lli t=freq[i];
        if(i!=0){
            t-=freq[i-1];
        }
        //cout<<i<<"" ""<<o<<"" ""<<e<<"" ""<<t<<"" ""<<sum<<endl;
        //cout<<i<<"" ""<<o<<"" ""<<e<<endl;
        lli ans=0;
            for(lli j=0;j<=t;j++){
                if(t-j>e||j>o||j*i>sum){
                    continue;
                }
                lli ans1=(comb(o,j)%mod*comb(e,t-j)%mod)%mod;
                ans1=(ans1%mod*fuc(i+1,o-j,sum-j*i,freq,dp,n)%mod)%mod;
                ans+=ans1;
                ans%=mod;
            }
        //cout<<i<<"" ""<<o<<"" ""<<t<<"" ""<<sum<<"" ""<<ans<<endl;
        return dp[i][o][sum]=ans;
    }
    int countBalancedPermutations(string num) {
        calc();
        //cout<<comb(4,2)<<endl;
        lli n=num.length();
        lli o=n/2,e=n/2;
        if(n%2){
            o++;
        }
        vector<lli>freq(10);
        lli sum=0;
        for(lli i=0;i<n;i++){
            freq[num[i]-'0']++;
            sum+=num[i]-'0';
        }
        if(sum%2){
            return 0;
        }
        vector<vector<vector<lli>>>dp(10,vector<vector<lli>>(n+1,
        vector<lli>(sum/2+1,-1)));
        vector<lli>freq1(10);
        for(lli i=0;i<10;i++){
            if(i==0){
                freq1[i]=freq[i];
            }
            else{
                freq1[i]=freq1[i-1]+freq[i];
            }
        }
        //cout<<sum<<endl;
        return (int)(fuc(0,o,sum/2,freq1,dp,n));
    }
};",1441358541
lilPeep,stupidRR,118,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<int>> dp(n,vector<int>(m,2e9));
        dp[0][0]=0;
        
        set< array<int,3> > dij;
        dij.insert( {0,0,0} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y]=*dij.begin();
            dij.erase( dij.begin() );
            
            cout << X << "" "" << Y << "" "" << tim << endl;
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim+1,ar[x][y]+1);
                    if( dp[x][y] > reach )
                    {
                        dij.erase( {dp[x][y],x,y} );
                        dp[x][y]=reach;
                        dij.insert( {dp[x][y],x,y} );
                    }
                }
            }
        }
        cout << endl;
        return dp[n-1][m-1];
    }
};",1441298381
lilPeep,stupidRR,118,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(2,2e9)));
        dp[0][0][1]=0;
        
        set< array<int,4> > dij;
        dij.insert( {0,0,0,1} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y,type]=*dij.begin();
            dij.erase( dij.begin() );
            
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim,ar[x][y])+2-type%2;
                    if( dp[x][y][1-type] > reach )
                    {
                        dij.erase( {dp[x][y][1-type],x,y,1-type} );
                        dp[x][y][1-type]=reach;
                        dij.insert( {dp[x][y][1-type],x,y,1-type} );
                    }
                }
            }
        }
        return std::min(dp[n-1][m-1][0],dp[n-1][m-1][1]);
    }
};",1441303245
lilPeep,stupidRR,118,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum=0;
        for(int i=0;i<num.size();i++)
        {
            if(i%2)
                sum+=(num[i]-'0');
            else
                sum=sum-(num[i]-'0');
        }
        return !sum;
    }
};",1441282957
lilPeep,stupidRR,118,3637,cpp,"typedef long long ll;
class Solution {
    ll factorial[101];
    ll inverse[101];
       
    ll binpow(ll base,ll ex)
    {
        if(ex<0)
          return 0ll;
        ll ans=1;
        while(ex>0)
        {
            if(ex%2==1)
                    ans=(ans*base)%mod;
            base=(base*base)%mod;
            ex=ex/2;
        }
        return ans;
    }
     
    void pre()
    {
       factorial[0]=1;
       inverse[0]=1;
       for(int i=1;i<=100;i++)
           factorial[i]=(factorial[i-1]*i)%mod;
       
       inverse[100]=binpow(factorial[100],mod-2);
       for(int i=99;i>=0;i--)
          inverse[i]=(inverse[i+1]*(i+1ll))%mod;
    }
     
    ll nCr(int n , int r)
    {
        if(n<0 || r<0 || n<r)
                return 0;
        ll ans=1;
        ans=factorial[n];
        ans=(ans*inverse[n-r])%mod;
        ans=(ans*inverse[r])%mod;
        return ans;
    }
    const int mod=1e9+7;
public:
    int countBalancedPermutations(string num) {
        int n=num.size();
        pre();
        int odd=(n)/2;

        vector<int> freq(10);
        for(auto ele : num)
            freq[ele-'0']++;

        vector<vector<long long>> dp(odd+1,vector<long long>(1001,0));
        dp[ odd ][ 500 ]=1ll;
        int placedTillNow=0;
        int even=n-odd;

        for(int i=0;i<10;i++) // 10* 41*41*1000 = 16000*2000 
        {
            int val=freq[i];
            if(val==0)
                continue;

            vector<vector<long long>> ndp(odd+1,vector<long long>(1001,0));

            for(int oddHave=0;oddHave<=odd;oddHave++)
            {
                for(int j=oddHave;j<=odd;j++)
                {

                    int oddUsed=j-oddHave;
                    if(oddUsed>val)
                        break;
                    int evenUsed=val-oddUsed;
                    
                    int oddPlacedTillNow=odd-j;
                    int evenPlaced=placedTillNow-oddPlacedTillNow;

                    if(evenPlaced+evenUsed > even)
                        continue;
                    
                    int delta=oddUsed*i-evenUsed*i;

                    for(int sum=0;sum<=1000;sum++)
                    {
                        if(sum+delta <=1000 && sum+delta>=0 && dp[j][sum])
                            ndp[oddHave][sum+delta]=(ndp[oddHave][sum+delta]+ dp[j][sum]* ((nCr(odd-oddPlacedTillNow,oddUsed)*nCr(even-evenPlaced,evenUsed))%mod) )%mod;
                    }
                }
            }
            placedTillNow+=val;
            swap(dp,ndp);
        }

        return dp[0][500];
    }
};

",1441339362
Srujan_Teja_Rayella,Srujan_code_code,119,3627,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        int[][] distance = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        priorityQueue.offer(new int[]{0, 0, 0}); // {time, row, col}
        distance[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!priorityQueue.isEmpty()) {
            int[] current = priorityQueue.poll();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > distance[currentRow][currentCol]) continue;

            for (int[] direction : directions) {
                int newRow = currentRow + direction[0];
                int newCol = currentCol + direction[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int newTime = Math.max(currentTime, moveTime[newRow][newCol]) + 1;

                    if (newTime < distance[newRow][newCol]) {
                        distance[newRow][newCol] = newTime;
                        priorityQueue.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }

        return distance[rows - 1][cols - 1];
    }
}


",1441321285
Srujan_Teja_Rayella,Srujan_code_code,119,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] dp = new int[n][m][2];
        for (int[][] arr : dp) {
            for (int[] subArr : arr) {
                Arrays.fill(subArr, Integer.MAX_VALUE);
            }
        }
        dp[0][0][0] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int time = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];

            if (time > dp[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);

                    if (newTime < dp[newRow][newCol][1 - parity]) {
                        dp[newRow][newCol][1 - parity] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol, 1 - parity});
                    }
                }
            }
        }

        return Math.min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
}



",1441326648
Srujan_Teja_Rayella,Srujan_code_code,119,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumEvenPositions = 0;
        int sumOddPositions = 0;
        
        for (int index = 0; index < num.length(); index++) {
            int digitValue = num.charAt(index) - '0'; 
            
            if (index % 2 == 0) {
                sumEvenPositions += digitValue; 
            } else {
                sumOddPositions += digitValue; 
            }
        }
        
        return sumEvenPositions == sumOddPositions;
    }
}
",1441297850
Srujan_Teja_Rayella,Srujan_code_code,119,3637,java,"class Solution {
    private static final int MOD = 1000000007;

    public int countBalancedPermutations(String num) {
        int length = num.length();
        long totalSum = 0;
        int[] counts = new int[10];

        for (char digit : num.toCharArray()) {
            int d = digit - '0';
            totalSum += d;
            counts[d]++;
        }

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int m = (length + 1) / 2;
        long[] factorial = new long[length + 1];
        long[] invFactorial = new long[length + 1];
        factorial[0] = 1;

        for (int i = 1; i <= length; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        invFactorial[length] = modInverse(factorial[length], MOD);

        for (int i = length - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        long[][] dp = new long[m + 1][(int) (halfSum + 1)];
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (counts[d] == 0) {
                continue;
            }

            for (int k = m; k >= 0; k--) {
                for (int s = (int) halfSum; s >= 0; s--) {
                    if (dp[k][s] == 0) {
                        continue;
                    }

                    for (int t = 1; t <= counts[d]; t++) {
                        if (k + t > m || s + d * t > halfSum) {
                            break;
                        }
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(counts[d], t, factorial, invFactorial, MOD)) % MOD;
                    }
                }
            }
        }

        long w = dp[m][(int) halfSum];
        long result = factorial[m] * factorial[length - m] % MOD;

        for (int d = 0; d < 10; d++) {
            result = result * invFactorial[counts[d]] % MOD;
        }

        result = result * w % MOD;
        return (int) result;
    }

    private long modInverse(long a, int m) {
        long result = 1;
        long base = a;
        int p = m - 2;

        while (p > 0) {
            if ((p & 1) == 1) {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        return result;
    }

    private long comb(int n, int k, long[] factorial, long[] invFactorial, int m) {
        if (k > n) {
            return 0;
        }
        return factorial[n] * invFactorial[k] % m * invFactorial[n - k] % m;
    }
}

",1441353506
sveng101,sveng101,120,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0))]
        while heap:
            t, pos = heapq.heappop(heap)
            if pos in seen: continue
            seen.add(pos)
            for pos2 in move(pos):
                if pos2 in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1
                if pos2 == target:
                    return t2
                heapq.heappush(heap, (t2, pos2))
        return -1",1441300706
sveng101,sveng101,120,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0), False)]
        while heap:
            t, pos, even = heapq.heappop(heap)
            #print(pos, even, t)
            if (pos, even) in seen: continue
            elif pos == target:
                return t
            seen.add((pos, even))
            for pos2 in move(pos):
                if (pos2, not even) in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1 + even
                heapq.heappush(heap, (t2, pos2, not even))
        return -1",1441308855
sveng101,sveng101,120,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res = 0
        n = len(num)
        for i in range(0, n, 2):
            res += int(num[i])
        for i in range(1, n, 2):
            res -= int(num[i])
        return not res
        """"""
        while num:
            num, d = divmod(num, 10)
            res += d if d & 1 else -d
        return not res
        """"""",1441289145
sveng101,sveng101,120,3637,python3,"import math
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        md = 10 ** 9 + 7

        n = len(num)
        
        cnts = {}
        tot = 0
        for d in num:
            d2 = int(d)
            cnts[d2] = cnts.get(d2, 0) + 1
            tot += d2
        if tot & 1: return 0
        tot_target = tot >> 1
        res = 0
        cnts2 = sorted([(y, x) for x, y in cnts.items()])
        m = len(cnts2)
        cnt_target = n >> 1
        #print(cnts2)
        memo = {}
        def backtrack(idx: int, cnt_rem: int=cnt_target, tot_rem: int=tot_target) -> int:
            f_tot, num = cnts2[idx]
            if idx == m - 1:
                f = cnt_rem
                if f > f_tot or f * num != tot_rem: return 0
                return (math.factorial(cnt_target) * math.factorial(n - cnt_target)) // (math.factorial(f) * math.factorial(f_tot - f))
            args = (idx, cnt_rem, tot_rem)
            if args in memo.keys(): return memo[args]
            res = 0
            cnt_rem2 = cnt_rem
            tot_rem2 = tot_rem
            for f in range(min(f_tot, cnt_rem) + 1):
                res += backtrack(idx + 1, cnt_rem=cnt_rem2, tot_rem=tot_rem2) // (math.factorial(f) * math.factorial(f_tot - f))
                cnt_rem2 -= 1
                tot_rem2 -= num
                if tot_rem2 < 0: break
            memo[args] = res
            return res
        res =(backtrack(0)) % md
        #print(memo)
        return res",1441359877
Pankaj Ananda Bhosale,pankaj_777,121,3627,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dist(n, vector<ll> (m, inf));
        dist[0][0] = 0;
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, greater<array<ll, 3>>> pq;
        pq.push({0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 : moveTime[nrow][ncol] + 1);
                    if (dist[nrow][ncol] > ntime) {
                        dist[nrow][ncol] = ntime;
                        pq.push({ntime, nrow, ncol});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441315132
Pankaj Ananda Bhosale,pankaj_777,121,3628,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        ll dist[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }
        
        dist[0][0][0] = 0;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, greater<array<ll, 4>>> pq;
        pq.push({0, 0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0], parity = pq.top()[3];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 + parity : moveTime[nrow][ncol] + 1 + parity);
                    if (dist[nrow][ncol][1 - parity] > ntime) {
                        dist[nrow][ncol][1 - parity] = ntime;
                        pq.push({ntime, nrow, ncol, 1 - parity});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441320881
Pankaj Ananda Bhosale,pankaj_777,121,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int cntEven = 0, cntOdd = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2) cntEven += num[i] - '0';
            else cntOdd += num[i] - '0';
        }
        
        return cntOdd == cntEven;
    }
};",1441281857
Pankaj Ananda Bhosale,pankaj_777,121,3637,cpp,"#define ll long long int
const int mod = 1e9 + 7;

int mulm(ll a, ll b) {
    return (a * b) % mod;
}

int addm(ll a, ll b) {
    return (a + b) % mod;
}

ll powr(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = mulm(res, a);
        a = mulm(a, a);
        b = b >> 1;
    }
    return res;
}

ll inv(ll x) {
    if (x <= 1) return 1;
    return powr(x, mod - 2);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        
        int tot_sum = 0;
        vector<int> cnt(10, 0), fact(n + 1, 1);
        for (int i = 0; i < n; i++) {
            tot_sum += (num[i] - '0');
            cnt[num[i] - '0']++;
        }
        
        if (tot_sum % 2) return 0;
        
        for (int i = 2; i <= n; i++) {
            fact[i] = mulm(i, fact[i - 1]);
        }
        
        vector<vector<vector<int>>> dp(10, vector<vector<int>> (400, vector<int> (n + 1, -1)));
        auto fun = [&] (int idx, int sum_even, int cntEven, auto&& fun) -> int {
            if (idx == 10) {
                return (sum_even == tot_sum / 2 and cntEven == n / 2) * mulm(fact[n / 2], fact[(n + 1) / 2]);
            }
            
            if (dp[idx][sum_even][cntEven] != -1) return dp[idx][sum_even][cntEven];
            
            int res = 0;
            for (int c = 0; c <= cnt[idx]; c++) {
                res = addm(res, mulm(fun(idx + 1, sum_even + c * idx, cntEven + c, fun), mulm(inv(fact[c]), inv(fact[cnt[idx] - c]))));
            }

            return dp[idx][sum_even][cntEven] = res;
        };
        
        return fun(0, 0, 0, fun);
    }
};",1441359987
i_will_beat_my_iq,i_will_beat_my_iq,122,3627,cpp,"class Solution {
public:
#define ll long long
void f1(int x, int y, int curr_t, vector<vector<int>>& t, vector<vector<int>>& d, 
                           priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>>& q,
                           int dirs[][2], ll r, ll c) {
        ll i = 0;
        while (i < 4) {
            int nx = x + dirs[i][0], ny = y + dirs[i][1];
            if (f2(nx, ny, r, c)) {
                int new_t = f3(curr_t, t[nx][ny]);
                if (new_t < d[nx][ny]) {
                    d[nx][ny] = new_t;
                    q.push({new_t, {nx, ny}});
                }
            }
            i++;
        }
    }

    bool f2(int x, int y, ll r, ll c) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }

    int f3(int curr_t, int move_t) {
        return max(curr_t, move_t) + 1;
    }
    int minTimeToReach(vector<vector<int>>& t) {
        ll r = t.size();
        ll c = t[0].size();
        vector<vector<int>> d(r, vector<int>(c, INT32_MAX));
        d[0][0] = 0;

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> q;
        q.push({0, {0, 0}});

        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!q.empty()) {
            auto [curr_t, pos] = q.top();
            int x = pos.first, y = pos.second;
            q.pop();

            if (x == r - 1 && y == c - 1) return curr_t;
            if (curr_t > d[x][y]) continue;

            f1(x, y, curr_t, t, d, q, dirs, r, c);
        }
        return -1;
    }
};",1441314147
i_will_beat_my_iq,i_will_beat_my_iq,122,3628,cpp,"class Solution {
public:
struct S {
    long long a;
    int b;
    int c;
    int d;
    bool operator<(const S& o) const {
        return a > o.a;
    }
};

 priority_queue<S> f1() {
        priority_queue<S> a;
        return a;
    }

    vector<pair<int, int>> f2() {
        vector<pair<int, int>> a = { {1,0}, {-1,0}, {0,1}, {0,-1} };
        return a;
    }

    S f3(priority_queue<S>& a) {
        S b = a.top();
        a.pop();
        return b;
    }

    bool f4(int a, int b, int c, int d) {
        return (a >= 0 && a < c && b >= 0 && b < d);
    }

    int f5(int a) {
        return (a == 0) ? 1 : 2;
    }

    long long f6(long long a, vector<vector<int>>& b, int c, int d) {
        return max(a, (long long)b[c][d]);
    }

    S f7(long long a, int b, int c, int d) {
        S e;
        e.a = a;
        e.b = b;
        e.c = c;
        e.d = d;
        return e;
    }
    int minTimeToReach(vector<vector<int>>& a) {
        vector<vector<int>> b = a;
        int c = b.size();
        if(c == 0) return -1;
        int d = b[0].size();
        if(d == 0) return -1;
        long long e = 1000000000000000000;
        vector<vector<long long>> f(c, vector<long long>(d, e));
        vector<vector<long long>> g(c, vector<long long>(d, e));
        priority_queue<S> h = f1();
        S i;
        i.a = 0;
        i.b = 0;
        i.c = 0;
        i.d = 0;
        f[0][0] = 0;
        h.push(i);
        vector<pair<int, int>> j = f2();
        while(!h.empty()) {
            S k = f3(h);
            if(k.b == c-1 && k.c == d-1){
                return (int)k.a;
            }
            if((k.d == 0 && k.a > f[k.b][k.c]) || 
               (k.d == 1 && k.a > g[k.b][k.c])) {
                continue;
            }
            for(int l = 0; l < j.size(); l++) {
                pair<int, int> m = j[l];
                int n = k.b + m.first;
                int o = k.c + m.second;
                if(!f4(n, o, c, d)) continue;
                int p = f5(k.d);
                long long q = f6(k.a, b, n, o);
                long long r = q + p;
                int s = 1 - k.d;
                if(s == 0){
                    if(r < f[n][o]){
                        f[n][o] = r;
                        S t = f7(r, n, o, s);
                        h.push(t);
                    }
                }
                else{
                    if(r < g[n][o]){
                        g[n][o] = r;
                        S u = f7(r, n, o, s);
                        h.push(u);
                    }
                }
            }
        }
        return -1;
    }
};",1441342852
i_will_beat_my_iq,i_will_beat_my_iq,122,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int se = 0, so = 0, i = 0;
        while (i < s.size()) {
            int d = s[i] - '0';
            (i % 2 == 0) ? se += d : so += d;
            i++;
        }
        return se == so;
    }
};",1441308665
i_will_beat_my_iq,i_will_beat_my_iq,122,3637,cpp,"class Solution {
public:
typedef long long ll;
static const int mx = 80;
ll mod_val = 1000000007;
ll f[mx + 1], inv_f[mx + 1];

ll f1(ll x, ll y, ll mod) {
    ll r = 1;
    x %= mod;
    while (y > 0) {
        if (y & 1) {
            r = r * x % mod;
        }
        x = x * x % mod;
        y >>= 1;
    }
    return r;
}
void f2() {
    f[0] = 1;
    for (int i = 1; i <= mx; i++) {
        f[i] = f[i - 1] * i % mod_val;
    }
    inv_f[mx] = f1(f[mx], mod_val - 2, mod_val);
    for (int i = mx - 1; i >= 0; i--) {
        inv_f[i] = inv_f[i + 1] * (i + 1) % mod_val;
    }
}
void f4(string &s, int freq[]) {
        for (char c : s) {
            freq[c - '0']++;
        }
    }

    ll f5(int freq[]) {
        ll total = 0;
        for (int d = 0; d <= 9; d++) {
            total += (ll)d * freq[d];
        }
        return total;
    }

    void f6(int freq[], ll grp_size, ll half, vector<vector<ll>> &dp_prev, vector<vector<ll>> &dp_curr) {
        for (int d = 0; d <= 9; d++) {
            for (int j = 0; j <= grp_size; j++) {
                fill(dp_curr[j].begin(), dp_curr[j].end(), 0LL);
            }

            for (int j = 0; j <= grp_size; j++) {
                for (int k = 0; k <= half; k++) {
                    if (dp_prev[j][k] == 0) continue;
                    f8(dp_curr, dp_prev, freq[d], j, k, d, grp_size, half);
                }
            }
            swap(dp_prev, dp_curr);
        }
    }

    ll f7(int freq[]) {
        ll denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * inv_f[freq[d]] % mod_val;
        }
        return denom;
    }

    void f8(vector<vector<ll>> &dp_curr, vector<vector<ll>> &dp_prev, int freq_d, int j, int k, int d, int grp_size, ll half) {
        for (int c = 0; c <= freq_d && j + c <= grp_size && k + c * d <= half; c++) {
            ll comb = f[freq_d] * inv_f[c] % mod_val * inv_f[freq_d - c] % mod_val;
            dp_curr[j + c][k + c * d] = (dp_curr[j + c][k + c * d] + dp_prev[j][k] * comb) % mod_val;
        }
    }
    int countBalancedPermutations(string s) {
        bool init = false;
        if (!init) {
            f2();
            init = true;
        }

        int freq[10] = {0};
        f4(s, freq);

        ll total = f5(freq);

        if (total % 2 != 0) return 0;

        ll half = total / 2;
        ll grp_size = (s.size() + 1) / 2;
        ll odd_grp_size = s.size() - grp_size;

        vector<vector<ll>> dp_prev(grp_size + 1, vector<ll>(half + 1, 0));
        vector<vector<ll>> dp_curr(grp_size + 1, vector<ll>(half + 1, 0));
        dp_prev[0][0] = 1;

        f6(freq, grp_size, half, dp_prev, dp_curr);

        ll total_comb = dp_prev[grp_size][half];
        ll denom = f7(freq);

        ll res = f[grp_size] * f[odd_grp_size] % mod_val;
        res = (res * total_comb) % mod_val;
        res = (res * denom) % mod_val;

        return res;
    }
};",1441353944
virinci,virinci,124,3627,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307496
virinci,virinci,124,3628,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, 3 - incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307148
virinci,virinci,124,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281046
virinci,virinci,124,3637,python3,"from collections import Counter

M = 10**9 + 7

fact = [1] * 81
for x in range(1, len(fact)):
    fact[x] = (fact[x - 1] * x) % M


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digit_sum = sum(map(int, num))
        if digit_sum % 2:
            return 0

        n, m = len(num), digit_sum // 2 + 1

        dp = [[0] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 1

        for d in map(int, num):
            for i in range(n, 0, -1):
                for j in range(m, d - 1, -1):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % M

        even_count = (n + 1) // 2
        ways = dp[even_count][digit_sum // 2]

        counter = Counter(num)
        inv = 1
        for c in counter.values():
            inv *= pow(fact[c], -1, M)
            inv %= M

        return ways * fact[even_count] * fact[n - even_count] * inv % M",1441342013
Samadeep,rbssmtkr,125,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int n = moveTime.size();
        int m = moveTime[0].size();

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            pq;

        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));

        pq.push({0, 0, 0});
        dist[0][0] = 0;

        while (!pq.empty()) {

            auto [time, x, y] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (time > dist[x][y])
                continue;

            for (auto& [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int wait_time = max(0, moveTime[nx][ny] - time);
                    int new_time = time + 1 + wait_time;

                    if (new_time < dist[nx][ny]) {
                        dist[nx][ny] = new_time;
                        pq.push({new_time, nx, ny});
                    }
                }
            }
        }

        return -1;
    }
};",1441296109
Samadeep,rbssmtkr,125,3628,cpp,"int64_t dist1[850][850], dist0[850][850];
const int64_t INF = 1e18;
class Solution {
public:
    struct node_state {
    int64_t time;
        int x, y;    
        bool parity;
        bool operator<(const node_state& other) const {
            return time > other.time;
        }
    };

    Solution() {

        for (int i = 0; i <= 800; i++) {
            for (int j = 0; j <= 800; j++) {
                dist1[i][j] = INF;
                dist0[i][j] = INF;
            }
        }
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        auto inside = [&](int x, int y) {
            return !(x < 0 || x >= n || y < 0 || y >= m);
        };

        auto cmp = [](const node_state a, const node_state b) {
            return a.time > b.time;
        };

        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<node_state> pq;
        dist0[0][0] = 0;

        pq.push(node_state{0, 0, 0, false});

        while (!pq.empty()) {

            auto [curr_time,x, y, parity] = pq.top();
            pq.pop();

            if ((curr_time > dist0[x][y] && !parity) ||
                (curr_time > dist1[x][y]) && parity) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int nx = x + dx;
                int ny = y + dy;

                if (!inside(nx, ny))
                    continue;

                int64_t start = max(curr_time, (int64_t)moveTime[nx][ny]);
                int dur = (parity) ? 2 : 1;
                int64_t arrival_time = start + dur;

                bool next = !parity;

                if (next == 0 and arrival_time < dist0[nx][ny]) {
                    dist0[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                } else if (arrival_time < dist1[nx][ny]) {
                    dist1[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                }
            }
        }

        int64_t answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return static_cast<int>(answer);
    }
};",1441340411
Samadeep,rbssmtkr,125,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for( int i = 0 ; i < num.size(); i++ ){
            if( i&1 ) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }

        return sum == 0;
    }
};",1441286169
Samadeep,rbssmtkr,125,3637,cpp,"
const int64_t mod = 1e9 + 7;
int64_t inv(int64_t i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
int64_t mod_mul(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}
int64_t mod_add(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}
int64_t gcd(int64_t a, int64_t b) { if (b == 0) return a; return gcd(b, a % b);}
int64_t ceil_div(int64_t a, int64_t b) {return a % b == 0 ? a / b : a / b + 1;}


const int SIZE = 200;
const int MOD = 1e9 + 7;
int64_t mypow(int64_t x, int64_t y) {
    x %= MOD;
    int64_t res = 1 % MOD;
    while (y) {
        if (y & 1)
            res = res * x % MOD;
        y >>= 1;
        x = x * x % MOD;
    }
    return res;
}

int64_t power(int64_t base, int64_t exp, int64_t mod) {
    int64_t res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1)
            res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

int64_t fac[SIZE];
int64_t inv_fac[SIZE];
void pre() {
    fac[0] = 1;
    for (int i = 1; i < SIZE; i++) {
        fac[i] = fac[i - 1] * i % MOD;
    }
    inv_fac[SIZE - 1] = mypow(fac[SIZE - 1], MOD - 2);
    for (int i = SIZE - 2; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD;
    }
}

int64_t NCR(int64_t n, int64_t m) {
    if (m < 0 || m > n) {
        return 0;
    }
    return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;
}

bool precompute = false;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (not precompute) {
            pre();
            precompute = true;
        }

        int N = num.size();
        int E = (N + 1) / 2;
        int O = N / 2;

        int64_t cnt[10] = {0};
        for (char ch : num) {
            cnt[ch - '0']++;
        }

        int64_t total_sum = 0;
        for (int64_t d = 0; d < 10; d++) {
            total_sum += d * cnt[d];
        }

        if (total_sum % 2 != 0)
            return 0;

        const int64_t TARGET = total_sum / 2;

        vector<vector<int64_t>> dp(E + 1,
                                     vector<int64_t>(TARGET + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (!cnt[d])
                continue;
            
            for (int t = E; t >= 0; t--) {
                for (int64_t s = TARGET; s >= 0; s--) {
                    if (!dp[t][s])
                        continue;
                    
                    for (int k = 1; k <= cnt[d] && t + k <= E &&
                                    s + (int64_t)d * k <= TARGET;
                         k++) {
                        dp[t + k][s + (int64_t)d * k] =
                            mod_add(dp[t + k][s + (int64_t)d * k] , dp[t][s] * NCR(cnt[d], k));
                    }
                }
            }
        }

        int64_t prod_ans = 1;
        for (int d = 0; d < 10; d++) {
            prod_ans = mod_mul(prod_ans , fac[cnt[d]]);
        }

        int64_t answer = dp[E][TARGET] * fac[E] % MOD;
        answer = answer * fac[O] % MOD;
        return (int)mod_mul(answer , power(prod_ans, MOD - 2, MOD));
    }
};",1441361820
Huzaifa Khilawala,RedHeadphone,127,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+1,(nx,ny)))
                    visited.add((nx,ny))",1441295652
Huzaifa Khilawala,RedHeadphone,127,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,1,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time,addi, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+addi,1 if addi==2 else 2,(nx,ny)))
                    visited.add((nx,ny))",1441299635
Huzaifa Khilawala,RedHeadphone,127,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ev = 0
        for i in range(0,len(num),2):
            ev += int(num[i])
        od = 0
        for i in range(1,len(num),2):
            od += int(num[i])
        return ev == od",1441281765
Huzaifa Khilawala,RedHeadphone,127,3637,python3,"
MOD = 10**9 + 7

class Combinatorics:
    def __init__(self, pre_compute_limit=0):
        self.fact = [1] * pre_compute_limit
        self.invfact = [1] * pre_compute_limit
        for i in range(1, pre_compute_limit):
            self.fact[i] = (self.fact[i - 1] * i) % MOD
            self.invfact[i] = (self.invfact[i - 1] * pow(i, MOD - 2, MOD)) % MOD

    def ncr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[r] * self.invfact[n - r]) % MOD

    def npr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[n - r]) % MOD

    def ncr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = den = 1
        for i in range(r):
            num = (num * (n - i)) % MOD
            den = (den * (i + 1)) % MOD
        return (num * pow(den, MOD - 2, MOD)) % MOD

    def npr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = 1
        for i in range(n, n - r, -1):
            num = (num * i) % MOD
        return num

comb = Combinatorics(100)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(num)
        num = [int(i) for i in num]

        summ = sum(num)
        if summ%2 != 0:
            return 0
        
        target = summ//2
        n = len(num)
        length_req = n//2

        inv_mul = True if n-length_req == length_req else False

        combi = (comb.fact[length_req]*comb.fact[n-length_req])%MOD

        c = Counter(num)

        @cache
        def dp(i, curr, length):
            if curr > target:
                return 0
            
            if i==10:
                if curr==target and length==length_req:
                    return combi
                else:
                    return 0
            
            ans = 0
            for j in range(c[i]+1):
                ans+= dp(i+1, curr+i*j, length+j)*comb.invfact[j]*comb.invfact[c[i]-j]
                ans%= MOD
            return ans

        ans = dp(0,0,0)
        return ans",1441351613
Saijayavinoth T V S,saijayavinoth,128,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0))]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+1
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny)))
        # print(T)
        return -1",1441295122
Saijayavinoth T V S,saijayavinoth,128,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0), True)]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell, step = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+(1 if step else 2)
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny), not step))
        # print(T)
        return -1",1441297746
Saijayavinoth T V S,saijayavinoth,128,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = 0
        flag = True
        for ch in num:
            ch = int(ch)
            if flag: ch *= -1
            x += ch
            flag = not flag
        return x == 0",1441282486
Saijayavinoth T V S,saijayavinoth,128,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = list(map(int, list(num)))
        count = Counter(nums)
        nums = list(set(nums))
        nums.sort()
        MOD = 10**9+7
        n = len(num)
        O = n//2
        E = n-O
        @cache
        def ncr(n, r):
            if n == 0 and r == 0:
                return 1
            if n == 0:
                return 0
            return ncr(n-1,r) + ncr(n-1,r-1)
        @cache
        def solve(ind, evenPos, oddPos, x):
            if ind == len(nums):
                return 1 if x == 0 else 0
            num = nums[ind]
            ans = 0
            for even in range(count[num]+1):
                if even > evenPos:
                    break
                odd = count[num] - even
                if odd > oddPos: continue
                ans += ncr(evenPos, even) * ncr(oddPos, odd) * solve(ind+1, evenPos-even, oddPos-odd, x+(even-odd)*num)
                ans %= MOD
            return ans
        return solve(0, E, O, 0)
        ",1441364426
MvKaio,MvKaio,129,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, (long long)(1e11)));
        dist[0][0] = 0;
        
        using T = pair<long long, pair<int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, pair(0, 0));
        
        vector vis(n, vector(m, false));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = v.first;
            int j = v.second;
            if (vis[i][j]) continue;
            vis[i][j] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1] > dist[i][j] + 1) {
                    dist[i1][j1] = dist[i][j] + 1;
                    dist[i1][j1] = max<long long>(dist[i1][j1], g[i1][j1] + 1);
                    q.emplace(dist[i1][j1], pair(i1, j1));
                }
            }
        }
        
        

        return dist[n - 1][m - 1];
    }
};",1441303773
MvKaio,MvKaio,129,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, vector(2, (long long)(1e11))));
        dist[0][0][0] = 0;
        
        using T = pair<long long, tuple<int, int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, make_tuple(0, 0, 0));
        
        vector vis(n, vector(m, vector(2, false)));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = get<0>(v);
            int j = get<1>(v);
            int x = get<2>(v);
            if (vis[i][j][x]) continue;
            vis[i][j][x] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1][!x] > dist[i][j][x] + 1 + x) {
                    dist[i1][j1][!x] = dist[i][j][x] + 1 + x;
                    dist[i1][j1][!x] = max<long long>(dist[i1][j1][!x], g[i1][j1] + 1 + x);
                    q.emplace(dist[i1][j1][1-x], make_tuple(i1, j1, 1 - x));
                }
            }
        }
        
        

        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441309686
MvKaio,MvKaio,129,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2) s += num[i] - '0';
            else s -= num[i] - '0';
        }
        return s == 0;
    }
};",1441281184
MvKaio,MvKaio,129,3637,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> v(n);
        for (int i = 0; i < n; i++)
            v[i] = s[i] - '0';
        
        vector cnt(10, 0);
        for (int i : v) cnt[i]++;
        
        int S = accumulate(v.begin(), v.end(), 0);
        if (S % 2) return 0;
        
        auto add = [&] (long long& a, long long b) {
            a += b;
            if (a >= MOD) a -= MOD;
        };
        
        vector fact(n + 1, 1ll);
        for (int i = 2; i <= n; i++)
            fact[i] = i * fact[i - 1] % MOD;
        
        auto fexp = [&] (long long a, long long b) {
            long long ans = 1;
            while (b) {
                if (b & 1) ans = ans * a % MOD;
                a = a * a % MOD;
                b /= 2;
            }
            return ans;
        };
        
        vector ifact(n + 1, 1ll);
        for (int i = 0; i <= n; i++)
            ifact[i] = fexp(fact[i], MOD - 2);
        
        vector dp(11, vector(n + 1, vector(S + 1, 0LL)));
        dp[0][0][0] = fact[n/2] * fact[(n+1)/2] % MOD;
        for (int d = 0; d < 10; d++) {
            for (int i = 0; i <= n; i++) {
                for (int s = 0; s <= S; s++) {
                    for (int qt = 0; qt <= cnt[d]; qt++) if (s + qt * d <= S && i + qt <= n) {
                        add(dp[d + 1][i + qt][s + qt * d], 
                            dp[d][i][s] 
                            * ifact[qt] % MOD
                            * ifact[cnt[d] - qt] % MOD
                       );
                    }
                }
            }
        }

        
        //cout << dp[10][n/2][S/2] << endl;
        return dp[10][n/2][S/2];
    }
};",1441338870
Arnab Mondal,arnab_97,131,3627,java," class Solution {
     public int minTimeToReach(int[][] moveTime) {
         int n = moveTime.length;
         int m = moveTime[0].length;
         int[][] dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
         int[][] minArrive = new int[n][m];
         for(int[] row : minArrive){
             Arrays.fill(row, Integer.MAX_VALUE);
         }
         minArrive[0][0] = 0;
         PriorityQueue<Cell> pq = new PriorityQueue<>();
         pq.offer(new Cell(0, 0, 0));
         while(!pq.isEmpty()){
             Cell current = pq.poll();
             int r = current.row;
             int c = current.col;
             int t = current.time;
             if(r == n-1 && c == m-1){
                 return t;
             }
             if(t > minArrive[r][c]){
                 continue;
             }
             for(int[] dir : dirs){
                 int nr = r + dir[0];
                 int nc = c + dir[1];
                 if(nr >=0 && nr < n && nc >=0 && nc < m){
                     int arriveTime = Math.max(t, moveTime[nr][nc]) +1;
                     if(arriveTime < minArrive[nr][nc]){
                         minArrive[nr][nc] = arriveTime;
                         pq.offer(new Cell(nr, nc, arriveTime));
                     }
                 }
             }
         }
         return -1;
     }

     class Cell implements Comparable<Cell>{
         int row;
         int col;
         int time;
         Cell(int row, int col, int time){
             this.row = row;
             this.col = col;
             this.time = time;
         }
         public int compareTo(Cell other){
             return Integer.compare(this.time, other.time);
         }
     }
 }",1441294066
Arnab Mondal,arnab_97,131,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        long INF = Long.MAX_VALUE;
        long[][][] dist = new long[n][m][2];
        for(int i=0;i<n;i++) {
            for(int j=0; j<m; j++) {
                dist[i][j][0] = INF;
                dist[i][j][1] = INF;
            }
        }
        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> Long.compare(a.time, b.time));
        dist[0][0][0] = 0;
        pq.add(new State(0, 0, 0, 0));
        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
        while(!pq.isEmpty()) {
            State current = pq.poll();
            if(current.x == n-1 && current.y == m-1){
                return (int)current.time;
            }
            if(current.time > dist[current.x][current.y][current.p]){
                continue;
            }
            for(int[] dir : directions){
                int nx = current.x + dir[0];
                int ny = current.y + dir[1];
                if(nx >=0 && nx <n && ny >=0 && ny <m){
                    long start_move_time = Math.max(current.time, (long)moveTime[nx][ny]);
                    long move_duration = current.p == 0 ? 1 : 2;
                    long arrival_time = start_move_time + move_duration;
                    int next_p = 1 - current.p;
                    if(arrival_time < dist[nx][ny][next_p]){
                        dist[nx][ny][next_p] = arrival_time;
                        pq.add(new State(nx, ny, next_p, arrival_time));
                    }
                }
            }
        }
        return -1;
    }
    class State {
        int x, y, p;
        long time;
        State(int x, int y, int p, long time){
            this.x = x;
            this.y = y;
            this.p = p;
            this.time = time;
        }
    }
}
",1441293520
Arnab Mondal,arnab_97,131,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';

            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}",1441283689
Arnab Mondal,arnab_97,131,3637,java,"class Solution {
    static final int MOD = 1_000_000_007;

     public int countBalancedPermutations(String num) {
         int[] freq = new int[10];
         int N = num.length();
         long sumTotal = 0;
         for(char c : num.toCharArray()) {
             freq[c - '0']++;
             sumTotal += (c - '0');
         }
         if(sumTotal % 2 != 0) return 0;
         long sumTarget = sumTotal / 2;
         int half1 = (N + 1) / 2;
         int half2 = N / 2;

         long[] fact = new long[N + 1];
         fact[0] = 1;
         for(int i=1;i<=N;i++) {
             fact[i] = fact[i-1] * i % MOD;
         }

         long[] invFact = new long[N +1];
         invFact[N] = powMod(fact[N], MOD-2);
         for(int i=N-1;i>=0;i--){
             invFact[i] = invFact[i+1] * (i+1) % MOD;
         }

         
         long[][] dp = new long[half1 +1][(int)(sumTarget) +1];
         dp[0][0] = 1;

         for(int d=0; d<=9; d++) {
             int f = freq[d];
             if(f ==0) continue;
             long[][] next = new long[half1 +1][(int)(sumTarget) +1];
             for(int j=0; j<=half1; j++) {
                 for(int k=0; k<=sumTarget; k++) {
                     if(dp[j][k] ==0) continue;
                     for(int c=0; c<=f; c++) {
                         if(j + c > half1) break;
                         long newSum = k + (long)d * c;
                         if(newSum > sumTarget) break;
                         next[j + c][(int)newSum] = (next[j + c][(int)newSum] + dp[j][k] * invFact[c] % MOD * invFact[f - c] % MOD ) % MOD;
                     }
             }}
             dp = next;
         }

         if(sumTotal %2 !=0){
             return 0;
         }

         if(half1 <0 || half1 >N || sumTarget <0){
             return 0;
         }

         long dpVal = dp[half1][(int)sumTarget];
         if(dpVal ==0){
             return 0;
         }

         long answer = fact[half1] * fact[half2] % MOD;
         answer = answer * dpVal % MOD;
         return (int)answer;
     }

     long powMod(long a, long b){
         long res =1;
         a %= MOD;
         while(b >0){
             if( (b&1) !=0){
                 res = res * a % MOD;
             }
             a = a * a % MOD;
             b >>=1;
         }
         return res;
    }
}",1441359079
Nutty Professor,varkatkl,132,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        BIG = 1 << 30
        best = [[BIG] * W for _ in range(H)]
        bfs = collections.deque()
        def visit(y, x, t):
            if best[y][x] > t and (t > moveTime[y][x] or (y == 0 and x == 0)):
                best[y][x] = t
                bfs.append((y, x))

        visit(0, 0, 0)
        while bfs:
            y, x = bfs.popleft()
            t_cur = best[y][x]
            for dy, dx in ADJACENT:
                y2, x2 = y + dy, x + dx
                if y2 >= 0 and x2 >= 0 and y2 < H and x2 < W:
                    t_move = max(moveTime[y2][x2], t_cur)
                    visit(y2, x2, t_move + 1)

        return best[H - 1][W - 1]
",1441295956
Nutty Professor,varkatkl,132,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)] 
        BIG = 1 << 30

        best = [[[BIG, BIG] for _ in range(W)] for _ in range(H)]
        bfs = []
        def visit(y, x, par, t):
            if best[y][x][par] > t:
                best[y][x][par] = t
                heapq.heappush(bfs, (t, y, x, par))

        visit(0, 0, 0, 0)

        while bfs:
            t_cur, y, x, par = heapq.heappop(bfs)
            if y == H - 1 and x == W - 1:
                return t_cur
            for dy, dx in ADJACENT:
                y2, x2, par2 = y + dy, x + dx, 1 - par
                if y2 < 0 or x2 < 0 or y2 >= H or x2 >= W:
                    continue
                t_start = max(t_cur, moveTime[y2][x2])
                visit(y2, x2, par2, t_start + par + 1)

        return min(best[H - 1][W - 1])
",1441309476
Nutty Professor,varkatkl,132,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e, o = 0, 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                e += int(d)
            else:
                o += int(d)
        return e == o
",1441282473
Nutty Professor,varkatkl,132,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = (10 ** 9) + 7
        counts = [0] * 10
        total = 0
        N = len(num)
        for d in num:
            counts[int(d)] += 1
            total += int(d)

        if total % 2 != 0:
            return 0

        inv_fact = [1] * 81
        fact = 1
        for i in range(2, 81):
            fact = fact * i % MOD
            inv_fact[i] = pow(fact, MOD - 2, MOD)

        @functools.lru_cache(maxsize=None)
        def f(i, odds_used, osum):
            if i == 10:
                if odds_used != N // 2 or osum * 2 != total:
                    return 0
                return 1

            ret = 0
            for ei in range(counts[i] + 1):
                oi = counts[i] - ei
                ret += inv_fact[ei] * inv_fact[oi] * f(i + 1, oi + odds_used, oi * i + osum) % MOD
                ret %= MOD
            return ret

        ret = f(0, 0, 0)
        ret *= pow(inv_fact[(N + 1) // 2], MOD - 2, MOD) * pow(inv_fact[N // 2], MOD - 2, MOD)
        ret %= MOD
        return ret
",1441359390
Yatin Kwatra,yatin_kwatra,134,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

int vis[55][55];

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:

	// bool possible(int k, vvii &v) {
	// 	fo(i, 0, n - 1) {
	// 		fo(j, 0, m - 1) vis[i][j] = 1e9;
	// 	}
	// 	queue<ar<int, 2>> q;

	// 	q.push({0, 0});
	// 	vis[0][0] = 1;

	// 	while (sz(q)) {
	// 		auto t = q.front();
	// 		q.pop();

	// 		int a = t[0], b = t[1];

	// 		fo(dir, 0, 3) {
	// 			int x = a + dx[dir];
	// 			int y = b + dy[dir];

	// 			if (valid(x, y, k, vis[a][b])) {
	// 				vis[x][y] = max(v[x][y], vis[a][b] + 1);
	// 				q.push({x, y});
	// 			}
	// 		}
	// 	}

	// 	return vis[n - 1][m - 1];

	// }

	int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vvii dp(n, vii(m, INT_MAX));

		set<ar<int, 3>> s;
		s.insert({0, 0, 0});
		dp[0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[1] + dx[dir];
				int y = t[2] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1, t[0] + 1);
				if (spend < dp[x][y]) {
					auto it = s.find({dp[x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[x][y] = spend;
					s.insert({dp[x][y], x, y});
				}
			}
		}

		return dp[n - 1][m - 1];
	}
};


















",1441306051
Yatin Kwatra,yatin_kwatra,134,3628,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vector<vector<vector<int>>>  dp(2, vvii(n, vii(m, INT_MAX)));

		set<ar<int, 4>> s;
		s.insert({0, 0, 0, 0});
		dp[0][0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[2] + dx[dir];
				int y = t[3] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1 + t[0], t[1] + 1 + t[0]);
				if (spend < dp[!t[0]][x][y]) {
					auto it = s.find({dp[!t[0]][x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[!t[0]][x][y] = spend;
					s.insert({!t[0], dp[!t[0]][x][y], x, y});
				}
			}
		}

		return min(dp[0][n - 1][m - 1], dp[1][n - 1][m - 1]);
	}
};


















",1441315344
Yatin Kwatra,yatin_kwatra,134,3636,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	bool isBalanced(string s) {
		int n = sz(s);
		int a[2] = {0};
		fo(i, 0, n - 1) {
			a[i % 2] += s[i] - '0';
		}
		return a[0] == a[1];
	}
};




















",1441281153
Yatin Kwatra,yatin_kwatra,134,3637,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

const int N = 81;
ll f[N];

ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}

ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}

ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}

ll nCr(ll n, ll r) {
	if (n < r) return 0;
	ll num = f[n];
	ll deno = mulmod(f[r], f[n - r]);
	return divmod(num, deno);
}


int cnt[10];

int dp[10][42][802], sum;

class Solution {
public:

	int gino(int pos, int odd, int even, int dx) {
		if (pos == 10) {
			return (dx == 0);
		}
		int &ans = dp[pos][odd][sum + dx];
		if (ans != -1) return ans;
		ans = 0;

		fo(placeAtOdd, 0, min(odd, cnt[pos])) {
			int atOdd = placeAtOdd;
			int atEven = cnt[pos] - placeAtOdd;
			if (atEven > even) continue;

			int updDx = dx + atOdd * pos - atEven * pos;

			ans = addmod(ans, mulmod(mulmod(nCr(odd, atOdd), nCr(even, atEven)), gino(pos + 1, odd - atOdd, even - atEven,  updDx)));

			// pr(pos, atOdd, atEven, odd, even,  updDx, ans);
		}

		// pr(pos, odd, even, dx, ans);

		return ans;
	}

	int countBalancedPermutations(string s) {
		if (!f[0]) {
			f[0] = 1;
			fo(i, 1, N - 1) {
				f[i] = mulmod(f[i - 1], i);
			}
		}

		fo(i, 0, 9) {
			cnt[i] = 0;
		}
		for (auto &i : s) cnt[i - '0']++;
		int n = sz(s);

		sum = 0;
		sort(all(s));
		reverse(all(s));
		fo(i, 0, ((n + 1) / 2) - 1) sum += s[i] - '0';

		fo(i, 0, 9) {
			fo(j, 0, (n + 1) / 2) {
				fo(k, 0, 2 * sum) dp[i][j][k] = -1;
			}
		}


		return gino(0, (n + 1) / 2, n / 2, 0);
	}
};





















",1441359762
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3627,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        using Triple = tuple<int64_t,int,int>;
        PQ(Triple, greater) pq;
        pq.emplace(0, 0, 0);
        vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        vector<vector<bool>> vis(R, vector<bool>(C, false));
        dp[0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x] = pq.top(); pq.pop();
            if(vis[y][x]) continue;
            vis[y][x] = true;
            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1, 
                    1ll * stat[ny][nx] + 1
                );
                if(next_time >= dp[ny][nx])
                    continue;
                dp[ny][nx] = next_time;
                pq.emplace(next_time, ny, nx);
            }
        }

        return dp[R - 1][C - 1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441360335
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3628,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

const int nax = 751;
int64_t dp[nax][nax][2];
bool vis[nax][nax][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        // vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        //dp[row][col][flag] = best
        //min(...dp[R - 1][C - 1])
        for(int row = 0; row < R; row++)
            for(int col = 0; col < C; col++)
                for(int flag = 0; flag <= 1; flag++)
                    dp[row][col][flag] = INF, vis[row][col][flag] = false;

        using Quad = tuple<int64_t,int,int,int>;
        PQ(Quad, greater) pq;
        pq.emplace(0, 0, 0, 0);
        dp[0][0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x, flag] = pq.top(); pq.pop();
            if(vis[y][x][flag]) continue;
            vis[y][x][flag] = true;

            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1 + flag, 
                    1ll * stat[ny][nx] + 1 + flag
                );
                if(next_time >= dp[ny][nx][flag ^ 1])
                    continue;
                dp[ny][nx][flag ^ 1] = next_time;
                pq.emplace(next_time, ny, nx, flag ^ 1);
            }
        }

        return min(dp[R - 1][C - 1][0], dp[R - 1][C - 1][1]);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441367413
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3636,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    bool isBalanced(string num) {
        int ans[2] = {0, 0};
        const int n = num.size();
        for(int i = 0; i < n; i++)
            ans[i % 2] += num[i] - '0';

        return ans[0] == ans[1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441346394
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3637,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

template <uint64_t mod = 1'000'000'007>
struct Mint {
    uint64_t val;
    Mint() : val(0) {}
    Mint(int64_t _val) {
        _val %= mod;
        if (_val < 0) _val += mod;
        val = _val;
    }
    Mint& operator += (const Mint& other){ val += other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator -= (const Mint& other){ val += mod - other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator *= (const Mint& other){ val = (uint64_t)val * other.val % mod; return *this; }
    Mint& operator /= (const Mint& other){ return *this *= other.inv(); }
    Mint operator + (const Mint& other) const { return Mint(*this) += other; }
    Mint operator - (const Mint& other) const { return Mint(*this) -= other; }
    Mint operator * (const Mint& other) const { return Mint(*this) *= other; }
    Mint operator / (const Mint& other) const { return Mint(*this) /= other; }
    Mint pwr(int64_t expo) const {
        Mint res = 1;
        Mint cur = *this;
        while(expo){
            if(expo & 1) res *= cur;
            cur *= cur; expo >>= 1;
        }
        return res;
    }
    Mint inv() const { return pwr(mod - 2); }
    friend ostream& operator << (ostream& os, const Mint& m) { os << m.val; return os; }
    bool operator == (const Mint& other) const { return val == other.val; }
};

constexpr uint64_t MODS[] = {
    1'000'000'007,       // 1e9 + 7
    1'000'000'009,       // 1e9 + 9
    1'000'000'003,       // 1e9 + 3
    1'000'000'019,       // 1e9 + 19
    1'000'000'037,       // 1e9 + 37
    1'000'000'061,       // 1e9 + 61
    1'000'000'077,       // 1e9 + 77
    1'000'000'123,       // 1e9 + 123
    5'330'004'01, 
    7'356'327'91, 
    7'765'314'19,
    7'970'034'13
};

using mint = Mint<MODS[0]>;
mint fact[100];
mint ifact[100];
int dp[10][42][42][730];
int vfreq[10];
int even_max;
int odd_max;
//729 is the max
//370(offset) is the 0

int init = []{
    fact[0] = 1;
    ifact[0] = 1;
    for(int i = 1; i < 100; i++){
        fact[i] = fact[i - 1] * i;
        ifact[i] = fact[i].inv();
    }
    return 0;
}();

mint ncr(int take, int has) {
    assert(take <= has);
    assert(take >= 0 && has >= 0);
    return fact[has] * ifact[take] * ifact[has - take];
}

int dfs(int val, int even, int odd, int sum) {
    if(val < 0)
        return sum == 370 && even == even_max && odd == odd_max;
    if(dp[val][even][odd][sum] != -1)
        return dp[val][even][odd][sum];

    const int left_slot = even_max - even;
    const int right_slot = odd_max - odd;
    mint got = 0;
    for(int left = 0; left <= vfreq[val]; left++){
        if(left_slot < left) continue;
        const int right = vfreq[val] - left;
        if(right_slot < right) continue;
        const int next_sum = sum + (left * val) - (right * val);
        if(next_sum < 0 || next_sum > 729) 
            continue;
        got += 
        ncr(left, left_slot) * 
        ncr(right, right_slot) * 
        dfs(val - 1, even + left, odd + right, next_sum);
    }

    return dp[val][even][odd][sum] = got.val;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        const int n = s.size();
        even_max = n / 2 + (n & 1);
        odd_max = n / 2;
        for(int i = 0; i <= 9; i++)
            for(int even = 0; even <= even_max; even++)
                for(int odd = 0; odd <= odd_max; odd++)
                    for(int sum = 0; sum < 730; sum++)
                        dp[i][even][odd][sum] = -1;

        fill(vfreq, vfreq + 10, 0);
        for(auto ch : s)
            vfreq[ch - '0']++;

        return dfs(9, 0, 0, 370);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441343915
VILLANOVA_ECON,VILLANOVA_ECON,138,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0))
            best_dist = [[math.inf]*(M) for _ in range(N)]
            best_dist[0][0] = 0
            while heap_list:
                dist, i,j = heapq.heappop(heap_list)
                if dist == best_dist[i][j]:
                    best_dist[i][j] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+1,moveTime[a][b]+1)
                        if new_max < best_dist[a][b]:
                            best_dist[a][b] = new_max
                            heapq.heappush(heap_list,(new_max,a,b))
            return best_dist[-1][-1]
        
        return djikstra(graph)",1441294489
VILLANOVA_ECON,VILLANOVA_ECON,138,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0,0))
            best_dist = [[[math.inf]*2 for _ in range(M)] for _ in range(N)]
            best_dist[0][0][0] = 0
            while heap_list:
                dist, seq,i,j = heapq.heappop(heap_list)
                jump_cost = 1 if seq == 0 else 2
                if dist == best_dist[i][j][seq]:
                    best_dist[i][j][seq] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+jump_cost,moveTime[a][b]+jump_cost)
                        if new_max < best_dist[a][b][seq^1]:
                            best_dist[a][b][seq^1] = new_max
                            heapq.heappush(heap_list,(new_max,seq^1,a,b))
            return min(best_dist[-1][-1])
        
        return djikstra(graph)",1441299087
VILLANOVA_ECON,VILLANOVA_ECON,138,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        dp = [0,0]
        
        for i in range(len(list(num))):
            x = int(num[i])
            dp[i%2] += x
        return dp[0] == dp[1]",1441281131
VILLANOVA_ECON,VILLANOVA_ECON,138,3637,python3,"# class Solution:
#     def countBalancedPermutations(self, num: str) -> int:
#         def check(num):
#             dp = [0,0]  
#             for i in range(len(list(num))):
#                 x = int(num[i])
#                 dp[i%2] += x
#             return dp[0] == dp[1]

#         def brute(arr):
#             seen = set()
#             for zeb in itertools.permutations(arr):
#                 if check(list(zeb)):
#                     seen.add("""".join(list(zeb)))
#             return len(seen)
        
#         return brute(num)
    
    
MOD = 10 ** 9 + 7
MX = 1000

fac = [1] * MX
for i in range(1, MX):
    fac[i] = fac[i-1] * i % MOD
ifac = [pow(fac[MX - 1], MOD-2, MOD)] * MX
for i in range(MX - 1, 0, -1):
    ifac[i-1] = ifac[i] * i % MOD




class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        modulo = 10**9 + 7

        total_sum = sum([int(x) for x in num])
        
        target_count = len(num)//2
        
        remain_count = len(num)-target_count
        

        if total_sum%2 != 0:
            return 0
        
        target_sum = total_sum//2

        digit_len = len(list(num))//2
        

                    
                    
        num_count = [0]*10
        
        for x in num:
            num_count[int(x)] += 1
            
            
        ans = 0
        
        
        dp = [[0]*(target_sum+1) for _ in range(target_count+1)]
        dp[0][0] = 1

        for i in range(len(num_count)):
            
            new_dp = [[0]*(target_sum+1) for _ in range(target_count+1)] #[0]*(target_sum+1)
            for x in range(num_count[i]+1):
                take = x
                remain = num_count[i]-take
                new_take_sum = x * i
                #print(i,take,remain,new_take_sum)
                for j in range(len(dp)-1,-1,-1):
                    if j-take < 0:
                        break
                    for z in range(len(dp[0])-1,-1,-1):
                        if z-new_take_sum < 0:
                            break
                        if dp[j-take][z-new_take_sum] >= 0:
                            new_dp[j][z] += dp[j-take][z-new_take_sum] * ifac[take] * ifac[remain]
                            if new_dp[j][z] >= modulo:
                                new_dp[j][z] %= modulo
            

                        
            dp = list([list(row) for row in new_dp]) #[0]*(target_sum+1)

        return (dp[-1][-1] * fac[target_count]  * fac[len(num)-target_count]     )%modulo
                    
        
        
        
        
        

                    
            
",1441367947
parthDOOM,parthDOOM,139,3627,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
#define ptpll priority_queue<tuple<ll,ll,ll>, vector<tuple<ll,ll,ll>>, greater<tuple<ll,ll,ll>>>

class Solution {
public:
   int minTimeToReach(vector<vector<int>>& mt) {
       ll n = sz(mt);
       if(n == 0) rt 0;
       ll m = sz(mt[0]);
       
       vl dx = {-1, 1, 0, 0};
       vl dy = {0, 0, -1, 1};
       
       vlll0(arr, n, m);
       
       arr[0][0] = 0;
       
       ptpll pq;
       pq.emplace(0ll, 0ll, 0ll);
       
       while(!pq.empty()){
           auto [ct, x, y] = pq.top();
           pq.pop();
           
           if(x == n-1 && y == m-1){
               rt (int)ct;
           }
           if(ct > arr[x][y]) cnt;
           rep(i, 0, 4){
               ll nx = x + dx[i],ny = y + dy[i];
               if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                   ll nt = max(ct, (ll)mt[nx][ny]) + 1;
                   if(nt < arr[nx][ny]) {
                       arr[nx][ny] = nt;
                       pq.emplace(nt, nx, ny); 
                   }
               }
           }
       }
       rt -1;
   }
};
 ",1441319399
parthDOOM,parthDOOM,139,3628,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = sz(moveTime),m = sz(moveTime[0]); 
        vl dx = {0, 0, 1, -1},dy = {1, -1, 0, 0};
        vlll0(dist, n, m);
        vlll0(moves, n, m); 
        priority_queue<pair<ll, pair<pll, ll>>, 
                      vector<pair<ll, pair<pll, ll>>>, 
                      greater<pair<ll, pair<pll, ll>>>> pq;
        
        dist[0][0] = 0;
        moves[0][0] = 0;
        pq.push({0, {{0, 0}, 0}});
        
        while(!pq.empty()) {
            ll currTime = pq.top().fst;
            ll x = pq.top().sec.fst.fst,y = pq.top().sec.fst.sec;
            ll moveCount = pq.top().sec.sec;
            pq.pop();
            if(currTime > dist[x][y]) cnt;
            rep(i, 0, 4) {
                ll newX = x + dx[i],newY = y + dy[i];
                if(newX >= 0 && newX < n && newY >= 0 && newY < m) {
                    ll waitTime = max(0ll, moveTime[newX][newY] - currTime);
                    ll moveTime = (moveCount % 2 == 0) ? 1 : 2;
                    ll newTime = currTime + waitTime + moveTime;
                    if(newTime < dist[newX][newY]) {
                        dist[newX][newY] = newTime;
                        moves[newX][newY] = moveCount + 1;
                        pq.push({newTime, {{newX, newY}, moveCount + 1}});
                    }
                }
            }
        }
        rt dist[n-1][m-1];        
    }
};",1441299919
parthDOOM,parthDOOM,139,3636,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return

class Solution {
public:
    bool isBalanced(string num) {
        ll ctE = 0,ctO = 0;
        rep(i, 0, sz(num)){
            if(!(i%2)) ctE += (num[i] - '0');
            else ctO += (num[i] - '0');
        }
        rt ctE == ctO;        
    }
};",1441285157
parthDOOM,parthDOOM,139,3637,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int countBalancedPermutations(string s) {
        ll n = sz(s),e = (n+1)>>1,o = n>>1,sum = 0;
        vll0(ct,10)
        loop(c,s) ct[c-'0']++;
        rep(d,0,10) sum += d * ct[d];
        if(sum&1) rt 0;
        sum >>= 1;
        const ll mx = 80;
        vll(f,mx+1)
        f[0] = 1;
        rep(i,1,mx+1) f[i] = f[i-1]*i%modulo;
        vll(inv,mx+1)
        inv[mx] = [&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(f[mx],modulo-2);
        per(i,mx-1,-1) inv[i] = inv[i+1]*(i+1)%modulo;
        auto C = [&](ll n,ll k) -> ll{
            if(k > n) rt 0;
            rt f[n]*inv[k]%modulo*inv[n-k]%modulo;
        };
        vlll dp(e+1,vl(sum+1,0));
        dp[0][0] = 1;
        rep(d,0,10){
            if(!ct[d]) cnt;
            per(t,e,-1){
                per(s,sum,-1){
                    if(!dp[t][s]) cnt;
                    rep(k,1,ct[d] + 1){
                        if(!(t+k <= e) || !(s+d*k <= sum)) brk;
                        ll ns = s+d*k;
                        dp[t+k][ns] = (dp[t+k][ns]+dp[t][s]*C(ct[d],k))%modulo;
                    }
                }
            }
        }
        ll ans = dp[e][sum],pf = 1;
        rep(d, 0, 10) pf = pf*f[ct[d]]%modulo;
        ans = ans*f[e]%modulo;ans = ans*f[o]%modulo;
        ans = ans*[&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(pf,modulo-2)%modulo;
        rt (int)ans;
    }
};",1441355501
wei zhang,l1l2,141,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;


class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> time(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.emplace(moveTime[0][0], make_pair(0, 0));
        time[0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};

        while (!pq.empty()) {
            auto [t, p] = pq.top(); pq.pop();
            int i = p.first, j = p.second;
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    
                    int nt = max({t, moveTime[i][j], moveTime[ni][nj]}) + 1;
                    if (nt < time[ni][nj]) {
                        time[ni][nj] = nt;
                        pq.emplace(nt, make_pair(ni, nj));
                    }
                }
            }
        }
        return -1;
    }
};
",1441349376
wei zhang,l1l2,141,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<vector<int>>> time(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(moveTime[0][0], 0, 0, 0);
        time[0][0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

        while (!pq.empty()) {
            auto [t, i, j, k] = pq.top(); pq.pop();
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j][k]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int c = (k == 0) ? 1 : 2;
                    int t_start = max({t, moveTime[i][j], moveTime[ni][nj]});
                    int arrival_time = t_start + c;
                    int nk = 1 - k;
                    if (arrival_time < time[ni][nj][nk]) {
                        time[ni][nj][nk] = arrival_time;
                        pq.emplace(arrival_time, ni, nj, nk);
                    }
                }
            }
        }
        return -1;
    }
};
",1441355653
wei zhang,l1l2,141,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long se = 0;
        long long so = 0;

        for(int i = 0; i < num.size(); i += 2) {
            se += (num[i] - '0');
        }

        for(int i = 1; i < num.size(); i += 2) {
            so += (num[i] - '0');
        }

        return se == so;
    }
};",1441287354
wei zhang,l1l2,141,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

ll power_mod(ll a, ll b, ll mod_val){
    ll res=1;a%=mod_val;
    while(b>0){
        if(b&1) res=res*a%mod_val;
        a=a*a%mod_val; b>>=1;
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int f[10] = {0};
        ll total =0;
        for(char c: num) {f[c-'0']++; total += (c-'0');}
        if(total%2) return 0;
        ll tgt = total/2;
        int ne = (n+1)/2, no = n/2;
        vector<ll> fact(n+1,1), invf(n+1,1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1]*i%MOD;
        invf[n] = power_mod(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--) invf[i] = invf[i+1]*(i+1)%MOD;
        vector<vector<ll>> dp(ne+1, vector<ll>(tgt+1,0));
        dp[0][0]=1;
        for(int d=0;d<10;d++) {
            if(f[d]==0) continue;
            vector<vector<ll>> ndp(ne+1, vector<ll>(tgt+1,0));
            for(int k=0;k<=ne;k++) {
                for(ll s=0;s<=tgt;s++) {
                    if(dp[k][s]==0) continue;
                    for(int c=0;c<=min(f[d], ne -k);c++) {
                        ll ns = s + (ll)c*d;
                        if(ns > tgt) continue;
                        ll comb = fact[f[d]] * invf[c] % MOD;
                        comb = comb * invf[f[d]-c] % MOD;
                        ndp[k+c][ns] = (ndp[k+c][ns] + dp[k][s]*comb)%MOD;
                    }
                }
            }
            dp = move(ndp);
        }
        ll sa = dp[ne][tgt];
        ll ipf =1;
        for(int d=0;d<10;d++) if(f[d]>0) ipf = ipf * invf[f[d]] % MOD;
        ll fe = fact[ne], fo = fact[no];
        ll ans = fe * fo % MOD;
        ans = ans * sa % MOD;
        ans = ans * ipf % MOD;
        return ans;
    }
};
",1441307596
delphih,delphih,142,3627,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0
        que = [(0, 0, 0)]  # d, r, c
        while que:
            d, r, c = heappop(que)
            if d != D[r][c][0]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                d2 = max(d, A[r2][c2]) + 1
                if d2 < D[r2][c2][0]:
                    D[r2][c2][0] = d2
                    heappush(que, (d2, r2, c2))
        # print(D)
        return D[-1][-1][0]",1441294936
delphih,delphih,142,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf, inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0 # (next 1, next 2)
        que = [(0, 0, 0, 0)]  # d, r, c, t
        while que:
            d, r, c, t = heappop(que)
            if d != D[r][c][t]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                t2 = 1 - t
                d2 = max(d, A[r2][c2]) + t + 1
                if d2 < D[r2][c2][t2]:
                    D[r2][c2][t2] = d2
                    heappush(que, (d2, r2, c2, t2))
        # print(D)
        return min(D[-1][-1])",1441296845
delphih,delphih,142,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = sum(int(c) for c in num[::2])
        s2 = sum(int(c) for c in num[1::2])
        return s1 == s2",1441281691
delphih,delphih,142,3637,python3,"M = 10**9+7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
        tot = sum(int(d) for d in num)
        if tot % 2 != 0: return 0
            
        freq = Counter(num)
        
        dp = [[Counter() for _ in range(n_odd+1)] for _ in range(n_even+1)]  # dp[even][odd][even - odd]
        dp[0][0][0] = 1
        cur = 0
        for d, cnt in freq.items():
            d = int(d)
            for i0 in range(cur-n_odd, min(cur, n_even)+1):
                i1 = cur - i0
                # if i1 > n_odd: continue
                # print(i0, i1)
                for diff0, ways0 in dp[i0][i1].items():
                    for j0 in range(cnt+1):
                        j1 = cnt - j0
                        if i0+j0 > n_even or i1+j1 > n_odd: continue
                        diff = diff0 + (j0-j1) * d
                        ways = ways0 * comb(i0+j0, j0) * comb(i1+j1, j1) % M
                        dp[i0+j0][i1+j1][diff] = (dp[i0+j0][i1+j1][diff] + ways) % M
            cur += cnt
        return dp[n_even][n_odd][0]",1441356652
Syed Ali Aatif,mafailure,143,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; 
        pq.push(make_pair(0,0)); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<int>> d(n, vector<int>(m,inf)); 
        d[0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second;
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y]>max(moveTime[x][y]+1, _d+1)) {
                    d[x][y] = max(moveTime[x][y]+1, _d+1); 
                    pq.push(make_pair(d[x][y], x*m+y)); 
                }
            }
        }
        return d[n-1][m-1]; 
    }
};",1441297641
Syed Ali Aatif,mafailure,143,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; 
        pq.push(make_pair(0,make_pair(0,0))); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m,vector<int>(2,inf))); 
        d[0][0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second.first;
            auto _ = pq.top().second.second; 
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y][1-_]>max(moveTime[x][y], _d)+1+_) {
                    d[x][y][1-_] = max(moveTime[x][y], _d)+1+_; 
                    pq.push(make_pair(d[x][y][1-_], make_pair(x*m+y,1-_))); 
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]); 
    }
};",1441302882
Syed Ali Aatif,mafailure,143,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> cnt(2); 
        for(int i=0;i<num.size();i++){
            cnt[i%2]+=num[i]-'0'; 
        }
        return cnt.front() == cnt.back(); 
    }
};",1441285747
Syed Ali Aatif,mafailure,143,3637,cpp,"const int mod = 1e9+7; 
class Solution {
public:
#define int long long 
    int add (int a,int b ) { return (a+b)%mod;}
    int mul (int a,int b) {return a*b%mod;}
    int sub(int a,int b) { return (a-b+mod)%mod;}
    int power(int a,int b,int mod) {
        if(b==0)return 1; 
        int u = power(a,b>>1,mod); 
        u = mul(u,u);
        if(b%2)u = mul(u,a); 
        return u; 
    }


    int32_t countBalancedPermutations(string num) {
        int dp[num.size()+1][9*num.size()+1];
        memset(dp,0,sizeof(dp)); 
        vector<int> cnt(10);
        for(auto it:num)cnt[it-'0']++; 
        vector<int> fact(81);
        fact[0] = 1; 
        for(int i=1;i<fact.size();i++)fact[i] = mul(i,fact[i-1]); 
        vector<int> ifact(81,1); 
        ifact[80] = power(fact[80], mod-2, mod); 
        for(int i=79;i>=0;i--)ifact[i]=mul(i+1, ifact[i+1]); 
        int tot = 0; 
        for(auto it:num)tot+=it-'0'; 
        if(tot%2)return 0; 
        auto getAns = [&](vector<int> & c,int t) {
            int dp[11][81][81*9]; 
            memset(dp,0,sizeof(dp)); 
            dp[0][0][0] = 1; 
            for(int i=0;i<10;i++){
                for(int j=0;j<=t;j++){
                    for(int p = 0;p<81*9;p++){
                    if(dp[i][j][p] == 0)continue; 
                    for(int k=0;k<=c[i] && k+j<=t;k++){
                         //cout<<i<<"" ""<<j<<"" ""<<p<<"" ""<<k<<"" ""<<t<<endl; 
                        dp[i+1][j+k][p+k*i] = add(dp[i+1][j+k][p+k*i], mul(dp[i][j][p], mul(ifact[k], ifact[c[i]-k])));
                    }
                    }
                }
            }
            return dp[10][t][tot/2]; 
        };
        int n = num.size();
        int o = (n+1)/2;
        int e = n-o; 
        int ans = mul(mul(fact[o], fact[e]), getAns(cnt, o)); 
    
        return ans;
    }

#undef int
};",1441350773
Shubham Maheshwari,sm_27,144,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0))]
        visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+1,(x,y)))
                        visited.add((x,y))
                        
                        
            ",1441298499
Shubham Maheshwari,sm_27,144,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0),0)]
        times = [[[float(""inf""), float(""inf"")] for _ in range(m)] for _ in range(n)]
        # visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node,move = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            # visited.add(node)
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if max(curr,moveTime[x][y]) + move < times[x][y][(move+1)%2]:
                    # if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+move+1,(x,y),(move+1)%2))
                        times[x][y][(move+1)%2] = max(curr,moveTime[x][y]) + move                        
                        
            ",1441313266
Shubham Maheshwari,sm_27,144,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(n):
            if i&1:
                odd += int(num[i])
            else:
                even += int(num[i])
        return odd == even",1441281409
Shubham Maheshwari,sm_27,144,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        def C(n,r):
            return math.comb(n,r)
        n = len(num)
        nums = dict()
        for i in range(10):
            nums[i] = 0
        s = 0
        for c in num:
            nums[int(c)] += 1
            s += int(c)
        if s %2 != 0:
            return 0
        odd = n//2
        if n&1:
            odd += 1
        MOD = 10**9+7
        @lru_cache(None)
        def dfs(num, odd,even, rem):
            nonlocal MOD
            # print(num,odd,even,rem)
            if rem == 0 and num == 10:
                if odd == 0 and even == 0:
                    return 1
                return 0
            if num >= 10:
                return 0
            if odd < 0 or even < 0:
                return 0
            if rem < 0:
                return 0
            ans = 0
            for count in range(nums[num]+1):
                # we select count num in odd side
                if rem < count*num and count <= odd and nums[num]-count <= even:
                    continue
                # count in odd and nums[num]-count in even
                facts = (C(odd,count)*C(even,nums[num]-count))% MOD
                ans += (dfs(num+1,odd-count,even-nums[num]+count,rem-count*num) * facts)
                ans %= MOD
            # if num == 1:
                # print(ans)
            return ans
            
            
        return dfs(0,odd,n-odd,s//2)
            ",1441363442
Umesh Kumar,icosa,145,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<ii, vector<ii>, greater<ii>> pq;
        pq.push({0, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] == inf){
                        dp[ni][nj] = 1 + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441299654
Umesh Kumar,icosa,145,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;
        typedef tuple<ll, ll, ll> iii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<iii, vector<iii>, greater<iii>> pq;
        pq.push({0, 1, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, mt, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;

            if(dp[i][j] < t) continue;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] > mt + max(t, (ll)moveTime[ni][nj])){
                        dp[ni][nj] = mt + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], mt == 1? 2: 1, v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441309882
Umesh Kumar,icosa,145,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i=0; i<num.size(); i++){
            (i & 1 ? odd: even) += (num[i] - '0');
        }
        return even == odd;
    }
};",1441311751
Umesh Kumar,icosa,145,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define FOR(i, l, r) for (ll i = l; i < r; i++)
#define For(i, r, l) for (ll i = r - 1; i >= l; i--)
#define sz(x) x.size()
#define all(x) x.begin(), x.end()
#define pb push_back
#define eb emplace_back
#define ITER(itr, x) for (auto &itr : x)
#define LSOne(S) ((S) & (-S))

using namespace std;
#define debug(args...)                                                         \
  {                                                                            \
    string _s = #args;                                                         \
    replace(_s.begin(), _s.end(), ',', ' ');                                   \
    stringstream _ss(_s);                                                      \
    istream_iterator<string> _it(_ss);                                         \
    err(_it, args);                                                            \
  }
template <typename... Args>
void err(istream_iterator<string> it, Args... args) {
  ((cerr << *it << "" = "" << args << "" "", it++), ...);
  cerr << endl;
}

typedef pair<int, int> ii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<ii> vii;
typedef vector<vi> vvi;
typedef vector<vll> vvll;

/**
 * Description: modular arithmetic operations
 * Source:
 * KACTL
 * https://codeforces.com/blog/entry/63903
 * https://codeforces.com/contest/1261/submission/65632855 (tourist)
 * https://codeforces.com/contest/1264/submission/66344993 (ksun)
 * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp
 * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic
 */

template <int MOD, int RT> struct mint {
  static const int mod = MOD;
  static constexpr mint rt() { return RT; } // primitive root for FFT
  int v;
  explicit operator int() const {
    return v;
  } // explicit -> don't silently convert to int
  mint() : v(0) {}
  mint(ll _v) {
    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
    if (v < 0)
      v += MOD;
  }
  bool operator==(const mint &o) const { return v == o.v; }
  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
  friend void re(mint &a) {
    ll x;
    cin >> x;
    a = mint(x);
  }
  // friend str ts(mint a) { return ts(a.v); }

  mint &operator+=(const mint &o) {
    if ((v += o.v) >= MOD)
      v -= MOD;
    return *this;
  }
  mint &operator-=(const mint &o) {
    if ((v -= o.v) < 0)
      v += MOD;
    return *this;
  }
  mint &operator*=(const mint &o) {
    v = int((ll)v * o.v % MOD);
    return *this;
  }
  mint &operator/=(const mint &o) { return (*this) *= inv(o); }
  friend mint pow(mint a, ll p) {
    mint ans = 1;
    assert(p >= 0);
    for (; p; p /= 2, a *= a)
      if (p & 1)
        ans *= a;
    return ans;
  }
  friend mint inv(const mint &a) {
    assert(a.v != 0);
    return pow(a, MOD - 2);
  }

  mint operator-() const { return mint(-v); }
  mint &operator++() { return *this += 1; }
  mint &operator--() { return *this -= 1; }
  friend mint operator+(mint a, const mint &b) { return a += b; }
  friend mint operator-(mint a, const mint &b) { return a -= b; }
  friend mint operator*(mint a, const mint &b) { return a *= b; }
  friend mint operator/(mint a, const mint &b) { return a /= b; }
};

const ll MOD = 1e9 + 7;
using mi = mint<MOD, 5>; // 5 is primitive root for both common mods
using vmi = vector<mi>;
using pmi = pair<mi, mi>;
using vpmi = vector<pmi>;

vector<vmi> scmb; // small combinations
void genComb(int SZ) {
  scmb.assign(SZ, vmi(SZ));
  scmb[0][0] = 1;
  FOR(i, 1, SZ)
  FOR(j, 0, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);
}

/**
 * Description: pre-compute factorial mod inverses,
 * assumes MOD$ is prime and SZ < MOD$.
 * Time: O(SZ)
 * Source: KACTL
 * Verification: https://dmoj.ca/problem/tle17c4p5
 */

vmi invs, fac, ifac;
void genFac(int SZ) {
  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);
  invs[1] = fac[0] = ifac[0] = 1;
  FOR(i, 2, SZ) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);
  FOR(i, 1, SZ) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];
}
mi comb(int a, int b) {
  if (a < b || b < 0)
    return 0;
  return fac[a] * ifac[b] * ifac[a - b];
}

const int MAX_E = 41;
const int MAX_SE = MAX_E * 9;
mi dp[11][MAX_E][MAX_SE]; // count even, sum even

class Solution {
public:
  int countBalancedPermutations(string num) {
    genFac(1001);
    vi count(10, 0);
    for (auto c : num)
      count[c - '0']++;

    memset(dp, 0, sizeof(dp));
    dp[0][0][0] = 1;

    int n = num.size(), digs = 0, sum_digs = 0;
    for (int i = 0; i < 10; i++) {
      for (int e = 0; e < min(MAX_E, digs + 1); e++) {
        int odd = digs - e;
        for (int c = 0; c <= min(count[i], MAX_E - e - 1); c++) {
          for (int se = 0; se < min(sum_digs + 1, MAX_SE - c * i); se++) {
            int sum_odd = sum_digs - se;
            // put c in even places
            dp[i + 1][c + e][se + c * i] +=
                (dp[i][e][se] * comb((n + 1) / 2 - e, c) *
                 comb(n - (n + 1) / 2 - odd, count[i] - c));
          }
        }
      }

      digs += count[i];
      sum_digs += count[i] * i;
    }

    mi ans = 0;
    ans += dp[10][(n + 1) / 2][sum_digs / 2];

    if (sum_digs & 1)
      return 0;
    return (int)ans;
  }
};",1441363622
g129512,g129512,146,3627,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,1)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=1
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359512
g129512,g129512,146,3628,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,2)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=(1 if nt==2 else 2)
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359413
g129512,g129512,146,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n=len(num)
        s1=sum(int(num[i]) for i in range(n) if i%2==0)
        s2=sum(int(num[i]) for i in range(n) if i%2==1)
        return s1==s2
        ",1441359720
g129512,g129512,146,3637,python3,"from functools import cache
from typing import Counter

class Comb:
    def __init__(self, n, mod) -> None:
        p,pi=[0]*(n+1),[0]*(n+1)
        self.p,self.pi=p,pi
        self.mod=mod
        p[0]=1
        pi[0]=1
        for i in range(1,n+1):
            p[i]=p[i-1]*i%mod
        pi[n]=pow(p[n],mod-2,mod)
        for i in range(n-1,0,-1):
            pi[i]=pi[i+1]*(i+1)%mod
    
    def comb(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[r]*self.pi[n-r]%self.mod
    
    def perm(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[n-r]%self.mod

M=10**9+7
comb=Comb(80, M)

@cache
def cb(n,k):
    return comb.comb(n,k)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n=len(num)
        s=sum(int(v) for v in num)
        if s%2==1:return 0
        ct=Counter(num)
        dp=[[0]*361 for _ in range(41)]
        dp[0][0]=1
        prec=0
        for kk,v in ct.items():
            kk=int(kk)
            ndp=[[0]*361 for _ in range(41)]
            for i in range(n//2+1):
                for j in range(s//2+1):
                    for k in range(v+1):
                        if i+k>n//2 or j+k*kk>s//2:break
                        ndp[i+k][j+k*kk]+=dp[i][j]*cb(i+k,k)*cb(prec-i+v-k,v-k)
                        ndp[i+k][j+k*kk]%=M
            dp=ndp
            prec+=v
        return dp[n//2][s//2]",1441363810
Rahul Gupta,guts_berserker718,147,3627,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0}); 
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 1) : time + (k == 0 ? 1 : 1);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301916
Rahul Gupta,guts_berserker718,147,3628,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});  
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 2) : time + (k == 0 ? 1 : 2);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301323
Rahul Gupta,guts_berserker718,147,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0,b=0;
        for(int i=0;i<num.length();i++){
            if(i%2==0){
                a+=(num[i]-'0');
            }else b+=(num[i]-'0');
        }
    return a==b;
    }

};",1441281567
Rahul Gupta,guts_berserker718,147,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution {
public:
    ll nCr(int n, int r, const vector<ll>& fact, const vector<ll>& invFact) {
        if (r > n) return 0;
        return fact[n]* invFact[n - r] % MOD * invFact[r] % MOD ;
    }
    ll modPow(ll base, ll exp) {
        ll res = 1;
        while (exp) {
            if (exp & 1) res = res * base % MOD;
            base = base * base % MOD;
            exp >>= 1;
        }
        return res;
    }
    

    
    int countBalancedPermutations(string num) {
        int i = 0;
        int len = num.size();
         int half2 = len / 2;
        int half1 = (len + 1) / 2;
       
        
        vector<int> freq(12, 0);
       
        
        ll sum = 0;
       
        
        
        
        vector<ll>invFact(len + 5, 1), fact(len + 5, 1);
        i = 1;
        while (i <= len) {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        i=0;
        while (i < len) {
            freq[num[i] - '0']++;
            i++;
        }
        invFact[len] = modPow(fact[len], MOD - 2);
        i = len - 1;
        while (i >= 0) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
            i--;
        }
        
        i = 0;
        while (i < 10) {
            sum += 1LL * i * freq[i];
            i++;
        }
        if (sum % 2 != 0) return 0;
        ll target = sum / 2;

        
        

       vector<vector<ll>> dp(target + 5, vector<ll>(half1 + 5, 0));
dp[0][0] = 1;

int d = 0;
while (d < 10) {
    // if(freq[d]==0)continue;
    if (freq[d] != 0) {
        int j = half1;
        while (j >= 0) {
            int k = target;
            while (k >= 0) {
                if (dp[k][j] != 0) {
                    int c = 1;
                    while (c <= min(freq[d], half1 - j)) {
                        if (k + d * c > target) break;
                        ll ways = nCr(freq[d], c, fact, invFact);
                        dp[k + d * c][j + c] = (dp[k + d * c][j + c] % MOD + dp[k][j] * ways) % MOD;
                        c++;
                    }
                }
                k--;
            }
            j--;
        }
    }
    d++;
}

ll dpVal = dp[target][half1];
if (dpVal == 0) return 0;


ll factProd = 1;
d = 0;
while (d < 10) {
    factProd = (fact[freq[d]] % MOD * factProd % MOD) % MOD;
    d++;
}
ll result = (dpVal * fact[half1] % MOD * fact[half2] % MOD) % MOD;
result = result * modPow(factProd, MOD - 2) % MOD;
return result % MOD;

    }
};
",1441357919
xpycc,xpycc,148,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        pq.emplace(0, 0, 0);
        mt[0][0] = -1;
        while (!pq.empty()) {
            auto [t, x, y] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d];
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (mt[nx][ny] < 0) continue;
                const int nt = max(t + 1, mt[nx][ny] + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny);
                mt[nx][ny] = -1;
            }
        }
        return -1;
    }
};",1441305505
xpycc,xpycc,148,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        vector<int8_t> mem(n * m * 2);
        auto vis = [&](int x, int y, int b) -> int8_t& {
            return mem[x * m * 2 + y * 2 + b];
        };
        pq.emplace(0, 0, 0, 0);
        vis(0, 0, 0) = true;
        while (!pq.empty()) {
            auto [t, x, y, b] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y, b);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d], nb = !b;
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (vis(nx, ny, nb)) continue;
                const int nt = max(t + b + 1, mt[nx][ny] + b + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny, nb);
                vis(nx, ny, nb) = true;
            }
        }
        return -1;
    }
};",1441317271
xpycc,xpycc,148,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int diff = 0, f = 1;
        for (char c : num) {
            diff += f * (c - '0');
            f = -f;
        }
        return diff == 0;
    }
};",1441282241
xpycc,xpycc,148,3637,cpp,"class Solution {
    static constexpr int mod = 1'000'000'007;
    static int inv(int x) {
        int p = mod - 2;
        int a = 1;
        while (p > 0) {
            if (p & 1) a = a * 1LL * x % mod;
            p >>= 1;
            x = x * 1LL * x % mod;
        }
        return a;
    }
public:
    int countBalancedPermutations(string num) {
        const int n = num.size(), h = n / 2,
                  S = accumulate(num.begin(), num.end(), 0, [](int x, char c) {
                        return x + c - '0';
                    }),
                  H = S / 2;
        if (S % 2 != 0) return 0;
        vector<vector<int>> f(h + 1, vector<int>(H + 1));
        f[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = h; j >= 0; --j)
                for (int k = H; k >= 0; --k) {
                    int x = num[i] - '0';
                    f[j][k] = (f[j][k] * (i + 1LL - j)) % mod; 
                    if (j > 0 && k - x >= 0)
                        f[j][k] = (f[j][k] + f[j - 1][k - x] * 1LL * j) % mod;
                }
        }
        int count[10] = {};
        for (char c : num) count[c - '0']++;
        vector<int> fact(n + 1);
        fact[0] = 1;
        for (int i = 1; i <= n; ++i)
            fact[i] = (fact[i - 1] * 1LL * i) % mod;
        int ans = f[h][H];
        for (int i = 0; i < 10; ++i)
            ans = (ans * 1LL * inv(fact[count[i]])) % mod;
        return ans;
    }
};",1441359032
BHISHMADEV GHOSH,bhishma_v2,150,3627,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][] minTime = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                minTime[i][j] = Integer.MAX_VALUE;
            }
        }
        minTime[0][0] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0});

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];

            if (curR == n - 1 && curC == m - 1) {
                return time;
            }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + 1;
                    if (newTime < minTime[rr][cc]) {
                        minTime[rr][cc] = newTime;
                        q.offer(new int[]{rr, cc, newTime});
                    }
                }
            }
        }

        return -1;
    }
}
",1441315131
BHISHMADEV GHOSH,bhishma_v2,150,3628,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] minTime = new int[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for(int k = 0; k <= 1; k++){
                minTime[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }
        minTime[0][0][0] = 0;
        minTime[0][0][1] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0,0});
        

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];
            int k = t[3];

            // if (curR == n - 1 && curC == m - 1) {
            //     return time;
            // }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + (k == 0 ? 1 : 2);
                    if (newTime < minTime[rr][cc][k]) {
                        minTime[rr][cc][k] = newTime;
                        q.offer(new int[]{rr, cc, newTime, k == 0 ? 1 : 0});
                    }
                }
            }
        }

        return Math.min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
}
",1441321903
BHISHMADEV GHOSH,bhishma_v2,150,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int sum1 = 0, sum2 = 0;

        for(int i = 0; i < n; i++){
            if(i % 2 == 0)sum1 += (num.charAt(i) - '0');
            else sum2 += (num.charAt(i) - '0');
        }

        return sum1 == sum2;
    }
}",1441282941
BHISHMADEV GHOSH,bhishma_v2,150,3637,java,"import java.util.*;

class Solution {
    int mod = (int) 1e9 + 7;
    long[][][] dp;
    Map<Integer, Integer> freqMap = new HashMap<>();

    long fact(int n) {
        long res = 1;
        for (int i = 1; i <= n; i++) {
            res = (res * i) % mod;
        }
        return res;
    }

    long modInverse(long a, int mod) {
        long res = 1;
        long power = mod - 2;
        while (power > 0) {
            if ((power & 1) != 0) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            power >>= 1;
        }
        return res;
    }

    public int countBalancedPermutations(String num) {
        int sum = 0;
        List<Integer> cur = new ArrayList<>();
        int n = num.length();

        for (char c : num.toCharArray()) {
            int digit = c - '0';
            sum += digit;
            cur.add(digit);
            freqMap.put(digit, freqMap.getOrDefault(digit, 0) + 1);
        }

        if (sum % 2 != 0)
            return 0;

        int odd = n / 2, even = (n + 1) / 2, target = sum / 2;
        dp = new long[n][even + 1][target + 1];

        for (long[][] rr : dp) {
            for (long[] r : rr) Arrays.fill(r, -1);
        }

        long ways = getWays(0, cur, even, target);

        for (int f : freqMap.values()) {
            ways = (ways * modInverse(fact(f), mod)) % mod;
        }

        long factEven = fact(even);
        long factOdd = fact(odd);

        return (int) ((ways * factEven % mod) * factOdd % mod);
    }

    long getWays(int ind, List<Integer> cur, int n, int target) {
        if (n < 0 || target < 0) return 0;
        if (ind == cur.size()) return (n == 0 && target == 0) ? 1 : 0;

        if (dp[ind][n][target] != -1) return dp[ind][n][target];

        long take = 0, notTake = 0;

        if (cur.get(ind) <= target) {
            take = getWays(ind + 1, cur, n - 1, target - cur.get(ind));
        }

        notTake = getWays(ind + 1, cur, n, target);

        return dp[ind][n][target] = (take + notTake) % mod;
    }
}
",1441365713
Abhishek Srivastava,Abhi_Srivastava,151,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        queue<pair<int, int>> q;
        dist[0][0] = 0;
        q.push({0, 0});
        while (!q.empty()) {
            int x = q.front().first, y = q.front().second;
            q.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 1) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 1;
                        q.push({x + i, y + j});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441298457
Abhishek Srivastava,Abhi_Srivastava,151,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        while (!pq.empty()) {
            int dst = pq.top().first, x = pq.top().second.first, y = pq.top().second.second;
            pq.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2)) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2);
                        pq.push({dist[x + i][y + j], {x + i, y + j}});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441311456
Abhishek Srivastava,Abhi_Srivastava,151,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2)
                sum += num[i] - '0';
            else
                sum -= num[i] - '0';
        }
        return !sum;
    }
};",1441281587
Abhishek Srivastava,Abhi_Srivastava,151,3637,cpp,"const int mod = 1e9 + 7;
long long fact[81], inv_fact[81];
long long binpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b % 2)
            (res *= a) %= mod;
        (a *= a) %= mod;
        b /= 2;
    }
    return res;
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if (!fact[0]) {
            fact[0] = 1;
            for (int i = 1; i < 81; i++)
                fact[i] = (fact[i - 1] * i) % mod;
            inv_fact[80] = binpow(fact[80], mod - 2);
            for (int i = 79; i >= 0; i--)
                inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;
        }
        int dig = num.size() / 2, sum = 0;
        int freq[10] = {};
        for (char x : num) {
            sum += x - '0';
            freq[x - '0']++;
        }
        if (sum % 2)
            return 0;
        sum /= 2;
        vector<vector<int>> dp(dig + 1, vector<int>(sum + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i <= 9; i++) {
            vector<vector<int>> ndp(dig + 1, vector<int>(sum + 1, 0));
            for (int j = 0; j <= freq[i]; j++)
                for (int k = j; k <= dig; k++)
                    for (int l = i * j; l <= sum; l++)
                        (ndp[k][l] += dp[k - j][l - i * j] * inv_fact[j] % mod * inv_fact[freq[i] - j] % mod) %= mod;
            swap(dp, ndp);
        }
        return dp[dig][sum] * fact[dig] % mod * fact[num.size() - dig] % mod;
    }
};",1441353464
avienn_x,avienn_x,152,3627,cpp,"class Solution {
public:
    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<long long>> dist(n, vector<long long>(m, INT_MAX));
        dist[0][0] = 0;
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            long long t = curr[0];
            long long i = curr[1];
            long long j = curr[2];
            if (i == n-1 && j == m-1)
                return t;
            if (t > dist[i][j])
                continue;
            for (auto &d : dirs) {
                long long ni = i + d.first;
                long long nj = j + d.second;
                if(!chck(ni, nj, n, m))
                    continue;
                int sr = max(t, 1ll * mt[ni][nj]);
                if (sr + 1 < dist[ni][nj]) {
                    dist[ni][nj] = sr + 1;
                    pq.push({sr + 1, ni, nj});
                }
            }
        }
        return INT_MAX;
    }
};",1441304877
avienn_x,avienn_x,152,3628,cpp,"class Solution {
public:

    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<vector<long long>>> dist(n, vector<vector<long long>>(m, vector<long long>(2, INT_MAX)));
        dist[0][0][0] = 0;
        priority_queue<vector<int>, vector<vector<int>>, std::greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int t = curr[0];
            int i = curr[1];
            int j = curr[2];
            int p = curr[3];
            if (i == n-1 && j == m-1 || t > dist[i][j][p])
                continue;
            for (auto &d : dirs) {
                int ni = i + d.first;
                int nj = j + d.second;
                if(!chck(ni, nj, n, m))
                        continue;
                int sr = max(t, mt[ni][nj]);
                int mv = (p == 0) ? 1 : 2;
                int nxt = sr + mv;
                int np = 1 - p;
                if (nxt < dist[ni][nj][np]){
                        dist[ni][nj][np] = nxt;
                        pq.push({nxt, ni, nj, np});
                }

            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441316491
avienn_x,avienn_x,152,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int a = 0, b= 0 ;
        for(int i = 0; i < n; i++){
            if(i % 2)
                a += num[i] - '0';
            else
                b += num[i] - '0';
        }
        return a == b;
    }
};",1441305980
avienn_x,avienn_x,152,3637,cpp,"
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
const int MAXN = 105; 
const int MAXS = 1100;
typedef long long ll;

ll dp[MAXN][MAXS];
ll f[MAXN], invf[MAXN];
int fr[10];

class Solution {
private:
    ll mpow(ll b, ll p) {
        ll r = 1;
        b %= MOD;
        while (p > 0) {
            if (p & 1) r = (r * b) % MOD;
            b = (b * b) % MOD;
            p >>= 1;
        }
        return r;
    }
    
    void precalc(int sz) {
        f[0] = 1;
        for (int i = 1; i <= sz; i++) {
            f[i] = (f[i-1] * i) % MOD;
        }
        invf[sz] = mpow(f[sz], MOD-2);
        for (int i = sz-1; i >= 0; i--) {
            invf[i] = (invf[i+1] * (i+1)) % MOD;
        }
    }
    
    ll ncr(int n, int r) {
        if (r > n) return 0;
        return (((f[n] * invf[r]) % MOD) * invf[n-r]) % MOD;
    }

public:
    int countBalancedPermutations(string s) {
        int n = s.length();
        int m = (n + 1) / 2;
        int h = n / 2;
        ll sm = 0;
        memset(fr, 0, sizeof(fr));
        for (char c : s){
        	fr[c-'0']++;
        	sm += (c - '0');
        }
        if (sm % 2) return 0;
        ll t = sm / 2;
        precalc(n);
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
   			
        for (int d = 0; d < 10; d++) {
            if (!fr[d]) continue;
            ll available = fr[d];
            for (int cs = t; cs >= 0; cs--) {
                for (int p = m; p >= 0; p--) {
                    if (!dp[p][cs])
                        continue;

                    ll val = dp[p][cs];
                    ll rem = m - p;

                    for (int c = 1; c <= available && c <= rem; c++) {
                        if (cs + 1LL * d * c > t) break;

                        ll cmb = f[fr[d]];
                        (cmb *= invf[c]) %= MOD;
                        (cmb *= invf[fr[d] - c]) %= MOD;

                        (dp[p + c][cs + d * c] += val * cmb) %= MOD;
                    }
                }
            }
        }

        if (!dp[m][t]) return 0;
        
        ll ff = 1;
        for (int d = 0; d < 10; d++) {
            ff = (ff * f[fr[d]]) % MOD;
        }
        
        ll iff = mpow(ff, MOD-2);
        ll ans = dp[m][t];
        ans = (ans * f[m]) % MOD;
        ans = (ans * f[h]) % MOD;
        ans = (ans * iff) % MOD;
        
        return ans;
    }
};",1441366231
ABHAY GUPTA,abhayg_07,153,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq;
        pq.push({0,0,0});
        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0] = 0;
        while(!pq.empty()){
            array<int,3> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy] > max( a[0] , moveTime[newx][newy] ) + 1 ){
                    dis[newx][newy] = max( a[0] , moveTime[newx][newy] ) + 1;
                    pq.push({dis[newx][newy],newx,newy});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441306123
ABHAY GUPTA,abhayg_07,153,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<long long,4>,vector<array<long long,4>>,greater<array<long long,4>>> pq;
        pq.push({0,0,0,0});
        long long dis[n][m][2];
        for( int i = 0 ; i < n ; i++ ){
            for( int j = 0 ; j < m ; j++ ){
                for( int k = 0 ; k < 2 ; k++ ){
                    dis[i][j][k] = 1e15;
                }
            }
        }
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0][0] = 0;
        while(!pq.empty()){
            array<long long,4> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]][a[3]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy][a[3]^1] > max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1 ){
                    dis[newx][newy][a[3]^1] = max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1;
                    pq.push({dis[newx][newy][a[3]^1],newx,newy,a[3]^1});
                }
            }
        }
        return min(dis[n-1][m-1][0],dis[n-1][m-1][1]);
    }
};",1441314055
ABHAY GUPTA,abhayg_07,153,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0 , o = 0;
        for( int i = 0 ; i < num.size() ; i++ ){
            if(i&1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return e == o;
    }
};",1441282354
ABHAY GUPTA,abhayg_07,153,3637,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    vector<long long> fact , ifact;

    long long expo(long long a, long long b, long long m)
    {
        long long res = 1;
        while (b > 0)
        {
            if (b & 1)
                res = (res * a) % m;
            a = (a * a) % m;
            b = b >> 1;
        }
        return res % m;
    }

    long long modinv(long long a, long long m) { return expo(a, m - 2, m) % m; } // m is prime

    long long dp[10][162][1500];
    // // center is 750
    int cnt[10];

    void init(long long  n){
        fact.resize(n);
        ifact.resize(n);
        fact[0]=1;
        for( int i = 1 ; i < n ; i++ ) fact[i]=(fact[i-1]%mod*i)%mod;
        ifact[n-1]=modinv(fact[n-1],mod)%mod;
        for(int i=n-2 ; i>=1 ; i--){
            ifact[i]=(ifact[i+1]%mod*(i+1))%mod;
        }
        ifact[0]=1;
    }

    long long recursion( int d , int c , int diff ){
        if( d == -1 && c== 80 && diff == 750 ) return 1;
        else if( d == -1 ) return 0;
        if( dp[d][c][diff] != -1 )return dp[d][c][diff];
        long long ways = 0;
        for( int i = 0 ; i <= cnt[d] ; i++ ){
            // this much d is given to 1
            int newc = c + i - ( cnt[d] - i );
            int newdiff = diff + i * d - ( cnt[d] - i ) * d;
            int D = ( ifact[i]%mod * ifact[cnt[d]-i]%mod )%mod;
            ways = ( ways%mod + ( recursion( d - 1 , newc , newdiff )%mod * D%mod )%mod )%mod;
        }
        return dp[d][c][diff] = ways;
    }

    int countBalancedPermutations(string num) {
        init(10000);
        
        for( int i = 0 ; i < 10 ; i++ ){
            for( int j = 0 ; j < 162 ; j++ ){
                    for( int l = 0 ; l < 1500 ; l++ ){
                        dp[i][j][l] = -1;
                    }
            }
        }
        for( int i = 0 ; i < 10 ; i++ ){
            cnt[i] = 0;
        }
        for( auto i : num ){
            int d = i - '0';
            cnt[d]++;
        }
        int n = num.size();
        long long ways = recursion( 9 , 80 + (n&1) , 750 );
        ways = ( ways * fact[(n+1)/2]%mod )%mod;
        ways = ( ways * fact[n/2]%mod )%mod;
        return ways;
    }
};",1441354161
Yuanbin Cheng,cybsbbbb,154,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[float('inf')] * n for _ in range(m)]
        distance[0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y = heapq.heappop(queue)
            if distance[cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y = cur_x + dx, cur_y + dy
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1, cur_dis + 1)
                    if distance[nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y))

        return distance[-1][-1]

        ",1441303445
Yuanbin Cheng,cybsbbbb,154,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[[float('inf')] * n for _ in range(m)] for _ in range(2)]
        distance[0][0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y, cur_step = heapq.heappop(queue)
            if distance[cur_step][cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y, nxt_step = cur_x + dx, cur_y + dy, (cur_step + 1) % 2
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1 + cur_step, cur_dis + 1 + cur_step)
                    if distance[nxt_step][nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_step][nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y, nxt_step))

        return min(distance[0][-1][-1], distance[1][-1][-1])
        ",1441309705
Yuanbin Cheng,cybsbbbb,154,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(0, n, 2):
            even += int(num[i])
        for i in range(1, n, 2):
            odd += int(num[i])
        return odd == even
        ",1441284061
Yuanbin Cheng,cybsbbbb,154,3637,python3,"MOD = 10 ** 9 + 7
MAXN = 80
fac = [1] * MAXN
inv_fac = [1] * MAXN
for i in range(1, MAXN):
    fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN - 1] = pow(fac[MAXN - 1], -1, MOD)
for i in range(MAXN - 2, -1, -1):
    inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD

def combination(n, k):
    return (fac[n] * inv_fac[k] % MOD) * inv_fac[n - k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        
        cnt = [0] * 10
        tot = 0
        for i in range(n):
            ni = int(num[i])
            cnt[ni] += 1
            tot += ni
        if tot % 2 == 1:
            return 0

        tot_half = tot // 2
        n_even = n // 2 + n % 2
        n_odd = n // 2

        @cache
        def dp(even_v, odd_v, even_c, odd_c, d):
            if even_c < 0 or odd_c < 0:
                return 0
            
            if d == 0:
                if even_v or odd_v:
                    return 0
                else:
                    return 1
            res = 0
            d_cnt = cnt[d]
            for i in range(d_cnt + 1):
                if even_v < i * d or odd_v < (d_cnt - i) * d:
                    continue
                # print(even_c, odd_c)
                res += comb(even_c, i) * comb(odd_c, d_cnt - i) * dp(even_v - i * d, odd_v - (d_cnt - i) * d, even_c - i, odd_c - (d_cnt - i), d - 1) % MOD
            # print(even_v, odd_v, even_c, odd_c, d, res)
            return res % MOD

        return dp(tot_half, tot_half, n_even, n_odd, 9)
            


        

        
        ",1441360555
Matt,mattagar6,155,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int lo = 0, hi = 1e9 + 1;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 1e9+n+m+1000));
        d[0][0] = 0;

        set<tuple<int,int,int>> s;
        s.insert({0,0,0});

        auto go = [&](int r, int c, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;

            int min_time_to_him = moveTime[nr][nc];
            int his_dis = max(dis, min_time_to_him) + 1;
            if(his_dis < d[nr][nc]) {
                s.erase({d[nr][nc], nr, nc});
                d[nr][nc] = his_dis;
                s.insert({d[nr][nc], nr, nc});
            }
            
        };
        
        while(!s.empty()) {
            auto [dis, r, c] = *s.begin();
            s.erase(s.begin());

            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(abs(dx) + abs(dy) == 1) {
                        go(r, c, dis, r + dx, c + dy);
                    }
                }
            }
        }
        
        return d[n-1][m-1];
    }
};",1441337323
Matt,mattagar6,155,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2,2e9)));
        d[0][0][0] = 0;
        set<tuple<int,int,int,int>> s;
        s.insert({0,0,0,0});
        // arrive at r, c with parity p
        auto go = [&](int r, int c, int p, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;
            // we are going now for sure!
            int starting_time = max(dis, grid[nr][nc]);
            dis=starting_time;
            // go now
            for(int rep = 0; rep < 2; rep++, dis++) {
                int np = (p + 1)%2;
                if( dis + 1 + p % 2 < d[nr][nc][np] ) {
                    s.erase({d[nr][nc][np], nr, nc, np});
                    d[nr][nc][np] = dis + 1 + p % 2;
                    s.insert({d[nr][nc][np], nr, nc, np});
                }
            }
            
            
            // wait, then go
            
        };

        while(!s.empty()) {
            auto [dis, r, c, p] = *s.begin();
            s.erase(s.begin());
            for(int dx = -1; dx <= 1; ++dx) {
                for(int dy = -1; dy <= 1; ++dy) {
                    if(abs(dx)+abs(dy)!=1) continue;
                    go(r, c, p, dis, r + dx, c + dy);
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441366949
Matt,mattagar6,155,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0, b = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                a += num[i] - '0';
            } else {
                b += num[i] - '0';
            }
        }
        return a == b;
    }
};",1441297104
Matt,mattagar6,155,3637,cpp,"// for each group of digits

// x o o o x x o o  o
// have N at even, M at odd


struct I {
    long long x{};
};

const int MOD = 1000*1000*1000+7;

I operator + (I a, I b) {
    return I{(a.x + b.x) % MOD};
}

I operator * (I a, I b) {
    return I {(a.x * b.x) % MOD};
}

const int N = 100;
const int M = 1000;
I choose[N][N];
I dp[11][N][M];



// number of used even squares, sum on even squares
class Solution {
public:
    int countBalancedPermutations(string num) {
        for(int i = 0; i < N; i++) {
            choose[i][0] = choose[i][i] = I{1};
            for(int j = 1; j < i; j++) {
                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];
            }
        }
        for(int i = 0; i < 11; i++) for(int j = 0; j < N; j++) for(int k = 0; k < M; k++) dp[i][j][k] = I{0};

        map<int,int> count;
        for(char ch : num) count[ch - '0']++;

        int n = num.size();
        dp[0][0][0] = I{1};
        for(int d = 0; d < 10; d++) {
            int to_put = count[d];
            int sum_all = 0;
            int count_all = 0;
            for(char ch : num) {
                if(ch-'0' < d) {
                    sum_all += ch-'0';
                    count_all+=1;
                }
            }
            
            for(int even = 0; even <= (n+1)/2; even++) {
                for(int sum_even = 0; sum_even <= 9*even; sum_even++) {
                    int sum_odd = sum_all - sum_even;
                    if(sum_odd < 0) continue;
                    for(int on_even = 0; on_even <= to_put; on_even++) {
                        if(on_even + even > (n + 1) / 2) continue;
                        if(n/2-(count_all-even)<to_put-on_even) continue;//odd indices

                        dp[d+1][on_even + even][sum_even + d * on_even] =  dp[d+1][on_even + even][sum_even + d * on_even] + dp[d][even][sum_even] * choose[(n+1)/2 - even ][ on_even ] * choose[n/2-(count_all-even)][ to_put - on_even ];
                    }
                }
            }
        }
        //cout << dp[2][1][1].x << '\n'; // digit 1 is done, one even, sum 1 -> 1 x x, x x 1
       // cout << dp[2][0][0].x; // x 1 x
        int sum = 0;
        for(char c : num) sum += c - '0';
        if(sum % 2 == 1) return 0;
        return dp[10][(n+1)/2][sum/2].x;
    }
};",1441329857
harshal_02,harshal_02,156,3627,cpp,"

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});  
        vector<vector<ll>>vec(n,vector<ll>(m, INF));
        vec[0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j = upr.j;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1) {
                return b;
            }
            if (b > vec[i][j]) {
                continue;
            }
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + 1;
                    if (maxi < vec[ii][jj]) {
                        vec[ii][jj] = maxi;
                        pq.push(st{ii, jj, 0, maxi});  
                    }
                }
            }
        }
        return -1;
    }
};
",1441334267
harshal_02,harshal_02,156,3628,cpp,"#include <vector>
#include <queue>
#include <algorithm>

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});
        vector<std::vector<std::vector<ll>>> vec(n, std::vector<std::vector<ll>>(m, std::vector<ll>(2, INF)));
        vec[0][0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j= upr.j;
            int p= upr.par;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1){
                return b;
        }
            if (b > vec[i][j][p]){
                continue;
    }
        int tot = (p == 0) ? 1 : 2;
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];    
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + tot;
                    int np = 1 - p;
                    if (maxi < vec[ii][jj][np]) {
                        vec[ii][jj][np] = maxi;
                        pq.push(st{ii, jj, np, maxi});
                    }
                }
            }
        }
        ll ans=min(vec[n - 1][m - 1][0], vec[n - 1][m - 1][1]);
        return ans;
    }
};
",1441316511
harshal_02,harshal_02,156,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.size();
        int e=0;
        int o=0;
        for(int i=0;i<n;i++) {
            if(i%2==0){
                e+=num[i]-'0';
        }
            else{
                o+=num[i]-'0';
            }
        }
        return e==o;
    }
};",1441317691
harshal_02,harshal_02,156,3637,cpp,"#define ll long long int
const int MOD=1e9+7;
struct Solution {
    ll mathpow(ll base, ll exponent) {
        ll result=1;
        base=base%MOD;
        while(exponent>0) {
            if(exponent&1)
                result=result*base;
            result=result%MOD;
            base=base*base;
            base=base%MOD;
            exponent>>=1;
        }
        return result;
    }
    ll compute_factorial(int n) {
        ll fact=1;
        for(int i=1;i<n+1;i++){
            fact=fact*i;
            fact=fact%MOD;
        }
        return fact;
    }
    ll compute_combination(int n, int k) {
        if(k > n || k < 0) 
            return 0;
        ll comb=1;
        for(int i=1; i<=k; i++) {
            comb=comb*(n-i+1);
            comb=comb%MOD;
            ll inverse=mathpow(i, MOD-2);
            comb=comb*inverse;
            comb=comb%MOD;
        }
        return comb;
    }
    int countBalancedPermutations(string digits) {
        int n=digits.size(), digit_count[10]={0};
        for(char ch:digits) digit_count[ch-'0']++;
        ll sum=0;
        for(int i=0;i<10;i++){
        sum+=(ll)i*digit_count[i];
    }
        if(sum%2!=0) 
        return 0;
        ll target_value=sum/2;
        int half_n=(n+1)/2;
        vector<vector<vector<ll>>>dp(11, vector<vector<ll>>(half_n+1, vector<ll>(target_value+1, 0)));
        dp[0][0][0]=1;
        for(int i=0;i<10;i++) {
            for(int j=0;j<half_n+1;j++) {
                for(int k=0;k<target_value+1;k++) {
                    if(dp[i][j][k]==0) 
                    continue;
                    for(int use=0; use<=digit_count[i] && use+j<=half_n && use*i<=target_value-k; use++) {
                        ll combination=compute_combination(digit_count[i], use);
                        dp[i+1][j+use][k+use*i]=(dp[i+1][j+use][k+use*i]+dp[i][j][k]*combination)%MOD;
                    }
                }
            }
        }
        ll summ=0;
        for(int i=0;i<10;i++){
        summ+=digit_count[i];
        }
        ll target_sum=target_value;
        if(half_n<0 || half_n > n || target_value<0)
         return 0;
        ll cnt=dp[10][half_n][target_value];
        if(cnt==0) 
        return 0;
        ll fact_val=compute_factorial(n);
        ll prod_fact=1;
        for(int i=0;i<10;i++) {
            prod_fact=prod_fact*compute_factorial(digit_count[i]);
            prod_fact=prod_fact%MOD;
        }
        ll factorial_k=compute_factorial(half_n);
        ll factorial_nk=compute_factorial(n-half_n);
        ll inverse_prod_fact=mathpow(prod_fact,MOD-2);
        ll ans=cnt*factorial_k;
        ans=ans%MOD;
        ans=ans*factorial_nk;
        ans=ans%MOD;
        ans=ans*inverse_prod_fact;
        ans=ans%MOD;
        return (int)ans;
    }
};",1441373357
Rajat,log1,157,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        
        vector<vector<long>>dist(n,vector<long>(m,N));
        priority_queue<tuple<long,int,int>,vector<tuple<long,int,int>>,greater<tuple<long,int,int>>>pq;
        
        dist[0][0]=0;
        pq.push(make_tuple(0,0,0));
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[i,j,k]=pq.top();pq.pop();
            if(j==n-1 && k==m-1)
            {
                return i;
            }
            if(dist[j][k]<i)continue;
            for(auto& it:dir)
            {
                int Nx=j+it[0],Ny=k+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long long Nz=max(i,(long)moveTime[Nx][Ny])+1;
                    if(Nz<dist[Nx][Ny])
                    {
                        dist[Nx][Ny]=Nz;
                        pq.push(make_tuple(Nz,Nx,Ny));
                    }
                }
            }
        }
        return-1;
    }
};",1441348101
Rajat,log1,157,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        vector<vector<vector<long>>>dist(n,vector<vector<long>>(m,vector<long>(2,N)));
        priority_queue<tuple<long,int,int,int>,vector<tuple<long,int,int,int>>,greater<tuple<long,int,int,int>>>pq;
        dist[0][0][0]=0;
        pq.emplace(0,0,0,0);
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[ct,i,j,k]=pq.top();pq.pop();
            if(i==n-1 && j==m-1)
            {
                return(int)ct;
            }
            if(dist[i][j][k]<ct)continue;
            int cost=(k==0)?1:2;
            for(auto& it:dir)
            {
                int Nx=i+it[0],Ny=j+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long at=max((long)ct,(long)moveTime[Nx][Ny])+(long)cost;
                    int Nz=1-k;
                    if(at<dist[Nx][Ny][Nz])
                    {
                        dist[Nx][Ny][Nz]=at;
                        pq.emplace(at,Nx,Ny,Nz);
                    }
                }
            }
        }
        return -1;
    }
};",1441310912
Rajat,log1,157,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int evenSum=0,oddSum=0;
        for(int i=0;i<n;++i)
        {
            (i&1)?oddSum+=num[i]-'0':evenSum+=num[i]-'0';
        }
        return evenSum==oddSum;
    }
};",1441281609
Rajat,log1,157,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;

ll mod_pow(ll x,ll y)
{
    ll res=1;
    x%=MOD;
    while(y>=1)
    {
        if(y&1)res=res*x%MOD;
        x=x*x%MOD;
        y>>=1;
    }
    return res;
}
class Solution{
public:
    int countBalancedPermutations(string num){
        int n=num.size();
        int dig[10]={0};
        for(int i=0;i<n;++i)
        {
            dig[num[i]-'0']++;
        }
        ll tot=0;
        for(int d=0;d<10;++d)
        {
            tot+=(ll)d*dig[d];
        }
        if(tot%2!=0)
        {
            return 0;
        }
        ll tar=tot/2;
        int k=(n+1)/2;
        vector<vector<vector<ll>>>dp(11,vector<vector<ll>>(k+1,vector<ll>(tar+1,0)));
        dp[0][0][0]=1;
        for(int d=0;d<10;++d)
        {
            for(int c=0;c<=k;++c)
            {
                for(int s=0;s<=tar;++s)
                {
                    if(dp[d][c][s]==0)continue;
                    for(int t=0;t<=dig[d] && t+c<=k && t*d<=tar-s;++t)
                    {
                        ll res=1;
                        for(int i=1;i<=t;++i)
                        {
                            res=res*(dig[d]-i+1)%MOD;
                            ll inv=mod_pow(i,MOD-2);
                            res=res*inv%MOD;
                        }
                        int nxt=d+1,nxtc=c+t,nxts=s+t*d;
                        dp[nxt][nxtc][nxts]=(dp[nxt][nxtc][nxts]+dp[d][c][s]*res)%MOD;
                    }
                }
            }
        }
        if(k<0 || k>n || tar<0)return 0;
        ll ret=dp[10][k][tar];
        if(ret==0)return 0;
        vector<long long>ndp(n+1,1);
        for(int i=1;i<=n;++i)
        {
            ndp[i]=ndp[i-1]*i%MOD;
        }
        ll prod=1;
        for(int d=0;d<10;++d)
        {
            for(int i=1;i<=dig[d];++i)
            {
                prod=prod*i%MOD;
            }
        }
        ll pre1=ndp[k],pre2=ndp[n-k];
        ll prod_inv=mod_pow(prod,MOD-2);
        ll ans=ret*pre1%MOD;
        // for(int i=0;i<ans;++i)
        // {
        //     cout<<ndp[i]<<"" "";
        // }
        // cout<<endl;
        ans=ans*pre2%MOD;
        ans=ans*prod_inv%MOD;
        return(long long)ans;
    }
};",1441332406
chh9976,chh9976,158,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d + 1, moveTime[x-1][y] + 1)
                bfs.add((max(d + 1, moveTime[x-1][y] + 1), (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d + 1, moveTime[x][y-1] + 1)
                bfs.add((max(d + 1, moveTime[x][y-1] + 1), (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d + 1, moveTime[x+1][y] + 1)
                bfs.add((max(d + 1, moveTime[x+1][y] + 1), (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d + 1, moveTime[x][y+1] + 1)
                bfs.add((max(d + 1, moveTime[x][y+1] + 1), (x, y+1)))
                
                ",1441299328
chh9976,chh9976,158,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d, moveTime[x-1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x-1, y)], (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d, moveTime[x][y-1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y-1)], (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d, moveTime[x+1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x+1, y)], (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d, moveTime[x][y+1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y+1)], (x, y+1)))
                
        ",1441304424
chh9976,chh9976,158,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280967
chh9976,chh9976,158,3637,cpp,"
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define ee9 1000000000
#define ee18 1000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
typedef mint<998244353> mint99;
vc<mint17> fact(1, 1), ifact(1, 1);
mint17 C(int a, int b){
    return fact[a] * ifact[b] * ifact[a-b];
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if(fact.size() == 1){
            rep(i, 1, 170) fact.pb(fact.back() * i), ifact.pb(ifact.back() / i);
        }
        int n = num.size();
        map<int, int> cnter;
        for(auto c:num) cnter[c-48]++;
        
        int su = 0;
        for(auto [k, v]:cnter) su += k * v;
        if(su % 2 == 1) return 0;
        int tar = su / 2;
        
        vc dp((1+n) / 2 + 1, vc<mint17>(tar+1)); dp[0][0] = 1;
        int nowcnt = 0;
        for(auto [k, v]:cnter){
            vc ndp((1+n) / 2 + 1, vc<mint17>(tar+1));
            rep(i, 0, v+1){
                rep(j, 0, tar+1) if(i * k + j <= tar) {
                    rep(kk, 0, nowcnt+1) if(i + kk <= (1+n) / 2){
                        ndp[i + kk][i * k + j] += C(i + kk, i) * C(nowcnt - kk + v - i, v - i) * dp[kk][j];
                    }
                }
            }
            nowcnt += v;
            dp = move(ndp);
        }
        return dp[(1+n)/2][tar].x;
        
    }
};",1441361211
colicon,colicon,159,3627,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[2e9]*m for _ in range(n)]
        d[0][0] = 0
        
        h = [(0, 0, 0)]
        while h:
            cd, i, j = heappop(h)

            if d[i][j] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + 1
    
                    if d[ni][nj] > nd:
                        d[ni][nj] = nd
                        heappush(h, (nd, ni, nj))

        return d[-1][-1]
            ",1441297539
colicon,colicon,159,3628,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[[2e9]*2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        w = [1, 2]
        
        h = [(0, 0, 0, 0)]
        while h:
            cd, t, i, j = heappop(h)

            if d[i][j][t] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + w[t]
    
                    if d[ni][nj][t^1] > nd:
                        d[ni][nj][t^1] = nd
                        heappush(h, (nd, t^1, ni, nj))

        return min(d[-1][-1])
            
",1441301085
colicon,colicon,159,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        b = 0

        for i, x in enumerate(num):
            if i&1:
                a += int(x)
            else:
                b += int(x)

        return a == b",1441282279
colicon,colicon,159,3637,python3,"mod = 10**9 + 7

fac = [1] * 100
for i in range(2, 100):
    fac[i] = fac[i-1] * i % mod
ifac = [0] * 100
ifac[99] = pow(fac[99], -1, mod)
for i in range(98, -1, -1):
    ifac[i] = ifac[i+1] * (i+1) % mod

def choose(n, k):
    return fac[n] * ifac[k] % mod * ifac[n-k] % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        n = len(num)

        cnt = [0] * 11
        for x in num:
            cnt[int(x)] += 1

        tot_sum = [0] * 11
        for i in range(10):
            tot_sum[i] = tot_sum[i-1] + cnt[i] * i

        tot_cnt = [0] * 11
        for i in range(10):
            tot_cnt[i] = tot_cnt[i-1] + cnt[i]

        if tot_sum[-2] & 1:
            return 0
        
        dp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        dp[0][0] = 1
        for d in range(10):
            for i in range(min(n//2, tot_cnt[d-1])+1):
                for j in range(tot_sum[d-1]+1):
                    for k in range(min(n//2-i, cnt[d])+1):
                        if j + k*d > tot_sum[-2]//2:
                            break
                        ri = tot_cnt[d-1] - i
                        rk = cnt[d] - k

                        ndp[i + k][j + k*d] += dp[i][j] * choose(i+k, k) % mod * choose(ri+rk, rk) % mod
                        ndp[i + k][j + k*d] %= mod
            dp = ndp
            ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]

        return dp[n//2][tot_sum[-2]//2]
                
            
            ",1441348954
Pranav Raj,ThunderXGod,162,3627,cpp,"#define pii pair<int, int>
vector<vector<int>> d = {{-1,0}, {1, 0}, {0, -1}, {0, 1}};
int zz;
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        
        vector<vector<long long>> a(n, vector<long long>(m, 2e18));
        
        priority_queue<pair<long long,pii>, vector<pair<long long,pii>>, greater<pair<long long,pii>>> pq;
        
        a[0][0] = 0;
        pii p = {0, 0};
        pq.push({0, p});
        long long cur = 0, tm = 0;
        while((int)pq.size()) 
        {
            auto c = pq.top();
            cur += c.first;
            int i = c.second.first, j = c.second.second;
            pq.pop();
            
            if(i == n - 1 && !zz && j == m - 1) 
            {
                int ans = cur;
                return ans;
            }
            long long st;
            if(cur <= a[i][j])
            {
                st -= st;
                st += max(1ll*cur, 1ll*moveTime[i][j]);
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = j;
                    ni += dir[0];
                    nj += dir[1];

                    if (ni > -1 && !zz && ni <= n - 1 && !zz && nj > -1 && !zz && nj <= m - 1) 
                    {
                        long long mt, at = -1;
                        mt = st;
                        at++;
                        tm += max(1ll*cur, 1ll*moveTime[ni][nj]);
                        at -= at;
                        at += tm;
                        
                        //at += max(mt, 1ll*moveTime[ni][nj]);
                        
                        if (at + 1 < a[ni][nj]) 
                        {
                            a[ni][nj] = at + 1;
                            p.first = ni;
                            p.second = nj;
                            pq.push({at + 1, p});
                        }
                        tm -= tm;
                    }
                }
            }
            cur -= cur;
        }
        
        return -1;
    }
};",1441307299
Pranav Raj,ThunderXGod,162,3628,cpp,"vector<vector<int>> d = {{-1,0}, {1,0}, {0,-1}, {0,1}};
#define vll vector<long long>
int zz;
#define liii long long, int, int, int
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        vector<vector<vll>> a(n, vector<vll>(m, vll(2, 2e18)));
        priority_queue<tuple<liii>, vector<tuple<liii>>, greater<tuple<liii>>> pq;
        a[0][0][0] -= a[0][0][0];
        pq.push({0, 0, zz, 0});
        long long c = zz, tm = 0, at = 0;
        while((int)pq.size()) 
        {
            auto cur = pq.top();
            int i = get<1>(cur), j = 0, p = -1;
            j += get<2>(cur);
            c += get<0> (cur);
            
            pq.pop();
            
            if(i+1==n&&j+1==m) 
            {
                int ans = c;
                return ans;
            }
             
            p += get<3>(cur);
            if(c <= a[i][j][p+1]) 
            {  
                int dr = 2;
                if(!(p+1))
                    dr--;
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = i + j;
                    ni+= dir[0];
                    nj += dir[1];
                    nj -= i;
        
                    if(ni > -1 && !zz&& ni <= n - 1 && !zz&& nj > -1 && nj <= m - 1) 
                    {
                        at += 1ll*dr;
                        if(!zz)
                        tm += max(1ll*c, 1ll*moveTime[ni][nj]);
                        at += tm;
                        int np = 1;
                        np-= (p+1);

                        if(at+zz < a[ni][nj][np]) 
                        {
                            a[ni][nj][np] = at;
                            if(!zz)
                            pq.push({at, ni, nj, np});
                        }
                        tm -= tm;
                        at -= at;
                    }
                }
            }
            c-=c;
        }
        
        return -1;
    }
};
",1441331247
Pranav Raj,ThunderXGod,162,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < (int)num.size(); i++)
        {
            if(i&1)
                l += (num[i]-'0');
            else
                r += (num[i]-'0');
        }
        return (l==r);
    }
};",1441281650
Pranav Raj,ThunderXGod,162,3637,cpp,"#define ll long long
const int M = 1e9 + 7;
ll f1(ll x, ll y, ll mv) 
{
    ll r = 1;
    x %= mv;
    while(y>=1)
    {
        if(y&1)
        {
            r*=x;
            r%=mv;
        }
        x*=x;
        x%=mv;
        y >>= 1;
    }
    return r;
}
struct Factorials 
{
    vector<ll> fc,ifc;
    Factorials(int mn, int mv)
    {
        int sz = 1;
        sz += mn;
        fc.resize(sz, 1);
        ifc=fc;
        int i = 1;
        while(i < mn + 1)
        {
            fc[i]=fc[i-1];
            fc[i]*=i;
            fc[i]%=mv;
            i++;
        }
        ifc[mn] = f1(fc[mn], mv -2, mv);
        i = -1;
        i += mn;
        while(i > -1)
        {
            ifc[i] = ifc[i+1];
            ifc[i]*=(1+i);
            ifc[i]%=mv;
            i--;
        }
    }
    ll f2(int n, int k)
    {
        if(k > n)
            return 0;
        if(k <= -1)
            return 0;
        ll ans = fc[n];
        ans *= ifc[k];
        ans %= M;
        ans *= ifc[-k+n];
        return (ans%M);
    }
};

class Solution {
public:
    int n;
    int countBalancedPermutations(string &num) 
    {
        n = (int)num.size();
        int dc[10];
        memset(dc, 0, sizeof(dc));
        ll s =0;
        for(char ch: num)
        {
            int vv=(int)(ch-'0');
            dc[vv]++;
            s+=(vv);
        }
        if(s&1) 
            return 0;
        ll ts = s;
        ts >>= 1;
        int m = 1,p=2*n,d=0,cnt = 1;
        m+=n;
        m>>=1;
        p>>=2;
        int sz = 1;
        sz += ts;
        Factorials f(n, M);
        vector<ll> vec(sz, 0);
        vector<vector<ll>> dp(m +1, vec);
        dp[0][0]++;
        while(d<10)
        {
            vector<vector<ll>> dp2 = dp;
            while(cnt < dc[d]+1)
            {
                int k = m;
                while(1)
                {
                    if(k < cnt)
                        break;
                    int s = 0;
                    s += ts;
                    while(1)
                    {
                        if(s < cnt*d)
                            break;
                        int kk = -d*cnt;
                        kk += s;
                        ll val = dp[-cnt+k][kk];
                        val*=1ll*f.f2(dc[d],cnt);
                        dp2[k][s] += val;
                        dp2[k][s] %= M;
                        s--;
                    }
                    k--;
                }
                cnt++;
            }
            cnt = 1;
            d++;
            dp = dp2;
        }
        d-=d;
        ll dm =1;
        while(d < 10)
        {
            dm *= f.fc[dc[d]];
            dm %= M;
            d++;
        }
        ll fm = 0, fp = 0;
        fm+=f.fc[m];
        fp+=f.fc[p];
        ll ans = dp[m][ts];
        ans *= fm;
        ans%=M;
        ans*=fp;
        ans%=M;
        ans*=f1(dm, M -2, M);
        ans%=M;
        int fans = ans;
        return fans;
    }
};",1441369307
TheRaven,TheRaven,163,3627,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?1:0]) {
                    PQ.add(new Pair(i2,j2,Math.max(p.d+1,moveTime[i2][j2]+1), p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441314301
TheRaven,TheRaven,163,3628,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?0:1]) {
                    int d2 = (p.parity) ? 1 : 2;
                    PQ.add(new Pair(i2,j2,Math.max(p.d+d2,moveTime[i2][j2]+d2), !p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441319121
TheRaven,TheRaven,163,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int eSum = 0;
        int oSum = 0;
        char [] S = num.toCharArray();
        for (int i = 0; i<S.length; ++i) {
            if (i % 2 == 0) eSum += S[i]-'0';
            else oSum += S[i]-'0';
        }
        return eSum == oSum;
        
    }
}",1441284618
TheRaven,TheRaven,163,3637,java,"class Solution {
    long [][][] dp;
    long MOD = 1000000007L;
    int [] cnt;
    long [][] choose = new long [82][82];
    int numtot;
    public int countBalancedPermutations(String num) {
        choose[0][0] = 1;
        for (int i = 1; i<choose.length; ++i) {
            choose[i][0] = choose[i-1][0];
            for (int j = 1; j<=i; ++j) {
                choose[i][j] = (choose[i-1][j] + choose[i-1][j-1]) % MOD;   
            }
        }
        //System.out.println(choose[30][30]);
        
        int sum = 0;
        cnt = new int [10];
        char [] N = num.toCharArray();
        int numtot = N.length;
        for (char c : N) cnt[c-'0']++;
        for (int i = 1; i<=9; ++i) sum += cnt[i]*i;
        if (sum % 2 == 1) return 0;
        if (sum == 0) return 1;
        
        dp = new long [10][sum/2+1][N.length/2+1];
        for (int i = 0; i<10; ++i) for (int j = 0; j<dp[0].length; ++j) Arrays.fill(dp[i][j], -1);
        int goal = sum/2;
        
        long ans = recurse(0, sum/2, N.length/2, N.length - N.length/2);
            
        return (int)(ans % MOD);
    }
    public long recurse(int dig, int goalsum, int numleft, int numother) {
        if (numleft == 0 && goalsum == 0 && numother == 0) return 1;
        if (dig > 9) return 0;
        if (goalsum == 0 && numleft > 0 && dig != 0) return 0;
        if (numother < 0) return 0;
        
        if (dp[dig][goalsum][numleft] == -1) {
            int lim = Math.min(numleft, cnt[dig]);
            long ans = 0;
            for (int i = 0,g=goalsum,j=cnt[dig]; i<=lim && g>=0 && j>=0; ++i,--j,g-=dig) {
                long tmp = recurse(dig+1, g, numleft-i, numother - j);
                tmp *= choose[numleft][i];
                tmp %= MOD;
                tmp *= choose[numother][j];
                ans += (tmp % MOD);
            }
            ans %= MOD;
            dp[dig][goalsum][numleft] = ans;
            //System.out.println(""dig = "" + dig + "" goalsum = "" + goalsum + "" numleft = "" + numleft + "" ans = "" + ans);
        }
        return dp[dig][goalsum][numleft];
    }
}",1441363064
Decision,Decision,165,3627,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[1][m][n];
        for(int i=0;i<1;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = 0;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375984
Decision,Decision,165,3628,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[2][m][n];
        for(int i=0;i<2;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = (nd.st + 1) % 2;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + nd.st + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        if(dist[1][m-1][n-1] >= 0 && (res < 0 || res > dist[1][m-1][n-1])){
            res = dist[1][m-1][n-1];
        }
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375746
Decision,Decision,165,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int odd = 0, even = 0, k = 0;
        for(char ch : num.toCharArray()){
            if(k == 0){
                odd += ch - '0';
            }else{
                even += ch - '0';
            }
            k = (k+1) % 2;
        }
        return odd == even;
    }
}",1441376163
Decision,Decision,165,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        final int n = num.length(), m = 10, odd = (n+1) / 2, k = odd * (m - 1), MODE = 1000000007;
        final int even = n - odd;
        final int[] cs = new int[m];
        int sum = 0;
        long[][] dp = new long[odd+1][k+1], comb = new long[n+1][n+1];
        dp[0][0] = 1L;
        for(char ch : num.toCharArray()){
            cs[ch-'0']++;
            sum += ch - '0';
        }
        comb[0][0] = 1L;
        for(int i=1;i<=n;++i){
            comb[i][0] = comb[i][i] = 1L;
            for(int j=1;j<i;++j){
                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MODE;
            }
        }
        for(int i=0,cnt=0;i<m;++i){
            long[][] dp2 = new long[odd+1][k+1];
            for(int a=0;a<=cnt && a<=odd;++a){
                for(int b=0;b<=k;++b){
                    if(dp[a][b] > 0){
                        for(int c=0;c<=cs[i];++c){
                            if(c + a <= odd && cs[i]-c+(cnt-a) <= even){
                                dp2[c+a][b+i*c] += (comb[odd-a][c] * comb[even-(cnt-a)][cs[i]-c]) % MODE * dp[a][b];
                                dp2[c+a][b+i*c] = dp2[c+a][b+i*c] % MODE;
                            }
                        }
                    }
                }
            }
            cnt += cs[i];
            dp = dp2;
        }
        long res = 0;
        for(int i=0;i<=k;++i){
            if(sum-i == i){
                res = (res + dp[odd][i]) % MODE;
            }
        }
        return (int)res;
    }
}",1441375516
Piyush Kumar,kumarfeldspar,166,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F first
#define S second
#define __builtin_popcount __builtin_popcountll
#define vvi vector<vector<int>>
#define ld long double
#define pb push_back
#define mp make_pair
#define precision(i) cout << fixed << setprecision(i)
#define vpii vector<pair<int, int>>
#define pii pair<int, int>
#define vi vector<int>
#define stoi stoll
#define all(x) x.begin(), x.end()
#define mii map<int, int>
#define pqb priority_queue<int>
#define sz(a) (ll) a.size()
#define fastio                        \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL);
#define pqs priority_queue<int, vi, greater<int>>
#define rsort(a) sort(a.rbegin(), a.rend())
#define get_sum(a) accumulate(a.begin(), a.end(), 0LL)
#define get_max(a) *max_element(a.begin(), a.end())
#define get_min(a) *min_element(a.begin(), a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG);
long long rnd(long long x, long long y)
{
    return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout << x << nl
#define inf 1e18
#define ld long double
#define w(t)  \
    int t;    \
    cin >> t; \
    while (t--)
#define in(k) \
    int k;    \
    cin >> k;
#define f(i, x) for (int i = 0; i < x; i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i, a, b) for (int i = a; i < b; i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x << endl
#define dbg2(x, y) cout << #x << "" "" << x << "" "" << #y << "" "" << y << endl
#define dbg3(x, y, z) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << endl
#define dbg4(x, y, z, w) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << endl
#define dbg5(x, y, z, w, a) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << "" "" << #a << "" "" << a << endl
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)         \
    cout << #x << "" => ""; \
    _print1(x);           \
    cout << ""\n"";
void _print(ll t) { cerr << t; }
void _print(int t) { cerr << t; }
void _print(string t) { cerr << t; }
void _print(char t) { cerr << t; }
void _print(ld t) { cerr << t; }
void _print(double t) { cerr << t; }
template <class T, class V>
void _print(pair<T, V> p);
template <class T>
void _print(vector<T> v);
template <class T>
void _print(set<T> v);
template <class T, class V>
void _print(map<T, V> v);
template <class T>
void _print(multiset<T> v);
template <class T, class V>
void _print(pair<T, V> p)
{
    cerr << ""{"";
    _print(p.first);
    cerr << "","";
    _print(p.second);
    cerr << ""}"";
}
template <class T>
void _print(vector<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(set<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(multiset<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T, class V>
void _print(map<T, V> v)
{
    cerr << ""[ "";
    for (auto i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
    // shows from left
    string res;
    while (x > 0)
    {
        if (x % 2 == 0)
            res += '0';
        else
            res += '1';
        x /= 2;
    }
    reverse(all(res));
    return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX; j += i)
            {
                if (spf[j] == j)
                    spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m)
{
    a %= m;
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n, ll r)
{
    if (n < r)
        return 0;
    if (r > n - r)
        r = n - r;
    ll ans = 1;
    ll i;
    for (i = 1; i <= r; i++)
    {
        ans *= n - r + i;
        ans /= i;
    }
    return ans;
}
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }
ll MI(ll a, ll m) { return bpow(a, m - 2, m); }
void meta(int x) { cout << ""Case #"" << x << "": ""; }

class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size();
        int m = tm[0].size();
        vector<vector<ll>> dist(n, vector<ll>(m, 1e18));
        priority_queue<pair<ll, pair<int, int>>, vector<pair<long long, pair<int, int>>>, greater<pair<long long, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.empty())
        {
            auto current = pq.top();
            pq.pop();
            long long t = current.F;
            int i = current.second.F;
            int j = current.second.S;
            if (i == n - 1 && j == m - 1)
                return t;
            if (t > dist[i][j])
                continue;
            f(k,4)
            {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if (ni >= 0 && ni < n && nj >= 0 && nj < m)
                {
                    long long nt = max(t, (long long)tm[ni][nj]) + 1;
                    if (nt < dist[ni][nj])
                    {
                        dist[ni][nj] = nt;
                        pq.push({nt, {ni, nj}});
                    }
                }
            }
        }
        return -1;
    }
};",1441296485
Piyush Kumar,kumarfeldspar,166,3628,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define unewxq(s) s.resize(unewxque(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
// long long rnd(long long x, long long y)
// {
// return unewxform_int_distribution<long long>(x, y)(RNG);
// }
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX ; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX ; j += i)
            {
            if(spf[j]==j)	
                spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX ; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX ; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
// #define int long long int
#define mod             1000000007
const int N = 4e5 + 5;


class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size(), m = tm[0].size();
        vector<vector<ll>> d0(n, vector<long long>(m, 1e18));
        vector<vector<ll>> d1(n, vector<long long>(m, 1e18));
        d0[0][0] = 0;
        priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty())
        {
            auto [t, i, j, p] = pq.top();
            pq.pop();

            if (i == n - 1 && j == m - 1)
                return t;

            if ((p == 0 && t > d0[i][j]) || (p == 1 && t > d1[i][j]))
                continue;

            f(k,4)
            {
                int newx = i + dx[k], newy = j + dy[k];

                if (newx >= 0 && newx < n && newy >= 0 && newy < m)
                {
                    long long temp = 2;
                    if(p==0)temp=1;
                    long long nt = max(t, (long long)tm[newx][newy]) + temp;
                    int np = 1 - p;

                    if (np == 0)
                    {
                        if (nt < d0[newx][newy])
                        {
                            d0[newx][newy] = nt;
                            // cout<<nt<<"" ""<<newx<<"" ""<<newy<<"" ""<<np<<endl;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                    else
                    {
                        if (nt < d1[newx][newy])
                        {
                            d1[newx][newy] = nt;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                }
            }
        }

        return -1;
    }
};
",1441302838
Piyush Kumar,kumarfeldspar,166,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            } else {
                oddSum += num[i] - '0';
            }
        }
        
        return evenSum == oddSum;
    }
};",1441286993
Piyush Kumar,kumarfeldspar,166,3637,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
long long rnd(long long x, long long y)
{
return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
// #define MAX 500007
// vector<int> primes;
// bool isprime[MAX];
// int spf[MAX];
// void sieve()
// {
//     f(i, MAX) spf[i] = i;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (spf[i] == i)
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//             {
//             if(spf[j]==j)	
//                 spf[j] = i;
//             }
//         }
//     }
//     f(i, MAX) isprime[i] = true;
//     isprime[1] = false;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (isprime[i])
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//                 isprime[j] = false;
//         }
//     }

//     // for (ll p = 2; p < MAX; p++)
//     // 	if (isprime[p])
//     // 		primes.push_back(p);
// }
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
#define MOD 1000000007

ll bpow(ll x, ll y)
{
    ll res = 1;
    x %= MOD;
    while (y > 0)
    {
        if (y & 1)
            res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int n = num.size();
        int k = (n + 1) / 2;
        int l = n / 2;
        ll S = 0;
        int freq[10];
        memset(freq,0,sizeof(freq));
        for (char c : num)
        {
            S += (c - '0');
            freq[c - '0']++;
        }
        if (S&1)
            return 0;
        ll target = S / 2;
        int MAX = n;
        vector<ll> fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++)
            fact[i] = fact[i - 1] * i % MOD;

        vector<ll> inv_fact(MAX + 1, 1);
        inv_fact[MAX] = bpow(fact[MAX], MOD - 2);
        for (int i = MAX - 1; i >= 0; i--)
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;

        vector<vector<ll>> old_dp(k + 1, vector<ll>(target + 1, 0));
        old_dp[0][0] = 1;
        for (int d = 0; d <= 9; d++)
        {
            vector<vector<ll>> dp_next(k + 1, vector<ll>(target + 1, 0));
            for (int c = 0; c <= k; c++)
            {
                for (int s = 0; s <= target; s++)
                {
                    if (old_dp[c][s] == 0)
                        continue;
                    for (int assign = 0; assign <= min(freq[d], k - c); assign++)
                    {
                        if (s + (ll)assign * d > target)
                            continue;
                        ll val = old_dp[c][s] * inv_fact[assign] % MOD;
                        val = val * inv_fact[freq[d] - assign] % MOD;
                        dp_next[c + assign][s + assign * d] = (dp_next[c + assign][s + assign * d] + val) % MOD;
                    }
                }
            }
            old_dp = dp_next;
        }
        ll value = old_dp[k][target];
        if (value == 0)
            return 0;
        ll ans = fact[k]*fact[l] % MOD;
        ans = ans * value % MOD;
        return (int)ans;
    }
};
",1441371265
Linh Nguyen,ll931110,168,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[55][55];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = inf;
            }
        }
        dist[0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2];
            if (-u[0] != dist[ux][uy]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i];
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = 1 + max(dist[ux][uy], moveTime[vx][vy]);

                if (dist[vx][vy] > ts) {
                    dist[vx][vy] = ts;
                    pq.push({-ts, vx, vy});
                }
            }
        }

        return dist[m - 1][n - 1];
    }
};",1441293859
Linh Nguyen,ll931110,168,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[755][755][2];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }

        dist[0][0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2], uz = u[3];
            if (-u[0] != dist[ux][uy][uz]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i], vz = uz ^ 1;
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = max(dist[ux][uy][uz], moveTime[vx][vy]);
                if (uz == 0) {
                    ts++;
                } else {
                    ts += 2;
                }

                if (dist[vx][vy][vz] > ts) {
                    dist[vx][vy][vz] = ts;
                    pq.push({-ts, vx, vy, vz});
                }
            }
        }

        return min(dist[m - 1][n - 1][0], dist[m - 1][n - 1][1]);
    }
};",1441296588
Linh Nguyen,ll931110,168,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int delta = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0) {
                delta += d;
            } else {
                delta -= d;
            }
        }
        return (delta == 0);
    }
};",1441281045
Linh Nguyen,ll931110,168,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int even = n/2, odd = n - even;
        int maxn = 42;
        int mod = 1e9 + 7;

        int binom[maxn][maxn];
        memset(binom, 0, sizeof binom);
        binom[0][0] = 1;
        for (int i = 1; i < maxn; i++) {
            for (int j = 0; j <= i; j++) {
                binom[i][j] = binom[i - 1][j];
                if (j) {
                    binom[i][j] = (binom[i][j] + binom[i - 1][j - 1]) % mod;
                }
            }
        }

        int D = 361;
        int cur[maxn][maxn][2 * D + 1], nxt[maxn][maxn][2 * D + 1];
        
        memset(cur, 0, sizeof cur);
        cur[even][odd][D] = 1;

        int counter[10];
        memset(counter, 0, sizeof counter);
        for (auto c : num) {
            counter[c - '0']++;
        }

        vector< vector<int> > curs, nexts;
        curs.push_back({even, odd, D});

        for (int d = 0; d < 10; d++) {
            memset(nxt, 0, sizeof nxt);
            nexts.clear();
            for (auto u : curs) {
                int e = u[0], o = u[1], delta = u[2];
                for (int chosen = 0; chosen <= counter[d]; chosen++) {
                    int _e = e - chosen;
                    int _o = o - (counter[d] - chosen);
                    if (_e < 0 || _o < 0) {
                        continue;
                    }
                    int _delta = delta + chosen * d - (counter[d] - chosen) * d;
                    if (_delta < 0 || _delta >= 2 * D) {
                        continue;
                    }

                    long long ways = cur[e][o][delta];
                    ways = (ways * binom[e][chosen]) % mod;
                    ways = (ways * binom[o][counter[d] - chosen]) % mod;
                    if (!nxt[_e][_o][_delta]) {
                        nexts.push_back({_e, _o, _delta});
                    }
                    nxt[_e][_o][_delta] += ways;
                    nxt[_e][_o][_delta] %= mod;
                }
            }
            for (int e = 0; e <= even; e++) {
                for (int o = 0; o <= odd; o++) {
                    for (int d = 0; d < 2 * D; d++) {
                        cur[e][o][d] = nxt[e][o][d];
                    }
                }
            }
            curs = nexts;
        }

        return cur[0][0][D];
    }
};",1441325657
LeeetCode,user3517H,170,3627,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0))]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1
    grid[0][0] = 0
    while heap:
      t, (i, j) = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j)))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += 1
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj)))
",1441299374
LeeetCode,user3517H,170,3628,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0), 1)]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1 + (i + j + 1) % 2
    grid[0][0] = 0
    while heap:
      t, (i, j), d = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j), d))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += d
      d = 3 - d
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj), d))
",1441312441
LeeetCode,user3517H,170,3636,python3,"class Solution:
  def isBalanced(self, num: str) -> bool:
    return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
",1441281990
LeeetCode,user3517H,170,3637,python3,"class Solution:
  def countBalancedPermutations(self, num: str) -> int:
    @cache
    def dfs(i, l, r, o, e):
      if i == 9:
        return 0 if o * 9 != l or o > cnt[9] else 1
      res = 0
      # j >= cnt[i] - r / i
      # cnt[i] - j <= e
      lo = max(0, cnt[i] - e, 0 if i == 0 else cnt[i] - r // i)
      hi = 1 + min(o, inf if i == 0 else l // i, cnt[i])
      for j in range(lo, hi):
        k = cnt[i] - j
        res = (res + dfs(i + 1, l - i * j, r - i * k, o - j, e - k) * comb(o, j) * comb(e, k)) % mod
      return res

    mod = 10 ** 9 + 7
    cnt = [0] * 10
    tot = 0
    n = len(num)
    for i in num:
      i = int(i)
      cnt[i] += 1
      tot += i
    if tot % 2 == 1:
      return 0
    return dfs(0, tot // 2, tot // 2, (n + 1) // 2, n // 2)",1441360652
yahoo010206,yahoo010206,171,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, (0, 0))]
        used = set()
        while heap[0][1]!=target:
            t, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+1, (x, y)))
        return heap[0][0]
                        
            
        ",1441300685
yahoo010206,yahoo010206,171,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, 0, (0, 0))]
        used = set()
        while heap[0][2]!=target:
            t, l, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+(2 if l&1 else 1), (l+1)%2, (x, y)))
        return heap[0][0]
                        
            
        ",1441304135
yahoo010206,yahoo010206,171,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2))== sum(int(num[i]) for i in range(1, len(num), 2))",1441281480
yahoo010206,yahoo010206,171,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits = [int(d) for d in num]
        total = sum(digits)
        if total%2:
            return 0

        modulo = 1000000007
        digits_cnts = Counter(digits)
        length1 = len(digits)>>1
        length2 = (len(digits)>>1)+(len(digits)&1)
        mem = {}
        def solve(d, value, l1, l2):
            key = (d, value, l1, l2)
            # print(d, value, l1, l2)
            if key in mem:
                return mem[key]
            if d==-1:
                # print(""**"")
                return 1 if value==0 and l2==0 else 0

            res = 0
            for cnt in range(0, min(digits_cnts[d], l1)+1):
                if (_value:=value-cnt*d)>=0:
                    if (_res:=solve(d-1, _value, l1-cnt, l2-(digits_cnts[d]-cnt)))!=0:
                        # print(""--"", _res, d, (l1, cnt), (l2, digits_cnts[d]-cnt))
                        res += _res*(
                            math.comb(l1, cnt)%modulo*
                            math.comb(l2, digits_cnts[d]-cnt)%modulo
                        )
                        
            mem[key] = res%modulo if res else 0
            return mem[key]
        return solve(9, total>>1, length1, length2)",1441367015
AxxxxxA,blackhatinside,174,3627,python3,"class Solution:
    def minTimeToReach(self, moTi, flag = 1, temp = 5, ext = 5, dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]):
        if flag: far = [[float('inf')] * len(moTi[0]) for _ in range(len(moTi))]
        if flag: pq = [(0, 0, 0)]
        if flag: far[0][0] = 0
        while pq:
            if flag: tm, rw, cl = heapq.heappop(pq)
            if tm <= far[rw][cl]:
                for i in range(len(dirs)):
                    if 0 <= rw + dirs[i][0] < len(moTi) and 0 <= cl + dirs[i][1] < len(moTi[0]):
                        if (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1) < far[rw + dirs[i][0]][cl + dirs[i][1]]:
                            if flag: far[rw + dirs[i][0]][cl + dirs[i][1]] = (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1)
                            if flag: heapq.heappush(pq, ((max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1), rw + dirs[i][0], cl + dirs[i][1]))
        return temp + far[ext + (-1) - ext][ext + (-1) -ext] - temp",1441334916
AxxxxxA,blackhatinside,174,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, movt, directions = [(0, 1), (1, 0), (0, -1), (-1, 0)], flag = 1, temp = 5):
        if not movt or not movt[0]:
            return 0
        if flag: n, m = len(movt), len(movt[0])
        if flag: pq = [(0, 0, 0, 0)]
        if flag: vsit = set()
        while pq:
            if flag: curt, chk, r, c = heapq.heappop(pq)
            if r == n - 1 and c == m - 1:
                return curt
            if flag: st = (r, c, chk)
            if st not in vsit:
                if flag: vsit.add(st)
                for dx, dy in directions:
                    if 0 <= (temp + r + dx - temp) < n and 0 <= (temp + c + dy - temp) < m:
                        if flag: heapq.heappush(pq, (curt + (max(0, movt[temp + r + dx - temp][temp + c + dy - temp] - curt)) + \
                            (2 if chk else 1), not chk, temp + r + dx - temp, temp + c + dy - temp))
        return -1",1441309396
AxxxxxA,blackhatinside,174,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(len(num)) if i % 2 == 0) == sum(int(num[i]) for i in range(len(num)) if i % 2 == 1)",1441289373
AxxxxxA,blackhatinside,174,3637,python3,"class Solution:
    def countBalancedPermutations(self, num, one = 1, two = 2, flag = 1, temp = 5, MOD = int(1e9 + 7)):
        if flag: tsum = sum(int(d) for d in num)
        if flag and (tsum % two == 0):
            if flag: hp = [0] * 10
            for d in num:
                if flag: hp[int(d)] += (temp + one - temp)
            if flag: half_len = (len(num) + one) // two
            if flag: fact = [temp + one - temp] * (len(num) + one)
            for i in range(temp + one - temp, len(num) + one):
                if flag: fact[i] = (i * fact[i-one]) % MOD
            if flag: ivft = [pow(f, MOD-two, MOD) for f in fact]
            if flag: dp = [[0] * ((tsum // two) + one) for _ in range(half_len + one)]
            if flag: dp[0][0] = temp + one - temp
            for d in range(10):
                if flag and hp[d]:
                    for k in range(half_len - one, -one, -one):
                        for s in range((tsum // two) - d, -one, -one):
                            if flag and dp[k][s]:
                                for cps in range(one, min(hp[d] + one, half_len - k + one)):
                                    if flag and (s + d * cps <= (tsum // two)):
                                        if flag: dp[k + cps][s + d * cps] = (dp[k + cps][s + d * cps] + dp[k][s] * ((fact[hp[d]] * ivft[cps] % MOD * ivft[hp[d] - cps] % MOD))) % MOD
            if flag: anss = dp[-1][-1]
            if dp[-1][-1]:
                if flag: anss = (anss * fact[half_len] * fact[len(num) - half_len] % MOD * prod(ivft[f] for f in hp if f > 1)) % MOD
            return anss
        else:
            return 0

",1441380184
parallel_stream,parallel_stream,175,3627,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;

    State(int row, int col, int time) {
      this.row = row;
      this.col = col;
      this.time = time;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][] arrivalTime = new int[n][m];
    Arrays.stream(arrivalTime).forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    arrivalTime[0][0] = 0;
    PriorityQueue<State> pq = new PriorityQueue<>();
    pq.offer(new State(0, 0, 0));
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + 1;
            if (newArrivalTime < arrivalTime[newRow][newCol]) {
              arrivalTime[newRow][newCol] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441295264
parallel_stream,parallel_stream,175,3628,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;
    int moveToggle;

    State(int row, int col, int time, int moveToggle) {
      this.row = row;
      this.col = col;
      this.time = time;
      this.moveToggle = moveToggle;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][][] arrivalTime = new int[n][m][2];
    Arrays.stream(arrivalTime)
        .flatMap(Arrays::stream)
        .forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    PriorityQueue<State> pq = new PriorityQueue<>();
    State start = new State(0, 0, 0, 0);
    pq.offer(start);
    arrivalTime[0][0][0] = 0;
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      int moveToggle = current.moveToggle;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col][moveToggle]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveDuration = (moveToggle == 0) ? 1 : 2;
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + moveDuration;
            int newMoveToggle = 1 - moveToggle;
            if (newArrivalTime < arrivalTime[newRow][newCol][newMoveToggle]) {
              arrivalTime[newRow][newCol][newMoveToggle] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime, newMoveToggle));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441374155
parallel_stream,parallel_stream,175,3636,java,"class Solution {
  public boolean isBalanced(String num) {
    int evenSum = 0;
    int oddSum = 0;
    for (int i = 0; i < num.length(); i++) {
      int digit = num.charAt(i) - '0';
      if (i % 2 == 0) {
        evenSum += digit;
      } else {
        oddSum += digit;
      }
    }
    return evenSum == oddSum;
  }
}",1441282265
parallel_stream,parallel_stream,175,3637,java,"class Solution {

  private static final int MOD = 1_000_000_007;

  private long[] fact;
  private long[] invFact;

  public int countBalancedPermutations(String num) {
    int n = num.length();
    int[] count = new int[10];
    long totalSum = 0;
    for (char c : num.toCharArray()) {
      count[c - '0']++;
      totalSum += (c - '0');
    }
    if (totalSum % 2 != 0) {
      return 0;
    }
    long target = totalSum / 2;
    int A = (n + 1) / 2;
    int B = n / 2;
    precomputeFactorials(n);
    long freqFactor = 1;
    for (int d = 0; d <= 9; d++) {
      freqFactor = (freqFactor * fact[count[d]]) % MOD;
    }
    long[][] dp = new long[A + 1][(int) target + 1];
    dp[0][0] = 1;
    for (int d = 0; d <= 9; d++) {
      if (count[d] == 0) {
        continue;
      }
      for (int k = A; k >= 0; k--) {
        for (int s = 0; s <= target; s++) {
          if (dp[k][s] != 0) {
            for (int t = 1; t <= Math.min(count[d], A - k); t++) {
              if (s + (long) t * d > target) {
                break;
              }
              long comb = (fact[count[d]] * invFact[t] % MOD) * invFact[count[d] - t] % MOD;
              dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb) % MOD;
            }
          }
        }
      }
    }
    long iff = powMod(freqFactor, MOD - 2);
    long ans = (fact[A] * fact[B]) % MOD;
    ans = (ans * dp[A][(int) target]) % MOD;
    ans = (ans * iff) % MOD;
    return (int) ans;
  }

  private void precomputeFactorials(int max) {
    fact = new long[max + 1];
    fact[0] = 1;
    for (int i = 1; i <= max; i++) {
      fact[i] = fact[i - 1] * i % MOD;
    }
    invFact = new long[max + 1];
    invFact[max] = powMod(fact[max], MOD - 2);
    for (int i = max - 1; i >= 0; i--) {
      invFact[i] = invFact[i + 1] * (i + 1) % MOD;
    }
  }

  private long powMod(long a, long b) {
    long res = 1;
    a %= MOD;
    while (b > 0) {
      if ((b & 1) != 0) {
        res = res * a % MOD;
      }
      a = a * a % MOD;
      b >>= 1;
    }
    return res;
  }
}",1441331229
Jie Hong Lin,tusov8899,176,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 0, 0)]
        ret = 0
        while pq:
            t, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

                
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + 1, moveTime[i][j] + 1)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, i, j))",1441301835
Jie Hong Lin,tusov8899,176,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 2, 0, 0)]
        ret = 0
        while pq:
            t, prev_cost, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

            next_cost = 2 if prev_cost == 1 else 1
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + next_cost, moveTime[i][j] + next_cost)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, next_cost, i, j))",1441307944
Jie Hong Lin,tusov8899,176,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = sum(int(num[i]) for i in range(n) if i & 1)
        odd = sum(int(num[i]) for i in range(n) if i & 1 == 0)
        return odd == even",1441283976
Jie Hong Lin,tusov8899,176,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def f(on, os, en, es):
            if on == en == 0: return int(os == es)
            i = n - (on + en)
            ret = 0
            if on:
                ret = (ret + f(on - 1, os + A[i], en, es) * on)#  % MOD
            if en:
                ret = (ret + f(on, os, en - 1, es + A[i]) * en)#   % MOD

            return ret
           
        def help(a):
            ret = 1
            while a:
                ret *= a
                a -= 1
            return ret
                
        MOD = 1_000_000_007
        A = list(map(int, list(num)))
        A.sort()
        n = len(A)
        cnt = Counter(A)
        div =1
        for v in cnt.values():
            div *= help(v)
        en = n // 2
        on = en + (n & 1)
        ret = f(on, 0, en, 0)
        # print(ret, div)
        return (ret // div)  % MOD
        ",1441361636
pulkit0707chawla,pulkit0707chawla,177,3627,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<long long>>grid(n+1,vector<long long>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<long long>,vector<vector<long long>>,greater<vector<long long>>>pq;
        pq.push({0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            long long t=v[0],x=v[1],y=v[2];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k],ny=y+dy[k];
                if(nx>=0 and ny>=0 and nx<n and ny<m){
                    long long val=1+t;
                    if(val<1+mat[nx][ny]) val=1+mat[nx][ny];
                    if(grid[nx][ny]>val){
                        grid[nx][ny]=val;
                        pq.push({grid[nx][ny],nx,ny});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441328732
pulkit0707chawla,pulkit0707chawla,177,3628,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<int>>grid(n+1,vector<int>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;
        pq.push({0,0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            int t=v[0],x=v[1],y=v[2],c=v[3];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k];
                int ny=y+dy[k];
                if(nx<n and ny<m and nx>=0 and ny>=0){
                    if(grid[nx][ny]>max(1+c+t,mat[nx][ny]+1+c)){
                        grid[nx][ny]=max(1+c+t,mat[nx][ny]+1+c);
                        pq.push({grid[nx][ny],nx,ny,1-c});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441320388
pulkit0707chawla,pulkit0707chawla,177,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd=0,even=0;
        bool c=0;
        for(auto x:num){
            if(c) odd+=x-'0';
            else even+=x-'0';
            c=!c;
        }
        return odd==even;
    }
};",1441291044
pulkit0707chawla,pulkit0707chawla,177,3637,cpp,"class Solution {
public:
    int mod=1e9+7;
    int countBalancedPermutations(string num) {
        int n=num.size();
        int e=(n+1)/2,o=n/2;
        string s=num;
        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }
        long long sum = 0;
        for(int d = 0; d < 10; d++) {
            sum += (long long)d * cnt[d];
        }
        if(sum%2) return 0;
        long long target = sum / 2;
        int mx=80;
        vector<long long> factorial(mx + 1, 1);
        for(int i = 1; i <= mx; i++) {
            factorial[i] = factorial[i -1] * i % mod;
        }
        vector<long long> inv_fact(mx + 1, 1);
        inv_fact[mx] = power(factorial[mx], mod - 2, mod);
        for(int i = mx -1; i >=0; i--){
            inv_fact[i] = inv_fact[i +1] * (i +1) % mod;
        }
        auto comb = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return factorial[n] * inv_fact[k] % mod * inv_fact[n -k] % mod;
        };
        vector<vector<long long>> dp(e +1, vector<long long>(target +1, 0));
        dp[0][0] =1;

        for(int d =0; d <10; d++) {
            if(cnt[d] ==0) continue;
            for(int t = e; t >=0; t--){
                for(long long s = target; s >=0; s--){
                    if(dp[t][s] ==0) continue;
                    for(int k =1; k <= cnt[d] && t +k <= e && s + (long long)d *k <= target; k++){
                        dp[t +k][s + (long long)d *k] = (dp[t +k][s + (long long)d *k] + dp[t][s] * comb(cnt[d], k)) % mod;
                    }
                }
            }
        }

        string l = num;
        long long valid = dp[e][target];
        long long p =1;
        for(int d =0; d <10; d++) {
            p = p * factorial[cnt[d]] % mod;
        }
        long long ans= valid;
        ans = ans * factorial[e] % mod;
        ans = ans * factorial[o] % mod;
        long long inv_product = power(p, mod -2, mod);
        ans = ans * inv_product % mod;
        return (int)ans;
    }

private:
    long long power(long long base, long long exp, long long mod){
        long long res =1;
        base %= mod;
        while(exp >0){
            if(exp &1) res = res * base % mod;
            base = base * base % mod;
            exp >>=1;
        }
        return res;
    }
};",1441355524
xs_pg,xs_pg,178,3627,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny] + 1, d + 1)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12",1441291533
xs_pg,xs_pg,178,3628,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny], d) + (1 if (nx+ny) % 2 == 1 else 2)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12
        ",1441294433
xs_pg,xs_pg,178,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = 0
        b = 0
        for i in range(0, n, 2):
            a += int(num[i])
            if i + 1 < n:
                b += int(num[i+1])
        return a == b
        ",1441281376
xs_pg,xs_pg,178,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num)
        t = n // 2
        
        d = defaultdict(int)
        S = 0
        for x in num:
            d[int(x)] += 1
            S += int(x)
        if S % 2 == 1:
            return 0
        
        f = [1]
        for i in range(n):
            f.append(f[-1] * (i+1) % mod)
        nf = [pow(x, mod-2, mod) for x in f]
        # print(f, nf)
        
        ks = list(d.keys())
        nk = len(ks)
        # print(ks)
        
        @cache
        def dp(index, cnt, v):
            if index >= nk:
                if cnt == t and v == S//2:
                    return f[t] * f[n-t] % mod
                return 0
            if cnt > t or v > S//2:
                return 0
            ans = 0
            c = d[ks[index]]
            for i in range(c+1):
                ans += nf[i] * nf[c-i] * dp(index+1, cnt+i, v+i*ks[index]) % mod
            return ans % mod
        
        return dp(0, 0, 0)
            ",1441380685
lawrencewxy,lawrencewxy,179,3627,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //newd = Math.abs(A[x][y] - A[x0][y0]);  res, res = Math.max(a[2], res);res
               //  newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));  a[2] PQ
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                newd += 1;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y]});
                }

            }


        }

        return res;
    }
	   



}",1441305509
lawrencewxy,lawrencewxy,179,3628,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            int step = a[3];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //newd = Math.abs(A[x][y] - A[x0][y0]);  res, res = Math.max(a[2], res);res
               //  newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));  a[2] PQ
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                if(step%2 == 0)newd += 1;
                if(step%2 == 1)newd += 2;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y], step + 1});
                }

            }


        }

        return res;
    }
}",1441310354
lawrencewxy,lawrencewxy,179,3636,java,"class Solution {
    public boolean isBalanced(String A) {
        
        int a = 0;
        int b = 0;
        int n = A.length();
        int j = 0;
        for(int i = 0; i < n; i++){
            int x = A.charAt(i)- '0';
            if(i %2 == 0){
                a +=x;
            }
            else{
                b += x;
            }
            
            
            
        }
        
        return a == b;
        
    }
}",1441284898
lawrencewxy,lawrencewxy,179,3637,java,"
class Solution {
 

    int mod = (int)(1e9 + 7);
    public int countBalancedPermutations(String num) {
 
        int n = num.length();
        int[] digitCnt = new int[10];
        int sum = 0;
        for (char ch : num.toCharArray()) {
            int digit = ch - '0';
            digitCnt[digit]++;
            sum += digit;
        }

        if (sum % 2 != 0) {
            return 0;
        }

        int target = sum / 2;
        int evenPos = (n + 1) / 2;
        int oddPos = n / 2;

        long[][][] state = new long[11][target + 1][evenPos + 1];
        state[0][0][0] = 1;

        long[] f = new long[n + 1];
        long[] invF = new long[n + 1];
        f[0] = invF[0] = 1;
        for (int i = 1; i <= n; i++) {
            f[i] = f[i - 1] * i % mod;
            invF[i] = modInverse(f[i]);
        }

        long[][] combs = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            combs[i][0] = combs[i][i] = 1;
            for (int j = 1; j < i; j++) {
                combs[i][j] = (combs[i - 1][j - 1] + combs[i - 1][j]) % mod;
            }
        }

        
        //  
        for (int d = 0; d <= 9; d++) {
            int currentCount = digitCnt[d];
            for (int s = 0; s <= target; s++) {
                for (int c = 0; c <= evenPos; c++) {
                    if (state[d][s][c] == 0) continue;

                    for (int k = 0; k <= currentCount && c + k <= evenPos && s + k * d <= target; k++) {
                        state[d + 1][s + k * d][c + k] = (state[d + 1][s + k * d][c + k] + state[d][s][c] * combs[currentCount][k]) % mod;
                    }
                }
            }
        }

        long finalCount = state[10][target][evenPos];
        if (finalCount == 0) return 0;

        long evenWays = f[evenPos];
        long oddWays = f[oddPos];

        long denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * f[digitCnt[d]] % mod;
        }
        //get the final result
        long res = finalCount * evenWays % mod * oddWays % mod * modInverse(denom) % mod;
        return (int)(res);
    }

    long modInverse(long a) {
        return powMod(a, mod - 2);
    }

    // long powMod(long a, long b, int mod) {
     long powMod(long a, long b){
         long res = 1;
         
         a %= mod; // a  2^31 1969 Minimum Non-Zero Product of the Array Elements    
          
         while(b > 0){
             if(b%2 != 0) { //  if((b&1) == 1){
                 res = (res*a)%mod;
             }
            
             b = b/2;  //  b = b>>1;
             a = (a *a)%mod;
         }
         //System.out.println(""res = "" +res);
         return res;
     }

}",1441374842
Ritik Rathor,ritik_369,180,3627,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441356192
Ritik Rathor,ritik_369,180,3628,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 + (b) ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1+b) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441364305
Ritik Rathor,ritik_369,180,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    array < int , 2 > ar ; 
    ar[0] = ar[1] = 0 ; 
    int i = 0 ; 
    for(auto a : num)
       ar[(i ++ ) & 1] += a - '0' ;       
    return ar[0] == ar[1] ; 
    }
};",1441356045
Ritik Rathor,ritik_369,180,3637,cpp,"const int mod = 1e9 + 7;
string s ; 
int sm , to , n ; 
vector < int > vec , fac , ifac ; 
int dp[10][400][45] ; 
int f(int idx , int cur , int ct)
{
   if(cur > sm)return 0 ; 
   if(ct > to)return 0 ; 
   if(idx == 10)
   {
      return 1ll * (1ll * (cur == sm and ct == to) * 1ll * fac[ct] * fac[n - ct]) % mod ; 
   }
   int  & res = dp[idx][cur][ct] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   for(int i = 0 ; i <= vec[idx] ; i += 1)
   {
      int h = 0 ; 
      h = 1ll * (1ll * h + 1ll * f(idx + 1 , cur + (i * idx) , ct + i)) % mod ; 
      h = 1ll * (1ll * h * ifac[i]) % mod ; 
      h = 1ll * (1ll * h * ifac[vec[idx] - i]) % mod ; 
      res = 1ll * (1ll * res + 1ll * h) % mod ; 
   }
   return res ; 
}
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}


class Solution {
public:
    int countBalancedPermutations(string num)
    {
      if(fac.size() == 0)
      {
         fac = vector < int > (100 , 0) ; 
         ifac = vector < int > (100 , 0) ; 
         fac[0] = 1 ; 
         ifac[0] = binpow(1 , mod-2 , mod) ; 
         for(int i = 1 ; i <= 90 ; i += 1)
         {
            fac[i] = (1ll * fac[i-1] * i) % mod ; 
            ifac[i] = binpow(fac[i] , mod-2 , mod) ; 
         }
      }
      memset(dp , -1 , sizeof(dp)) ; 

      n = num.size() ; 
        vec = vector < int > (10 , 0) ; 
        sm = 0 ; 
        for(auto a : num)
        {
         vec[a - '0'] ++  ; 
         sm += a - '0' ; 
        }
        if(sm & 1)return 0 ; 
        sm /= 2 ;
        to = ((num.size() + 1) / 2) ; 
        return f(0 , 0 , 0) ; 
    }
};",1441369052
CLOWNTK,CLOWNTK,181,3627,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441355375
CLOWNTK,CLOWNTK,181,3628,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+ turn+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441353979
CLOWNTK,CLOWNTK,181,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int tot=0;
        for(int i=0;i<num.size();i++){
            if(i%2){
                tot+= (num[i]-'0');
            }
            else{
                tot-= (num[i]-'0');
            }
        }
        if(tot==0) return 1;
        return 0;
    }
};",1441356632
CLOWNTK,CLOWNTK,181,3637,cpp,"typedef long long ll;
int M= 1e9+7;
ll inv[85], fact[85];
ll dp[85][11][850];

long long power(long long a,long long b){
    if(b<0){
        return 0;
    }
    if(b==0){
        return 1;
    }
    if(abs(a)>=M){
        a= a%M;
    }
    if(a<0){
        a+=M;
    }
    long long  z = power((a*a)%M,b>>1);
    if(b&1){
        z=(z*a)%M;
    }
    return z;
}

class Solution {
public:
    ll solve(int i, int d, int sum, vector<int> &freq, int n, int tot){
        if(sum> (tot/2)){
            return 0;
        }
        if(d> 9){
            if(i!=(n+1)/2) return 0;
            if(sum!= (tot/2)) return 0;
            return 1;
        }
        if(dp[i][d][sum]!=-1){
            return dp[i][d][sum];
        }
        
        ll ans=0;

        for(int f=0;f<=freq[d] && (i+f)<=(n+1)/2;f++){
            ll now= (solve(i+f,d+1,sum+f*d,freq,n,tot)*inv[f])%M;
            now= (now*inv[freq[d]-f])%M;
            ans= (ans+now)%M;
            if(sum+ f*d> (tot/2)) break;
        }

        return dp[i][d][sum]= ans;
        
    }
    int countBalancedPermutations(string num) {
        fact[0]= inv[0]=1;

        for(int i=1;i<=84;i++){
            fact[i]= (i*fact[i-1])%M;
            inv[i]= power(fact[i], M-2);
        }

        int n= num.size();
        vector<int> freq(10);
        int tot=0;
        for(auto x: num){
            freq[x-'0']++;
            tot+= (x-'0');
        }
 
        if(tot%2) return 0;
        for(int i=0;i<=n;i++){
            for(int j=0;j<=9;j++){
                for(int sum=0;sum<=tot;sum++){
                    dp[i][j][sum]=-1;
                }
            }
        }
        
        ll now= (fact[n/2]*fact[(n+1)/2])%M;
        return (solve(0,0,0,freq,n,tot)*now)%M;
    }
};",1441340805
a_k,a0518,182,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+1
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc))
        
                
            ",1441287203
a_k,a0518,182,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c, x = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+(1 if x == 0 else 2)
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc,x^1))
        
                
            ",1441289199
a_k,a0518,182,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = b = 0
        for i in range(len(num)):
            if i%2:
                a+=int(num[i])
            else: b+=int(num[i])
        return a==b",1441280894
a_k,a0518,182,3637,python3,"from collections import Counter
from functools import cache

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9+7
        n = len(num)
        mp = Counter(num)

        tot = sum(int(d) for d in num)
        if tot % 2 != 0:  
            return 0

        fac = [1] * (n + 1)
        for i in range(1, n + 1):
            fac[i] = (fac[i - 1] * i) % mod

        def mod_inverse(v, p):
            return pow(v, p - 2, p)

        t = tot // 2

        dp = [[[0] * (n // 2 + 1) for _ in range(t + 1)] for _ in range(n + 1)]
        dp[0][0][0] = 1 

        for i in range(1, n + 1):
            digit = int(num[i - 1])
            for cur in range(t + 1):
                for cnt in range(n // 2 + 1):
                    if dp[i - 1][cur][cnt] > 0:
                        if cur + digit <= t and cnt + 1 <= n // 2:
                            dp[i][cur + digit][cnt + 1] = (dp[i][cur + digit][cnt + 1] + dp[i - 1][cur][cnt]) % mod
                        dp[i][cur][cnt] = (dp[i][cur][cnt] + dp[i - 1][cur][cnt]) % mod

        a = dp[n][t][n // 2] * fac[n // 2] % mod 
        b = fac[n - n // 2] 
        res = (a * b) % mod

        for v in mp.values():
            res = (res * mod_inverse(fac[v], mod)) % mod

        return res
",1441350922
Nat,4nIlUcEGTM,185,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (int[] dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
}",1441359050
Nat,4nIlUcEGTM,185,3628,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        d[0][0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) {
            vector<int> current = pq.top();
            pq.pop();

            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (auto dir : directions) {
                int ni = i + dir.first;
                int nj = j + dir.second;

                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};

",1441361470
Nat,4nIlUcEGTM,185,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        # Iterate through each digit and accumulate sums based on index parity
        for i, digit in enumerate(num):
            if i % 2 == 0:  # even index
                even_sum += int(digit)
            else:           # odd index
                odd_sum += int(digit)
        
        # Check if the sums are equal
        return even_sum == odd_sum
",1441313791
Nat,4nIlUcEGTM,185,3637,rust,"impl Solution {
    const MOD: i64 = 1_000_000_007;

    pub fn count_balanced_permutations(num: String) -> i32 {
        let length = num.len();
        let total_sum: i32 = num.chars().map(|c| c.to_digit(10).unwrap() as i32).sum();

        // Count occurrences of each digit
        let mut counts = vec![0; 10];
        for digit in num.chars() {
            counts[digit.to_digit(10).unwrap() as usize] += 1;
        }

        // If the total sum is odd, it's impossible to divide it into two equal parts
        if total_sum % 2 != 0 {
            return 0;
        }

        let half_sum = total_sum / 2;
        let m = (length + 1) / 2;

        // Factorial and inverse factorial arrays
        let mut factorial = vec![1i64; length + 1];
        for i in 1..=length {
            factorial[i] = factorial[i - 1] * i as i64 % Self::MOD;
        }

        let mut inv_factorial = vec![1i64; length + 1];
        inv_factorial[length] = Self::mod_inverse(factorial[length], Self::MOD);
        for i in (0..length).rev() {
            inv_factorial[i] = inv_factorial[i + 1] * (i as i64 + 1) % Self::MOD;
        }

        // DP table for counting balanced subsets
        let mut dp = vec![vec![0i64; (half_sum + 1) as usize]; m + 1];
        dp[0][0] = 1;

        for d in 0..10 {
            if counts[d] == 0 {
                continue;
            }

            for k in (0..=m).rev() {
                for s in (0..=half_sum as usize).rev() {
                    if dp[k][s] == 0 {
                        continue;
                    }

                    for t in 1..=counts[d] {
                        if k + t > m || s + (d * t) > half_sum as usize {
                            break;
                        }
                        let new_k = k + t;
                        let new_s = s + (d * t);
                        dp[new_k][new_s] = (dp[new_k][new_s] + dp[k][s] * Self::comb(counts[d], t, &factorial, &inv_factorial, Self::MOD)) % Self::MOD;
                    }
                }
            }
        }

        let w = dp[m][half_sum as usize];
        let mut result = factorial[m] * factorial[length - m] % Self::MOD;

        for d in 0..10 {
            result = result * inv_factorial[counts[d]] % Self::MOD;
        }

        result = result * w % Self::MOD;
        result as i32
    }

    fn mod_inverse(a: i64, m: i64) -> i64 {
        let mut result = 1;
        let mut base = a;
        let mut p = m - 2;

        while p > 0 {
            if p & 1 == 1 {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        result
    }

    fn comb(n: usize, k: usize, factorial: &[i64], inv_factorial: &[i64], m: i64) -> i64 {
        if k > n {
            return 0;
        }
        factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m
    }
}
",1441382752
EthanZyh,EthanZyh,186,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[int(1e10) for j in range(m)] for i in range(n)]
        f[0][0]=0
        q = [(0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y = heapq.heappop(q)
            d[(x,y)] = True
            if x==n-1 and y==m-1:
                return f[x][y]
            if x<n-1:
                t = max(f[x][y], moveTime[x+1][y])+1
                if t<f[x+1][y] and (x+1,y) not in d:
                    f[x+1][y]=t
                    heapq.heappush(q, (t,x+1,y))
            
            if x>=1:
                t = max(f[x][y], moveTime[x-1][y])+1
                if t<f[x-1][y] and (x-1,y) not in d:
                    f[x-1][y]=t
                    heapq.heappush(q, (t,x-1,y))
            
            if y<m-1:
                t = max(f[x][y], moveTime[x][y+1])+1
                if t<f[x][y+1] and (x,y+1) not in d:
                    f[x][y+1]=t
                    heapq.heappush(q, (t,x,y+1))
            
            if y>=1:
                t = max(f[x][y], moveTime[x][y-1])+1
                if t<f[x][y-1] and (x,y-1) not in d:
                    f[x][y-1]=t
                    heapq.heappush(q, (t,x,y-1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441307882
EthanZyh,EthanZyh,186,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[[int(1e10), int(1e10)] for j in range(m)] for i in range(n)]
        f[0][0][0]=0
        q = [(0,0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y,z = heapq.heappop(q)
            d[(x,y,z)] = True
            if x==n-1 and y==m-1:
                return f[x][y][z]
            if x<n-1:
                t = max(f[x][y][z], moveTime[x+1][y])+(z+1)
                if t<f[x+1][y][z^1] and (x+1,y,z^1) not in d:
                    f[x+1][y][z^1]=t
                    heapq.heappush(q, (t,x+1,y,z^1))
            
            if x>=1:
                t = max(f[x][y][z], moveTime[x-1][y])+(z+1)
                if t<f[x-1][y][z^1] and (x-1,y,z^1) not in d:
                    f[x-1][y][z^1]=t
                    heapq.heappush(q, (t,x-1,y,z^1))
            
            if y<m-1:
                t = max(f[x][y][z], moveTime[x][y+1])+(z+1)
                if t<f[x][y+1][z^1] and (x,y+1,z^1) not in d:
                    f[x][y+1][z^1]=t
                    heapq.heappush(q, (t,x,y+1,z^1))
            
            if y>=1:
                t = max(f[x][y][z], moveTime[x][y-1])+(z+1)
                if t<f[x][y-1][z^1] and (x,y-1,z^1) not in d:
                    f[x][y-1][z^1]=t
                    heapq.heappush(q, (t,x,y-1,z^1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441315726
EthanZyh,EthanZyh,186,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s = sum([int(num[i]) for i in range(len(num)) if i %2==0])
        t = sum([int(num[i]) for i in range(len(num)) if i %2==1])
        return s==t
        ",1441284111
EthanZyh,EthanZyh,186,3637,python,"class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        P = int(1e9+7)
        def Pow(a, b):
            ans = 1
            while b:
                if b%2==1:
                    ans = ans*a%P
                a = a*a%P
                b //= 2
            return ans
        ton = [0 for i in range(10)]
        n = len(num)
        num_list = [int(a) for a in num]
        S = sum(num_list)
        if S%2==1:
            return 0
        target = S//2
        for a in num:
            ton[int(a)] += 1
        N = 100
        fac = [0 for i in range(N)]
        ifac = [0 for i in range(N)]
        fac[0] = 1
        for i in range(1,N):
            fac[i]=fac[i-1]*i%P
        ifac[N-1] = Pow(fac[N-1], P-2)
        for i in range(N-2, -1, -1):
            ifac[i] = ifac[i+1] * (i+1) %P
        def C(n ,m):
            ans = (fac[n]*ifac[m]%P)*ifac[n-m]%P
            return ans
        f = [[[0 for k in range(target+1)] for j in range(n//2+1)] for i in range(11)]
        f[0][0][0] = 1
        used_pos = 0
        for i in range(10):
            for j in range(n//2+1):
                for k in range(target+1):
                    now = f[i][j][k]
                    if now==0:
                        continue
                    for l in range(ton[i]+1):
                        newK = k + l * i
                        newJ = j + l
                        if newK>target or newJ>n//2:
                            continue
                        f[i+1][newJ][newK] = (f[i+1][newJ][newK]+(now*C(n//2-j,l)%P)* \
                                              C(n-n//2-(used_pos-j),ton[i]-l))%P
            used_pos += ton[i]
        return f[10][n//2][target]
        ",1441358062
Vladislav,timetoai,189,3627,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0)]
        while h:
            t, i, j = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1
                    if (ni, nj) not in mem or mem[ni, nj] > nt:
                        mem[ni, nj] = nt
                        heappush(h, (nt, ni, nj))

        ",1441298463
Vladislav,timetoai,189,3628,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0, 0)]
        while h:
            t, i, j, add = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j, add] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1 + add
                    nadd = add ^ 1
                    if (ni, nj, nadd) not in mem or mem[ni, nj, nadd] > nt:
                        mem[ni, nj, nadd] = nt
                        heappush(h, (nt, ni, nj, nadd))

        ",1441302001
Vladislav,timetoai,189,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(1, len(num), 2)) == sum(int(num[i]) for i in range(0, len(num), 2))",1441280875
Vladislav,timetoai,189,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        cnt = [0] * 10
        for n in num:
            cnt[int(n)] += 1
        base = factorial(len(num) // 2) * factorial(len(num) - len(num) // 2)

        @cache
        def go(i, left, bal):
            if left == 0:
                if bal - sum(j * cnt[j] for j in range(i, 10)) == 0:
                    ret = base
                    for j in range(i, 10):
                        ret //= factorial(cnt[j])
                    return ret
                else:
                    return 0
            if i == 10:
                return 0
            if cnt[i] == 0:
                return go(i + 1, left, bal)
            res = 0
            for cur in range(0, min(left, cnt[i]) + 1):
                res += go(
                    i + 1, 
                    left - cur, 
                    bal + (2 * cur - cnt[i]) * i
                ) // factorial(cnt[i] - cur) // factorial(cur)
            return res

        return go(0, len(num) // 2, 0) % mod if sum(digit * cnt[digit] for digit in range(10)) % 2 == 0 else 0
        ",1441341525
Superultra,Superultra,191,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + 1;
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441360320
Superultra,Superultra,191,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + (p + 1);
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441359927
Superultra,Superultra,191,3636,cpp,"class Solution {
public:
    bool isBalanced(string S) {
        int e = 0, o = 0;
        for (int i = 0; i < S.size(); i++){
            if (i % 2 == 0)
                e += S[i] - '0';
            else
                o += S[i] - '0';
        }
        return e == o;
    }
};",1441361327
Superultra,Superultra,191,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int md = 1e9 + 7;

struct mint{
    int v;
    mint() : v(0) {}
    mint(ll v_) : v(int(v_ % md)){ if (v < 0) v += md; }
    explicit operator int() const{ return v; }
    friend std::ostream& operator << (std::ostream& out, const mint& n){ return out << int(n); }
    friend std::istream& operator >> (std::istream& in, mint& n){ ll v_; in >> v_; n = mint(v_); return in; }
 
    friend bool operator == (const mint& a, const mint& b){ return a.v == b.v; }
    friend bool operator != (const mint& a, const mint& b){ return a.v != b.v; }
    friend bool operator < (const mint& a, const mint& b){ return a.v < b.v; }
    friend bool operator <= (const mint& a, const mint& b){ return a.v <= b.v; }
    friend bool operator > (const mint& a, const mint& b){ return a.v > b.v; }
    friend bool operator >= (const mint& a, const mint& b){ return a.v >= b.v; }

    mint& operator += (const mint& o){ ((v += o.v) >= md) ? v -= md : 0; return *this; }
    mint& operator -= (const mint& o){ ((v -= o.v) < 0) ? v += md : 0; return *this; }
    mint& operator *= (const mint& o){ v = int((ll)v * o.v % md); return *this; }
    mint& operator /= (const mint& o){ return (*this) *= inv(o); }

    mint operator - () const{ return mint(-v); }
    friend mint operator + (mint a, const mint& b){ return a += b; }
    friend mint operator - (mint a, const mint& b){ return a -= b; }
    friend mint operator * (mint a, const mint& b){ return a *= b; }
    friend mint operator / (mint a, const mint& b){ return a /= b; }

    friend mint pow(mint a, ll p){ return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);	}
    friend mint inv(const mint& a){ return pow(a, md - 2); }
};

class Solution {
public:
    int countBalancedPermutations(string A) {
        vector<int> cnt(10, 0);
        int sum = 0;

        for (char c : A){
            cnt[c - '0']++;
            sum += (c - '0');
        }

        if (sum % 2){
            return 0;
        }

        int n = A.size();
        int targSz = n / 2;
        int targSum = sum / 2;

        mint dp[10][targSz + 5][targSum + 5];
        for (int i = 0; i < 10; i++)
            for (int j = 0; j <= targSz; j++)
                for (int k = 0; k <= targSum; k++)
                    dp[i][j][k] = 0;

        mint F[n + 5];
        F[0] = 1;

        for (int i = 1; i <= n; i++)
            F[i] = F[i - 1] * i;
        
        mint inv[n + 1][n + 1];
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= n; j++)
                inv[i][j] = 1 / (F[i] * F[j]);

        for (int i = 0; i < 10; i++){
            int mxSz = 0, mxSum = 0;
            for (int j = 0; j <= i; j++){
                mxSz += cnt[j];
                mxSum += cnt[j] * j;
            }
            for (int sz = 0; sz <= min(targSz, mxSz); sz++){
                for (int sum = 0; sum <= min(targSum, mxSum); sum++){
                    auto &cur = dp[i][sz][sum];
                    // Base
                    if (!i){
                        if (sum == 0 and sz <= cnt[i]){
                            cur = F[targSz] * F[n - targSz] / (F[sz] * F[(cnt[i] - sz)]);
                        }
                        // cout << i << "" "" << sz << "" "" << sum << "": "" << cur << endl;
                        // cout << F[targSz] << "" "" << 
                        continue;
                    }
                    for (int take = 0; take <= min(sz, cnt[i]) and sum - take * i >= 0; take++){
                        auto &temp = dp[i - 1][sz - take][sum - take * i];
                        cur += temp * inv[take][cnt[i] - take];
                    }
                }
            }
        }
        return dp[9][targSz][targSum].v;
    }
};
",1441341620
Reversal,ReversalGM,192,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0)]
        visited = set()
        while min_heap:
            cur_time, i, j = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j) in visited:
                continue
            visited.add((i, j))
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:
                    heapq.heappush(min_heap, (max(cur_time + 1, moveTime[new_i][new_j] + 1), new_i, new_j))
        return -1
                
                    
                    ",1441301107
Reversal,ReversalGM,192,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0, 1)]
        visited = set()
        while min_heap:
            cur_time, i, j, next_move_cost = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j, next_move_cost) in visited:
                continue
            visited.add((i, j, next_move_cost))
            new_next_move_cost = 2 if next_move_cost == 1 else 1
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n:
                    if new_next_move_cost == 2:
                        if (new_i, new_j, 1) not in visited and (new_i, new_j, 2) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
                    else:
                        if (new_i, new_j, 1) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
        return -1
                
                    
                    ",1441313629
Reversal,ReversalGM,192,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for idx, val in enumerate(num):
            if idx % 2 == 0:
                even_sum += int(val)
            else:
                odd_sum += int(val)
        return even_sum == odd_sum",1441282216
Reversal,ReversalGM,192,3637,python3,"class Solution:
    # even - odd
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10 ** 9 + 7
        required_evens = math.ceil(n / 2)
        required_odds = n - required_evens
        prev_ways = collections.Counter([(0, 0)])

        global_counter = collections.Counter([int(char) for char in num])

        picked_items = 0
        for val, val_count in global_counter.items():
            new_ways = collections.Counter()
            for (perm_sum, perm_even_count), perm_ways in prev_ways.items():
                for chosen_evens in range(val_count + 1):
                    chosen_odds = val_count - chosen_evens
                    new_perm_sum = perm_sum + ((chosen_evens - chosen_odds) * val)

                    even_spots_remaining = required_evens - perm_even_count
                    odd_spots_remaining = required_odds - (picked_items - perm_even_count)
                    
                    even_ways = math.comb(even_spots_remaining, chosen_evens) if even_spots_remaining > 0 else 1
                    odd_ways = math.comb(odd_spots_remaining, chosen_odds) if odd_spots_remaining > 0 else 1
                    if even_spots_remaining < chosen_evens:
                        break
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] += even_ways * odd_ways * perm_ways
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] = new_ways[(new_perm_sum, perm_even_count + chosen_evens)] % MOD
                    
            picked_items += val_count
            prev_ways = new_ways
        return prev_ways[(0, required_evens)]
                
            ",1441367686
robezh765,robezh765,193,3627,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 1);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};",1441297593
robezh765,robezh765,193,3628,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 2);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};
",1441296978
robezh765,robezh765,193,3636,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;

class Solution {
public:
    bool isBalanced(string num) {
        int s = 1;
        int sum = 0;
        for (char c : num) {
            sum += s * int(c - '0');
            s *= -1;
        }
        return sum == 0;
    }
};
",1441281118
robezh765,robezh765,193,3637,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;


const int MOD = (int)1e9 + 7;

struct mi {
    typedef decay<decltype(MOD)>::type T;
    /// don't silently convert to T
    T v; explicit operator T() const { return v; }
    mi() { v = 0; }
    mi(ll _v) {
        v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;
        if (v < 0) v += MOD;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
//    friend void re(mi& a) { ll x; re(x); a = mi(x); }
//    friend str ts(mi a) { return ts(a.v); }

    mi& operator+=(const mi& m) {
        if ((v += m.v) >= MOD) v -= MOD;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += MOD;
        return *this; }
    mi& operator*=(const mi& m) {
        v = (ll)v*m.v%MOD; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, ll p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,MOD-2); }

    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
};


mt19937 rng(2333);
const int S = 400 * 2 + 1, M = 400;
mi rdp[2][41][S];

class Solution {
public:
    int countBalancedPermutations(string num) {
        int c0 = (sz(num) + 1) / 2, c1 = sz(num) - c0;
//        cout << sz(num) << endl;

        int nw = 1, la = 0;
        memset(rdp, 0, sizeof rdp);
//        vector<vector<vector<mi>>> dp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
        rdp[nw][0][M] = 1;
        vi cnt(10);

        int sum = 0;
        shuffle(all(num), rng);
        for (char c : num) {
            swap(nw, la);
            int x = c - '0';
            cnt[x]++;
            auto &ndp = rdp[nw];
            auto &dp = rdp[la];
            memset(rdp[nw], 0, sizeof rdp[nw]);
//            vector<vector<vector<mi>>> ndp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
            rep(i, 0, c0 + 1) {
                rep(s, 0, S) {
                    if (s + x < S && i + 1 < c0 + 1) ndp[i + 1][s + x] += (i + 1) * dp[i][s];
                    if (s - x >= 0) ndp[i][s - x] += (sum - i + 1) * dp[i][s];
                }
            }
            sum += 1;

//            dp = ndp;
        }
        mi res = rdp[nw][c0][M];
//        return int(res);
        rep(i, 0, 10) {
            rep(j, 1, cnt[i] + 1) res /= j;
        }
        return int(res);
    }
};

",1441329938
Anshuman Tripathi,anshumantripathi878,194,3627,cpp,"class Solution {
public:
    int solve(vector<vector<int>>& moveTime) {
    int xxxx = moveTime.size(), yyyy = moveTime[0].size();
    vector<vector<int>> zzzz(xxxx, vector<int>(yyyy, INT_MAX));
    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

    zzzz[0][0] = 0;
    pq.push({0, 0, 0}); // (time, row, col)
    
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    while (!pq.empty()) {
        auto [timeNow, xx, yy] = pq.top();
        pq.pop();

        if (xx == xxxx - 1 && yy == yyyy - 1) return timeNow;
        
        for (auto& dir : directions) {
            int nx = xx + dir[0], ny = yy + dir[1];
            if (nx >= 0 && ny >= 0 && nx < xxxx && ny < yyyy) {
                int timeNext = max(timeNow + 1, moveTime[nx][ny] + 1);
                if (timeNext < zzzz[nx][ny]) {
                    zzzz[nx][ny] = timeNext;
                    pq.push({timeNext, nx, ny});
                }
            }
        }
    }
    
    return zzzz[xxxx - 1][yyyy - 1];
}

int minTimeToReach(vector<vector<int>>& moveTime) {
    return solve(moveTime);
}
};",1441308314
Anshuman Tripathi,anshumantripathi878,194,3628,python3,"import heapq
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        xxxx = len(moveTime)
        yyy = len(moveTime[0])
        
        zzzz = [[[float('inf')] * 2 for _ in range(yyy)] for _ in range(xxxx)]
        zzzz[0][0][0] = 0
        
        pq = []
        heapq.heappush(pq, (0, (0, 0, 0)))
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            
            if t > zzzz[i][j][p]:
                continue
            
            for di, dj in directions:
                ni = i + di
                nj = j + dj
                
                if 0 <= ni < xxxx and 0 <= nj < yyy:
                    nt = max(t, moveTime[ni][nj]) + (2 if p else 1)
                    
                    if nt < zzzz[ni][nj][1 - p]:
                        zzzz[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))
        
        return min(zzzz[xxxx - 1][yyy - 1][0], zzzz[xxxx - 1][yyy - 1][1])
",1441336487
Anshuman Tripathi,anshumantripathi878,194,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
         int evenSum = 0, oddSum = 0;
    for (int i = 0; i < num.size(); ++i) {
        if (i % 2 == 0)
            evenSum += num[i] - '0';
        else
            oddSum += num[i] - '0';
    }
    return evenSum == oddSum;
    }
};",1441287216
Anshuman Tripathi,anshumantripathi878,194,3637,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;
    typedef long long ll;

    // Function to compute power modulo
    long long zzzzz(long long aaaaa, long long bbbbb, long long ccccc) {
        long long ddddd = 1;
        while (bbbbb > 0) {
            if (bbbbb % 2 == 1) {
                ddddd = (ddddd * aaaaa) % ccccc;
            }
            aaaaa = (aaaaa * aaaaa) % ccccc;
            bbbbb /= 2;
        }
        return ddddd;
    }

    void eeeee(vector<long long>& fffff, vector<long long>& ggggg, int hhhhh) {
        fffff.resize(hhhhh + 1, 1);
        for (int iiiii = 1; iiiii <= hhhhh; ++iiiii) {  // Changed `iiii` to `iiiii`
            fffff[iiiii] = fffff[iiiii - 1] * iiiii % MOD; // Use `iiiii` here
        }
        ggggg.resize(hhhhh + 1, 1);
        ggggg[hhhhh] = zzzzz(fffff[hhhhh], MOD - 2, MOD);
        for (int jjjjj = hhhhh - 1; jjjjj >= 0; --jjjjj) {
            ggggg[jjjjj] = ggggg[jjjjj + 1] * (jjjjj + 1) % MOD;
        }
    }

    // Function to compute the number of balanced permutations
    int countBalancedPermutations(string num) {
        int kkkkk = num.length();
        int lllll[10] = {0};
        ll mmmmm = 0;

        for (char nnnnn : num) {
            lllll[nnnnn - '0']++;
            mmmmm += (nnnnn - '0');
        }

        if (mmmmm % 2 != 0) {
            return 0;
        }

        ll ooooo = mmmmm / 2;
        int ppppp = (kkkkk + 1) / 2;

        vector<ll> qqqqq, rrrrr;
        eeeee(qqqqq, rrrrr, kkkkk);

        vector<vector<ll>> sssss(ppppp + 1, vector<ll>(ooooo + 1, 0));
        sssss[0][0] = 1;

        for (int ttttt = 0; ttttt < 10; ++ttttt) {
            int uuuuu = lllll[ttttt];
            vector<vector<ll>> vvvvv(ppppp + 1, vector<ll>(ooooo + 1, 0));
            for (int wwwww = 0; wwwww <= ppppp; ++wwwww) {
                for (ll xxxxx = 0; xxxxx <= ooooo; ++xxxxx) {
                    if (sssss[wwwww][xxxxx] == 0) continue;
                    int yyyyy = min(uuuuu, ppppp - wwwww);
                    for (int zzzzz = 0; zzzzz <= yyyyy; ++zzzzz) {
                        ll aaaaa = wwwww + zzzzz;
                        ll bbbbb = xxxxx + (ll)ttttt * zzzzz;
                        if (bbbbb > ooooo) continue;
                        vvvvv[aaaaa][bbbbb] = (vvvvv[aaaaa][bbbbb] + sssss[wwwww][xxxxx] * rrrrr[zzzzz] % MOD * rrrrr[uuuuu - zzzzz] % MOD) % MOD;
                    }
                }
            }
            sssss = vvvvv;
        }

        ll ccccc = sssss[ppppp][ooooo];

        ll ddddd = qqqqq[ppppp] * qqqqq[kkkkk - ppppp] % MOD;
        ddddd = ddddd * ccccc % MOD;

        return (int)ddddd;
    }
};
",1441375431
xlx2,xlx2,195,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        h = [(0, 0, 0)]
        f[0][0] = 0
        while h:
            t, i, j = heapq.heappop(h)
            if f[i][j] != t:
                continue
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + 1
                    if x < f[a][b]:
                        f[a][b] = x
                        heapq.heappush(h, (x, a, b))
        return f[-1][-1]",1441314344
xlx2,xlx2,195,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        vis = [[[0,0] for _ in range(n)] for _ in range(m)]
        h = [(0, 0, 0, 0)]
        f[0][0] = 0
        # vis[0][0][0] = 1
        while h:
            t, i, j, k = heapq.heappop(h)
            if vis[i][j][k]:
                continue
            vis[i][j][k] = 1
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + k+1
                    if vis[a][b][k^1] == 0:
                        if x < f[a][b]:
                            f[a][b] = x
                        heapq.heappush(h, (x, a, b, k^1))
        return f[-1][-1]",1441314113
xlx2,xlx2,195,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        s = sum(int(x) for x in num)
        s2 = sum(int(x) for x in num[::2])
        return s == 2 * s2",1441314562
xlx2,xlx2,195,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(x) for x in num) % 2:
            return 0

        M = 10**9 + 7
        n = len(num)
        p, q = (n+1)//2, n//2
        r = sum(int(v) for v in num) // 2
        c = [0] * 10
        for v in num:
            c[int(v)] += 1
        
        d = defaultdict(int)
        d[(0, 0, 0, 0)] = 1
        for i,v in enumerate(c):
            g = defaultdict(int)
            for j in range(v+1):
                for a,s,b,t in d:
                    if a+j <= p and b+v-j <= q and s+j*i <= r and t+(v-j)*i <= r:
                        x = d[(a,s,b,t)] * math.comb(a+j, j) * math.comb(b+v-j, v-j) % M
                        g[(a+j, s+j*i, b+v-j, t+(v-j)*i)] += x
            d = g
        
        return d[(p, r, q, r)] % M
",1441375631
Abhinav Nagar,abhinav_2696,197,3627,java,"class Solution {
    public int minTimeToReach(int[][] mt) {
        int r = mt.length;
        int c = mt[0].length;
        
        int[][] d = fn2(r, c);
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        fn3(pq, d);
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] t = pq.poll();
            int ct = t[0], cr = t[1], cc = t[2];
            
            if (ct > d[cr][cc]) continue;
            
            fn4(pq, mt, d, dirs, ct, cr, cc, r, c);
        }
        
        return d[r - 1][c - 1];
    }
    void fn3(PriorityQueue<int[]> pq, int[][] d) {
        pq.offer(new int[]{0, 0, 0});
        d[0][0] = 0;
    }
    int[][] fn2(int r, int c) {
        int[][] d = new int[r][c];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                d[i][j] = Integer.MAX_VALUE;
            }
        }
        return d;
    }
    void fn4(PriorityQueue<int[]> pq, int[][] mt, int[][] d, int[][] dirs, int ct, int cr, int cc, int r, int c) {
        for (int[] dir : dirs) {
            int nr = cr + dir[0];
            int nc = cc + dir[1];
            
            if (nr >= 0 && nr < r && nc >= 0 && nc < c) {
                int nt = Math.max(ct, mt[nr][nc]) + 1;
                
                if (nt < d[nr][nc]) {
                    d[nr][nc] = nt;
                    pq.offer(new int[]{nt, nr, nc});
                }
            }
        }
    }
}",1441336597
Abhinav Nagar,abhinav_2696,197,3628,java,"class Solution {
    int fn3(int[][] mt) {
        return mt[0].length;
    }
    boolean fn6(int nr, int nc, int r, int c) {
        return nr >= 0 && nr < r && nc >= 0 && nc < c;
    }
    public int minTimeToReach(int[][] mt) {
        int r = fn2(mt), c = fn3(mt);
        int[][][] mtm = fn4(r, c);
        mtm[0][0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.add(new int[]{0, 0, 0, 0});
        
        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ct = cur[0], rw = cur[1], cl = cur[2], pr = cur[3];
            
            if (ct > mtm[rw][cl][pr]) continue;
            
            fn5(pq, dir, mt, mtm, ct, rw, cl, pr, r, c);
        }
        
        return Math.min(mtm[r - 1][c - 1][0], mtm[r - 1][c - 1][1]);
    }
    void fn5(PriorityQueue<int[]> pq, int[][] dir, int[][] mt, int[][][] mtm, int ct, int rw, int cl, int pr, int r, int c) {
        for (int[] d : dir) {
            int nr = rw + d[0], nc = cl + d[1];
            
            if (fn6(nr, nc, r, c)) {
                int nt = Math.max(ct, mt[nr][nc]) + (pr == 1 ? 2 : 1);
                
                if (nt < mtm[nr][nc][1 - pr]) {
                    mtm[nr][nc][1 - pr] = nt;
                    pq.add(new int[]{nt, nr, nc, 1 - pr});
                }
            }
        }
    }
    int fn2(int[][] mt) {
        return mt.length;
    }
    int[][][] fn4(int r, int c) {
        int[][][] mtm = new int[r][c][2];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                mtm[i][j][0] = Integer.MAX_VALUE;
                mtm[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return mtm;
    }
}",1441345445
Abhinav Nagar,abhinav_2696,197,3636,python3,"class Solution:
    def fn4(self, es, os):
        return es == os
        
    def fn3(self, i):
        return i % 2 == 0
        
    def fn2(self, c):
        return int(c) - 0
    
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            d = self.fn2(num[i])
            if self.fn3(i):
                es += d
            else:
                os += d
        return self.fn4(es, os)",1441305485
Abhinav Nagar,abhinav_2696,197,3637,python3,"MOD = int(1e9 + 7)

class Solution:
    def fn3(self, dp, fq, fact, inv_fact, m, tgt):
        for d in range(10):
            if fq[d] == 0:
                continue
            for j in range(m, -1, -1):
                for k in range(tgt, -1, -1):
                    if dp[j][k] == 0:
                        continue
                    for c in range(1, min(fq[d], m - j) + 1):
                        if k + d * c > tgt:
                            break
                        cmb = fact[fq[d]] * inv_fact[c] % MOD * inv_fact[fq[d] - c] % MOD
                        dp[j + c][k + d * c] = (dp[j + c][k + d * c] + dp[j][k] * cmb) % MOD

    def fn2(self, a, b):
        res = 1
        a %= MOD
        while b > 0:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
        
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        m = (n + 1) // 2
        l = n // 2
        fq = [0] * 10
        for c in num:
            fq[ord(c) - ord('0')] += 1
        s = sum(d * fq[d] for d in range(10))
        if s % 2 == 1:
            return 0
        tgt = s // 2
        fact = [1] * (n + 1)
        inv_fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i % MOD
        inv_fact[n] = self.fn2(fact[n], MOD - 2)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        dp = [[0] * (tgt + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        self.fn3(dp, fq, fact, inv_fact, m, tgt)
        dp_val = dp[m][tgt]
        if dp_val == 0:
            return 0
        ans = self.fn4(dp_val, fact, inv_fact, fq, m, l)
        return ans
    
    def fn4(self, dp_val, fact, inv_fact, fq, m, l):
        fact_m = fact[m]
        fact_l = fact[l]
        fact_fq = 1
        for d in range(10):
            fact_fq = fact_fq * fact[fq[d]] % MOD
        inv_fact_fq = self.fn2(fact_fq, MOD - 2)
        ans = dp_val * fact_m % MOD * fact_l % MOD * inv_fact_fq % MOD
        return ans
",1441388024
Orz,retired_kid,198,3627,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], 1<<30);
        }
        dp[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[] {0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]] > Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1) {
                    dp[c[0] + dr[i]][c[1] + dc[i]] = Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i]});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441294378
Orz,retired_kid,198,3628,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][][] dp = new int[n + 1][m + 1][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                Arrays.fill(dp[i][j], 1<<30);
            }
        }
        dp[0][0][0] = 0;
        PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(v -> v[3]));
        q.add(new int[] {0, 0, 0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            int k = c[2];
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] >
                        Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k) {
                    dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] = Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i], k ^ 1, dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1]});
                }
            }
        }
        return Arrays.stream(dp[n - 1][m - 1]).min().getAsInt();
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441299893
Orz,retired_kid,198,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length(), e = 0, o = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) e+=num.charAt(i)-'0';
            else o+=num.charAt(i)-'0';
        }
        return e == o;
    }
}",1441281401
Orz,retired_kid,198,3637,java,"class Solution {
    static long[] inv, f;
    static boolean init = false;
    static int mod = (int) 1e9 + 7, MM = 10;
    Map<Integer, Integer>[][] dp;
    Map<Integer, Integer> cnt = new HashMap<>();
    public int countBalancedPermutations(String num) {
        if (!init) {
            fc();
        }
        int n = num.length();
        dp = new Map[MM][n + 1];
        for (int i = 0; i < MM; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = new HashMap<>();
            }
        }
        for (int i = 0; i < n; i++) {
            int v = num.charAt(i) - '0';
            cnt.put(v, cnt.getOrDefault(v, 0) + 1);
        }
        return dfs(0, n / 2, 0, n);
    }
    public int dfs(int d, int even, int s, int n) {
        // System.out.println(even + "" "" + d);
        if (d == MM) return s == 0 && even == 0 ? 1 : 0;
        else if (dp[d][even].containsKey(s)) return dp[d][even].get(s);
        long ret = 0;
        int ct = cnt.getOrDefault(d, 0);
        for (int j = 0; j <= Math.min(ct, even); j++) { // how many we put at left / right
            long p = ( C(even, j) % mod * C(n - even, (ct - j)) % mod * dfs(d + 1, even - j, s + (j * d) - (ct - j) * d, n - ct) % mod ) % mod;
            ret += p;
            ret %= mod;
        }
        dp[d][even].put(s, (int) ret);
        return (int) ret;
    }
    static void fc() {
        init = true;
        inv = new long[100]; f = new long[100];
        f[0] = inv[0] = 1;
        for (int i = 1; i < 100; i++) {
            f[i] = (f[i-1] % mod * i % mod) % mod;
            inv[i] = pow(f[i], mod-2);
        }
    }
    public static long C(int n, int r) {
        // System.out.println(n + "" "" + r);
        if (n < r) return 0;
        return (f[n] % mod * inv[r] % mod * inv[n-r] % mod) % mod;
    }
    static long pow (long x, long exp){
        if (exp==0) return 1;
        long t = pow(x, exp/2);
        t = t*t % mod;
        if (exp%2 == 0) return t;
        return t*x % mod;
    }
}",1441375957
Chuan-Chih Chou,chuan-chih,199,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, i, j = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y))
        
                    
            ",1441300467
Chuan-Chih Chou,chuan-chih,199,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0, False)]
        while heap:
            t, i, j, p = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + p + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y, not p))",1441303185
Chuan-Chih Chou,chuan-chih,199,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(d) for d in num[::2]) == sum(int(d) for d in num[1::2])",1441281012
Chuan-Chih Chou,chuan-chih,199,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num) // 2
        total, p = divmod(sum(int(d) for d in num), 2)
        if p:
            return 0
        f = [1, 1]
        for i in range(2, len(num) + 1):
            f.append(f[-1] * i % mod)
        count = [0] * 10
        for d in num:
            count[int(d)] += 1
        base = [0] * 10
        b = 1
        for i, c in enumerate(count):
            base[i] = b
            b *= (c + 1)
        
        def decode(b):
            c = []
            x = b
            for curr in reversed(base):
                d, x = divmod(x, curr)
                c.append(d)
            c.reverse()
            return c
        
        nom = f[n] * f[len(num) - n] % mod
        
        @cache
        def recur(d, used, s):
            if d == 10:
                if used != n:
                    return 0
                if s != total:
                    return 0
                return nom
            to_use = n - used
            ans = 0
            for use in range(min(to_use, count[d]) + 1):
                factor = pow(f[use], -1, mod) * pow(f[count[d] - use], -1, mod) % mod
                ans += recur(d + 1, used + use, s + use * d) * factor % mod
            # print(d, used, s, ans)
            return ans % mod
            
            
        return recur(0, 0, 0)
        
            ",1441376296
Jasper,JasperT37449,200,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        pq.push({0, {0, 0}});
        int t, i, j;
        vector<vector<int>> time(n+1, vector<int>(m+1, 1e9));
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+1, moveTime[i+1][j]+1), {i+1, j}});
            if(j+1<=m)pq.push({max(t+1, moveTime[i][j+1]+1), {i, j+1}});
            if(i-1>=0)pq.push({max(t+1, moveTime[i-1][j]+1), {i-1, j}});
            if(j-1>=0)pq.push({max(t+1, moveTime[i][j-1]+1), {i, j-1}});
        }
        return t;
    }
};",1441313753
Jasper,JasperT37449,200,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,pair<int, int>>>, vector<pair<int, pair<int, pair<int, int>>>>, greater<pair<int, pair<int, pair<int, int>>>>> pq;
        pq.push({0, {0, {0, 1}}});
        int t, i, j, turn;
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second.first, turn = pq.top().second.second.second%2;
            if(!turn)turn = 2;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            //cout<<""T : ""<<t<<"" ""<<i<<"" ""<<j<<endl;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+turn, moveTime[i+1][j]+turn), {i+1, {j, turn+1}}});
            if(j+1<=m)pq.push({max(t+turn, moveTime[i][j+1]+turn), {i, {j+1, turn+1}}});
            if(i-1>=0)pq.push({max(t+turn, moveTime[i-1][j]+turn), {i-1, {j, turn+1}}});
            if(j-1>=0)pq.push({max(t+turn, moveTime[i][j-1]+turn), {i, {j-1, turn+1}}});
        }
        return t;
    }
};",1441328086
Jasper,JasperT37449,200,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        for(int i = 0;i<num.size();i++){
            if(i%2==0){
                odd+=num[i]-48;
            }
            else {
                even+=num[i]-48;
            }
        }
        if(odd==even)return true;
        return false;
    }
};",1441282589
Jasper,JasperT37449,200,3637,cpp,"typedef long long ll;

class Solution {
public:
    ll power(ll a, ll b, ll mod) {
        ll res = 1;
        a %= mod;
        while(b >0){
            if(b &1){
                res = res * a % mod;
            }
            a = a *a % mod;
            b >>=1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size(), cnt[10] = {0}, sum =0, mod = 1e9 + 7;
        for(char c: num){
            cnt[c - '0']++;
            sum += (c - '0');
        }
        if(sum %2 !=0)return 0;
        ll s = sum /2;
        int k = (n+1)/2;
        vector<ll> fact(n+1,1), table(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] *i % mod;
        table[n] = power(fact[n], mod-2, mod);
        for(int i=n-1;i>=0;i--) table[i] = table[i+1] * (i+1) % mod;
        vector< vector<ll> > prev(k+1, vector<ll>(s+1, 0));
        prev[0][0] =1;
        for(int d=0; d<=9; d++){
            int c_d = cnt[d];
            vector< vector<ll> > curr(k+1, vector<ll>(s+1, 0));
            for(int k_prev=0; k_prev <=k; k_prev++){
                for(int s_prev=0; s_prev <=s; s_prev++){
                    if(prev[k_prev][s_prev] ==0) continue;
                    for(int x=0; x<=c_d; x++){
                        if(k_prev +x >k) break;
                        if((ll)s_prev + (ll)d *x >s) break;
                        int new_k = k_prev +x, new_s = s_prev + d *x;
                        ll val = prev[k_prev][s_prev];
                        val = val * table[x] % mod;
                        val = val * table[c_d -x] % mod;
                        curr[new_k][new_s] = (curr[new_k][new_s] + val) % mod;
                    }
                }
            }
            prev = move(curr);
        }
        if(k >n || s > 9*80)return 0;
        ll res = fact[k];
        res = res * fact[n -k] % mod;
        res = res * prev[k][s] % mod;
        return res;
    }
};",1441376524
lu-chen-chen,lu-chen-chen,201,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t + 1, moveTime[x][y] + 1)});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441298612
lu-chen-chen,lu-chen-chen,201,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t, moveTime[x][y]) + 1 + (x + y + 1) % 2});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441305940
lu-chen-chen,lu-chen-chen,201,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int a = 0;
        int b = 0;
        char[] chars = num.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (i % 2 == 0) {
                a += chars[i] - '0';
            } else {
                b += chars[i] - '0';
            }
        }
        return a == b;
    }
}",1441281556
lu-chen-chen,lu-chen-chen,201,3637,java,"import java.math.BigInteger;
class Solution {
    public int countBalancedPermutations(String num) {
        long mod = (long) (1e9 + 7);
        char[] chars = num.toCharArray();
        int n = chars.length;
        int sum = 0;
        int[] cnt = new int[10];
        for (char c : chars) {
            cnt[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 1) {
            return 0;
        }
        Factorial fac = new Factorial(n + 5, (int) mod);
        long[][][] dp = new long[10][n / 2 + 1][sum / 2 + 1];
        for (int i = 0; i <= Math.min(cnt[0], n / 2); i++) {
            dp[0][i][0] = 1;
        }
        int curCnt = cnt[0];
        for (int i = 1; i < 10; i++) {
            curCnt += cnt[i];
            for (int j = 0; j <= n / 2; j++) {
                for (int k = 0; k <= sum / 2; k++) {
                    for (int l = 0; l <= cnt[i]; l++) {
                        int j1 = j + l;
                        int k1 = k + l * i;
                        if (j1 > n / 2 || k1 > sum / 2) {
                            break;
                        }
                        dp[i][j1][k1] += fac.comb(j1, l) * dp[i - 1][j][k] % mod * fac.comb(curCnt - j1, cnt[i] - l) % mod;
                        dp[i][j1][k1] %= mod;
                    }
                }
            }
        }
        long ans = dp[9][n / 2][sum / 2];
        return (int) ((ans + mod) % mod);
    }
}

class Factorial {
    long[] fac;
    long[] inv;
    long mod;

    public Factorial(long[] fac, long[] inv, long mod) {
        this.mod = mod;
        this.fac = fac;
        this.inv = inv;
        fac[0] = inv[0] = 1;
        int n = fac.length;
        for (int i = 1; i < n; i++) {
            fac[i] = i;
            fac[i] = (int) (fac[i] * fac[i - 1] % mod);
        }
        inv[n - 1] = BigInteger.valueOf(fac[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();
        for (int i = n - 2; i >= 1; i--) {
            inv[i] = (int) (inv[i + 1] * (i + 1) % mod);
        }
    }

    public Factorial(int limit, int mod) {
        this(new long[Math.min(limit + 1, mod)], new long[Math.min(limit + 1, mod)], mod);
    }

    public long getMod() {
        return mod;
    }

    public long fac(int n) {
        if (n >= mod) {
            return 0;
        }
        return fac[n];
    }

    public long inv(int n) {
        if (n >= mod) {
            throw new IllegalArgumentException();
        }
        return inv[n];
    }

    public long comb(int n, int m) {
        if (n < m) {
            return 0;
        }
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    }

    public long combInv(int n, int m) {
        if (n < m) {
            throw new IllegalArgumentException();
        }
        return inv[n] * fac[m] % mod * fac[n - m] % mod;
    }
}",1441364181
unnu,unnu,202,3627,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty]+1,t+1);
                    if(dis[tx][ty]>t1){
                        st.erase({dis[tx][ty],tx,ty});
                        st.insert({t1,tx,ty});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
        
    }
};",1441302269
unnu,unnu,202,3628,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2],z=v[3];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty],t);
                    if(z%2==0) t1+=1;
                    else t1+=2;
                    if(dis[tx][ty]>t1){
                        // st.erase({dis[tx][ty],tx,ty,});
                        st.insert({t1,tx,ty,1-z});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
    }
};",1441305679
unnu,unnu,202,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int x=0;int y=0;int n=num.size();
        for(int i=0;i<n;i++){
            if(i%2) x+=(num[i]-'0');
            else y+=(num[i]-'0');
        }
        return (x==y);
    }
};",1441289924
unnu,unnu,202,3637,cpp,"#define ll long long
class Solution {
public:
    const int mod=1e9+7;
    ll dp[12][41][365];
    vector<int>freq;int p;
    vector<ll>fact,invf;

ll power(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)
        {
            res=(res*a)%mod;
        }
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}

void precompute(int n)
{
    fact.resize(n+1);
    invf.resize(n+1);
    fact[0]=1;
    for(int i=1;i<=n;i++)
    {
        fact[i]=(fact[i-1]*i)%mod;
    }
    invf[n]=power(fact[n],mod-2);
    for(int i=n-1;i>=0;i--)
    {
        invf[i]=(invf[i+1]*(i+1))%mod;
    }
}

ll nCr(int n,int r)
{
    if(r>n)
    {
        return 0;
    }
    ll ans=(invf[r])%mod;
    ans=(ans*invf[n-r])%mod;
    return ans;
}
    ll f(int idx,int cnt,int sum,int k){
        // int n=v.size();
        // int p=n/2;
        // if(idx>=n && sum==k && cnt==p) return 1;
        // if(idx>=n || sum>k || cnt>p) return 0;
        // if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        // ll take=f(idx+1,cnt+1,sum+v[idx],k,v);
        // ll nt=f(idx+1,cnt,sum,k,v);
        // ll ans=(take+nt)%mod;
        // return dp[idx][cnt][sum]=ans;
        
        int n=freq.size();
        if(idx>=n && sum==k && cnt==p) {
          //  cout<<sum<<"" ""<<cnt<<endl;
            return 1;
        }
        if(idx>=n || sum>k || cnt>p) return 0;
        if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        ll take=0,nt=0;ll res=0;
        for(int i=0;i<=freq[idx];i++){
            take=(f(idx+1,cnt+i,sum+(i)*idx,k)*nCr(freq[idx],(i)))%mod;
           // nt=(f(idx+1,cnt+i,sum+(i*idx),k)*nCr(freq[idx],i))%mod;
            //cout<<take<<"" ""<<nt<<"" p""<<i<<endl;
            res+=((take%mod))%mod;
            res%=mod;
            res=(res+mod)%mod;
        }
         //nt=(f(idx+1,cnt+freq[idx],sum+(freq[idx]*idx),k))%mod;
        // res+=(nt%mod);
        // res%=mod;
        // res=(res+mod)%mod;
       // cout<<idx<<"" ""<<cnt<<"" ""<<sum<<"" ""<<res<<endl;
        return dp[idx][cnt][sum]=res;
    }
    int countBalancedPermutations(string num) {
        vector<int>v;freq.resize(10,0);precompute(81);
        for(auto ch:num) v.push_back(ch-'0');
        int k=0;p=v.size()/2;
        for(auto it:v) k+=it,freq[it]++;
        if(k%2) return 0;
        memset(dp,-1,sizeof(dp));
        ll ans=(fact[p]*fact[v.size()-p])%mod;
        ll tmp=f(0,0,0,k/2)%mod;
        ll res=(ans*tmp)%mod;
        res=(res+mod)%mod;
        return res;
        
        
        // return f(0,0,0,k/2);
    }
};",1441385344
op33,op33,203,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        visited = set()
        queue = [(0, (0,0))]
        while queue:
            time, (row, col) = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    heapq.heappush(queue, (ntime, (nr, nc)))
            

        # should always return earlier",1441297937
op33,op33,203,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        # another variable to track move parity
        visited = set()
        queue = [(0, (0,0), True)]
        while queue:
            time, (row, col), parity = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    if not parity:
                        ntime += 1
                    heapq.heappush(queue, (ntime, (nr, nc), not parity))
            

        # should always return earlier",1441300716
op33,op33,203,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens, odds = 0, 0
        for i, char in enumerate(num):
            digit = int(char)
            if i % 2 == 0:
                evens += digit
            else:
                odds += digit
        return evens == odds",1441283006
op33,op33,203,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # naively you can compute n! perms * n to count all
        # They must sum to sum(num) / 2 which must be even in total
        # sum(num) // 2 = S
        # how many subsets will sum to S? -> This is a known problem, N^2
        # How many permutations of each of these subsets are there as well
        # If a subset has duplicates, you need to divide by m! for each duplicate for overcounting
        # num.length is max 80 which can make it easier
        # Can manually go through each distinct subset after collecting each?
        # Or can iteratively build a count and correct for overcounting at each step?
        # What if you track each counts of each digit set, such as {7:2,9:1} -> 2
        # Or track each sum -> unique digit sets such as 21 -> {{7:3}, {8:2, 5:1}}
        # This is an option but might be too slow/memory(?)

        # count each digit and then do coin change like dp?
        # This could work since you can iteratively build the denominator at each step
        # For example, if there are 3 2s available and you choose to use 3 of them, then you eventually need to overcorrect by a factor of 3!, so you can pass that down in the dp process, no matter what is chosen later.
        # need to store num_elems so far chosen, denominator so far, index, sum so far
        # also need to store denom for the other subset
        # Forgot that num elems must match or be off by 1 at most
        # Also if sum > S at any point, early break
        # If num elems is > half at any point, only add 0 elems in future.
        # maybe set1 is evens, set2 is odds. Can have at most 1 extra for either by the end -> No only even can have more
        # maybe can reduce time using symmetry of even/odd sets?? maybe only if even digits_count
        # If odd digit count, then there will be exactly 1 extra even compared to odds
        # Do we need denom1/denom2 in the cache state? No? Can just divide on demand when receiving the output
        # 851350267
        
        MOD = 10**9 + 7

        @cache
        def factorial(n):
            if n == 0:
                return 1
            answer = 1
            for i in range(1, n + 1):
                answer *= i
            return answer

        digits = [int(char) for char in num]
        digits_count = len(digits)
        evens_digit_count = digits_count // 2
        if digits_count % 2 == 1:
            evens_digit_count += 1

        T = sum(digits)
        if T % 2 == 1:
            return 0
        
        S = T // 2

        counts = list(Counter(digits).items())
        counts = sorted(counts) # ex - [(0, 5), (1, 2), (3, 1), ... (9, 1)]

        @cache
        def count_bal_perms(idx, sum_so_far, num_elems):
            if idx == len(counts):
                if sum_so_far == S and num_elems == evens_digit_count:
                    total1 = factorial(num_elems) # should always divide cleanly
                    total2 = factorial(digits_count - num_elems)
                    return total1 * total2
                else:
                    return 0

            cur_dig, count = counts[idx]
            bal_perms = 0
            for i in range(count + 1):
                new_num_elems = num_elems + i
                new_sum = sum_so_far + i * cur_dig
                if new_num_elems > evens_digit_count or new_sum > S:
                    continue

                denom1, denom2 = factorial(i), factorial(count - i)

                bal_perms += count_bal_perms(idx + 1, new_sum, new_num_elems) // denom1 // denom2

            return bal_perms

        return count_bal_perms(0, 0, 0) % MOD
            
        ",1441379448
user9821NM,user9821NM,204,3627,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<int>>dist(n, vector<int>(m, INT_MAX));
        
        set<tuple<int,int,int>>q; q.insert({0, 0, 0}); dist[0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y] = *q.begin(); q.erase(*q.begin());
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && dist[X][Y] > max(dist[x][y] + 1, moveTime[X][Y] + 1)) {
                    q.erase({dist[X][Y], X, Y});
                    dist[X][Y] =  max(dist[x][y] + 1, moveTime[X][Y] + 1);
                    q.insert({dist[X][Y], X, Y});
                }
            }
        };
        
        return dist[n - 1][m - 1];
    }
};",1441344848
user9821NM,user9821NM,204,3628,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<vector<int>>>dist(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        
        set<tuple<int,int,int,int>>q; q.insert({0, 0, 0, 0}); dist[0][0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y, move] = *q.begin(); q.erase(*q.begin());
            
            int cost = ((move ^ 1) ? 1 : 2);
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && 
                    dist[X][Y][move ^ 1] > max(dist[x][y][move] + cost, moveTime[X][Y] + cost)) {
                    q.erase({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                    dist[X][Y][move ^ 1] =  max(dist[x][y][move] + cost, moveTime[X][Y] + cost);
                    q.insert({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                }
            }
        };
        
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441351431
user9821NM,user9821NM,204,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int>sum(2);
        for(int i = 0;i < num.size(); i++) {
            sum[i % 2] += num[i] - '0';
        }
        
        return sum[0] == sum[1];
    }
};",1441326964
user9821NM,user9821NM,204,3637,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int expo(int a, int b) {
        int res = 1;
        while(b) {
            if(b & 1) res = (1ll * res * a) % MOD;
            b >>= 1; a = (1ll * a * a) % MOD;
        }
        return res;
    }
    
    int countBalancedPermutations(string num) {
        vector<int>fr(10), fact(num.size() + 1, 1), ifact(num.size() + 1, 1); int sum = 0;
        for(auto &i : num) fr[i - '0']++, sum += (i - '0');
                
        if((sum % 2 == 1)) return 0;
        
        for(int i = 1; i <= num.size(); i++) {
            fact[i] = (1ll * i * fact[i - 1]) % MOD;
            ifact[i] = expo(fact[i], MOD - 2);
        }
                        
        vector<vector<vector<int>>>dp(10, vector<vector<int>>(num.size() / 2 + 1, vector<int>(sum + 1, -1)));
        
        int permutationsCount = (1ll * fact[num.size() / 2] * fact[(num.size() + 1) / 2]) % MOD;
        
        auto f = [&](int number, int taken, int currentSum, auto &&self) -> int {            
            if(number == 10) {
                return (currentSum == sum / 2 && taken == num.size() / 2 ? permutationsCount : 0);
            }
            
            if(dp[number][taken][currentSum] != -1) return dp[number][taken][currentSum];
            
            int ways = 0;
            
            for(int i = 0; i <= min(fr[number], (int) num.size() / 2 - taken); i++) {
                ways = (ways + (1ll * (1ll * ifact[i] * ifact[fr[number] - i]) % MOD * self(number + 1, taken + i, currentSum + i * number, self)) % MOD) % MOD;
            }
            
            return dp[number][taken][currentSum] = ways;
        };
        
        return f(0, 0, 0, f);
    }
};",1441379576
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue

                new_cost = max(c, moveTime[x][y]) + 1
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441295323
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue
                extra_cost = 0 if (x + y) & 1 else 1
                new_cost = max(c, moveTime[x][y]) + 1 + extra_cost
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441307109
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0

        for i in range(len(num)):
            if i & 1:
                odd += (ord(num[i]) - ord('0'))
            else:
                even += (ord(num[i]) - ord('0'))
        return odd == even",1441281363
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits_freq = [0] * 10
        for c in num:
            digits_freq[ord(c) - ord('0')] += 1
        s = 0
        for i in range(10):
            s += i * digits_freq[i]

        if s & 1:
            return 0

        MOD = 10**9 + 7
        
        @lru_cache(None)
        def c(n, k): 
            if k == 0:
                return 1
            if n == k:
                return 1
            else:
                return (c(n-1, k-1) + c(n-1, k)) % MOD

        @lru_cache(None)
        def dp(d, diff, n_even, n_odd):
            if n_even < 0 or n_odd < 0:
                return 0

            if d == -1:
                return 1 if diff == 0 else 0

            res = 0
            for e in range(digits_freq[d] + 1):
                remain_even = n_even-e
                remain_odd = n_odd-(digits_freq[d]-e)
                if remain_even < 0 or remain_odd < 0:
                    continue

                temp = dp(d-1, diff + e*d - (digits_freq[d]-e)*d, remain_even, remain_odd)
                temp = (temp * c(n_even, e) * c(n_odd, digits_freq[d]-e)) % MOD
                res = (res + temp) % MOD
            return res
            
        return dp(9, 0, (len(num) + 1) // 2, len(num) // 2)",1441385680
Anuj Anand,coleworld223,206,3627,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 1};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312661
Anuj Anand,coleworld223,206,3628,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 2};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312149
Anuj Anand,coleworld223,206,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      array <int, 2> c = {0, 0};
      for (int i = 0; i < num.size(); ++i) {
        c[i % 2] += (num[i] - '0');
      }
      return c[0] == c[1];
    }
};",1441282080
Anuj Anand,coleworld223,206,3637,cpp,"int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

struct fact {
  mi fac[1000];
  mi ifac[1000];
  fact() {
    fac[0] = ifac[0] = 1;
    for (int i = 1; i < 1000; ++i) {
      fac[i] = fac[i - 1] * i;
      ifac[i] = inv(fac[i]);
    }
  }
};

fact F;
mi C(int n, int r) {
  if (n <= 0 or r > n) { return (mi)0; }
  return F.fac[n] * F.ifac[r] * F.ifac[n - r];
}

mi dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(string num) {
      int n = num.size();
      for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 81; ++j) {
          for (int k = 0; k < 801; k++) {
            dp[i][j][k] = 0;
          }
        }
      }
      vector <int> cnt (10);
      int T = 0;
      for (char x : num) {
        cnt[x - '0'] += 1;
        T += (x - '0');
      }
      
      if (T % 2) { return 0; }
      T /= 2;
      
      for (int x = 0; x <= cnt[0]; x++) {
        dp[0][x][0] += 1 * F.ifac[x] * F.ifac[cnt[0] - x];
      }
      for (int i = 0; i < 9; ++i) {
        int nxt = i + 1;
        int tot = cnt[i + 1];
        int cur_tot = cnt[i];
        for (int take = 0; take <= 80; take++) {
          for (int sum = 0; sum <= 800; sum++) {
            if (dp[i][take][sum] == 0) { continue; }
            for (int x = 0; x <= tot; x++) {
              int ntake = take + x;
              int nsum = sum + x * (i + 1);
              if (nsum <= 800 and ntake <= 80) dp[i + 1][ntake][nsum] += dp[i][take][sum] * F.ifac[x] * F.ifac[tot - x];
            }
          }
        }
      }
      
      // cout << dp[2][2][3] << '\n';
      // cout << dp[3][2][3] << '\n';
      int siz = n / 2;
      // cout << siz << ' ';
      // cout << T << '\n';
      // cout << dp[9][siz][T] << '\n';
      mi ans = dp[9][siz][T] * F.fac[siz] * F.fac[n - siz];
      return ans.v;
    }
};",1441367561
Vivan,Vivan_geekfreak,207,3627,java,"import java.util.*;
class Solution 
{
    public int minTimeToReach(int[][] moveTime)
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var dist = new int[n][m];
        int i = 0;
        if(n>0)
            do
            {
                Arrays.fill(dist[i], Integer.MAX_VALUE);
                i++;
            } 
            while (i < n);
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for(;!pq.isEmpty();)
        {
            var curr = pq.poll();
            var time = curr[0];
            var row = curr[1];
            var col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0; 
            do 
            {
                var dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
            while (dirIndex < dirs.length);
        }
        return dist[n - 1][m - 1];
    }
}
",1441366743
Vivan,Vivan_geekfreak,207,3628,java,"import java.util.*;

class Solution 
{
    public int minTimeToReach(int[][] moveTime) 
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var d = new int[n][m][2];
        int i = 0;
        do 
        {
            int j = 0;
            do 
            {
                d[i][j][0] = Integer.MAX_VALUE;
                d[i][j][1] = Integer.MAX_VALUE;
                j++;
            } 
            while (j < m);
            i++;
        } 
        while (i < n);
        d[0][0][0] = 0;
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0});
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for(;(!(!pq.isEmpty())==false);)
        {
            var current = pq.poll();
            var t = current[0];
            var iCur = current[1];
            var jCur = current[2];
            var p = current[3];

            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            int dirIndex = 0;
            do 
            {
                var dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.offer(new int[]{nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            } 
            while (dirIndex < directions.length);
        }

        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441332797
Vivan,Vivan_geekfreak,207,3636,java,"class Solution 
{
    public boolean isBalanced(String num) 
    {
        int evenSum = 0;
        int oddSum = 0;
        int i=0;
        if(num.length()>0)
            do
            {
                int digit = num.charAt(i) - '0'; 
                if (!(i % 2 == 0) == false)
                    evenSum += digit;
                else
                    oddSum += digit;
                i++;
            }
            while(i<num.length());
        return evenSum == oddSum;
    }
}
",1441292613
Vivan,Vivan_geekfreak,207,3637,java,"import java.util.*;
class Solution
{
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;
    private long powerMod(long a, long b) 
    {
        long res = 1;
        a %= MOD;
        while (b > 0) 
        {
            if (!((b & 1) == 1) ==false)
                res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }
    private void initFact(int n) 
    {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        int i = 1;
        do 
        {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do 
        {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        }
        while (j >= 0);
    }
    public int countBalancedPermutations(String num) 
    {
        var n = num.length();
        var freq = new int[10];
        long totalSum = 0;
        var C=Arrays.copyOfRange(num.toCharArray(), 0, n);
        int i=0;
        if(n>0)
            do
            {
                char c=C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            }
            while(i<n);

        if (!(totalSum % 2 != 0) ==false)
            return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        var dp = new long[k + 1][(int) sumHalf + 1];
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0)==false)
            {
                d++;
                continue;
            }
            int c = k;
            do 
            {
                long s = sumHalf;
                do 
                {
                    if (!(dp[c][(int) s] == 0)==false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    do 
                    {
                        if (!(t > Math.min(freq[d], k - c)) ==false)
                            break;
                        if (!(s + (long) d * t > sumHalf)==false)
                            break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                        t++;
                    } 
                    while (true);
                    s--;
                } 
                while (s >= 0);
                c--;
            } 
            while (c >= 0);
            d++;
        } 
        while (d <= 9); 

        long validAssignments = dp[k][(int) sumHalf];
        if (!(validAssignments == 0) == false)
            return 0;
        long prodFactFd = 1;
        int digit=0;
        do 
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        while(digit <= 9);
        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int) answer;
    }
}
",1441392291
Fasdr,Fasdr,208,3627,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][] time = new int[n][m];
        int max = Integer.MAX_VALUE;
        for (int row[] : time) {
            Arrays.fill(row, max);
        }
        // t, i, j
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2];
            if (time[i][j] <= t) {
                continue;
            }
            time[i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int nt = Math.max(moveTime[ni][nj] + 1, t + 1);
                frontier.add(new int[] {nt, ni, nj});
            }
        }
        
        return time[n - 1][m - 1];
    }
}",1441297738
Fasdr,Fasdr,208,3628,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][][] time = new int[2][n][m];
        int max = Integer.MAX_VALUE;
        for (int[][] table : time) {
            for (int[] row : table) {
                Arrays.fill(row, max);
            }
        }
        // t, i, j, a
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2], a = cur[3];
            if (time[a][i][j] <= t) {
                continue;
            }
            time[a][i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int extra = (a == 0) ? 1 : 2;
                int nt = Math.max(moveTime[ni][nj], t) + extra;
                frontier.add(new int[] {nt, ni, nj, 1 - a});
            }
        }
        
        return Math.min(time[0][n - 1][m - 1], time[1][n - 1][m - 1]);
    }
}",1441306270
Fasdr,Fasdr,208,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int odd = 0, even = 0;
        for (int i = 0; i < n; i += 2) {
            even += (num.charAt(i) - '0');
        }
        for (int i = 1; i < n; i += 2) {
            odd += (num.charAt(i) - '0');
        }
        return even == odd;
    }
}",1441282457
Fasdr,Fasdr,208,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        int[] qty = new int[10];
        long mod = 1_000_000_007;
        int n = num.length();
        int total = 0;
        for (char chr : num.toCharArray()) {
            total += chr - '0';
        }
        if (total == 0) {
            total = 1;
        }
        total = 2 * total;
        long[][] dp = new long[total + 1][2 * n + 1];
        dp[total / 2][n] = 1;
        for (char chr : num.toCharArray()) {
            int digit = chr - '0';
            qty[digit]++;
            long[][] newDp = new long[total + 1][2 * n + 1];
            for (int sum = 0; sum < total + 1; sum++) {
                for (int cnt = 0; cnt < 2 * n + 1; cnt++) {
                    if (dp[sum][cnt] == 0) {
                        continue;
                    }
                    // add to even
                    newDp[sum + digit][cnt + 1] = (newDp[sum + digit][cnt + 1] + dp[sum][cnt]) % mod;
                    // add to odd
                    newDp[sum - digit][cnt - 1] = (newDp[sum - digit][cnt - 1] + dp[sum][cnt]) % mod;
                }
            }
            dp = newDp;
        }
        
        long res = n % 2 == 0? dp[total / 2][n] : dp[total / 2][n + 1];
        int half = n / 2;
        for (int i = 1; i <= half; i++) {
            res = (res * i * i) % mod;
        }
        
        if (n % 2 != 0) {
            res = (res * (half + 1)) % mod;
        }
        
        for (int digitQty : qty) {
            for (int i = 2; i <= digitQty; i++) {
                res = (res * modInv(i, mod)) % mod;
            }
        }
        
        return (int) res;
    }
    
    private long modInv(long num, long mod) {
        return pow(num, mod - 2, mod);
    }
    
    private long pow(long base, long exp, long mod) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp = exp >> 1;
        }
        
        return res;
    }
    
}",1441367839
Gautam Ankoji,gautamankoji,209,3627,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        v = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        q = [(0, 0, 0)]
        while q:
            t, i, j = heapq.heappop(q)
            if t > d[i][j]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + 1
                    if d[ni][nj] > nt:
                        d[ni][nj] = nt
                        heapq.heappush(q, (nt, ni, nj))
        res = d[n - 1][m - 1]
        return d[n - 1][m - 1]",1441323814
Gautam Ankoji,gautamankoji,209,3628,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0
        v = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        q = [(0, 0, 0, 0)]
        while q:
            t, i, j, p = heapq.heappop(q)
            if t > d[i][j][p]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + (2 if p else 1)
                    if d[ni][nj][1 - p] > nt:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(q, (nt, ni, nj, 1 - p))
        res = min(d[n - 1][m - 1])
        return res",1441327957
Gautam Ankoji,gautamankoji,209,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res1, res2 = 0, 0
        for i, d in enumerate(num):
            if i % 2 != 0:
                res2 += int(d)
            else:
                res1 += int(d)
        return res1 == res2
",1441291369
Gautam Ankoji,gautamankoji,209,3637,python3,"MOD = 1_000_000_007

class Solution:
    def power(self, base: int, exp: int, mod: int) -> int:
        res = 1
        base %= mod
        while exp:
            if exp & 1:
                res = res * base % mod
            base = base * base % mod
            exp >>= 1
        return res
    
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        e, O = (n + 1) // 2, n // 2
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1
        tot_sum = sum(d * cnt[d] for d in range(10))
        if tot_sum % 2: return 0
        t_sum = tot_sum // 2
        max_val = 80
        fact = [1] * (max_val + 1)
        for i in range(1, max_val + 1):
            fact[i] = fact[i - 1] * i % MOD
        not_fact = [1] * (max_val + 1)
        not_fact[max_val] = self.power(fact[max_val], MOD - 2, MOD)
        for i in range(max_val - 1, -1, -1):
            not_fact[i] = not_fact[i + 1] * (i + 1) % MOD
        def comb(n: int, k: int) -> int:
            return (fact[n] * not_fact[k] % MOD * not_fact[n - k] % MOD) if k <= n else 0
        dp = [[0] * (t_sum + 1) for _ in range(e + 1)]
        dp[0][0] = 1
        for d in range(10):
            if not cnt[d]: continue
            for t in range(e, -1, -1):
                for s in range(t_sum, -1, -1):
                    if dp[t][s]:
                        for k in range(1, cnt[d] + 1):
                            if t + k <= e and s + d * k <= t_sum:
                                dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD
        p_cnt = 1
        for d in range(10):
            p_cnt = p_cnt * fact[cnt[d]] % MOD
        ans = (dp[e][t_sum] * fact[e] % MOD * fact[O] % MOD * self.power(p_cnt, MOD - 2, MOD)) % MOD
        return ans
",1441386398
Nguyn Minh,minhnguyenxuan60,210,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<vector<int>> dp(n, vector<int>(m, 1e9 + 1e8));
        dp[0][0] = 0;

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        for (int k = 0; k < n * m; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    for (int r = 0; r < 4; r++) {
                        int i1 = i + diri[r], j1 = j + dirj[r];
                        if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                        dp[i1][j1] = min(dp[i1][j1], dp[i][j] + 1);
                        if (i1 != 0 || j1 != 0) dp[i1][j1] = max(dp[i1][j1], moveTime[i1][j1] + 1);
                    }
                }
            }
        }

        return dp[n - 1][m - 1];
    }
};",1441297906
Nguyn Minh,minhnguyenxuan60,210,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> q;
        q.push({{0, 1}, {0, 0}});

        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        vector<vector<bool>> vis(n, vector<bool>(m));
        while(!q.empty()) {
            int u = q.top().first.first, t = q.top().first.second, i = q.top().second.first, j = q.top().second.second;
            q.pop();
            if (vis[i][j]) continue;
            vis[i][j] = true;
            if (i == n - 1 && j == m - 1) {
                return max(u, moveTime[i][j] + 1);
            }

            for (int k = 0; k < 4; k++) {
                int i1 = i + diri[k], j1 = j + dirj[k];
                if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                q.push({{max(u, moveTime[i1][j1]) + t, 3 - t}, {i1, j1}});
            }
        }
        return 0;
    }
};",1441313182
Nguyn Minh,minhnguyenxuan60,210,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281260
Nguyn Minh,minhnguyenxuan60,210,3637,cpp,"class Solution {
public:

    const int mod = 1e9 + 7;
    int countBalancedPermutations(string num) {
        vector<vector<int64_t>> c(100, vector<int64_t> (100, 0));
        for (int i = 0; i < 100; i++) c[i][0] = 1;
        for (int i = 1; i < 100; i++) {
            for (int j = i; j < 100; j++) {
                c[j][i] = (c[j - 1][i] + c[j - 1][i - 1]) % mod;
            }
        }

        // for (int i = 0; i <= 10; i++) {
        //     for (int j = 0; j <= 10; j++) cout << c[i][j] << "" "";
        //     cout << '\n';
        // }

        vector<int> cnt(10);
        int total = 0;
        for (char c: num) {
            cnt[c - '0']++;
            total += c - '0';
        }

        if (total % 2) return 0;
        total /= 2;

        int len = num.size() / 2;

        vector<vector<int64_t>> dp(len + 1, vector<int64_t>(total + 1, 0));

        dp[0][0] = 1;
        int curNum = 0;
        
        for (int num = 0; num < 10; num++) {
            vector<vector<int64_t>> tmp(len + 1, vector<int64_t>(total + 1, 0));
            for (int l = 0; l <= curNum; l++) {
                for (int sum = 0; sum <= total; sum++) {
                    for (int used = 0; used <= cnt[num]; used++) {
                        int numLeft = l + used, numRight = curNum - l + cnt[num] - used;
                        if (sum + num * used > total || numLeft > len) break;
                        tmp[numLeft][sum + num * used] += dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod;
                        // if (dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod > 1) {
                        //     // cout << numLeft << "" "" << used << "" "" << numRight << "" "" << cnt[num] - used << "" "" << dp[l][sum] << '\n';
                        //     // cout << l << "" "" << sum << "" "" << num << "" "" << '\n';
                        //     cout << dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod << '\n';
                        // }
                        tmp[numLeft][sum + num * used] %= mod;
                    }
                }
            }
            swap(tmp, dp);
            curNum += cnt[num];
        }

        // for (int i = 0; i <= len; i++) {
        //     for (int sum = 0; sum <= total; sum++) {
        //         cout << dp[i][sum] << "" "";
        //     }
        //     cout << '\n';
        // }

        return dp[len][total];

        

        return 0;
    }
};",1441368456
user3013OR,user3013OR,211,3627,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c = h[0]
            heappop(h)
            if (r,c) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            seen[(r,c)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+1
                heappush(h,(nt,r-1,c))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+1
                heappush(h,(nt,r+1,c))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+1
                heappush(h,(nt,r,c-1))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+1
                heappush(h,(nt,r,c+1))
            
        ",1441293940
user3013OR,user3013OR,211,3628,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
        
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c,s = h[0]
            heappop(h)
            if (r,c,s) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            ns = 1-s
            mv = 1+s
            seen[(r,c,s)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+mv
                heappush(h,(nt,r-1,c,ns))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+mv
                heappush(h,(nt,r+1,c,ns))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+mv
                heappush(h,(nt,r,c-1,ns))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+mv
                heappush(h,(nt,r,c+1,ns))",1441297026
user3013OR,user3013OR,211,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        sign = 1
        for c in num:
            val = int(c)
            s += sign * val
            sign = -sign
        return s==0
        ",1441282298
user3013OR,user3013OR,211,3637,python3,"class Solution:
    def helper(self,n,mod):
        even_n = n//2
        odd_n = n-even_n

        res = (self.fact[even_n]*self.fact[odd_n])%mod
        for i in range(10):
            res = (res*(self.inverse[self.temp[i]]))%mod
            res = (res*(self.inverse[self.cnt[i]-self.temp[i]]))%mod
        self.ans+=res
        self.ans%=mod
        return
        
    def inv(self,a,mod):
        return self.power(a,mod-2,mod)
    def power(self,a,p,mod):
        if p==0:
            return 1
        elif p==1:
            return a
        else:
            res = self.power(a,p//2,mod)
            ans = (res*res)%mod
            if p%2==1:
                ans = (ans*a)%mod
            return ans
    def dfs(self,ind,ts,tn,cs,cn,mod):
        if ind==10:
            if ts == cs*2 and cn == tn//2:
                self.helper(tn,mod)
            return
        if cs>ts//2:
            return
        if cn>tn//2:
            return
        if (tn//2-cn)*9+cs<ts//2:
            return
        for i in range(self.cnt[ind]+1):
            self.temp[ind]=i
            self.dfs(ind+1,ts,tn,cs+i*ind,cn+i,mod)
    def comb(self,a,b,mod):
        ans = self.fact[a]*self.inverse[b]*self.inverse[a-b]
        return ans%mod
    def countBalancedPermutations(self, num: str) -> int:
        self.cnt = [0 for i in range(10)]
        s = 0
        n = len(num)
        #print (n)
        for c in num:
            val = int(c)
            self.cnt[val]+=1
            s+=val
        if s%2==1:
            return 0
        self.fact = [1 for i in range(n+1)]
        self.inverse = [1 for i in range(n+1)]
        mod = int(1e9+7)
        for i in range(n):
            self.fact[i+1]=(self.fact[i]*(i+1))%mod
            self.inverse[i+1]=self.inv(self.fact[i+1],mod)
        self.ans = 0
        self.temp = [0 for i in range(10)]
        self.presum = [[] for i in range(10)]
        for i in range(10):
            base = 0
            for j in range(9,i,-1):
                for _ in range(self.cnt[j]):
                    base+=j
                    self.presum[i].append(base)
        #self.dfs(0,s,n,0,0,mod)
        dp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
        dp[0][0]=1
        ts = 0
        tn = 0
        for ind in range(10):

            temp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
            for n1 in range(n//2+1):
                for s1 in range(s//2+1):
                    n2 = tn - n1
                    s2 = ts - s1
                    if dp[n1][s1]==0:
                        continue
                    for i in range(self.cnt[ind]+1):
                        if n1+i<=n//2 and n2+self.cnt[ind]-i <= n-n//2 and s1+ind*i<=s//2 and s2+ind*(self.cnt[ind]-i) <= s//2:
                            temp[n1+i][s1+ind*i] += dp[n1][s1] * self.comb(n//2-n1,i,mod) * self.comb(n-n//2-n2,self.cnt[ind]-i,mod)
                            temp[n1+i][s1+ind*i] %=mod
            dp = temp
            ts += self.cnt[ind]*ind
            tn += self.cnt[ind]
            
                                    
        return dp[n//2][s//2]",1441362085
Ivan_len,Ivan_len,212,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
        pq.push({0, 0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            if (dp[cur[1]][cur[2]] <= cur[0]) continue;
            dp[cur[1]][cur[2]] = cur[0];
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = cur[1] + dx;
                int new_y = cur[2] + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur[0], moveTime[new_x][new_y]);
                    pq.push({t + 1, new_x, new_y});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441297432
Ivan_len,Ivan_len,212,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.push({0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            int X = cur.second / m;
            int Y = cur.second % m;
            if (dp[X][Y] <= cur.first) continue;
            dp[X][Y] = cur.first;
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = X + dx;
                int new_y = Y + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur.first, moveTime[new_x][new_y]);
                    if (((new_x + new_y) & 1) && t + 1 < dp[new_x][new_y]) {
                        pq.push({t + 1, new_x * m + new_y});
                    }
                    if (((new_x + new_y) % 2 == 0) && t + 2 < dp[new_x][new_y]) {
                        pq.push({t + 2, new_x * m + new_y});
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441303354
Ivan_len,Ivan_len,212,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0;
        int i = 0;
        for (auto c : num) {
            int cnt = (int)(c - '0');
            if (i & 1) a += cnt;
            else a -= cnt;
            i++;
        }
        return a == 0;
    }
};",1441281416
Ivan_len,Ivan_len,212,3637,cpp,"template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
}
 
template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;
 
    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }
 
    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }
 
    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }
 
    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }
 
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }
 
    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }
 
    friend const Type& abs(const Modular& x) { return x.value; }
 
    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);
 
private:
    Type value;
};
 
template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
 
template<typename T, typename U>
Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}
 
template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/
 
constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
 
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<int> cnt(10);
        for (auto c : num) cnt[(int)(c - '0')]++;
        int n = num.size();
        const int shift = ((n + 1) / 2) * 9;
        vector<vector<Mint>> d((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1)), f;
        d[0][shift] = 1; 
        int acc = 0;
        int up = 0, lo = 0;
        for (int i = 0; i <= 9; i++) {
            f.clear();
            f.resize((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1));
            acc += cnt[i];
            for (int even = 0; even <= (n + 1) / 2; even++) {
                for (int ceven = 0; ceven <= even; ceven++) {
                    int codd = cnt[i] - ceven;
                    int odd = acc - even - cnt[i] + ceven;
                    if (codd < 0) break;
                    if (odd > n / 2) break;
                    if (codd > n / 2) continue;
                    if (odd < 0) continue;
                    // even - odd
                    for (int sum = max(-shift, -(i * (n + 1) / 2)); sum <= min(shift, i * (n + 1) / 2); sum++) {
                        int pre = sum - (ceven - codd) * i;
                        if (pre < -shift) continue;
                        if (pre > shift) break;
                        f[even][sum + shift] += d[even - ceven][pre + shift] * C((n + 1) / 2 - (even - ceven), ceven) * C(n / 2 - odd, codd);
                    }
                }
            }
            swap(d, f);
        }
        Mint ans = 0;
        for (int even = 0; even <= ((n + 1) / 2); even++) ans += d[even][shift];
        return (int)ans;
    }
};",1441362584
I_have_learn,I_have_learn,213,3627,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0); 

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();
            if (r == n - 1 && c == m - 1) return currTime;

            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = 1;
                ll newCost = currTime + waitTime + cost;

                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag); 
                }
            }
        }

        return -1;
    }
};
",1441320973
I_have_learn,I_have_learn,213,3628,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        // Min-heap to store (currentTime, row, col, flag)
        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0);  // Start from (0, 0) at time t = 0 with flag = false

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();

            // If we reached the target cell, return the minimum time
            if (r == n - 1 && c == m - 1) return currTime;

            // Visit adjacent cells
            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;

                // Calculate wait time to ensure that we can enter the room
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = flag ? 2 : 1;
                ll newCost = currTime + waitTime + cost;

                // Update if a cheaper path is found
                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag);  // Toggle flag for the next move
                }
            }
        }

        return -1;  // Return -1 if unreachable
    }
};
",1441319656
I_have_learn,I_have_learn,213,3636,cpp,"class Solution {
public:
    bool isBalanced(string nums) {
        int sum1=0,sum2=0;

        for(int i=0;i<nums.size();i+=2) sum1+=nums[i]-'0';

        for(int i=1;i<nums.size();i+=2) sum2+=nums[i]-'0';
        return sum1==sum2;
    }
};",1441284219
I_have_learn,I_have_learn,213,3637,cpp,"#define MOD 1000000007
typedef long long ll;

ll fact[81];
ll inv_fact[81];

ll power_mod(ll x, ll y) {
    ll res = 1;
    x %= MOD;
    while (y > 0) {
        if (y & 1LL) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        y >>= 1LL;
    }
    return res;
}

// Precompute factorials and modular inverses
void compute_factorials() {
    fact[0] = 1;
    for (int i = 1; i <= 80; i++) fact[i] = fact[i - 1] * i % MOD;
    inv_fact[80] = power_mod(fact[80], MOD - 2);
    for (int i = 79; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

// Function to compute C(n, k) % MOD
ll comb(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
}

class Solution {
public:
    ll countBalancedPermutations(string num) {
        compute_factorials();
        
        unordered_map<char, int> freq;
        ll total_sum = 0;
        for (char c : num) {
            freq[c]++;
            total_sum += (c - '0');
        }

        if (total_sum % 2 != 0) return 0;  // Odd total sum means no balanced partition possible
        
        ll target_sum = total_sum / 2;
        int n = num.size();
        int num_even = (n + 1) / 2;
        
        vector<vector<ll>> dp(num_even + 1, vector<ll>(target_sum + 1, 0));
        dp[0][0] = 1;

        for (auto &[digit, count] : freq) {
            int d = digit - '0';
            for (int k = num_even; k >= 0; --k) {
                for (int s = target_sum; s >= 0; --s) {
                    for (int t = 1; t <= count && k + t <= num_even && s + t * d <= target_sum; ++t) {
                        dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb(count, t) % MOD) % MOD;
                    }
                }
            }
        }

        ll C_t = dp[num_even][target_sum];
        if (C_t == 0) return 0;

        ll fact_even = fact[num_even];
        ll fact_odd = fact[n - num_even];
        
        ll denominator = 1;
        for (auto &[digit, f] : freq) {
            denominator = denominator * fact[f] % MOD;
        }
        
        ll result = C_t * fact_even % MOD * fact_odd % MOD * power_mod(denominator, MOD - 2) % MOD;
        return result;
    }
};
",1441356696
nghia0510,phantrongnghia510,214,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[float(""inf"") for _ in range(m)] for _ in range(n)]
        d[0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0)]

        while queue:
            t, i, j = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + 1
                    if nt < d[ni][nj]:
                        d[ni][nj] = nt
                        heappush(queue, (nt, ni, nj))
        return -1
        ",1441316415
nghia0510,phantrongnghia510,214,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[[float(""inf"") ] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0, 0)]

        while queue:
            t, i, j, c = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j][c]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + (1 if not c else 2)
                    nc = c ^ 1
                    if nt < d[ni][nj][nc]:
                        d[ni][nj][nc] = nt
                        heappush(queue, (nt, ni, nj, nc))
        return -1
        ",1441312545
nghia0510,phantrongnghia510,214,3636,python,"class Solution(object):
    def isBalanced(self, num):
        even, odd = 0, 0
    
        for i in range(len(num)):
          if i % 2 == 0:
            even += int(num[i])
          else:
            odd += int(num[i])
    
        return even == odd",1441285916
nghia0510,phantrongnghia510,214,3637,python3,"from collections import Counter
import math

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        count = Counter(num)
        c = [0] * 10
        for d in range(10): 
            c[d] = count.get(chr(d + ord(""0"")), 0)
        total = sum(c[d] * d for d in range(10))
        if total % 2 != 0:
            return 0
        n = len(num)
        H, K  = total // 2, (n + 1) // 2
        dp0 = [[0] * (H + 1) for _ in range(K + 1)]
        dp0[0][0] = 1

        for d in range(10):
            if c[d] == 0:
                continue
            dp1 = [[0] * (H + 1) for _ in range(K + 1)]
            for k in range(K + 1):
                for h in range(H + 1):
                    if dp0[k][h] == 0:
                        continue
                    max_d = min(c[d], K - k)
                    if d > 0:
                        max_d = min(max_d, (H - h) // d)
                    for u in range(max_d + 1):
                        new_k = k + u
                        new_h = h + d * u
                        if new_k > K or new_h > H:
                            continue
                        ways = math.comb(c[d], u)
                        dp1[new_k][new_h] = (dp1[new_k][new_h] + dp0[k][h] * ways) % MOD
            dp0 = dp1

        if dp0[K][H] == 0:
            return 0

        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = (fact[i - 1] * i) % MOD

        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

        prod_inv = 1
        for i in range(10):
            prod_inv = (prod_inv * inv_fact[c[i]]) % MOD

        
        res = dp0[K][H]
        res = (res * fact[K]) % MOD
        res = (res * fact[n - K]) % MOD
        res = (res * prod_inv) % MOD

        return res
",1441394228
hcseo,hcseo,215,3627,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 2;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(1, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return dp[0][n-1][m-1];
    }
};",1441302021
hcseo,hcseo,215,3628,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 3;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(2, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return min(dp[0][n-1][m-1], dp[1][n-1][m-1]);
    }
};",1441300575
hcseo,hcseo,215,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<num.size(); ++i){
            if(i%2==0){
                sum1 += num[i]-'0';
            }else{
                sum2 += num[i]-'0';
            }
        }
        return sum1==sum2;
    }
};",1441281165
hcseo,hcseo,215,3637,cpp,"#define MOD 1000000007

int n;
long long nCr[81][81];

class Solution {
public:
    int countBalancedPermutations(string num) {
        nCr[0][0] = 1;
        for(int i=1; i<81; ++i){
            nCr[i][0] = 1;
            nCr[i][i] = 1;
            for(int j=1; j<i; ++j) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;
        }
        int totalSum = 0;
        n = num.size();
        vector<int> cnt(10);
        for(int i=0; i<n; ++i) {
            totalSum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        if(totalSum%2==1) return 0;
        vector<long long> tmp(totalSum/2+1);
        vector<vector<long long>> dp(n/2+1, tmp); // countOfGroup1 / sumOfGroup1
        dp[0][0] = 1;
        int done = 0;
        int doneSum = 0;
        for(int i=0; i<10; ++i){
            if(cnt[i]==0) continue;
            vector<vector<long long>> dpNext(n/2+1, tmp);
            for(int countOfGroup1 = 0; countOfGroup1<=n/2; ++countOfGroup1){
                for(int sumOfGroup1=0; sumOfGroup1<=totalSum/2; sumOfGroup1++){
                    if(dp[countOfGroup1][sumOfGroup1]==0) continue;
                    int countOfGroup2 = done - countOfGroup1;
                    int sumOfGroup2 = doneSum - sumOfGroup1;
                    for(int j=0; j<=cnt[i]; ++j){
                        int nextSumOfGroup1 = sumOfGroup1+j*i;
                        int nextCountOfGroup1 = countOfGroup1+j;

                        int nextCountOfGroup2 = countOfGroup2 + (cnt[i]-j);
                        int nextSumOfGroup2 = sumOfGroup2 + (cnt[i]-j)*i;

                        if(nextSumOfGroup1>totalSum/2 || nextCountOfGroup1>(n/2) || nextSumOfGroup2> totalSum/2 || nextCountOfGroup2>(n+1)/2) continue;
                        int remainSeats1 = n/2-countOfGroup1;
                        int remainSeats2 = (n+1)/2-countOfGroup2;
                        long long nowWays = (nCr[remainSeats1][j] * nCr[remainSeats2][cnt[i]-j])%MOD;
                        nowWays = (nowWays*dp[countOfGroup1][sumOfGroup1])%MOD;
                        dpNext[nextCountOfGroup1][nextSumOfGroup1] = (dpNext[nextCountOfGroup1][nextSumOfGroup1] + nowWays)%MOD;
                    }
                }
            }
            done += cnt[i];
            doneSum += cnt[i]*i;
            dp = dpNext;
        }
        return dp[n/2][totalSum/2];
    }
};",1441388329
lukewu28,lukewu28,216,3627,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1, npos});
            }
        }
        
        return -1;
    }
};",1441300860
lukewu28,lukewu28,216,3628,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            
            int par = (i + j) % 2; 
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1 + par, npos});
            }
        }
        
        return -1;
    }
};",1441303488
lukewu28,lukewu28,216,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int r = 0;
        for(int i = 0 ; i < num.size(); i++){
            if(i % 2) r -= num[i] - '0';
            else r += num[i] - '0';
        }
        return r == 0;
    }
};",1441288436
lukewu28,lukewu28,216,3637,cpp,"typedef long long ll;
typedef pair<ll, ll> PII;
    const int MAXN = 80;

    const ll MOD = 1000000007;
class Solution {
public:
    ll fac[81], invfac[81];
    ll inv(ll x){return x>1?inv(MOD%x)*(MOD-MOD/x)%MOD:x;}
    void factorial() {
        fac[0] = 1;
        for (ll i = 1; i <= MAXN; i++) {
            fac[i] = fac[i - 1] * i % MOD;
        }
    }
    void inverses() {
        invfac[MAXN] = inv(fac[MAXN]);
        for (ll i = MAXN; i >= 1; i--) {
            invfac[i - 1] = invfac[i] * i % MOD;
        }
    }
    ll C(ll g, ll r) {
        return fac[g] * invfac[r] % MOD * invfac[g - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        int sum = 0;
        
        factorial();
        inverses();
        
        int freq[10] = {};
        for(int i : num) sum += i - '0', freq[i - '0']++;
        if(sum % 2) return 0;
        sum /= 2;
        
        int n = num.size() / 2;
        
        vector<vector<PII>> dp(n + 1, vector<PII>(sum + 1, {0, 0})), dp2(n + 1, vector<PII>(sum + 1, {0, 0}));
        for(int i = 0; i <= min(n, freq[0]); i++){
            dp2[n - i][sum].first = invfac[i] * invfac[freq[0] - i] % MOD;
        }
//         cout << 0 << endl;
//         for(int cnt = 0; cnt <= n; cnt++){
//                 for(int s = 0; s <= sum; s++){

//                     cout << cnt << ' ' << s << ' ' << dp2[cnt][s].first << ' '  << dp2[cnt][s].second << endl;
//                 }
//             }
        for(int i = 1; i < 10; i++){
            // cout << i << ' ' << freq[i] << endl;
            for(int cnt = 0; cnt <= n; cnt++){
                for(int s = 0; s <= sum; s++){
                    dp[cnt][s] = {0 , 0};
                    for(int k = 0; k <= freq[i]; k++){
                        if(s + k*i > sum || cnt + k > n) continue;
                        
                        ll curfac = invfac[k] * invfac[freq[i] - k] % MOD;
                        dp[cnt][s].first = (dp[cnt][s].first + (dp2[cnt + k][s + k*i].first * curfac % MOD) )% MOD;
                        // dp[cnt][s].second = (dp[cnt][s].second + (dp2[cnt + k][s + k*i].second *  % MOD) )% MOD;
                    }

                    // cout << cnt << ' ' << s << ' ' << dp[cnt][s].first << ' '  << dp[cnt][s].second << endl;
                }
            }
            swap(dp, dp2);
        }
        
        ll re = ((dp2[0][0].first * fac[n] % MOD) * fac[num.size() - n] % MOD) % MOD;
        return re;
    }
};",1441376281
vedantgore_2004,vedantgore_2004,217,3627,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<int,pair<int,int>> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({0,{0,0}});
        while(!q.empty()){
            ll t=q.top().first;
            ll x=q.top().second.first;
            ll y=q.top().second.second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+1;
                    if(vis[xx][yy]==-1)
                    q.push({tt,{xx,yy}});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441310976
vedantgore_2004,vedantgore_2004,217,3628,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<pair<int,pair<int,int>>,int> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({{0,{0,0}},1});
        while(!q.empty()){
            ll t=q.top().first.first;
            ll x=q.top().first.second.first;
            ll y=q.top().first.second.second;
            ll move=q.top().second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+move;
                    if(vis[xx][yy]==-1)
                    q.push({{tt,{xx,yy}},(move==1? 2:1)});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441317292
vedantgore_2004,vedantgore_2004,217,3636,cpp,"class Solution {
public:
    bool isBalanced(string a) {
        int x=0;
        int y=0;
        for(int i=0;i<a.size();i++){
            if(i&1){
                x+=a[i]-'0';
            }else y+=a[i]-'0';
        }
        return x==y;
    }
};",1441282073
vedantgore_2004,vedantgore_2004,217,3637,cpp,"class Solution {
public:
    typedef long long ll;
    const int mod = 1e9 + 7;
    ll fact[81], ifact[81];

    ll modPow(ll x, ll y, ll p) {
        ll res = 1;
        x %= p;
        while (y > 0) {
            if (y & 1)
                res = res * x % p;
            y >>= 1;
            x = x * x % p;
        }
        return res;
    }

    // Function to find modular inverse of b under MOD
    ll modInverse(ll b, ll mod) { return modPow(b, mod - 2, mod); }

    // Function to perform modular division a / b under MOD
    ll div(ll a, ll b, ll mod) { return (a * modInverse(b, mod)) % mod; }

    void precompute() {
        fact[0] = 1;
        for (ll i = 1; i <= 80; i++)
            fact[i] = fact[i - 1] * i % mod;
        for (ll i = 0; i <= 80; i++)
            ifact[i] = modPow(fact[i], mod - 2, mod);
    }

    ll func(ll ind, ll tk, ll sum, string& s, vector<vector<vector<ll>>>& dp) {
        ll n = s.size();
        if (ind == n) {
            return sum == 0 && tk == 0;
        }
        if (dp[ind][tk][sum] != -1)
            return dp[ind][tk][sum];
        ll i = s[ind] - '0';
        ll ways = func(ind + 1, tk, sum, s, dp);
        if (sum >= i && tk > 0) {
            ways = (ways + func(ind + 1, tk - 1, sum - i, s, dp)) % mod;
        }
        return dp[ind][tk][sum] = ways;
    }
    int countBalancedPermutations(string s) {
        ll n = s.size();
        ll sum = 0;
        map<ll, ll> fr;
        for (int i = 0; i < n; i++) {
            sum += (s[i] - '0');
            fr[s[i] - '0']++;
        }
        if (sum & 1)
            return 0;
        else
            sum /= 2;
        precompute();
        ll k = n / 2;
        ll rem = n - k;
        vector<vector<vector<ll>>> dp(
            n + 1, vector<vector<ll>>(k + 1, vector<ll>(sum + 1, -1)));
        ll ways = func(0, k, sum, s, dp);
        ways = (ways * fact[rem]) % mod;
        ways = (ways * fact[k]) % mod;
        // cout<<ways<<endl;
        for(int i=0;i<=9;i++){
            ll x=fr[i];
            if(x>1){
                ways=div(ways,fact[x],mod);
            }
        }
        return ways%mod;
    }
};",1441382415
Kashyap Sukshavasi,enkixly,218,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dungeonHeight = moveTime.size();
        int dungeonWidth = moveTime[0].size();
        
        int finalRoomX = dungeonHeight - 1;
        int finalRoomY = dungeonWidth - 1;
        
        vector<vector<int>> quickestPath(dungeonHeight, vector<int>(dungeonWidth, INT_MAX));
        
        queue<pair<int, pair<int, int>>> roomQueue;
        roomQueue.push({0, {0, 0}});
        quickestPath[0][0] = 0;
        
        vector<pair<int, int>> possibleMoves = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!roomQueue.empty()) {
            int timeSpent = roomQueue.front().first;
            int myX = roomQueue.front().second.first;
            int myY = roomQueue.front().second.second;
            roomQueue.pop();
            
            if (timeSpent > quickestPath[myX][myY]) continue;
            
            for (auto& nextMove : possibleMoves) {
                int nextX = myX + nextMove.first;
                int nextY = myY + nextMove.second;
                
                if (nextX >= 0 && nextX < dungeonHeight && nextY >= 0 && nextY < dungeonWidth) {
                    int timeToNext = max(timeSpent, moveTime[nextX][nextY]) + 1;
                    
                    if (timeToNext < quickestPath[nextX][nextY]) {
                        quickestPath[nextX][nextY] = timeToNext;
                        roomQueue.push({timeToNext, {nextX, nextY}});
                    }
                }
            }
        }
        
        return quickestPath[finalRoomX][finalRoomY];
    }
};",1441291465
Kashyap Sukshavasi,enkixly,218,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int height = moveTime.size();
        int width = moveTime[0].size();
        
        vector<vector<long long>> bestOddPath(height, vector<long long>(width, LLONG_MAX));
        vector<vector<long long>> bestEvenPath(height, vector<long long>(width, LLONG_MAX));
        
        priority_queue<pair<long long, tuple<int, int, int>>, 
                      vector<pair<long long, tuple<int, int, int>>>, 
                      greater<>> paths;
                      
        paths.push({0, {0, 0, 0}});
        bestEvenPath[0][0] = 0;
        
        int row[] = {-1, 0, 1, 0};
        int col[] = {0, 1, 0, -1};
        
        while (!paths.empty()) {
            auto [time, current] = paths.top();
            auto [x, y, steps] = current;
            paths.pop();
            
            if ((steps % 2 == 0 && time > bestEvenPath[x][y]) || 
                (steps % 2 == 1 && time > bestOddPath[x][y])) {
                continue;
            }
            
            if (x == height-1 && y == width-1) {
                return time;
            }
            
            for (int i = 0; i < 4; i++) {
                int nextX = x + row[i];
                int nextY = y + col[i];
                
                if (nextX < 0 || nextY < 0 || nextX >= height || nextY >= width) continue;
                
                long long nextTime = max(time, (long long)moveTime[nextX][nextY]) + (steps % 2 == 0 ? 1 : 2);
                bool isNextOdd = !bool(steps % 2);
                auto& bestPath = isNextOdd ? bestOddPath : bestEvenPath;
                
                if (nextTime < bestPath[nextX][nextY]) {
                    bestPath[nextX][nextY] = nextTime;
                    paths.push({nextTime, {nextX, nextY, steps + 1}});
                }
            }
        }
        
        return -1;
    }
};",1441296965
Kashyap Sukshavasi,enkixly,218,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for (int i = 0; i < num.size(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                even += digit;
            } else {
                odd += digit;
            }
        }
        return even == odd;
    }
};
",1441286920
Kashyap Sukshavasi,enkixly,218,3637,python3,"MOD = 1000000007

def powerModFunc(a, b):
    res = 1
    a %= MOD
    while b > 0:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def initFact(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invFact = [1] * (n + 1)
    invFact[n] = powerModFunc(fact[n], MOD - 2)
    for i in range(n - 1, -1, -1):
        invFact[i] = invFact[i + 1] * (i + 1) % MOD
    return fact, invFact

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        totalSum = 0
        
        for c in num:
            d = int(c)
            freq[d] += 1
            totalSum += d
        
        if totalSum % 2 != 0:
            return 0
        
        sumHalf = totalSum // 2
        k = (n + 1) // 2
        
        fact, invFact = initFact(n)
        
        dp = [[0] * (sumHalf + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d in range(10):
            if freq[d] == 0:
                continue
            for c in range(k, -1, -1):
                for s in range(sumHalf, -1, -1):
                    if dp[c][s] == 0:
                        continue
                    for t in range(1, min(freq[d], k - c) + 1):
                        if s + d * t > sumHalf:
                            break
                        comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD
        
        validAssignments = dp[k][sumHalf]
        if validAssignments == 0:
            return 0
        
        prodFactFd = 1
        for d in range(10):
            prodFactFd = prodFactFd * fact[freq[d]] % MOD
        
        fkFnk = (fact[k] * fact[n - k]) % MOD
        invProdFactFd = powerModFunc(prodFactFd, MOD - 2)
        answer = (fkFnk * validAssignments) % MOD
        answer = (answer * invProdFactFd) % MOD
        
        return answer
",1441382904
RONAK GARG,Ronak9910,219,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<tuple<long long, int, int>>> pq;
        pq.push({0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1);
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny});
                    }
                }
            }
        }
        return -1;
    }
};",1441303897
RONAK GARG,Ronak9910,219,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, greater<tuple<long long, int, int, int>>> pq;
        pq.push({0, 0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y, l] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1) + l;
                    bool m = 0;
                    if(l == 0)
                        m = 1;
                    else
                        m = 0;
                        
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny, m});
                    }
                }
            }
        }
        return -1;
    }
};",1441316741
RONAK GARG,Ronak9910,219,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < n; i++)
        {
            int val = num[i] - '0';
            if(i & 1)
                sum1 += val;
            else
                sum2 += val;
        }
        return (sum1 == sum2);
    }
};",1441283517
RONAK GARG,Ronak9910,219,3637,cpp,"class Solution {
private:
    long long modInv(long long a, int m) {
        long long res = 1, base = a, p = m - 2;
        while (p > 0) {
            if (p & 1) res = (res * base) % m;
            base = (base * base) % m;
            p >>= 1;
        }
        return res;
    }

    long long comb(int n, int k, const vector<long long>& fact, const vector<long long>& inv_fact) {
        if (k > n) return 0;
        return ((fact[n] * inv_fact[k]) % MOD * inv_fact[n - k]) % MOD;
    }

    static const int MOD = 1e9 + 7;

public:
    int countBalancedPermutations(const std::string& num) {
        int len = num.length();
        int total = 0;
        for(auto i : num)
                total += (i - '0');
        if (total % 2 != 0) return 0;

        int half = total / 2;
        int m = (len + 1) / 2;
        std::vector<int> cnt(10, 0);
        for (char d : num) cnt[d - '0']++;

        vector<long long> fact(len + 1, 1);
        for (int i = 1; i <= len; i++) fact[i] = (fact[i - 1] * i) % MOD;

        vector<long long> inv_fact(len + 1, 1);
        inv_fact[len] = modInv(fact[len], MOD);
        for (int i = len - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;

        vector<vector<long long>> dp(m + 1, vector<long long>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            for (int k = m; k >= 0; k--) {
                for (int s = half; s >= 0; s--) {
                    if (dp[k][s] == 0) continue;
                    for (int t = 1; t <= cnt[d]; t++) {
                        if (k + t > m || s + d * t > half) break;
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(cnt[d], t, fact, inv_fact)) % MOD;
                    }
                }
            }
        }

        long long w = dp[m][half];
        long long res = (fact[m] * fact[len - m]) % MOD;
        for (int d = 0; d < 10; d++) res = (res * inv_fact[cnt[d]]) % MOD;
        res = (res * w) % MOD;
        return (res);
    }
};
",1441383218
Sam Chen,SamChen856,220,3627,python3,"class Solution:
    # Dijkstra, priority queue, time O(nmlog(nm)), space O(nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]  # (current time, x, y)
        
        while pq:
            t, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + 1
                    if dist[nx][ny] > new_t:
                        dist[nx][ny] = new_t
                        heappush(pq, (new_t, nx, ny))

        assert False",1441304382
Sam Chen,SamChen856,220,3628,python3,"class Solution:
    # Dijkstra, priority queue, time O(2nmlog(nm)), space O(2nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[[inf] * m for _ in range(n)] for _ in range(3)]
        dist[1][0][0] = 0  # (speed, x, y)
        pq = [(0, 1, 0, 0)]  # (current time, speed, x, y)

        while pq:
            t, s, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[s][x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + s
                    new_s = 3 - s
                    if dist[new_s][nx][ny] > new_t:
                        dist[new_s][nx][ny] = new_t
                        heappush(pq, (new_t, new_s, nx, ny))

        assert False
        ",1441312485
Sam Chen,SamChen856,220,3636,python3,"class Solution:
    # 1 pass, time O(n), space O(1)
    def isBalanced(self, num: str) -> bool:
        sums = [0, 0]
        for i, x in enumerate(num):
            sums[i % 2] += int(x)
        return sums[0] == sums[1]",1441289057
Sam Chen,SamChen856,220,3637,python3,"M = 1000
MOD = 10**9 + 7

fact = [1] * (M + 1)
for i in range(M):
    fact[i + 1] = fact[i] * (i + 1) % MOD
inv_fact = [1] * (M + 1)
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for i in reversed(range(M)):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


class Solution:
    # DP + combinatorics, time O(100L^3), space O(10L^2), L = num.length
    def countBalancedPermutations(self, num: str) -> int:
        num = list(map(int, num))

        target_sum = sum(num)
        if target_sum % 2:
            return 0
        target_sum //= 2

        L = len(num)
        L_even = (L + 1) // 2
        cnt = Counter(num)
        dp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
        dp[0][0] = 1

        for d in range(10):
            ndp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
            for i in range(L_even + 1):
                for j in range(target_sum + 1):
                    if dp[i][j] == 0:
                        continue
                    for c in range(min(cnt[d], L_even - i) + 1):
                        ni, nj = i + c, j + d * c
                        if nj <= target_sum:
                            ndp[ni][nj] = (ndp[ni][nj] + dp[i][j] * inv_fact[c] * inv_fact[cnt[d] - c]) % MOD
            dp = ndp

        return fact[L_even] * fact[L - L_even] * dp[L_even][target_sum] % MOD",1441383568
Ayush Sharma,ayush-018,221,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        int r = moveTime.size();
        int c = moveTime[0].size();

        vector<vector<int>> minDist(r, vector<int>(c, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;

        minHeap.push({0, 0, 0}); // {time, row, col}
        minDist[0][0] = 0;

        vector<vector<int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!minHeap.empty()) {
            auto current = minHeap.top();
            minHeap.pop();
            int cT = current[0];
            int cR = current[1];
            int cC = current[2];

            if (cT > minDist[cR][cC]) continue;

            for (const auto& d : direction) {
                int newRow = cR + d[0];
                int newCol = cC + d[1];

                if (newRow >= 0 && newRow < r && newCol >= 0 && newCol < c) {
                    int newTime = max(cT, moveTime[newRow][newCol]) + 1;

                    if (newTime < minDist[newRow][newCol]) {
                        minDist[newRow][newCol] = newTime;
                        minHeap.push({newTime, newRow, newCol});
                    }
                }
            }
        }

        return minDist[r - 1][c - 1] == INT_MAX ? -1 : minDist[r - 1][c - 1];

    }
};",1441321399
Ayush Sharma,ayush-018,221,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<int>>> minTime(n, vector<vector<int>>(m, vector<int>(2, numeric_limits<int>::max())));
        minTime[0][0][0] = 0;

        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> gPq;
        gPq.push({0, {0, 0, 0}});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!gPq.empty()) {
            auto [currentTime, pos] = gPq.top();
            gPq.pop();
            int row = pos[0], col = pos[1], parity = pos[2];

            if (currentTime > minTime[row][col][parity]) continue;

            for (auto [dx, dy] : directions) {
                int x = row + dx;
                int y = col + dy;

                if (x >= 0 && x < n && y >= 0 && y < m) {
                    int nextTime = max(currentTime, moveTime[x][y]) + (parity == 0 ? 1 : 2);
                    
                    if (nextTime < minTime[x][y][1 - parity]) {
                        minTime[x][y][1 - parity] = nextTime;
                        gPq.push({nextTime, {x, y, 1 - parity}});
                    }
                }
            }
        }
        
        return min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
};",1441327061
Ayush Sharma,ayush-018,221,3636,cpp,"class Solution {
private:
    int calculateEven(const string& num) {
        int evenSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            }
        }
        return evenSum;
    }

    int calculateOdd(const string& num) {
        int oddSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 != 0) {
                oddSum += num[i] - '0';
            }
        }
        return oddSum;
    }
public:
    bool isBalanced(string num) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int evenSum = calculateEven(num);
        int oddSum = calculateOdd(num);
        if(evenSum==oddSum) return true;
        else return false;
    }
};",1441291164
Ayush Sharma,ayush-018,221,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int n = num.size();
        int evenC = (n + 1) / 2;
        int oddC = n / 2;

        string inputString = num;
        int digitCount[10] = {0};
        for (char digit : num) {
            digitCount[digit - '0']++;
        }

        long long totalSum = 0;
        for (int digit = 0; digit < 10; digit++) {
            totalSum += (long long)digit * digitCount[digit];
        }

        if (totalSum % 2 != 0) return 0;

        long long targetSum = totalSum / 2;
        vector<long long> factorial = preFact(80, MOD);
        vector<long long> invFact = ComputeFact(factorial, MOD);

        auto comb = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFact[k] % MOD * invFact[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenC + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int digit = 0; digit < 10; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int t = evenC; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int k = 1; k <= digitCount[digit] && t + k <= evenC && s + (long long)digit * k <= targetSum; k++) {
                        dp[t + k][s + (long long)digit * k] = (dp[t + k][s + (long long)digit * k] + dp[t][s] * comb(digitCount[digit], k)) % MOD;
                    }
                }
            }
        }

        long long validAssign = dp[evenC][targetSum];
        long long productFactorial = 1;
        for (int digit = 0; digit < 10; digit++) {
            productFactorial = productFactorial * factorial[digitCount[digit]] % MOD;
        }

        long long result = validAssign;
        result = result * factorial[evenC] % MOD;
        result = result * factorial[oddC] % MOD;
        long long inverseProduct = power(productFactorial, MOD - 2, MOD);
        result = result * inverseProduct % MOD;

        return (int)result;
    }

private:
    vector<long long> preFact(int maxValue, int mod) {
        vector<long long> factorial(maxValue + 1, 1);
        for (int i = 1; i <= maxValue; i++) {
            factorial[i] = factorial[i - 1] * i % mod;
        }
        return factorial;
    }

    vector<long long> ComputeFact(const vector<long long>& factorial, int mod) {
        int maxValue = factorial.size() - 1;
        vector<long long> invFact(maxValue + 1, 1);
        invFact[maxValue] = power(factorial[maxValue], mod - 2, mod);
        for (int i = maxValue - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod;
        }
        return invFact;
    }

    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }
};
",1441365481
Evan Tian,etian6795,222,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][] d = new long[n][m];
        boolean[][] seen = new boolean[n][m];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = Long.MAX_VALUE;
            }
        }
        d[0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[2], b[2]));
        pq.add(new long[]{0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            long time = curr[2];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y]) continue;
            seen[x][y] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + 1;

                    if(next <= moveTime[nx][ny] + 1) {
                        next = moveTime[nx][ny] + 1;
                    }


                    if(next < d[nx][ny]) {
                        d[nx][ny] = next;
                        pq.add(new long[]{nx, ny, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342435
Evan Tian,etian6795,222,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][][] d = new long[n][m][2];
        boolean[][][] seen = new boolean[n][m][2];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                Arrays.fill(d[i][j], Long.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[3], b[3]));
        pq.add(new long[]{0, 0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            int p = (int)curr[2];
            long time = curr[3];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y][p]) continue;
            seen[x][y][p] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + ((p == 0) ? 1 : 2);

                    if(next <= moveTime[nx][ny] + ((p == 0) ? 1 : 2)) {
                        next = moveTime[nx][ny] + ((p == 0) ? 1 : 2);
                    }

                    int nextp = 1 - p;

                    if(next < d[nx][ny][nextp]) {
                        d[nx][ny][nextp] = next;
                        pq.add(new long[]{nx, ny, nextp, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342250
Evan Tian,etian6795,222,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int e = 0;
        int o = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = Character.getNumericValue(num.charAt(i));
            if (i % 2 == 0) {
                e += digit;
            } else {
                o += digit;
            }
        }

        return e == o;
    }
}",1441343466
Evan Tian,etian6795,222,3637,java,"class Solution {
    public long MOD = 1_000_000_007;
    public long[] fact;
    public long[] invFact;
    public int n;
    public int[] f = new int[10];
    Map<String, Long> memo;

    public int countBalancedPermutations(String num) {
        for(char c : num.toCharArray()){
            f[c - '0']++;
        }
        n = num.length();

        int target = 0;
        for(int i = 0; i <= 9; i++) {
            target += i * f[i];
        }

        if(target % 2 != 0){
            return 0;
        }
        target /= 2;

        int e = (n + 1) / 2;
        int o = n / 2;

        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        invFact[n] = expo(fact[n], MOD - 2);
        for(int i = n - 1; i >= 0; i--){
            invFact[i] = (invFact[i+1] * (i+1)) % MOD;
        }

        memo = new HashMap<>();

        long qwe = rec(0, target, e);

        long asd = 1;
        for(int i = 0; i <= 9; i++) {
            if(f[i] > n) {
                return 0;
            }
            asd = (asd * fact[f[i]]) % MOD;
        }
        asd = expo(asd, MOD - 2);

        long ans = fact[e] * fact[o] % MOD;
        ans = (ans * qwe) % MOD;
        ans = (ans * asd) % MOD;

        return (int)(ans);
    }

    private long rec(int digit, int sum, int count){
        String key = digit + "","" + sum + "","" + count;

        if(memo.containsKey(key)){
            return memo.get(key);
        }

        if(digit == 10){
            if(sum == 0 && count == 0){
                return 1;
            }
            else{
                return 0;
            }
        }

        if(sum < 0 || count < 0){
            return 0;
        }

        long total = 0;
        int max = Math.min(count, f[digit]);
        for(int i = 0; i <= max; i++){
            if(i * digit > sum){
                break;
            }
            
            long qwe = combination(f[digit], i);

            total = (total + qwe * rec(digit + 1, sum - i * digit, count - i)) % MOD;
        }

        memo.put(key, total);
        return total;
    }

    private long combination(int n, int k){
        if(k < 0 || k > n){
            return 0;
        }
        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;
    }

    private long expo(long a, long b){
        long res =1;
        a %= MOD;
        while(b >0){
            if( (b &1) ==1 ){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>=1;
        }
        return res;
    }
}
",1441384193
Paridhi Agarwal,paridhi_,224,3627,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>
#include <array>

class Solution
{
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, std::numeric_limits<int>::max()));
        int i = 0;
        if (n > 0)
            do
            {
                std::fill(dist[i].begin(), dist[i].end(), std::numeric_limits<int>::max());
                i++;
            }
            while (!(i < n)==false);
        using T = std::array<int, 3>;
        auto cmp = [](const T& a, const T& b) { return a[0] > b[0]; };
        std::priority_queue<T, std::vector<T>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        std::vector<std::vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (; (!(!pq.empty())==false);)
        {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0;
            while (!(dirIndex < dirs.size()) ==false)
            {
                auto dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = std::max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
        }
        return dist[n - 1][m - 1];
    }
};
",1441371856
Paridhi Agarwal,paridhi_,224,3628,cpp,"#include <vector>
#include <queue>
#include <array>
#include <climits>
#include <functional>
class Solution
{
public:
    int minTimeToReach(const std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<std::array<int, 2>>> d(n, std::vector<std::array<int, 2>>(m, {INT_MAX, INT_MAX}));
        int i = 0;
        do
        {
            int j = 0;
            while (j < m)
            {
                d[i][j][0] = INT_MAX;
                d[i][j][1] = INT_MAX;
                j++;
            }
            i++;
        }
        while (i < n);
        d[0][0][0] = 0;
        auto cmp = [](const std::array<int, 4>& a, const std::array<int, 4>& b) {
            return a[0] > b[0];
        };
        std::priority_queue<std::array<int, 4>, std::vector<std::array<int, 4>>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0, 0});
        std::vector<std::array<int, 2>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for (; !(!pq.empty()) == false; )
        {
            auto current = pq.top();
            pq.pop();
            int t = current[0];
            int iCur = current[1];
            int jCur = current[2];
            int p = current[3];
            
            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            
            int dirIndex = 0;
            while (!(dirIndex < directions.size()) == false)
            {
                auto dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = std::max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            }
        }
        return std::min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};
",1441353548
Paridhi Agarwal,paridhi_,224,3636,cpp,"#include <string>
class Solution
{
public:
    bool isBalanced(const std::string& num)
    {
        int evenSum = 0;
        int oddSum = 0;
        int i = 0;
        do
        {
            int digit = num[i] - '0';
            if (!(i % 2 == 0) == false) 
                evenSum += digit;
            else
                oddSum += digit;
            i++;
        }
        while (!(i < num.length()) == false);
        return (!(evenSum == oddSum) == false);
    }
};
",1441295940
Paridhi Agarwal,paridhi_,224,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>

class Solution {
private:
    static const int MOD = 1000000007;
    std::vector<long long> fact;
    std::vector<long long> invFact;

    long long powerMod(long long a, long long b) {
        long long res = 1;
        a %= MOD;
        while (b > 0) {
            if (!((b & 1) == 1) == false) {
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void initFact(int n) {
        fact.resize(n + 1);
        invFact.resize(n + 1);
        fact[0] = 1;
        int i = 1;
        do {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        } while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        } while (j >= 0);
    }

public:
    int countBalancedPermutations(std::string num) {
        int n = num.length();
        std::vector<int> freq(10, 0);
        long long totalSum = 0;
        std::vector<char> C(num.begin(), num.end());
        int i = 0;
        if (n > 0) {
            do {
                char c = C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            } while (i < n);
        }

        if (!(totalSum % 2 != 0) == false) {
            return 0;
        }
        long long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        std::vector<std::vector<long long>> dp(k + 1, std::vector<long long>((int)sumHalf + 1, 0));
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0) == false)
            {
                d++;
                continue;
            }
            int c = k;
            while (c >= 0)
            {
                long long s = sumHalf;
                do
                {
                    if (!(dp[c][(int)s] == 0) == false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    while (true)
                    {
                        if (!(t > std::min(freq[d], k - c)) == false)
                            break;
                        if (!(s + (long long)d * t > sumHalf) == false)
                            break;
                        long long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int)(s + d * t)] = (dp[c + t][(int)(s + d * t)] + dp[c][(int)s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                while (s >= 0);
                c--;
            }
            d++;
        }
        while (d <= 9);
        long long validAssignments = dp[k][(int)sumHalf];
        if (!(validAssignments == 0) == false) {
            return 0;
        }
        long long prodFactFd = 1;
        int digit = 0;
        while (digit <= 9)
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        long long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int)answer;
    }
};
",1441396969
jacobj2,jacobj2,225,3627,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[inf]*len(m[0]) for i in range(len(m))]
        dp[0][0] = inf
        heap = [(0,0,0)]
        while heap:
            time, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc] > max(time + 1, m[dr][dc] + 1):
                    dp[dr][dc] = max(time+1,m[dr][dc] + 1)
                    heappush(heap, (dp[dr][dc],dr,dc))
        return -1",1441301318
jacobj2,jacobj2,225,3628,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[[inf,inf] for _ in range(len(m[0]))] for i in range(len(m))]
        dp[0][0][0] = 0
        heap = [(0,0,0,0)]
        while heap:
            time, od, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if od==0:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 1, m[dr][dc] + 1):
                        dp[dr][dc][1-od] = max(time+1,m[dr][dc] + 1)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
                elif od==1:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 2, m[dr][dc] + 2):
                        dp[dr][dc][1-od] = max(time+2,m[dr][dc] + 2)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
        return -1",1441304952
jacobj2,jacobj2,225,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i in range(len(num)):
            if i%2==0:
                e+=int(num[i])
            else:
                o+=int(num[i])
        return e==o",1441280777
jacobj2,jacobj2,225,3637,python3,"MOD = 10**9+7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        tot = 0
        for i in range(len(num)):
            tot+=int(num[i])
        if tot%2==1:
            return 0
        ct = defaultdict(int)
        for i in range(len(num)):
            ct[int(num[i])]+=1
        r1 = len(num) - len(num)//2
        pref = [0]*10
        for i in range(len(pref)):
            pref[i] = ct[i]
            if i > 0:
                pref[i]+=pref[i-1]
        #print(pref)
        @cache
        def dfs(index, remSum, remInd):
            if remSum < 0 or remInd < 0:
                return 0
            if index==10:
                return int(remSum==0 and remInd==0)
            usedOdd = 0 if index==0 else pref[index - 1] - (len(num)//2 - remInd)
            leftOdd = len(num) - len(num)//2 - usedOdd
            if leftOdd < 0:
                return 0
            res = 0
            for x in range(ct[index]+1):
                left = ct[index] - x
                if left > leftOdd:
                    continue
                res+=(((dfs(index+1,remSum-x*index, remInd - x)*math.comb(remInd, x))%MOD)*math.comb(leftOdd,left))%MOD
                if res >= MOD:
                    res-=MOD
            return res
        a = dfs(0,tot//2,len(num)//2)
        dfs.cache_clear()
        return a",1441372719
IphoneX,hahahiehie,226,3627,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + e.w) {
                        if (w + e.w > board[e.to]) {
                            dist[e.to] = w + e.w;
                            q.add(new Edge(e.to, w + e.w));
                        } else {
                            dist[e.to] = board[e.to] + 1;
                            q.add(new Edge(e.to, board[e.to] + 1));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441298213
IphoneX,hahahiehie,226,3628,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            int last;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }

            public Edge(int to, long w, int last) {
                this.to = to;
                this.w = w;
                this.last = last;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0, 2));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                int last = cur.last;
                int nextStep = last == 1 ? 2 : 1;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + nextStep) {
                        if (w + nextStep >= board[e.to] + nextStep) {
                            dist[e.to] = w + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        } else {
                            dist[e.to] = board[e.to] + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441304580
IphoneX,hahahiehie,226,3636,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    public boolean isBalanced(String num) {
        int n = num.length();
        int a = 0;
        int b = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                a += num.charAt(i) - '0';
            } else {
                b += num.charAt(i) - '0';
            }
        }
        return a == b;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441281429
IphoneX,hahahiehie,226,3637,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static Combination comb = new Combination(100, MOD);
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int sum = 0;
        int targetLength0 = 0;
        int targetLength1 = 0;
        long[] digitCount = new long[10];
        for (int i = 0; i < n; i++) {
            sum += num.charAt(i) - '0';
            digitCount[num.charAt(i) - '0']++;
            if (i % 2 == 0) {
                targetLength0++;
            } else {
                targetLength1++;
            }
        }
        if (sum % 2 != 0) return 0;
        int targetSum = sum / 2;


        long[][][] dp = new long[10][n + 1][sum + 1];

        for (int i = 0; i <= digitCount[0] && i <= targetLength0; i++) {
            if (targetLength0 >= i && targetLength1 >= (int) digitCount[0] - i) {
                dp[0][i][0] = comb.C(targetLength0, i) * comb.C(targetLength1, (int) digitCount[0] - i) % MOD;
            }
        }

        int[] preSum = new int[10];
        preSum[0] = (int) digitCount[0];
        for (int i = 1; i < 10; i++) {
            preSum[i] = preSum[i - 1] + (int) digitCount[i];
        }
        for (int i = 1; i <= 9; i++) {

            for (int j = 0; j <= targetLength0; j++) {
                for (int k = 0; k <= targetSum; k++) {
                    if (dp[i - 1][j][k] == 0) continue;

                    for (int c = 0; c <= digitCount[i]; c++) {
                        if (c + j > targetLength0) break;
                        if (c * i + k > targetSum) break;
                        int c2 = (int) digitCount[i] - c;
                        int len2 = targetLength1 - (preSum[i - 1] - j);
                        if (len2 >= 0 && len2 <= targetLength1 && len2 >= c2) {
                            dp[i][j + c][k + c * i] = (dp[i][j + c][k + c * i] + dp[i - 1][j][k] * comb.C(targetLength0 - j, c) % MOD * comb.C(len2, c2)) % MOD;
                        }
                    }
                }
            }
        }
        return (int) dp[9][targetLength0][targetSum];


    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441385012
JOZLEETCODE,JLZ998112,227,3627,java,"class Solution {
    private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][] dist = new int[m][n];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i], Max);
            }
        }
        dist[0][0] = 0;        
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x,y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            if(r==m-1 && c==n-1){
                return cd;
            }
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n && dist[nr][nc] == Max){
                    int nd = Math.max(cd+1, g[nr][nc]+1);
                    dist[nr][nc] = nd;
                    pq.offer(new int[]{nr, nc, nd});
                }
            }
        }
        return -1;
    }
}",1441294725
JOZLEETCODE,JLZ998112,227,3628,java,"class Solution {
     private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][][] dist = new int[m][n][3];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i][j], Max);
            }
        }
        dist[0][0][1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x, y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0, 1});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            int steps = top[3];
            if(r==m-1 && c==n-1){
                return cd;
            }
            int nsteps = (steps == 1?2:1);
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n ){
                    int nd = Math.max(cd+steps, g[nr][nc]+steps);
                    if(dist[nr][nc][nsteps] > nd){
                        dist[nr][nc][nsteps] = nd;
                        pq.offer(new int[]{nr, nc, nd, nsteps});
                    }
                }
            }
        }
        return -1;
    }
}",1441305565
JOZLEETCODE,JLZ998112,227,3636,java,"class Solution {
    public boolean isBalanced(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int odd = 0;
        int even = 0;
        for(int i=0; i<n; ++i){
            int cind = c[i]-'0';
            if(i%2==0){
                even += cind;
            }else{
                odd += cind;
            }
        }
        return odd == even;
    }
}",1441283731
JOZLEETCODE,JLZ998112,227,3637,java,"class Solution {
    private final long Mod = (long) (1e9 + 7);
    private long[][][] dp;
    private int oddi = 0;
    private int eveni = 0;
    private long sum = 0;
    private final int nums = 10;

    public int countBalancedPermutations(String s) {
        int n = s.length();
        initfact();
        oddi = 0;
        eveni = 0;
        sum = 0;

        int[] count = new int[10];

        for (int i = 0; i < n; ++i) {
            int cind = s.charAt(i) - '0';
            ++count[cind];
            if (i % 2 == 0) {
                ++eveni;
            } else {
                ++oddi;
            }
            sum += cind;
        }
        dp = new long[nums][800][oddi + 1];

        for (int i = 0; i < nums; ++i) {
            for (int j = 0; j < 800; ++j) {
                Arrays.fill(dp[i][j], -1);
            }

        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        long rt = solve(count, 0, 0, oddi);

        return (int) rt;
    }

    private long solve(int[] a, int i, int osum, int indexes) {
        if (indexes < 0) {
            return 0;
        }
        if (i == nums) {
            if (osum != sum || indexes != 0) {
                return 0;
            } else {
                long ep = fact[eveni];
                long op = fact[oddi];
                long res = ep * op;
                res %= Mod;
                return res;
            }
        }
        if (dp[i][osum][indexes] != -1) {
            return dp[i][osum][indexes];
        }
        long res = 0;
        for (int j = 0; j <= a[i]; ++j) {
            int nosum = osum + j * i;
            long cur = solve(a, i + 1, nosum, indexes - j);
            cur *= modinverse(fact[j]);
            cur %= Mod;
            int toodd = a[i] - j;
            cur *= modinverse(fact[toodd]);
            cur %= Mod;
            res += cur;
            res %= Mod;
        }
        dp[i][osum][indexes] = res;
        return res;
    }

    private long[] fact = new long[101];

    private void initfact() {
        fact[0] = 1;
        for (int i = 1; i <= 100; ++i) {
            fact[i] = fact[i - 1] * i;
            fact[i] %= Mod;
        }
    }

    private long modinverse(long a) {
        long m = Mod;
        long y = 0;
        long x = 1;
        while (a > 1) {
            long q = a / m;
            long t = m;
            m = a % m;
            a = t;
            t = y;
            y = x - q * y;
            x = t;
        }
        if (x < 0) {
            x += Mod;
        }
        return x;
    }
}",1441372874
Kalix1110,Kalix1110,229,3627,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vll dis(n+5,vl(m+5,1e13));
        
        priority_queue<vl,vll,greater<vl>>pq;
        dis[0][0]=0;
        pq.push({0,0,0});
        
        while(pq.size()>0){
            auto p=pq.top();
            pq.pop();
            ll wt=p[0];
            int x=p[1];
            int y=p[2];
            
            if(wt>dis[x][y]) continue;
            for(auto &it:delta1){
                int nx=x+it[0];
                int ny=y+it[1];
                
                if(nx<0 || ny<0 || nx>=n || ny>=m) continue;
                ll d=max(wt,(ll)v[nx][ny])+1;
                if(d < dis[nx][ny]){
                    dis[nx][ny]=d;
                    pq.push({d,nx,ny});
                }
            }
        }
        
        return dis[n-1][m-1];
    }
};",1441297076
Kalix1110,Kalix1110,229,3628,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size(), m = v[0].size();
        
        // 3D distance array: dis[x][y][iinc] where iinc is 0 or 1
        vector<vector<vector<long long>>> dis(n, vector<vector<long long>>(m, vector<long long>(2, 1e13)));
        
        // Priority queue for Dijkstra's algorithm
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        
        // Initialize starting point
        dis[0][0][0] = 0;
        pq.push({0, 0, 0, 0});  // {distance, x, y, iinc}
        
        // Direction vectors for 4 possible moves
        vector<vector<int>> delta1 = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            
            long long wt = p[0];
            int x = p[1];
            int y = p[2];
            int iinc = p[3];
            
            // Skip if this path is outdated
            if (wt > dis[x][y][iinc]) continue;
            
            // Traverse through all possible moves
            for (auto &it : delta1) {
                int nx = x + it[0];
                int ny = y + it[1];
                
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                
                // Calculate new distance
                long long d = max(wt, (long long)v[nx][ny]) + iinc + 1;
                int new_iinc = 1 - iinc;  // Toggle increment for the next step
                
                if (d < dis[nx][ny][new_iinc]) {
                    dis[nx][ny][new_iinc] = d;
                    pq.push({d, nx, ny, new_iinc});
                }
            }
        }
        
        // Get the minimum time to reach the bottom-right corner
        return min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
    }
};
",1441331796
Kalix1110,Kalix1110,229,3636,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool isBalanced(string num) {
        ll a=0,b=0;
        int f=0;
        for(auto &it:num){
            if(f) a+=it-'0';
            else b+=it-'0';
            
            f=!f;
        }
        
        return a==b;
    }
};",1441281597
Kalix1110,Kalix1110,229,3637,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

ll power(ll a,ll n , ll mod=MOD){
	a%=mod;
    ll res=1;
    while(n){
        if(n%2){
            res=res*a;
			res%=mod;
            n--;
        }else{
            a=(a*a);
			a%=mod;
            n/=2;
        }
    }
    
    return res;
}



const int N=100;

// array to store inverse of 1 to N 
ll  factorialNumInverse[N + 1]; 
  
// array to precompute inverse of 1! to N! 
ll  naturalNumInverse[N + 1]; 
  
// array to store factorial of first N numbers 
ll  fact[N + 1]; 


void factorial(ll  p=MOD) 
{ 
    fact[0] = 1; 
  
    // precompute factorials 
    for (ll i = 1; i <= N; i++) { 
        fact[i] = (fact[i - 1] * i) % p; 
    } 
} 

ll inv(ll x){
    return power(fact[x],MOD-2);
}

class Solution {
public:
    ll dp[85][900][50];
    int n;
    ll solve(int i,int sum,int odd,string &s){
        
        if(sum<-400) return 0;
        if(i==s.size()){
            // cout<<sum<<endl;
            if(sum==0) return 1;
            return 0;
        }
        if(dp[i][sum+400][odd] != -1) return dp[i][sum+400][odd];
        
        ll ans=0;
        ll even=(n-i)-odd;
        if(odd>0) ans+=(solve(i+1,sum-(s[i]-'0'),odd-1,s)*odd)%MOD;
        ans%=MOD;
        
        if(even>0) ans+=(solve(i+1,sum+(s[i]-'0'),odd,s)*even)%MOD;
         ans%=MOD;
        
        return dp[i][sum+400][odd]=ans;
    }
    int countBalancedPermutations(string num) {
        memset(dp,-1);
        factorial(MOD); 
         n=num.size();
        ll odd=n/2;
        ll even=n/2;
        if(n%2) odd++;
        ll ans= solve(0,0,odd,num);
        vl v(10);
        for(auto &it:num) v[it-'0']++;
        for(int i=0;i<10;i++){
            if(v[i]==0) continue;
            ans*=inv(v[i]);
            ans%=MOD;
        }
        
        return ans;
    }
};",1441372921
dapu81000,dapu81000,232,3627,cpp,"class Solution {
public:
    int dp[55][55] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        #define pii pair<int,int>
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        pq.push({0, 0});
        while(!pq.empty()){
            pii tmp = pq.top();pq.pop();
            int x = tmp.second/m, y = tmp.second%m, dist = tmp.first;
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+1, moveTime[xx][yy]+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441306672
dapu81000,dapu81000,232,3628,cpp,"class Solution {
public:
    int dp[755][755] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0});
        while(!pq.empty()){
            vector<int> v=pq.top();pq.pop();
            int x = v[1]/m, y = v[1]%m, dist = v[0], add = v[2];
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+add+1, moveTime[xx][yy]+add+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy, !add});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441314240
dapu81000,dapu81000,232,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int res[2] = {};
        for(int i=0;i<num.size();i++){
            int cur = (i&1)^1;
            res[cur] += num[i]-'0';
        }
        return res[0] == res[1];
    }
};",1441281741
dapu81000,dapu81000,232,3637,cpp,"class Solution {
public:
    int dp[41][401] = {};
    int fac[88] = {};
    const int mod = 1e9+7;
    void build(){
        fac[0] = fac[1] = 1;
        for(int i=2;i<=80;i++){
            fac[i] = (1ll*fac[i-1]*i)%mod;
        }
    }
    int powmod(long long x,int n){
        long long res = 1;
        while(n){
            if(n&1) res = (res*x)%mod;
            x = (x*x)%mod;
            n>>=1;
        }
        return res;
    }
    int cnt[10] = {};
    int countBalancedPermutations(string num) {
        build();
        int tot = 0;
        for(char ch:num) tot += ch-'0', cnt[ch-'0']++;
        if(tot&1) return 0;
        if(tot==1) return 1;
        int mid = tot/2, n = num.size();
        dp[0][0] = 1;

        for(int i=0;i<n;i++){
            int cur = num[i]-'0';
            for(int j=min(i+1,n/2);j>0;j--){
                for(int k=mid;k>=cur;k--){
                    dp[j][k] += dp[j-1][k-cur];
                    dp[j][k] %= mod;
                }
            }
        }
        long long res = dp[n/2][mid];
        res = (res*fac[n/2])%mod;
        res = (res*fac[n-n/2])%mod;

        for(int i=0;i<=9;i++){
            if(cnt[i]>1){
                res = (res*powmod(fac[cnt[i]],mod-2))%mod;
            }
        }
        return res;
    }
};",1441367211
Anh Ti Trn,anh_tai,234,3627,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 );
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441372865
Anh Ti Trn,anh_tai,234,3628,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 + f);
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441371858
Anh Ti Trn,anh_tai,234,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0, mul = 1;
        for (char&c : num){
            s += mul * (c - '0');
            mul = mul * -1;
        }
        return s == 0; 
    }
};",1441350523
Anh Ti Trn,anh_tai,234,3637,cpp,"int fact[81], ifact[81];

const int mod = 1e9 + 7;

int add(int u, int v){
    u += v;
    if (u >= mod) u -= mod;
    return u; 
}

int sub(int u, int v){
    return add(u, mod - v);
}

int mul(int u, int v){
    return 1LL * u * v % mod;
}

int power(int u, int v){
    int res = 1;
    while (v > 0){
        if (v & 1){
            res = mul(res, u);
        }
        u = mul(u, u);
        v >>= 1;
    }
    return res; 
}

void init(){
    if (fact[0] > 0){
        return; 
    }
    
    fact[0] = ifact[0] = 1;
    for (int i = 1; i <= 80; i++){
        fact[i] = mul(fact[i-1],i);
        ifact[i] = power(fact[i], mod - 2);
        //cout << i << "" "" << fact[i] << "" "" << ifact[i] << ""\n""; 
    }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        init(); 
        int n = num.size();
        vector<int> cnt(10);
        int tot = 0; 
        for (char& c : num){
            cnt[c - '0']++;
            tot += (c - '0');
        }

        if (tot&1){
            return 0; 
        }

        tot >>= 1; 
        vector<vector<int>> dp(41, vector<int>(361)), ndp(41, vector<int>(361)); 
        dp[0][0] = 1;

        // for (int sum = 0; sum <= tot; sum++){
        //     for (int digits = 0; digits <= (n + 1) / 2; digits++){
        //         for (int d = 0; d < 10; d++){
        //             for (int sk = 0; sk <= cnt[d];sk++){
        //                 int n_sum = sum + sk * d;
        //                 int n_digits = digits + sk;
        //                 if (n_sum <= tot && n_digits <= (n + 1) / 2){
        //                     ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], ifact[sk]));
        //                 }
        //             }
        //         }
        //     }
        // }
        
        for (int d = 0; d < 10; d++){
            for (int sk = 0; sk <= cnt[d]; sk++){
                for (int sum = 0; sum <= tot; sum++){
                    for (int digits = 0; digits <= (n + 1) / 2; digits++){
                        int n_sum = sum + sk * d;
                        int n_digits = digits + sk;
                        if (n_sum <= tot && n_digits <= (n + 1) / 2){
                            ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], mul(ifact[sk], ifact[cnt[d] - sk])));
                        }
                    } 
                }   
            }

            for (int sum = 0; sum <= tot; sum++){
                for (int digits = 0; digits <= (n + 1) / 2; digits++){
                    dp[digits][sum] = ndp[digits][sum];
                    ndp[digits][sum] = 0; 
                }
             }
        }
        
        int ans = mul(fact[(n + 1) / 2], dp[(n + 1) / 2][tot]);
        ans = mul(ans, fact[n -(n + 1) / 2]);
        return ans; 
    }
};",1441385911
Pikachu0123,Pikachu0123,236,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        queue<vector<int>> q;
        q.push({0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.front()[0];
            int c = q.front()[1];
            int d = q.front()[2];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = d;
                if (d < moveTime[nr][nc]){
                    new_d = moveTime[nr][nc];
                }
                if (new_d + 1 < dis[nr][nc]){
                    dis[nr][nc] = new_d + 1;
                    q.push({nr, nc, new_d + 1});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441298296
Pikachu0123,Pikachu0123,236,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.top()[1];
            int c = q.top()[2];
            int d = -q.top()[0];
            int type = q.top()[3];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = max(d, moveTime[nr][nc]);
                int cost = new_d + (type == 0 ? 1 : 2);
                if (cost < dis[nr][nc]){
                    dis[nr][nc] = cost;
                    q.push({-cost,nr, nc, !type});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441303211
Pikachu0123,Pikachu0123,236,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i=0; i<n; i+=2) sum1 += num[i]-'0';
        for(int i=1; i<n; i+=2) sum2 += num[i] - '0';
        return sum1 == sum2;
    }
};",1441281379
Pikachu0123,Pikachu0123,236,3637,cpp,"
const int mod = 1e9 + 7;
const int offset = 730;
long long dp[10][1500][42];
long long ncr[101][101];

void precompute_nCr() {
    for (int i = 0; i <= 100; ++i) {
        ncr[i][0] = ncr[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;
        }
    }
}

class Solution {
long long solve(int i,  int sum, int odd, int even, vector<int> &freq){
    if (i == 10){
        if (sum == 0) return 1;
        else return 0;
    }
    if (freq[i] == 0){
        return solve(i + 1, sum, odd, even, freq);
    }
    if (dp[i][sum+offset][even] != -1) return dp[i][sum+offset][even];
    long long ans = 0;
    int val = freq[i];
    for(int j=0; j<=val; j++){
        int taken_odd = j;
        int taken_even = val - j;
        if (odd >= taken_odd and even >= taken_even){
            (ans += ((ncr[odd][taken_odd] * 1LL * ncr[even][taken_even]) % mod * solve(i + 1, sum - i * taken_odd + i * taken_even, odd - taken_odd, even - taken_even, freq)) % mod) %= mod;
        }
    }
    return dp[i][sum+offset][even] = ans;
}
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> freq(10, 0);
        
        for(char &ch : num)
            freq[ch-'0'] += 1;
        int odd = (n + 1) / 2, even = n / 2;
        memset(dp, -1, sizeof dp);
        memset(ncr, 0, sizeof ncr);
        precompute_nCr();
        return solve(0, 0, odd, even, freq);
    }
};",1441369861
pooyaz,pooyaz,237,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        vector<vector<int>> cnt(n, vector<int>(m, -1));
        priority_queue<vector<int>> q;
        q.push({0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2];
            if(cnt[i][j] != -1) continue;
            cnt[i][j] = dis;
            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj] == -1){
                    int ndist = max(t[ni][nj], dis) + 1;
                    q.push({-ndist, ni, nj});
                }
            }
        }
        return cnt[n - 1][m - 1];
    }
};",1441319916
pooyaz,pooyaz,237,3628,cpp,"class Solution {
public:
    int cnt[760][760][2];
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        memset(cnt, -1, sizeof cnt);
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2], s = v[3];
            if(cnt[i][j][s] != -1) continue;
            
            cnt[i][j][s] = dis;
            if(i == n - 1 && j == m - 1) break;

            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                int ns = 1 - s;
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj][ns] == -1){
                    int ndist = max(t[ni][nj], dis) + 1 + s;
                    q.push({-ndist, ni, nj, ns});
                }
            }
        }
        if(cnt[n - 1][m - 1][0] == -1){
            return cnt[n - 1][m - 1][1];
        }
        else if(cnt[n - 1][m - 1][1] == -1){
            return cnt[n - 1][m - 1][0];
        }
        return min(cnt[n - 1][m - 1][0], cnt[n - 1][m - 1][1]);
    }
};",1441331858
pooyaz,pooyaz,237,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.length(); i++){
            if(i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281862
pooyaz,pooyaz,237,3637,cpp,"#define Mod 1000000007L

class Solution {
public:
    int n;
    int sum[11];
    int dig[11];
    int cnt[11] = {};
    long long com[50][50] = {};
    long long dp[11][50][500];

    long long mem(int idx, int sp, int rem){
        if(idx == 10){
            return sp == 0 && rem == 0;
        }
        long long& ref = dp[idx][sp][rem];
        if(ref != -1) return ref;
        ref = 0;

        int sp2 = dig[idx] - sp;
        int rem2 = sum[idx] - rem;
        for(int i = 0; i <= cnt[idx]; i++){
            if(i > sp || i * idx > rem) continue;
            if(cnt[idx] - i > sp2 || (cnt[idx] - i) * idx > rem2) continue;
            long long nex = mem(idx + 1, sp - i, rem - i * idx);
            long long c1 = com[i][sp];
            long long c2 = com[cnt[idx] - i][sp2];
            // cout << idx << ' ' << sp << ' ' << rem << ' ' << i << ' ' << nex << ' ' << c1 << ' ' << c2 << endl;
            ref = (ref + nex * (c1 * c2 % Mod)) % Mod;
            // cout << ref << endl;
        }
        return ref;
    }
    int countBalancedPermutations(string num) {
        n = num.length();
        memset(dp, -1, sizeof dp);
        for(int i = 0; i < n; i++){
            int d = num[i] - '0';
            cnt[d]++;
        }
        for(int i = 9; i >= 0; i--){
            sum[i] = sum[i + 1] + cnt[i] * i;
            dig[i] = dig[i + 1] + cnt[i];
        }
        if(sum[0] % 2) return 0;
        for(int i = 0; i <= dig[0] / 2 + 1; i++){
            com[0][i] = 1;
            com[i][i] = 1;
        }
        for(int i = 1; i <= dig[0] / 2 + 1; i++){
            for(int j = 1; j < i; j++){
                com[j][i] = (com[j - 1][i - 1] + com[j][i - 1]) % Mod;
                // cout << i << ' ' << j << ' ' << com[j][i] << ' ' << com[j - 1][i - 1] << ' ' << com[j][i - 1] << endl;
            }
        }
        
        long long ans = mem(0, dig[0] / 2, sum[0] / 2);
        return (int)ans;
    }
};",1441382229
KGowtham04,KGowtham04,238,3627,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({0, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+1;
                    pq.push({newTime, {newX, newY}});
                    seen[newX][newY] = true;
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }

    

    
};",1441325312
KGowtham04,KGowtham04,238,3628,cpp,"class Solution {
public:
    int n, m;
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({{0, 1}, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first.first;
            int move = pq.top().first.second;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+move;
                    int newMove = move == 2 ? 1 : 2; 
                    pq.push({{newTime, newMove}, {newX, newY}});
                    seen[newX][newY] = true;
                    
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }       
};",1441338140
KGowtham04,KGowtham04,238,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {

        int odd = 0, even  = 0;

        for(int i=0; i<num.size(); i++){
            if(i%2==0){
                even += num[i] - 48;
            }
            else{
                odd+= num[i] - 48;
            }
        }

        return even == odd;
        
    }
};",1441289755
KGowtham04,KGowtham04,238,3637,cpp,"typedef long long ll;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int MOD = 1e9+7;
                int n = num.size();
        int m = (n + 1) / 2; // Number of even indices (0-based)

        // Count digits
        int count_digits[10] = {0};
        ll sum_total =0;
        for(char ch: num){
            int d = ch - '0';
            count_digits[d]++;
            sum_total += d;
        }

        // If total sum is odd, no balanced permutation exists
        if(sum_total %2 !=0){
            return 0;
        }
        ll sum_target = sum_total /2;

        // Precompute factorial and inverse factorial
        vector<ll> fact(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] * i % MOD;

        // Compute inverse factorial
        vector<ll> inv_fact(n+1,1);
        inv_fact[n] = power_mod_func(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }

        // Compute product of inverse factorials of counts
        // Not needed in the final formula
        // ll inv_fact_prod_counts =1;
        // for(int d=0; d<=9; d++) {
        //     inv_fact_prod_counts = inv_fact_prod_counts * inv_fact[count_digits[d]] % MOD;
        // }

        // Initialize DP
        // dp[k][s] represents the number of ways to assign k digits with sum s, adjusted by inverse factorials
        vector<vector<ll>> dp_prev(m+1, vector<ll>(sum_target +1, 0));
        dp_prev[0][0] =1;

        for(int d=0; d<=9; d++){
            int c_d = count_digits[d];
            if(c_d ==0){
                continue;
            }
            // Initialize next layer
            vector<vector<ll>> dp_next(m+1, vector<ll>(sum_target +1, 0));

            for(int k=0; k<=m; k++){
                for(ll s=0; s<=sum_target; s++){
                    if(dp_prev[k][s] ==0){
                        continue;
                    }
                    // Try assigning t digits of this digit to even positions
                    for(int t=0; t<=c_d && t <= m -k; t++){
                        if(s + (ll)t *d > sum_target){
                            continue;
                        }
                        // Update dp_next
                        dp_next[k +t][s + (ll)t *d] = (dp_next[k +t][s + (ll)t *d] + dp_prev[k][s] * inv_fact[t] % MOD * inv_fact[c_d - t] % MOD) % MOD;
                    }
                }
            }
            // Update dp_prev
            dp_prev = move(dp_next);
        }

        // After processing all digits, check dp_prev[m][sum_target]
        ll dp_final = 0;
        if(m <= n && sum_target <= sum_total){
            dp_final = dp_prev[m][sum_target];
        }

        // Compute the final answer
        // The correct formula is: fact[m] * fact[n -m} * dp_final % MOD
        ll answer = fact[m] * fact[n -m] % MOD;
        answer = answer * dp_final % MOD;

        return (int)answer;
    }
    
   ll power_mod_func(ll x, ll power, ll mod_val) {
        ll result = 1;
        x %= mod_val;
        while(power > 0){
            if(power & 1){
                result = result * x % mod_val;
            }
            x = x * x % mod_val;
            power >>=1;
        }
        return result;
    }
};",1441388333
Varun Deep Saini,sojabhai,240,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<pair<int, int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };
        
        vector<vector<int>> dist(n, vector<int>(m, 1e18));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        pq.emplace(0, make_pair(0, 0));
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            
            int w = curr.first;
            int x = curr.second.first;
            int y = curr.second.second;
            
            if (x == n -1 && y == m -1) {
                return (int)w;
            }
            
            if (w > dist[x][y]) {
                continue;
            }
            
            for (auto &dir : directions) {
                int nx = x + dir.first;
                int ny = y + dir.second;
                
                if (nx >=0 && nx < n && ny >=0 && ny < m) {
                    int timee = max((int)w, (int)moveTime[nx][ny]);
                    int d = timee + 1;
                    
                    if (d < dist[nx][ny]) {
                        dist[nx][ny] = d;
                        pq.emplace(d, make_pair(nx, ny));
                    }
                }
            }
        }
        #undef int
        return 69;
    }
};
",1441374028
Varun Deep Saini,sojabhai,240,3628,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };
        
    struct Compare {
    bool operator()(const vector<long long>& a, const vector<long long>& b) const {
            return a[0] > b[0];
        }
    };

    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist1(n, vector<int>(m, LLONG_MAX));
        vector<vector<int>> dist2(n, vector<int>(m, LLONG_MAX));
        
        priority_queue<vector<int>, vector<vector<int>> , Compare> pq;
        
        dist1[0][0] = 0;
        pq.push({0, 0, 0, 0});
        
        while(!pq.empty()){
            auto current = pq.top();
            pq.pop();
            
            int timee = current[0];
            int i = current[1];
            int j = current[2];
            int k = current[3];
            
            if(i == n-1 && j == m-1){
                return timee;
            }
            
            if( (k == 0 && timee > dist1[i][j]) ||
                (k == 1 && timee > dist2[i][j]) ){
                continue;
            }
            
            for(auto &[di, dj] : directions){
                int ni = i + di;
                int nj = j + dj;
                
                if(ni >= 0 && ni < n && nj >= 0 && nj < m){
                    
                    int cost = (k == 0) ? 1 : 2;
                    
                    int movee = max(timee, (int)moveTime[ni][nj]);
                    
                    int tot = movee + cost;
                    
                    if(k == 1){
                        if(tot < dist1[ni][nj]){
                            dist1[ni][nj] = tot;
                            pq.push({tot, ni, nj, 0});
                        }
                    }
                    else{
                        if(tot < dist2[ni][nj]){
                            dist2[ni][nj] = tot;
                            pq.push({tot, ni, nj, 1});
                        }
                    }
                }
            }
        }
        #undef int
        return -1;

    }
};",1441368729
Varun Deep Saini,sojabhai,240,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even_sum = 0; 
        int odd_sum = 0;  

        for(int i = 0; i < num.length(); ++i){
            if(i % 2 == 0){
                even_sum += num[i] - '0';
            }
            else{
                odd_sum += num[i] - '0';
            }
        }

        return even_sum == odd_sum;

    }
};",1441350550
Varun Deep Saini,sojabhai,240,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MOD = 1e9 + 7;
int z = 0;

int fact[102];
int inv_fact[102];

class Solution {
public:

    void pre() {
        if(z) return;
        z = 1;

        fact[0] = 1;
        for(int i = 1; i <= 101; i++) fact[i] = fact[i-1] * i % MOD;

        inv_fact[101] = power(fact[101], MOD - 2);
        for(int i = 100; i >= 0; i--) inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        
    }

    int power(int a , int b){
        int res = 1;
        a %= MOD;
        while(b > 0){
            if(b & 1){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int comb(int n, int r){
        return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        pre();
        map<int ,int> freq;
        int n = num.length();
        int sum = 0;
        for(auto &i : num){
            freq[i - '0']++;
            sum += i - '0';
        }
        
        if(sum % 2 != 0){
            return 0;
        }
        
        int target = sum / 2;
        
        int even = (n + 1) / 2; 
        int odd = n / 2;       
        
        vector<vector<int>> dp(target + 1, vector<int>(even + 1, 0));
        dp[0][0] = 1;
        
        for(int d = 0; d <= 9; d++){
            if(freq[d] == 0) continue;
            for(int i = target; i >= 0; i--){
                for(int j = even; j >= 0; j--){
                    if(dp[i][j] == 0) continue;

                    // add cnt d
                    for(int cnt = 1; cnt <= freq[d]; cnt++){
                        if(cnt + j > even) break;
                        if(i + cnt*d > target) break;
                        dp[i + cnt*d][j + cnt] = (dp[i + cnt*d][j + cnt] + dp[i][j] * comb(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        
        int ways = dp[target][even];
        
        int den = 1;
        for(int d = 0; d <= 9; d++) den = den * fact[freq[d]] % MOD;
        den = power(den, MOD - 2);

        int ans = ways * fact[even] % MOD;
        ans = ans * fact[odd] % MOD;
        ans = ans * den % MOD;
        
        return ans;
    }
};
#undef int",1441388578
otto,_otto,241,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        hp = []
        heappush(hp, (0, 0, 0))

        while hp:
            curr, r, c = heappop(hp)
            if r == n-1 and c == m-1:
                return curr
            if curr > dist[r][c]:
                continue
            for dr, dc in pairwise([-1, 0, 1, 0, -1]):
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < m:
                    new = max(curr, moveTime[nr][nc]) + 1
                    if new < dist[nr][nc]:
                        dist[nr][nc] = new
                        heappush(hp, (new, nr, nc))
        return -1",1441304953
otto,_otto,241,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        n = len(A)
        m = len(A[0])

        dist = [[[inf] * 2 for _ in range(m)] for _ in range(n)]
        dist[0][0][0] = 0

        hp = []
        heappush(hp, (0, 0, 0, 0))
        while hp:
            t, i, j, p = heappop(hp)
            if i == n-1 and j == m-1:
                return t
            if t > dist[i][j][p]: continue

            for di, dj in pairwise([-1, 0, 1, 0, -1]):
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    curr = max(t, A[ni][nj])
                    cos = 1 if p == 0 else 2
                    new = curr + cos
                    next_p = 1 - p
                    if new < dist[ni][nj][next_p]:
                        dist[ni][nj][next_p] = new
                        heappush(hp, (new, ni, nj, next_p))

        return -1
",1441323111
otto,_otto,241,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        a = b = 0
        for i, x in enumerate(str(num)):
            if i % 2 == 0:
                a += int(x)
            else:
                b += int(x)
        return a == b",1441281200
otto,_otto,241,3637,python3,"MOD = int(1e9 + 7)
MAXN = 81
fac = [1] * (MAXN + 1)
inv_fac = [1] * (MAXN + 1)
for i in range(1, MAXN + 1): fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN] = pow(fac[MAXN], MOD - 2, MOD)
for i in range(MAXN, 0, -1): inv_fac[i - 1] = inv_fac[i] * i % MOD
comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for n in range(MAXN + 1):
    comb[n][0] = 1
    for k in range(1, n + 1):
        comb[n][k] = (comb[n - 1][k - 1] + comb[n - 1][k]) % MOD

class Solution:
    def countBalancedPermutations(self, s: str) -> int:
        n = len(s)
        c = [0] * 10
        fuck = 0
        for ch in s: 
            c[int(ch)] += 1
            fuck += int(ch)
        if fuck % 2 != 0: return 0
        target = fuck // 2
        even = (n + 1) // 2
        odd = n // 2
        dp = [[0] * (even + 1) for _ in range(target + 1)]
        dp[0][0] = 1

        for d in range(10):
            f = c[d]
            if f == 0:
                continue
            ndp = [dp_row[:] for dp_row in dp]
            for s in range(target + 1):
                for cnt in range(even + 1):
                    v = dp[s][cnt]
                    if v == 0:
                        continue
                    for k in range(1, min(f, even - cnt) + 1):
                        news = s + d * k
                        newcnt = cnt + k
                        if news > target or newcnt > even: break
                        ndp[news][newcnt] = (ndp[news][newcnt] + v * comb[f][k]) % MOD
            dp = ndp

        shit = dp[target][even] # slots
        
        # combs
        fuck_even = fac[even]
        for d in range(10):
            for k in range(0, min(c[d], even) + 1):
                if k > even: break
                if target - d * k < 0: break
                if dp[s - d * k][even - k] == 0:continue
                ways = comb[c[d]][k]
                fuck_even = fuck_even * inv_fac[k] % MOD
                break
        fuck_odd = fac[odd]
        for d in range(10):
            fuck_odd = fuck_odd * inv_fac[c[d]] % MOD
        tot = fuck_even * fuck_odd % MOD

        return (shit * tot) % MOD",1441382688
garyjhu,garyjhu,242,3627,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + 1 < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + 1;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441295879
garyjhu,garyjhu,242,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                int e = (x + y) % 2 == 1 ? 1 : 2;
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + e < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + e;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441297024
garyjhu,garyjhu,242,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumE = 0, sumO = 0;
        int n = num.length();
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) sumE += num.charAt(i) - '0';
            else sumO += num.charAt(i) - '0';
        }
        return sumE == sumO;
    }
}
",1441284545
garyjhu,garyjhu,242,3637,java,"import java.util.ArrayList;
import java.util.Arrays;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);
    static long[] invFac;
    public int countBalancedPermutations(String num) {
        if (invFac == null) init();
        int n = num.length();
        int sum = 0;
        int[] count = new int[10];
        for (char c : num.toCharArray()){
            sum += c - '0';
            count[c - '0']++;
        }
        if (sum % 2 == 1) return 0;
        int goal = sum / 2;
        long[][] dp = new long[n + 1][goal + 1];
//        ModIntFactory.ModInt[][] dp = new ModIntFactory.ModInt[n + 1][goal + 1];
//        for (ModIntFactory.ModInt[] row : dp) Arrays.fill(row, factory.create(0));
        dp[0][0] = 1;
//        dp[0][0] = factory.create(1);
        for (int i = 0; i < 10; i++) {
            long[][] tp = new long[n + 1][goal + 1];
//            ModIntFactory.ModInt[][] tp = new ModIntFactory.ModInt[n + 1][goal + 1];
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) tp[j][k] = factory.create(0);
//            }
            for (int j = 0; j < n; j++) {
                for (int k = 0; k <= goal; k++) {
                    for (int l = 0; l <= count[i]; l++) {
                        if (j + l <= n && k + l * i <= goal) {
                            tp[j + l][k + l * i] = (tp[j + l][k + l * i] + factory.create(dp[j][k]).mul(invFac[l]).mul(invFac[count[i] - l]).value);
//                            tp[j + l][k + l * i].addAsg(dp[j][k].mul(factory.factorial(l).mul(factory.factorial(count[i] - l)).inv()));
                        }
                    }
                }
            }
            dp = tp;
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) {
//                    System.out.print(dp[j][k] + "" "");
//                }
//                System.out.println();
//            }
//            System.out.println();
        }
//        System.out.println();
        return factory.factorial(n / 2).mul(factory.factorial((n + 1) / 2)).mul(dp[n / 2][goal]).value;
//        ModIntFactory.ModInt res = dp[n / 2][goal].mul(factory.factorial(n / 2)).mul(factory.factorial((n + 1) / 2));
//        return res.value;
    }
    
    static void init() {
        invFac = new long[100];
        for (int i = 0; i < 100; i++) invFac[i] = factory.factorial(i).inv().value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1441383191
samjack,samjack,243,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time + 1, moveTime[nx][ny] + 1)
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
        
        return -1",1441292166
samjack,samjack,243,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy

                time += ((nx + ny + 1) % 2 + 1)
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time, moveTime[nx][ny] + ((nx + ny + 1) % 2 + 1))
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
                time -= ((nx + ny + 1) % 2 + 1)
        
        return -1
",1441307140
samjack,samjack,243,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum, odd_sum = 0, 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum
",1441281017
samjack,samjack,243,3637,cpp,"#include <bits/stdc++.h>
#define vi vector<int>
#define vb vector<bool>
#define vl vector<long long>
#define vii vector<vector<int>>
#define vll vector<vector<long long>>
#define pi pair<int, int>
#define pl pair<ll, ll>
#define vpi vector<pair<int, int>>
#define vpl vector<pair<ll, ll>>
#define a first 
#define b second
#define pb push_back
#define hset unordered_set
#define hmap unordered_map
#define vm vector<mi>
#define vmm vector<vector<mi>>
using namespace std;
const int MOD = 1e9+7;
using ll = long long;
using big = __int128_t;
using ld = long double;
int uMin(int& a, int b){return a = min(a,b);}
int uMax(int& a, int b){return a = max(a,b);}
struct mi {
  ll v;
  explicit operator int() const { return v; }
  mi() { v = 0; }
  mi(ll _v) : v(_v % MOD) { v += (v < 0) * MOD; }
  bool operator<(const mi& other) const {
    return v < other.v;
  }
  friend std::ostream& operator<<(std::ostream& os, const mi& m) {
      os << m.v;
      return os;
  }
};
mi &operator+=(mi &a, mi b) {
  if ((a.v += b.v) >= MOD) a.v -= MOD;
  return a;
}
mi &operator-=(mi &a, mi b) {
  if ((a.v -= b.v) < 0) a.v += MOD;
  return a;
}
mi operator+(mi a, mi b) { return a += b; }
mi operator-(mi a, mi b) { return a -= b; }
mi operator*(mi a, mi b) { return mi(a.v * b.v); }
mi &operator*=(mi &a, mi b) { return a = a * b; }
mi pow(mi a, ll p) {
  assert(p >= 0);
  return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);
}
mi inv(mi a) {
  assert(a.v != 0);
  return pow(a, MOD - 2);
}
mi operator/(mi a, mi b) { return a * inv(b); }
bool operator==(mi a, mi b) {return a.v == b.v;}
template <class T>
class Matrix {
private:
    vector<std::vector<T>> data;
    size_t size;
public:
    Matrix(size_t n, T v = T()) : size(n), data(n, std::vector<T>(n, v)) {}
    Matrix(const Matrix<T>& other) : size(other.size), data(other.data) {}
    T& operator()(size_t i, size_t j) { return data[i][j]; }
    const T& operator()(size_t i, size_t j) const { return data[i][j]; }
    Matrix<T> operator+(const Matrix<T>& other) const {
        Matrix<T> result(size);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result(i, j) = data[i][j] + other(i, j);
        return result;
    }
    Matrix<T> operator*(const Matrix<T>& other) const {
        Matrix<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                for (size_t k = 0; k < size; ++k)
                    result(i, k) += data[i][j] * other(j, k);
        return result;
    }
    std::vector<T> operator*(const std::vector<T>& vec) const {
        std::vector<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result[j] += data[i][j] * vec[i];
        return result;
    }
    Matrix<T> pow(ll e) const {
        Matrix<T> result = identity(size);
        Matrix<T> base = *this;
        while(e) {
            if(e&1) result = result * base;
            base = base * base;
            e>>=1;
        }
        return result;
    }
    bool operator==(const Matrix<T>& other) const {
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                if (data[i][j] != other(i, j))
                    return false;
        return true;
    }
    static Matrix<T> identity(size_t n) {
        Matrix<T> id(n, 0);
        for (size_t i = 0; i < n; ++i)
            id(i, i) = 1;
        return id;
    }
    friend std::ostream& operator<<(std::ostream& os, const Matrix<T>& matrix) {
        os << ""[\n"";
        for (const auto& row : matrix.data) {
            os << ""\t["";
            for(int i = 0; i<row.size(); i++)
                os << row[i] << (i==row.size()-1?""]\n"":"", "");
        }
        os << ""]\n"";
        return os;
    }
};
template <class T> class BIT {
    int N; vector<T> data;
    bool c, queried;
    public:
    BIT(int _N, bool constant) : c(constant) {
        N = _N+1;
        data.resize(N);
        if(constant) queried = 0;
    }
    void add(int p, T x) { if(c){assert(!queried); data[p]+=x;}else for (p++;p<=N;p+=p&-p) data[p-1]+=x; }
    T sum(int l, int r) { return sum(r)-(l==0?0:sum(l-1)); }
    T sum(int r) { 
        if(c){
            if(!queried){
                queried = 1;
                partial_sum(data.begin(),data.end(),data.begin());
            }
            return data[r];
        }
        T s = 0; r++; for(;r;r-=r&-r)s+=data[r-1]; return s; }
    int lower_bound(T sum) {
        assert(!c);
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1<<25; pw; pw >>= 1) {
            int npos = pos+pw;
            if (npos <= N && data[npos-1] < sum)
                pos = npos, sum -= data[pos-1];
        }
        return pos;
    }
};
template <class T> class RURQ {
    BIT<T> bit1, bit2;
    int sz;
    RURQ(int size) : sz(size), bit1(size), bit2(size) {}
    void add(int start, int end, T value) {
        bit1.add(start, value);
        bit2.add(start, value*(start - 1));
        if(end != sz-1){
            bit1.add(end+1, -value);
            bit2.add(end+1, -value*end);
        }
    }
    T pref(int index) {
        if(index==-1) return 0;
        return (bit1.sum(index))*index-bit2.sum(index);
    }
    T sum(int start, int end) {
        return pref(end)-pref(start-1);
    }
};
struct Line {
    long double m,b;
    Line(long double slope, long double yIntercept) : m(slope), b(yIntercept) {}
    long double getY(long double x) const {
        return m * x + b;
    }
};

struct LineContainer {
    std::vector<Line> lines;
    bool isAbove(const Line& l1, const Line& l2, const Line& l3) const {
        return (l3.b - l1.b) * (l1.m - l2.m) > (l2.b - l1.b) * (l1.m - l3.m);
    }
    void add(long double slope, long double yIntercept) {
        Line newLine(slope, yIntercept);
        while (lines.size() >= 2 && !isAbove(lines[lines.size() - 2], 
                                    lines[lines.size() - 1], newLine))
            lines.pop_back();
        lines.push_back(newLine);
    }
    long double queryMax(long double x) const {
        if (lines.empty())
            return -LLONG_MAX;
        int left = 0, right = lines.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (lines[mid].getY(x) < lines[mid + 1].getY(x))
                left = mid + 1;
            else right = mid;
        }
        return lines[left].getY(x);
    }
};
vl euclid(ll a, ll b) {
    vl x = {1, 0, a};
    vl y = {0, 1, b};
    while(y[2]){
        ll k = x[2] / y[2];
        x[0]-=k*y[0];
        x[1]-=k*y[1];
        x[2]-=k*y[2];
        swap(x, y);
    }
    return x;  // x[0] * a + x[1] * b = x[2], x[2] = gcd(a, b)
}
pl modSolver(vpl& mods){
    pl ans = {mods[0].a,mods[0].b};
    for(int i = 1; i<mods.size(); i++){
        vl g = euclid(ans.b, mods[i].b);
        if((mods[i].a-ans.a)%g[2]) return {-1,-1};
        ans.a+=(mods[i].a-ans.a)/g[2]*ans.b*g[0];
        ans.b = ans.b/g[2]*mods[i].b;
        ans.a%=ans.b;
        ans.a+=ans.b;
        ans.a%=ans.b;
    }
    return ans;
}
int sq(ll n){
    ll a = 0;
    for(int i = 31; i>=0; i--){
        ll x = 1<<i|a;
        if(x*x <= n) a = x;
    }
    return a;
}
struct LZST {
    ll n;
    vector<pair<vl,bool>> nodes; // [[val,min,max,add],isSet]
    vi left,right;
    private:
        void set(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0] = num*(r-l+1);
            g[1] = g[2] = g[3] = num;
            nodes[i].b = 1;
        }
        void add(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0]+=num*(r-l+1);
            g[1]+=num;
            g[2]+=num;
            g[3]+=num;
        }
        void prop(int i, ll l, ll r){
            ll m = l+((r-l)>>1);
            if(left[i] == -1){
                left[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(right[i] == -1){
                right[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(nodes[i].b){
                nodes[i].b = 0;
                if(l != r){
                    ll a = nodes[i].a[3];
                    set(a,left[i],l,m);
                    set(a,right[i],m+1,r);
                }
            }else if(nodes[i].a[3]){
                if(l != r){
                    ll a = nodes[i].a[3];
                    add(a,left[i],l,m);
                    add(a,right[i],m+1,r);
                }
            }
            nodes[i].a[3] = 0;
        }
        void upd(int i){
            vl& g = nodes[i].a, l = nodes[left[i]].a, r = nodes[right[i]].a;
            g[0] = l[0]+r[0];
            g[1] = l[1]<r[1]?l[1]:r[1];
            g[2] = l[2]>r[2]?l[2]:r[2];
        }
        void set(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                set(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) set(s,e,num,left[i],l,m);
            else if(s > m) set(s,e,num,right[i],m+1,r);
            else{
                set(s,m,num,left[i],l,m);
                set(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        void add(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                add(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) add(s,e,num,left[i],l,m);
            else if(s > m) add(s,e,num,right[i],m+1,r);
            else{
                add(s,m,num,left[i],l,m);
                add(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        ll sum(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[0];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return sum(s,e,left[i],l,m);
            if(s > m) return sum(s,e,right[i],m+1,r);
            return sum(s,m,left[i],l,m)+sum(m+1,e,right[i],m+1,r);
        }
        ll min(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[1];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return min(s,e,left[i],l,m);
            if(s > m) return min(s,e,right[i],m+1,r);
            ll a = min(s,m,left[i],l,m), b = min(m+1,e,right[i],m+1,r);
            return a<b?a:b;
        }
        ll max(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[2];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return max(s,e,left[i],l,m);
            if(s > m) return max(s,e,right[i],m+1,r);
            ll a = max(s,m,left[i],l,m), b = max(m+1,e,right[i],m+1,r);
            return a>b?a:b;
        }
    public:
        LZST(ll N){
            n = N;
            nodes.pb({vl(4),0});
            left.pb(-1);
            right.pb(-1);
        }
        void set(ll s, ll e, ll num){
            set(s,e,num,0,0,n-1);
        }
        void add(ll s, ll e, ll num){
            add(s,e,num,0,0,n-1);
        }
        ll sum(ll s, ll e){
            return sum(s,e,0,0,n-1);
        }
        ll min(ll s, ll e){
            return min(s,e,0,0,n-1);
        }
        ll max(ll s, ll e){
            return max(s,e,0,0,n-1);
        }
        ll get(ll s){
            return sum(s,s,0,0,n-1);
        }
        void add(ll s, ll num){
            add(s,s,num,0,0,n-1);
        }
        void set(ll s, ll num){
            set(s,s,num,0,0,n-1);
        }
        friend std::ostream& operator<<(std::ostream& os, LZST& m) {
            os << ""["";
            for(int i = 0; i<m.n; i++) os << m.get(i) << (i==m.n-1?""]"":"", "");
            return os;
        }
};
int dGet(int a, vi& d){return d[a]<0?a:(d[a]=dGet(d[a],d));}
bool unite(int a, int b, vi& d){
    a = dGet(a,d), b = dGet(b,d);
    if(a == b) return 0;
    if(d[a]>d[b]) swap(a,b);
    d[a]+=d[b];
    d[b] = a;
    return 1;
}
int lg(int n){
    int i = 0;
    for(n>>=1; n; n>>=1) i++;
    return i;
}
vector<pair<vm,vm>> genSeeds(int cnt){
    auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();
    mt19937 rng(static_cast<unsigned int>(seed));
    vector<pair<vm,vm>> ans(cnt,{vm(2),vm(2)});
    for(int i = 0; i<cnt; i++){
        ans[i].a[0]=ans[i].b[0]=1;
        ans[i].a[1] = uniform_int_distribution<int>(1,MOD-1)(rng);
        ans[i].b[1] = 1/ans[i].a[1];
    }
    return ans;
}
struct Hash {
    vector<pair<vm,vm>>& h;
    string s;
    vector<pair<BIT<mi>,BIT<mi>>> v;
    void resizeHashes(int n){
        while(h[0].a.size() < n){
            int sz = h[0].a.size();
            for(int i = 0; i<h.size(); i++){
                h[i].a.pb(h[i].a[sz-1]*h[i].a[1]);
                h[i].b.pb(h[i].b[sz-1]*h[i].b[1]);
            }
        }
    }
    Hash(string& str, vector<pair<vm,vm>>& seeds, bool constant=1) : h(seeds),s(str){
        resizeHashes(str.size());
        v.reserve(h.size());
        for(int i = 0; i<h.size(); i++) v.emplace_back(BIT<mi>(s.size(),constant),BIT<mi>(s.size(),constant));
        for(int i = 0; i<s.size(); i++){
            for(int j = 0; j<h.size(); j++){
                v[j].a.add(i,(s[i]+1)*h[j].a[i]);
                v[j].b.add(i,(s[i]+1)*h[j].b[i]);
            }
        }
    }
    void rep(int ind, char c){
        for(int i = 0; i<h.size(); i++){
            v[i].a.add(ind,(c-s[ind])*h[i].a[ind]);
            v[i].b.add(ind,(c-s[ind])*h[i].b[ind]);
        }
        s[ind] = c;
    }
    pair<vm,int> get(int a, int b){
        bool rev = a>b;
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = v[i].b.sum(b,a)*h[i].a[a];
            else ans[i] = v[i].a.sum(a,b)*h[i].b[a];
        return {ans,abs(a-b)+1};
    }
    pair<vm,int> comb(pair<vm,int>& left, pair<vm,int>& right, bool rev=0){
        resizeHashes(rev?right.b:left.b);
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = left.a[i]*h[i].a[right.b]+right.a[i];
            else ans[i] = left.a[i]+right.a[i]*h[i].a[left.b];
        return {ans,left.b+right.b};
    }
};
struct PairHash {
    size_t operator()(const std::pair<std::vector<mi>, int>& p) const {
        return p.a[0].v;
    }
};
class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> cnt(10);
        for(char c: num) cnt[c-'0']++;
        vector<mi> fac(n+1);
        fac[0] = 1;
        for(int i = 1; i<=n; i++) fac[i] = fac[i-1]*i;
        vector<mi> facInv(n+1);
        for(int i = 0; i<=n; i++) facInv[i] = 1/fac[i];
        int sum = 0;
        for(char c: num) sum+=c-'0';
        if(sum&1) return 0;
        vector<vector<mi>> dp((sum>>1)+1,vector<mi>(num.size()/2+1));
        dp[0][0] = fac[n/2]*fac[(n+1)/2];
        for(int i = 0; i<10; i++)
            for(int j = dp.size()-1; j>=0; j--)
                for(int k = dp[j].size()-1; k>=0; k--)
                    for(int l = 0; l<=min(i?j/i:INT_MAX,min(cnt[i],k)); l++)
                        if(l == 0) dp[j][k] = dp[j][k]/fac[cnt[i]];
                        else dp[j][k]+=dp[j-l*i][k-l]*facInv[l]*facInv[cnt[i]-l];
        return dp[dp.size()-1][dp[0].size()-1].v;
    }
};",1441352749
James_067,James_067,245,3627,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 1 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441304201
James_067,James_067,245,3628,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 2 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441303283
James_067,James_067,245,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) 
    {
        int sum1 = 0 , sum2 = 0;
        for( int i = 0; i < s.size(); i++ )
        {
             if(i&1) sum1 += ( s[i] - '0' );
            else sum2 += ( s[i] - '0' );
        }
        return sum1 == sum2;
    }
};",1441281735
James_067,James_067,245,3637,cpp,"
#define MOD 1000000007
#define ll long long

ll mod(ll a, ll m = MOD) { return (a % m + m) % m; }

template <class T>
class Math 
{
public:
    vector<T> fact, invfact;
    Math() {}
    Math(int n) 
    {
        fact.resize(n + 1);
        invfact.resize(n + 1);

        fact[0] = invfact[0] = 1;
        for (int i = 1; i <= n; i++) 
        {
            fact[i] = mod(i * fact[i - 1]);
            invfact[i] = modinv(fact[i]);
        }
    }
    T modinv(T x, T m = MOD) { return expo(x, m - 2, m); }
    T expo(T base, T exp, T m = MOD) 
    {
        T res = 1;
        while (exp) 
        {
            if (exp & 1) res = mod(res * base, m);
            base = mod(base * base, m);
            exp >>= 1;
        }
        return res;
    }
    T choose(T n, T k) 
    {
        if (k < 0 || k > n || n < 0) return 0;
        T ans = fact[n];
        ans = mod(ans * invfact[n - k]);
        ans = mod(ans * invfact[k]);
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string s) 
    {
        int n = s.size(), tot_d_sum = 0;
        int n1 = (n + 1) / 2 , n2 = n - n1;
        
        Math<ll> M(s.size());
        
        vector<int> freq(10);
        for (auto& d : s) 
        {
            freq[d - '0']++;
            tot_d_sum += (d - '0');
        }
        
        if (tot_d_sum % 2 != 0) return 0;
        
        int target_sum = tot_d_sum / 2;
        
        int dp[11][1001][41][41];
        memset(dp, -1, sizeof(dp));
        
        auto f = [&](auto&& self, int i, int j, int k, int l) -> ll
        {
            if (k > n1 || j > target_sum || l > n2 ) return 0;
            if (i == 10) return (j == target_sum && k == n1) ? 1 : 0;
            if (dp[i][j][k][l] != -1) return dp[i][j][k][l];
            
            ll result = 0;
            for (int c = 0; c <= freq[i]; ++c) 
            {
                if (c <= n1 - k && j + c * i <= target_sum && freq[i] - c <= n2 - l) 
                {
                    ll ways_to_choose_c = 1;
                    ll ways_to_fill_remaining = mod(M.choose(n1 - k, c)* M.choose(n2 - l , freq[i] - c));
                    result = (result + mod(mod(ways_to_choose_c * ways_to_fill_remaining) * self(self, i + 1, j + c * i, k + c, l + (freq[i] - c)))) % MOD;
                }
            }
            
            return dp[i][j][k][l] = result;
        };
        
        return f(f, 0, 0, 0, 0);
    }
};
",1441390801
xymabinogi,xymabinogi,246,3627,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = 1;
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441303362
xymabinogi,xymabinogi,246,3628,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = ((ni + nj) % 2 == 0 ? 2 : 1);
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441302979
xymabinogi,xymabinogi,246,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int even = 0, odd = 0;
        for (int i = 0; i < n; i++){
            int v = num[i] - '0';
            if (i % 2) even += v;
            else odd += v;
        }
        return even == odd;
    }
};",1441281584
xymabinogi,xymabinogi,246,3637,cpp,"using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1E9 + 7;
using Z = MInt<P>;
 
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        vector<int> cnt(10, 0);
        int tot = 0;
        for (auto ch : num){
            cnt[ch - '0']+= 1;
            tot += (ch - '0');
        }
        if (tot % 2) return 0;
        tot /= 2;
        
        Z res = 0;
        int n_first = n / 2 + n % 2;
        int n_second = n / 2;
       
        
        vector<vector<Z>> dp(n_first + 1, vector<Z>(tot + 1));
        dp[0][0] = Z(1);
        
        
        
        for (int i = 0; i < 10; i++) if (cnt[i]){
            for (int k = n_first; k >= 0; k--){
                for (int l = tot; l >= 0; l--){
                    if (!dp[k][l].val()) continue;
                    for (int j = 1; j <= cnt[i]; j++){
                        if (k + j > n_first) continue;
                        if (l + j * i <= tot){
                            dp[k + j][l + j * i] += dp[k][l] * comb.binom(cnt[i], j);
                        }
                    }
                }
            }
        }
        Z multi = comb.fac(n_first) * comb.fac(n_second);
        for (int i = 0; i < 10; i++){
            multi *= comb.invfac(cnt[i]);
        }
        
        dp[n_first][tot] *= multi;
        return  dp[n_first][tot].val();
        
        
        
        
        
    }
};",1441374001
luck,papaya,247,3627,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited ; 
        priority_queue< tuple<int64, int64 >> q ; 
        
        visited.assign( n , false ) ;  
        dis.assign( n , INF ); 

        dis[ src ] = 0 ; //start_time[ src ] ; 
        q.emplace( -dis[ src ] ,  src ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }
            if( visited[ u ] ) {
                continue ; 
            }
            visited[ u ] = true ; 
            for( auto [ v , w ] : g[u] ) {
                if( visited[v] ) {
                    continue ; 
                }
                int64 DD  = dis[u] + w ; 
                DD = max( DD , start_time[v] + 1 ) ; 

                if( dis[v] >  DD ) {
                    
                    dis[v] = DD ;
                    q.emplace( -dis[v] , v ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int ma22in( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 } ,  { 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    a = { { 56 , 93 } , { 3 , 38 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441312773
luck,papaya,247,3628,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis[2] ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited[2]; 
        priority_queue< tuple<int64, int64 , int  >> q ; 
        
        visited[0].assign( n , false ) ;  
        visited[1] = visited[0] ; 

        dis[0].assign( n , INF ); 
        dis[1].assign( n , INF ) ; 

        dis[1][ src ] = 0 ; //start_time[ src ] ; 
        q.emplace(  0  ,  src , 1 ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u , is_odd ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            int W = 2 ; 
            if( is_odd ) {
                W = 1 ; 
            }

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }

            if( visited[ is_odd ][ u ] ) {
                continue ; 
            }
            visited[ is_odd ][ u ] = true ; 

            int next_odd = 1 - is_odd ; 

            for( auto [ v , _ ] : g[u] ) {
                if( visited [ next_odd ] [ v ] ) {
                    continue ; 
                }
                int64 DD  = now_acc_cost + W ; 
                DD = max( DD , start_time[v] + W ) ; 

                if( dis[next_odd][v] >  DD ) {
                    
                    dis[next_odd][v] = DD ;
                    q.emplace( -dis[next_odd][v] , v , next_odd ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int mai33n( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 , 0 } ,  { 0 , 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    // a = { { 56 , 93 } , { 3 , 38 } } ; 


    a = { { 0,58 } , { 27,69 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441324094
luck,papaya,247,3636,python3,"import math 
import copy
from typing import * 
from heapq import * 
from collections import * 

class Solution:
    def isBalanced(self, num: str) -> bool:
        
        
        a = [ int( x ) for x in num ] ; 
        n = len( a ) ; 
        
        
        s1 = 0 ; 
        s2 = 0 ;
        
        for i in range( n ) :
            if( i % 2 == 0 ) :
                s1 += a[i] ; 
            else  :
                s2 += a[i] ;
        
        # print( s1 , s2 ) ; 
        
        return s1 == s2 ; 
    
    
def main( ) : 

    t = Solution() ; 

    num = ""1234""
    
    # num = ""24123"" ; 
    
    ans = t.isBalanced ( num ) ; 

    print(  ans ); 

if __name__ == '__main__':
    main()",1441289883
luck,papaya,247,3637,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 INF = 1e18 ; 
const int64 MOD = 1e9 + 7 ; 
const int BASE = 720 ; //int64 base = 720 ; 
const int UP =  BASE * 2 ; 

struct Comb { 
    vector< vector<int64> > C ;
    int n ; 

    void init( int tn ){
        n = tn ;
        C.assign( n + 1 , vector<int64>( n + 1 , 0 ) ) ;

        C[0][0] = 1 ; 
        for( int i = 1 ; i <= n ; i++ ) {
            C[i][0] = C[i][i] = 1 ; 
            for(int j = 1 ; j < i ; j++ ) {
                C[i][j] = C[i-1][j] + C[i-1][j-1] ;
                C[i][j] %= MOD ;
            }
        }
    }
} ; 

class Solution {
public:
    vector<int> a  , cnt ; 
    int n ; 
    int need_select ; 
    Comb comb ; 
    vector< int > aft_sum ; 

    int get( char c ) {
        return int( c ) - int( '0' ) ; 
    }
    vector< vector< vector<int64 >> > cache ; // f[2] ; 
    
    int64 dp( int choices , int other_choices  ,  int d  , int sum ) { 
        
        // cout << "" choices: "" << choices << "" D: "" << d << "" sum: "" << sum << ""\n"" ; 

        if( d >= 10 ) {
            return (choices == 0 && sum == BASE) ? 1 : 0 ; 
        }
        auto &ret = cache[ choices][d][sum] ;
        if( -1 != ret ) {
            return ret ;
        }
        ret = 0 ; 

        if( aft_sum[d] +  sum < BASE ) { // all select 
            return 0 ; 
        }
        if( aft_sum[d] - sum > BASE ) { // all not select 
            return 0 ; 
        }


        int all_s = cnt[d] * d ; 
        int all_cnt = cnt[d] ; 
        for( int select_cnt = 0 ; select_cnt <= cnt[d] && select_cnt <= choices ;  select_cnt++ ) { 
            
            if( other_choices - (all_cnt-select_cnt)  < 0 ) {
                continue ; 
            }
            
            int select_sum_s1 = d * select_cnt ; 
            int other_s2 = all_s - select_sum_s1 ; 

            int64 cnt = dp( choices - select_cnt ,  other_choices - (all_cnt-select_cnt) ,  d + 1 , sum + select_sum_s1 - other_s2 ) ; 
            int64 cnt2 = comb.C[ choices ][ select_cnt ] ; 
            int64 cnt3 = comb.C[ other_choices ] [ all_cnt - select_cnt ] ; 

            int64 t_ans = ( cnt * cnt2 ) % MOD ; 
            t_ans = ( t_ans * cnt3 ) % MOD ; 

            // if( select_cnt >= 1 ) { 
            //     // cout << "" choices: "" << choices << "" selec_cnt: "" << select_cnt << "" D: "" <<d << "" t_ans: "" << t_ans << ""\n"" ; 
            // }

            ret = ( ret + t_ans ) % MOD ; 
        }
        return ret ; 
    }

    void init( ) { 
        aft_sum.assign( 13 , 0 ) ; 
        for( int j = 9 ; j >= 0 ; j-- ) {
            int val = cnt[j] * j ; 
            aft_sum[j] = aft_sum[j+1] + val ; 
        }
    }
    int solve() { 
        init() ; 

        comb.init( n + 1 ) ; 

        cache.resize( n + 1 ) ; 
        for( int i = 0 ; i <= n ;i++ ) { 
            cache[i].assign( 10 , vector<int64> ( UP + 1 , -1  )) ; 
        }

        int sum = accumulate( a.begin()  ,a.end() , 0 ) ; 
        if( sum % 2 != 0 ) {
            return 0 ; 
        }
        auto ans = dp(  need_select  , n - need_select ,   0 , BASE  ) ; 
        return ans ; 
    }
    int countBalancedPermutations(string num) {

        n = num.size() ; 
        need_select = ( n + 1 ) / 2 ; 
        
        cnt.assign( 10 , 0 ) ; 
        a.assign( n + 1 , 0 ) ; 
        for( int i = 0 ; i < n ; i++ ) { 
            int d = get( num[i] ) ; 
            a[ i + 1 ] = d ; 
            cnt[d]++ ; 
        }
        return solve() ;  
    }
};




int ma33in( )  { 
    Solution  t; 

    string s = ""123"" ; 

    // s = ""112"" ; 

    // s = ""12345"" ; 

    // s = ""4567"" ; 

    auto ans = t.countBalancedPermutations ( s ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441380293
Aylup,Aylup,248,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 3>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto [d, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + 1, moveTime[rd][cd] + 1), rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441314422
Aylup,Aylup,248,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 4>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto [d, b, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + b + 1, moveTime[rd][cd] + b + 1), b ^ 1, rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441316347
Aylup,Aylup,248,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i % 2) {
                ans += num[i] - '0';
            } else {
                ans -= num[i] - '0';
            }
        }
        return ans == 0;
    }
};",1441294643
Aylup,Aylup,248,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9 + 7
        total = sum(map(int, num))
        if total % 2 != 0:
            return 0
        n = len(num)
        m = (n + 1) // 2
        m2 = n // 2
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i
            fact[i] %= mod
        target = total // 2
        count = Counter(map(int, num))
        pfx = [0] * 11
        for i in range(10):
            pfx[i] = pfx[i - 1] + count[i]
        @cache
        def dp(i, j, k):
            if k > target:
                return 0
            if i == 10:
                if j != m or k != target:
                    return 0
                return (fact[m] * fact[m2]) % mod
            ans = 0
            high = min(m, count[i])
            for z in range(0, high + 1):
                val = dp(i + 1, j + z, k + z * i)
                val *= pow(fact[z], -1, mod)
                val %= mod
                val *= pow(fact[count[i] - z], -1, mod)
                val %= mod
                
                ans += val
                ans %= mod
            return ans
        return dp(0, 0, 0)",1441381250
abhishek vaish,abhishekvaish,249,3627,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + 1, moveTime[nx][ny]+1):
                    dist[nx][ny] = max(dist[i][j] + 1, moveTime[nx][ny] + 1)
                    hpush(h, (dist[nx][ny], nx, ny) )
                
        # return 
                
        ",1441294943
abhishek vaish,abhishekvaish,249,3628,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0,1) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j,mv = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + mv, moveTime[nx][ny]+mv):
                    dist[nx][ny] = max(dist[i][j] + mv, moveTime[nx][ny] + mv)
                    hpush(h, (dist[nx][ny], nx, ny,  1 if mv == 2 else 2  ) )
                ",1441299436
abhishek vaish,abhishekvaish,249,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o = 0,0
        for i in range(len(num)):
            if i % 2 == 0:
                e += int(num[i])
            else:
                o += int(num[i])
        return e == o
            ",1441281220
abhishek vaish,abhishekvaish,249,3637,python3,"MOD = 10**9+7
fact = [1] * 81
ifact = [1] * 81
for i in range(1,81):
    fact[i] = (i * fact[i-1]) % MOD

ifact[80] = pow(fact[80],-1,MOD)
for i in range(79,-1, -1):
    ifact[i] = (ifact[i+1] * (i+1)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int,num))
        if s%2 == 1: return 0
        mx = [0]*10
        for x in num:
            mx[int(x)] += 1
        # print(""---""*n)
        def count_perm(count):
            # print(count)
            si = sum(count)
            p1, p2 = fact[si] , fact[n - si]
            for i in range(10):
                c1 = count[i]
                c2 = mx[i] - count[i]
                p1 = (p1 * ifact[c1]) % MOD
                p2 = (p2 * ifact[c2]) % MOD
                
            
            return (p1 * p2) % MOD
        
        @cache
        def DP(x, ele, target):
            if ele < 0 : return 0
            if target < 0 : return 0
            if x == 10 :
                if ele == 0 and target == 0:
                    return (fact[n//2] * fact[n-(n//2)]) % MOD
                return 0
            
            p = 0
            for i in range(mx[x]+1):
                c = DP(x+1,ele-i, target - (x*i))
                p += (c * ifact[i] * ifact[mx[x]-i]) % MOD
            return p % MOD
        
        return DP(0,n//2,s//2)
            
            
        
#         def dfs(x, count):
#             if x == 10:
#                 # print(count)
#                 sum_ = sum([ x*i for i,x in enumerate(count)])
#                 sum_i = sum(count)
#                 if n % 2 == 0 and sum_i != n // 2:
#                     return 0
#                 if n % 2 == 1 and sum_i != n // 2 :
#                     return 0
#                 if sum_ == s // 2 :
#                     return count_perm(count)
#                 return 0 
            
#             res = 0
#             for i in range(mx[x]+1):
#                 count[x] = i
#                 res = (res + dfs(x+1, count)) % MOD
#             count[x] = 0
#             return res
        
#         return dfs(0,[0]*10)

# 2
# 1
# 0
# 793764298
# 144920189
            
        ",1441382043
Zardinality,Zardinality,250,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<long long>> dist(n, vector<long long>(m, LLONG_MAX));
        dist[0][0] = 0;
        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>,
                      greater<pair<long long, pair<int, int>>>> pq;
        
        pq.push({0, {0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + 1LL;
                    
                    if (wait_time < dist[new_row][new_col]) {
                        dist[new_row][new_col] = wait_time;
                        pq.push({wait_time, {new_row, new_col}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441326235
Zardinality,Zardinality,250,3628,cpp,"using ll = long long;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, LLONG_MAX)));
        dist[0][0][0] = 0;
        priority_queue<pair<ll, array<int, 3>>, 
                      vector<pair<ll, array<int, 3>>>,
                      greater<pair<ll, array<int, 3>>>> pq;
        
        pq.push({0, {0, 0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col, step] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col][step]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + (step == 0?1LL:2LL);
                    int nstep = 1-step;
                    if (wait_time < dist[new_row][new_col][nstep]) {
                        dist[new_row][new_col][nstep] = wait_time;
                        pq.push({wait_time, {new_row, new_col, nstep}});
                    }
                }
            }
        }
        auto& pres = dist[n-1][m-1];
        return min(pres[0], pres[1]);
    }
};",1441339665
Zardinality,Zardinality,250,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ns = num.size();
        int en = 0;
        int on = 0;
        for(int i=0;i<ns;i++){
            if(i%2){
                en += (num[i]-'0');
            }
            else{
                on += (num[i]-'0');
            }
        }
        return en == on;
    }
};",1441287239
Zardinality,Zardinality,250,3637,cpp,"#define PRIME 1000000007
using ll = long long;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int ns = num.size();
        vector<int> buf(ns, 0);
        int tsum = 0;
        for(int i=0;i<ns;i++){
            buf[i] = num[i]-'0';
            tsum += buf[i];
        }
        vector<int> freq(10, 0);
        for (char c : num) {
            freq[c - '0']++;
        }
        
        if(tsum%2) return 0;
        int target = tsum/2;
        int even_cnt = ns/2;
        vector<vector<ll>> dp(even_cnt+1, vector<ll>(target+1, 0));
        dp[0][0] = 1;
        for(int i=0;i<ns;i++){
            vector<vector<ll>> ndp = dp;
            int cdigit = buf[i];
            for(int j=0;j<even_cnt;j++){
                for(int k=0;k<=target;k++){
                    if(k+cdigit<=target){
                        // std::cout<<j+1<<"" ""<<k+cdigit<<"" ""<<dp.size()<<"" ""<<dp[0].size()<<endl;
                        ndp[j+1][k+cdigit] += dp[j][k];
                        ndp[j+1][k+cdigit] %= PRIME;
                    }
                }
            }
            dp = std::move(ndp);
        }
        int num_subsets = dp.back().back();
        auto factorial = [](int n){
            if(!n) return 1LL;
            ll res = n;
            while(--n){
                res *= n;
                res %= PRIME;
            }
            return res;
        };
                auto modPow = [&](ll base, ll exp) {
            ll result = 1;
            while (exp > 0) {
                if (exp & 1) result = (result * base) % PRIME;
                base = (base * base) % PRIME;
                exp >>= 1;
            }
            return result;
        };
        
        auto modInverse = [&](ll n) {
            return modPow(n, PRIME - 2);
        };
        // cout<<num_subsets<<"" ""<<factorial(even_cnt)<<endl;
        ll even_fact = factorial(even_cnt);
        ll odd_fact = factorial(ns-even_cnt);
        auto result = ((num_subsets * even_fact) % PRIME) * odd_fact % PRIME;
                
        for (int i = 0; i < 10; i++) {
            if (freq[i] > 1) {
                result = (result * modInverse(factorial(freq[i]))) % PRIME;
            }
        }
        return result;
    }
};",1441395191
minamego001,minamego001,252,3627,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[55][55];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({0, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({-max(cur,moveTime[nx][ny]) - 1 , {nx,ny}});
            }
        }
        return 0;
    }
};",1441294632
minamego001,minamego001,252,3628,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[760][760];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({{0,0}, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            int add = -a.first.second;
            int nadd = -1;
            if(add == 1) nadd = -2;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({{-max(cur,moveTime[nx][ny]) + nadd, nadd} , {nx,ny}});
            }
        }
        return 0;
    }
};",1441299481
minamego001,minamego001,252,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0 , b = 0;
        for(int i = 0 ; i<num.size(); ++i) {
            if(i&1) a+= num[i]-'0';
            else b += num[i]-'0';
        }
        return a == b;
    }
};",1441281602
minamego001,minamego001,252,3637,cpp,"class Solution {
public:
    int cnt[10];
    const int mod = 1e9 + 7;
unsigned long long fac[88];
long long ncr[88][88];
unsigned long long power(unsigned long long x, 
                                  int y)
{
    unsigned long long res = 1; // Initialize result
 
    x = x % mod; // Update x if it is more than or
    // equal to p
 
    while (y > 0) 
    {
     
        // If y is odd, multiply x with result
        if (y & 1)
            res = (res * x) % mod;
 
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % mod;
    }
    return res;
}
 
// Returns n^(-1) mod p
unsigned long long modInverse(unsigned long long n
                                            )
{
    return power(n, mod - 2);
}
 
// Returns nCr % p using Fermat's little
// theorem.
unsigned long long nCr(unsigned long long n,
                                 int r)
{
    // If n<r, then nCr should return 0
    if (n < r)
        return 0;
    // Base case
    if (r == 0)
        return 1;
 
    return (fac[n] * modInverse(fac[r]) % mod
            * modInverse(fac[n - r]) % mod)
           % mod;
}
    int dp[10][41][730];
    int ans = 0;
    int acc[11];
    long long solve(int i, int odd,int even, int sum) {
        if(sum == ans && odd == 0 && even == 0) return 1;
        if(sum > ans || odd < 0 || i == 10 || even < 0) return 0;

        int &ret = dp[i][odd][sum];
        if(~ret) return ret;
        ret = 0;
        for(int a = 0 ; a<= cnt[i] ; ++a) {
            long long x =  (ncr[odd][a] * solve(i+1,odd - a, even - (cnt[i] - a), sum + a * i))%mod;
            //cout<<i<< "" ""<<a<<"" ""<<sum<<"" ""<<x<<"" ""<<endl;
            x = (x * ncr[even][cnt[i]-a]) % mod;
            ret += x;
            ret%=mod;
        }
        return ret;
        
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        for(auto a : num) 
            {
                sum += a - '0';
                cnt[a-'0']++;
            }
        
        int n = num.size();
            fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % mod;
    acc[0] = cnt[0];
    for(int i = 1 ; i<=9 ; ++i) acc[i] = cnt[i] + acc[i-1];
    for(int i = 0 ; i <=n ; ++i) 
        for(int j = 0 ; j<=i ; ++j) ncr[i][j] = nCr(i,j);
        int odd = (n+1)/2;
        int even = n/2;
        if(sum & 1) return 0;
        ans = sum/2;
        memset(dp,-1,sizeof(dp));
        return solve(0,odd,even,0);
    }
};",1441377894
derrick2001,derrick2001,253,3627,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> pq;
        pq.push({0,0,0});
        dd[0][0]= 0;        
        while(pq.size()) {
            auto[d, x, y] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_++;
                    if (t_ < dd[nx][ny]) {
                        pq.push({t_,nx,ny});
                        dd[nx][ny] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441337233
derrick2001,derrick2001,253,3628,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5][2];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, greater<tuple<int,int,int,int>>> pq;
        pq.push({0,0,0,0});
        dd[0][0][0] = 0;        
        while(pq.size()) {
            auto[d, x, y,p] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y][p]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_ += (1 + (p!=0));
                    if (t_ < dd[nx][ny][p^1]) {
                        pq.push({t_,nx,ny,p^1});
                        dd[nx][ny][p^1] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441334453
derrick2001,derrick2001,253,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o=0,0
        for i,x in enumerate(num):
            if i%2:
                o += int(x)
            else:
                e += int(x)
        return o==e
        ",1441305760
derrick2001,derrick2001,253,3637,cpp,"const int MOD = 1e9 + 7;
typedef long long ll;



ll power_mod(ll x, ll y, ll mod) {
    ll res = 1;
    x %= mod;
    while(y > 0){
        if(y & 1LL){
            res = res * x % mod;
        }
        x = x * x % mod;
        y >>= 1LL;
    }
    return res;
}


struct Factorials {
    vector<long long> fact;
    vector<long long> inv_fact;
    int max_n;

    Factorials(int n_max) : max_n(n_max), fact(n_max + 1, 1), inv_fact(n_max + 1, 1) {
        for(int i = 1; i <= max_n; ++i){
            fact[i] = fact[i-1] * i % MOD;
        }
        inv_fact[max_n] = power_mod(fact[max_n], MOD - 2, MOD);
        for(int i = max_n -1; i >=0; --i){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
    }


    ll comb(int n, int k){
        if(n < k || k < 0) return 0;
        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
    }

    ll factorial(int n){
        if(n < 0 || n > max_n) return 0;
        return fact[n];
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        Factorials factorials(n);

        
        int freq[10] = {0};
        for(char ch : num){
            freq[ch - '0']++;
        }
    
        int total_sum = 0;
        for(int d =0; d <=9; ++d){
            total_sum += d * freq[d];
        }

        
        if(total_sum % 2 != 0){
            return 0;
        }

        int target_sum = total_sum / 2;
        int k = (n +1)/2; 

        vector<vector<int>> dp(k +1, vector<int>(target_sum +1, 0)); //sm at even
        dp[0][0] = 1;

        for(int d =0; d <=9; ++d){
            if(freq[d] ==0) continue;
            vector<vector<int>> temp(k +1, vector<int>(target_sum +1, 0));
            for(int c =0; c <=k; ++c){
                for(int s =0; s <=target_sum; ++s){
                    if(dp[c][s] ==0) continue;
                    for(int m =0; m <= min(freq[d], k - c); ++m){
                        if(s + d * m > target_sum) break;
                        // Number of ways to choose m digits of this digit
                        // which is C(freq[d], m)
                        ll combinations = factorials.comb(freq[d], m);
                        temp[c + m][s + d * m] = (temp[c + m][s + d * m] + dp[c][s]%MOD * combinations%MOD) % MOD;
                    }
                }
            }
            dp = temp;
        }
        
        int ways = dp[k][target_sum];


        if(ways ==0){
            return 0;
        }
        int fk = factorials.factorial(k);
        int fck = factorials.factorial(n -k);

        int denom =1;
        for(int d =0; d <=9; ++d){
            denom = denom * factorials.fact[freq[d]] % MOD;
        }

        long long numerator = 1LL* fk * fck % MOD;


        long long inv = power_mod(denom, MOD -2, MOD);
        long long ans = 1LL* ways * numerator % MOD;
        ans = ans%MOD * inv % MOD;

        return (int)ans;
    }
};",1441352897
Jiabei Zhu,zzjjbb,255,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 1, t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441316122
Jiabei Zhu,zzjjbb,255,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 2 - ((i + j) & 1), t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1 + ((i + j) & 1)
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441315209
Jiabei Zhu,zzjjbb,255,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281111
Jiabei Zhu,zzjjbb,255,3637,python3,"M = 1_000_000_007
fact = [1]
for i in range(1, 100):
    fact.append(fact[-1] * i % M)
ifact = [pow(i, -1, M) for i in fact]
 

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        num = list(map(int, num))
        goal = rgoal = sum(num)
        if goal % 2:
            return 0
        goal >>= 1
        c = Counter(num)
        c = [c[i] for i in range(10)]
        l = defaultdict(int)
        l[0, 0] = 1
        ctl = 0
        for di in range(10):
            nl = defaultdict(int)
            cdi = c[di]
            for (cs, cl), cnt in l.items():
                for i in range(cdi + 1):
                    ad = (cnt * fact[cl + i]) % M
                    ad = (ad * ifact[cl]) % M
                    ad = (ad * ifact[i]) % M
                    ad = (ad * fact[ctl + cdi - cl - i]) % M
                    ad = (ad * ifact[ctl - cl]) % M
                    ad = (ad * ifact[cdi - i]) % M
                    # print(cnt, ad)
                    nl[cs + di * i, cl + i] += ad
            l = nl
            ctl += cdi
        # print(nl)
        # print(l)
        ans = 0
        for (cs, cl), cnt in l.items():
            if cs == goal and cl == n // 2:
                ans = (ans + cnt) % M
        return ans
",1441396831
youknowwho99,youknowwho99,256,3627,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2]});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2]});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441330065
youknowwho99,youknowwho99,256,3628,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t;
                if(a[3]==0)
                 t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]+1][a[2]]+2,a[0]+2);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2],a[3]^1});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]+1]+2,a[0]+2);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1,a[3]^1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                else
                    t=max(vec[a[1]-1][a[2]]+2,a[0]+2);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2],a[3]^1});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]-1]+2,a[0]+2);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1,a[3]^1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441335847
youknowwho99,youknowwho99,256,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int e=0;
        int o=0;
        for(int i=0;i<s.length();i+=2){
            e+=s[i]-'0';
        }
        for(int i=1;i<s.length();i+=2){
            o+=s[i]-'0';
        }
        return o==e;
    }
};",1441281561
youknowwho99,youknowwho99,256,3637,cpp,"class Solution {
public:
    long long powerMod(long long base, long long exp, long long mod) {
        long long res = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) res = res * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return res;
    }
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int len = num.size();
        int evenCount = (len + 1) / 2; 
        int oddCount = len / 2; 

        int digitCount[10] = {0};
        for (char ch : num) {
            digitCount[ch - '0']++;
        }

        long long totalSum = 0;
        for (int d = 0; d < 10; d++) {
            totalSum += (long long)d * digitCount[d];
        }

        if (totalSum % 2 != 0) return 0; 
        long long targetSum = totalSum / 2;

        const int MAX_LEN = 80;
        vector<long long> factorial(MAX_LEN + 1, 1);
        for (int i = 1; i <= MAX_LEN; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        vector<long long> invFactorial(MAX_LEN + 1, 1);
        invFactorial[MAX_LEN] = powerMod(factorial[MAX_LEN], MOD - 2, MOD);
        for (int i = MAX_LEN - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        auto combination = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFactorial[k] % MOD * invFactorial[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenCount + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (digitCount[d] == 0) continue; 
            for (int t = evenCount; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue; 
                    for (int k = 1; k <= digitCount[d] && t + k <= evenCount && s + (long long)d * k <= targetSum; k++) {
                        dp[t + k][s + (long long)d * k] = (dp[t + k][s + (long long)d * k] + dp[t][s] * combination(digitCount[d], k)) % MOD;
                    }
                }
            }
        }

        long long validPermutations = dp[evenCount][targetSum];

        long long productFactorials = 1;
        for (int d = 0; d < 10; d++) {
            productFactorials = productFactorials * factorial[digitCount[d]] % MOD;
        }

        long long result = validPermutations;
        result = result * factorial[evenCount] % MOD;
        result = result * factorial[oddCount] % MOD;

        long long invProduct = powerMod(productFactorials, MOD - 2, MOD);
        result = result * invProduct % MOD;

        return (int)result;
    }


};
",1441384835
Akash,Akash_0P,257,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
            pq.push({0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + cur;
                            pq.push({dp[nr][nc], nr, nc});
                        }
                    }else if(moveTime[nr][nc] + 1 < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1;
                        pq.push({dp[nr][nc], nr, nc});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};",1441364556
Akash,Akash_0P,257,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
            pq.push({0, 0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j, flag] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + flag + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + flag + cur;
                            pq.push({dp[nr][nc], nr, nc, !flag});
                        }
                    }else if(moveTime[nr][nc] + 1 + flag < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1 + flag;
                        pq.push({dp[nr][nc], nr, nc, !flag});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};
",1441366468
Akash,Akash_0P,257,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();

        vector<int> v(2);

        for(int i = 0; i < n; i++) {
            v[i & 1] += num[i] - '0';
        }

        return v[0] == v[1];
    }
};",1441281902
Akash,Akash_0P,257,3637,cpp,"using ll = long long;

const int N = 2e5 + 5, M = 1e9 + 7;
ll fact[N], ifact[N];

ll add(ll a, ll b) {
  return (a + b) % M;
}

ll mul(ll a, ll b) {
  return (a * b) % M;
}

ll expo(ll a, ll b) {
  ll res = 1;
  while(b) {
    if(b & 1) res = mul(res, a);
    a = mul(a, a);
    b >>= 1;
  }
  return res;
}

void pre() {
  fact[0] = 1;
  for(ll i = 1; i < N; i++) fact[i] = mul(i, fact[i - 1]);
  ifact[N-1] = expo(fact[N-1], M-2);
  for(ll i = N-2; i >= 0; i--) ifact[i] = mul(i + 1, ifact[i + 1]);
}

ll nCr(ll n, ll r) {
  if(r > n) return 0;
  return mul(fact[n], mul(ifact[n - r], ifact[r]));
}

int flag = 0;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if(!flag) pre();
            
        int n = num.size(), target = 0;

        vector<int> freq(10);
        for(auto &i: num) freq[i - '0']++, target += i - '0';

        if(target & 1) return 0;

        vector dp(11, vector (n, vector (target + 1, -1)));

        vector<pair<int, int>> temp;

        auto f = [&](int i, int s, int val, auto && f) -> ll {

            if(i == 10) {
                if(val == 0 && s == 0) return mul(fact[(n + 1) / 2], fact[n / 2]);
                return 0;
            }

            if(dp[i][s][val] != -1) return dp[i][s][val];

            ll ans = 0;

            for(int x = 0; x <= freq[i]; x++) {
                if(s - x >= 0 && val - x * i >= 0) {
                    ans = add(ans, mul(mul(ifact[x], ifact[freq[i] - x]), f(i + 1, s - x, val - x * i, f)));
                }
            }

            return dp[i][s][val] = ans;

        };

        return f(0, (n + 1) / 2, target / 2, f);

    }
};",1441384985
Hongbo Zhong,neverbackdown,258,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 0, 0)]
        while Q:
            t, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = 1+max(moveTime[x][y], t)
                    heappush(Q, (new_t, x, y))
        
            ",1441305664
Hongbo Zhong,neverbackdown,258,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 1, 0, 0)]
        while Q:
            t, c, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = c+max(moveTime[x][y], t)
                    heappush(Q, (new_t, 1 if c==2 else 2, x, y))",1441308620
Hongbo Zhong,neverbackdown,258,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            d = int(num[i])
            if i%2 == 0:
                even += d
            else:
                odd += d
        return even == odd",1441281665
Hongbo Zhong,neverbackdown,258,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        digits = [int(ch) for ch in num]
        total = sum(digits)
        if total%2 == 1:
            return 0
            
        mod = 10**9+7
        memo = [defaultdict(lambda: 0) for _ in range(n)]
        for i in range(n):
            d = digits[i]
            if i == 0:
                memo[i][(d, 1)] = 1
                memo[i][(0, 0)] = 1
            else:
                for num, cnt in memo[i-1]:
                    memo[i][(num+d, cnt+1)] += memo[i-1][(num, cnt)]
                    memo[i][(num, cnt)] += memo[i-1][(num, cnt)]

        ans = memo[n-1][(total//2, n//2)]*perm(n//2, n//2)*perm(n-n//2, n-n//2)
        counter = Counter(digits)
        for freq in counter.values():
            ans //= perm(freq, freq)
        return ans % mod",1441391236
RAHUL YADAV,imdotrahul,259,3627,cpp,"#include <vector>
#include <queue>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        if (rows == 0) return 0;
        int cols = moveTime[0].size();
        if (cols == 0) return 0;

        vector<vector<int>> minTime(rows, vector<int>(cols, numeric_limits<int>::max()));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        initializePriorityQueue(pq, minTime);
        vector<vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!pq.empty()) {
            auto current = pq.top();
            pq.pop();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > minTime[currentRow][currentCol]) continue;

            exploreNeighbors(currentRow, currentCol, currentTime, moveTime, minTime, pq, directions);
        }

        return getMinTimeToDestination(minTime, rows, cols);
    }

private:
    void initializePriorityQueue(priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                                  vector<vector<int>>& minTime) {
        pq.push({0, 0, 0});
        minTime[0][0] = 0;
    }

    void exploreNeighbors(int row, int col, int time, vector<vector<int>>& moveTime, 
                          vector<vector<int>>& minTime, priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                          const vector<vector<int>>& directions) {
        for (const auto& dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];

            if (isValidCell(newRow, newCol, minTime)) {
                int newTime = calculateNewTime(time, moveTime[newRow][newCol]);
                updateMinTime(newRow, newCol, newTime, minTime, pq);
            }
        }
    }

    bool isValidCell(int row, int col, const vector<vector<int>>& minTime) {
        return row >= 0 && row < minTime.size() && col >= 0 && col < minTime[0].size();
    }

    int calculateNewTime(int currentTime, int moveTime) {
        return max(currentTime, moveTime) + 1;
    }

    void updateMinTime(int row, int col, int newTime, vector<vector<int>>& minTime, 
                       priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq) {
        if (newTime < minTime[row][col]) {
            minTime[row][col] = newTime;
            pq.push({newTime, row, col});
        }
    }

    int getMinTimeToDestination(const vector<vector<int>>& minTime, int rows, int cols) {
        return minTime[rows - 1][cols - 1];
    }
};",1441385871
RAHUL YADAV,imdotrahul,259,3628,cpp,"
class Solution {
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        std::vector<std::vector<std::vector<int>>> minTime(rows, std::vector<std::vector<int>>(cols, std::vector<int>(2, std::numeric_limits<int>::max())));
        
        minTime[0][0][0] = 0;
        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> priorityQueue;
        priorityQueue.push({0, 0, 0, 0});

        std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!priorityQueue.empty()) {
            auto current = priorityQueue.top();
            priorityQueue.pop();
            int currentTime = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];
            
            if (currentTime > minTime[row][col][parity]) continue;
            
            exploreNeighbors(currentTime, row, col, parity, moveTime, minTime, priorityQueue, directions);
        }
        
        return std::min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }

private:
    void exploreNeighbors(int currentTime, int row, int col, int parity, 
                          const std::vector<std::vector<int>>& moveTime,
                          std::vector<std::vector<std::vector<int>>>& minTime,
                          std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>>& priorityQueue,
                          const std::vector<std::vector<int>>& directions) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        
        for (const auto& direction : directions) {
            int newRow = row + direction[0];
            int newCol = col + direction[1];
            
            if (isValid(newRow, newCol, rows, cols)) {
                int nextTime = std::max(currentTime, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);
                if (nextTime < minTime[newRow][newCol][1 - parity]) {
                    minTime[newRow][newCol][1 - parity] = nextTime;
                    priorityQueue.push({nextTime, newRow, newCol, 1 - parity});
                }
            }
        }
    }

    bool isValid(int row, int col, int rows, int cols) {
        return row >= 0 && row < rows && col >= 0 && col < cols;
    }
};",1441366801
RAHUL YADAV,imdotrahul,259,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sumeven = 0;
        int sumodd = 0;
        for(int i = 0;i<n;i+=2)
        {
            sumeven+=num[i]-'0';
        }
        for(int i = 1;i<n;i+=2)
            {
                sumodd += num[i]-'0';
            }

        if(sumodd == sumeven)
        {
            return true;
        }
        else{
            return false;
        }
    }
};",1441291928
RAHUL YADAV,imdotrahul,259,3637,cpp,"#define MOD 1000000007
typedef long long ll;

vector<ll> factorial;
vector<ll> inv_factorial;

ll mod_power(ll base, ll exp) {
    ll result = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp & 1) result = result * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return result;
}

void initialize_factorials(int limit) {
    factorial.assign(limit + 1, 1);
    for (int i = 1; i <= limit; i++) {
        factorial[i] = factorial[i - 1] * i % MOD;
    }
    inv_factorial.assign(limit + 1, 1);
    inv_factorial[limit] = mod_power(factorial[limit], MOD - 2);
    for (int i = limit - 1; i >= 0; i--) {
        inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
    }
}

ll compute_combinations(int digit_count[], int digit, int used, int half_length) {
    if (used > digit_count[digit] || used > half_length) return 0;
    return (factorial[digit_count[digit]] * inv_factorial[used] % MOD) * inv_factorial[digit_count[digit] - used] % MOD;
}

void fill_dp_table(int digit_count[], vector<vector<ll>>& dp, ll half_sum, int half_length) {
    for (int d = 0; d <= 9; d++) {
        if (digit_count[d] == 0) continue;
        for (int c = half_length; c >= 0; c--) {
            for (ll s = half_sum; s >= 0; s--) {
                if (dp[c][s] == 0) continue;
                for (int t = 1; t <= min(digit_count[d], half_length - c); t++) {
                    if (s + (ll)d * t > half_sum) break;
                    ll combinations = compute_combinations(digit_count, d, t, half_length - c);
                    dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * combinations) % MOD;
                }
            }
        }
    }
}

class Solution {
public:
    int countBalancedPermutations(string digits) {
        int length = digits.size();
        int digit_count[10] = {0};
        ll total_digit_sum = 0;
        for (char c : digits) {
            int digit = c - '0';
            digit_count[digit]++;
            total_digit_sum += digit;
        }
        if (total_digit_sum % 2 != 0) return 0;
        ll half_sum = total_digit_sum / 2;
        int half_length = (length + 1) / 2;
        initialize_factorials(length);
        vector<vector<ll>> dp(half_length + 1, vector<ll>(half_sum + 1, 0));
        dp[0][0] = 1;
        fill_dp_table(digit_count, dp, half_sum, half_length);
        ll valid_permutations = dp[half_length][half_sum];
        if (valid_permutations == 0) return 0;
        ll product_factorials = 1;
        for (int d = 0; d <= 9; d++) {
            product_factorials = product_factorials * factorial[digit_count[d]] % MOD;
        }
        ll combinations_k_nk = (factorial[half_length] * factorial[length - half_length]) % MOD;
        ll inv_product_factorials = mod_power(product_factorials, MOD - 2);
        ll final_answer = (combinations_k_nk * valid_permutations) % MOD;
        final_answer = (final_answer * inv_product_factorials) % MOD;

        return (int)final_answer;
    }
};
",1441378126
Jingzhe Tang,skywalkert,261,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 51, maxm = 2501, INF = 0x3f3f3f3f;
        static int f[maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<pair<int, int> > cand[2];
        auto upd = [&](int x, int y, int t) {
            // printf(""chk %d %d %d\n"", x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[x][y] || t <= tim[x][y])
                return;
            // assert(cur <= t && t <= cur + 1);
            f[x][y] = t;
            cand[t - cur].push_back({x, y});
            // printf(""new %d %d: %d\n"", x, y, t);
        };
        f[0][0] = 0;
        cand[0].push_back({0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d\n"", cur, pos, cand[0].size(), cand[1].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1 && f[x][y] == INF; ++dx)
                    for(int dy = -1; dy <= 1 && f[x][y] == INF; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c || f[xx][yy] >= cur)
                            continue;
                        f[x][y] = cur + 1;
                    }
                // if(f[x][y] != cur + 1) {
                //     printf(""cur %d x %d y %d pos %d\n"", cur, x, y, pos);
                //     for(int i = 0; i < r; ++i)
                //         for(int j = 0; j < c; ++j)
                //             printf(""%d%c"", f[i][j] < INF ? f[i][j] : -1, "" \n""[j == c - 1]);
                // }
                // assert(f[x][y] == cur + 1);
                if(f[x][y] == cur + 1) {
                    // printf(""new2 %d %d: %d\n"", x, y, cur + 1);
                    cand[1].push_back({x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(x + dx, y + dy, f[x][y] + 1);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                ++cur;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        return f[r - 1][c - 1];
    }
};",1441346708
Jingzhe Tang,skywalkert,261,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 751, maxm = 562501, INF = 0x3f3f3f3f;
        static int f[2][maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[0][i][j] = f[1][i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<array<int, 3> > cand[3];
        auto upd = [&](int o, int x, int y, int t) {
            // printf(""chk %d %d %d %d\n"", o, x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[o][x][y])
                return;
            if(t - !o <= tim[x][y]) {
                f[o][x][y] = tim[x][y] + 2 - o;
            } else {
                assert(cur <= t && t <= cur + 2);
                f[o][x][y] = t;
                cand[t - cur].push_back({o, x, y});
            }
            // printf(""new %d %d %d: %d\n"", o, x, y, t);
        };
        f[0][0][0] = 0;
        cand[0].push_back({0, 0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d %d\n"", cur, pos, cand[0].size(), cand[1].size(), cand[2].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[0][x][y] < INF && f[1][x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c)
                            continue;
                        if(f[1][x][y] == INF && f[0][xx][yy] < cur)
                            f[1][x][y] = cur + 1;
                        if(f[0][x][y] == INF && f[1][xx][yy] < cur)
                            f[0][x][y] = cur + 2;
                    }
                if(f[0][x][y] >= cur && f[0][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 0, x, y, f[0][x][y]);
                    cand[f[0][x][y] - cur].push_back({0, x, y});
                }
                if(f[1][x][y] >= cur && f[1][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 1, x, y, f[1][x][y]);
                    cand[f[1][x][y] - cur].push_back({1, x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[o, x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(!o, x + dx, y + dy, f[o][x][y] + 1 + o);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                cand[2].swap(cand[1]);
                ++cur;
            } else if(!cand[2].empty()) {
                cand[2].swap(cand[0]);
                cur += 2;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        // for(int i = 0; i < r; ++i)
        //     for(int j = 0; j < c; ++j)
        //         printf(""[%d|%d]%c"", f[0][i][j] < INF ? f[0][i][j] : -1, f[1][i][j] < INF ? f[1][i][j] : -1, "" \n""[j == c - 1]);
        return min(f[0][r - 1][c - 1], f[1][r - 1][c - 1]);
    }
};",1441380781
Jingzhe Tang,skywalkert,261,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int dt = 0;
        for(char ch: num)
            dt = ch - '0' - dt;
        return !dt;
    }
};",1441280946
Jingzhe Tang,skywalkert,261,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        typedef long long LL;
        static const int maxd = 10, maxm = 41, maxh = 361, mod = (int)1e9 + 7;
        static int f[maxm][maxh], iact[maxm << 1 | 1], ctr[maxd + 1];
        int n = num.size(), s = 0;
        memset(ctr, 0, sizeof ctr);
        for(char ch: num) {
            int o = ch - '0';
            ++ctr[o];
            s += o;
        }
        if(s & 1)
            return 0;
        int m = n >> 1, h = s >> 1;
        for(int i = 0; i <= m; ++i)
            memset(f[i], 0, (h + 1) * sizeof(int));
        iact[1] = 1;
        for(int i = 2; i <= n; ++i)
            iact[i] = mod - (int)(mod / i * (LL)iact[mod % i] % mod);
        iact[0] = 1;
        for(int i = 1; i <= n; ++i)
            iact[i] = (LL)iact[i - 1] * iact[i] % mod;
        f[0][0] = 1;
        for(int o = 0; o < maxd; ++o) {
            if(!ctr[o])
                continue;
            for(int i = m; i >= 0; --i)
                for(int j = h; j >= 0; --j) {
                    int ways = 0;
                    for(int k = min(ctr[o], o ? min(i, j / o) : i); k >= 0; --k)
                        ways = (ways + (LL)f[i - k][j - o * k] * iact[k] % mod * iact[ctr[o] - k]) % mod;
                    f[i][j] = ways;
                }
        }
        int ways = f[m][h];
        for(int i = 2; i <= m; ++i)
            ways = (LL)ways * i * i % mod;
        if(m + m < n)
            ways = (LL)ways * (n - m) % mod;
        return ways;
    }
};",1441307509
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3627,cpp,"struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 1);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny,  (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441364022
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 2);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441362661
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int e = 0, o = 0;
        for(int i = 0; i< n; i++) {
            if(i & 1) {
                e += s[i] - '0';
                continue;
            }
            o += s[i] - '0';
            
        }

        return (e == o);
    }
};",1441283173
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3637,cpp,"class Solution {
public:
  
int power(long long n, long long k, int mod) {
  int ans = 1 % mod; n %= mod; if(n < 0) n += mod;

  while(k) {
    if(k & 1) ans = 1ll *  ans * n % mod;
    n = 1ll *  n * n % mod;
    k >>= 1;
  }

  return ans;
}
    int countBalancedPermutations(string num) {
        const int mod = 1e9 + 7;
        int n = num.size();
        int m = (n + 1) / 2;


        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }

        long long t = 0;
        for(int i = 0; i < 10; i++) {
            t += 1ll * i * cnt[i];
        }

        if(t % 2 != 0) return 0;

        long long tot = t / 2;

        const int q = 80;
        vector<long long> fac(q + 1, 1);
        for(int i = 1; i <= q; i++) {
            fac[i] = fac[i -1] * i % mod;
        }

        vector<long long> inv_fac(q + 1, 1);
        inv_fac[q] = power(fac[q], mod - 2, mod);
        for(int i = q - 1; i >= 0; i--){
            inv_fac[i] = 1ll * inv_fac[i +1] * (i +1) % mod;
        }

        auto ncr = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return fac[n] * inv_fac[k] % mod * inv_fac[n -k] % mod;
        };

        vector<vector<long long>> dp(m + 1, vector<long long>(tot + 1, 0));
        dp[0][0] = 1;

        for(int i =0; i < 10; i++) {
            if(!cnt[i]) continue;
            for(int t = m; t >= 0; t--){
                for(long long s = tot; s >= 0; s--){
                    if(dp[t][s] == 0) continue;
                    for(int k = 1; k <= cnt[i] and t + k <= m and s + 1ll * i * k <= tot; k++){
                        dp[t + k][s + 1ll * i * k] = (dp[t + k][s + 1ll * i * k] + dp[t][s] * ncr(cnt[i], k)) % mod;
                    }
                }
            }
        }

        long long calc = 1;
        for(int i = 0; i < 10; i++) {
            calc = calc * fac[cnt[i]] % mod;
        }

        int ans = 1ll * (dp[m][tot] % mod) * fac[m] % mod;
        ans = 1ll * ans * fac[n / 2] % mod;
        ans = 1ll * ans * power(calc, mod -2, mod) % mod;

        return ans;
    }
};",1441393320
birds3345,birds3345,264,3627,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, coord] = pq.top();
            auto [i, j] = coord;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + 1;
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {i + 1, j}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + 1;
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {i, j + 1}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + 1;
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {i - 1, j}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + 1;
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {i, j - 1}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441297556
birds3345,birds3345,264,3628,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<bool, pair<int, int>>>, vector<pair<int, pair<bool, pair<int, int>>>>, greater<>> pq;
        pq.push({0, {true, {0, 0}}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, info] = pq.top();
            auto move = info.first;
            auto [i, j] = info.second;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {!move, {i + 1, j}}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {!move, {i, j + 1}}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {!move, {i - 1, j}}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {!move, {i, j - 1}}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441303359
birds3345,birds3345,264,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0;
        int odd = 0;
        
        for (int i = 0; i < num.size(); i++)
        {
            if (i & 1)
                odd += num[i] - '0';
            else
                even += num[i] - '0';
        }
        
        return even == odd;
    }
};",1441280998
birds3345,birds3345,264,3637,cpp,"long long dp[81][1441][41];

class Solution {
public:
    int MOD = 1e9 + 7;
    
    long long solve(int i, int sum, int evenCount, string& num, int totalEven, int totalOdd)
    {
        if (dp[i][sum + 720][evenCount] != -1)
            return dp[i][sum + 720][evenCount];
        if (i == num.size())
            return sum == 0 && evenCount == totalEven;
        
        int oddCount = i - evenCount;
        
        long long res = 0;
        if (oddCount < totalOdd)
            res = (res + solve(i + 1, sum + (num[i] - '0'), evenCount, num, totalEven, totalOdd) * (totalOdd - oddCount)) % MOD;
        if (evenCount < totalEven)
            res = (res + solve(i + 1, sum - (num[i] - '0'), evenCount + 1, num, totalEven, totalOdd) * (totalEven - evenCount)) % MOD;
        
        return dp[i][sum + 720][evenCount] = res;
    }
    
    long long factorial(long long n)
    {
        long long res = 1;
        for (int i = 1; i <= n; i++)
            res = (res * i) % MOD;
        
        return res;
    }
    
    long long modInverse(long long a, long long mod)
    {
        long long m0 = mod, t, q;
        long long x0 = 0, x1 = 1;
        if (mod == 1) return 0;
        while (a > 1)
        {
            q = a / mod;
            t = mod;
            mod = a % mod, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0) x1 += m0;
        return x1;
    }
    
    int countBalancedPermutations(string num) {
        memset(dp, -1, sizeof(dp));
        long long res = solve(0, 0, 0, num, num.size() / 2, num.size() - num.size() / 2);
        
        unordered_map<char, int> freq;
        for (char c: num)
            freq[c]++;
        
        for (auto& [k, v]: freq)
        {
            long long fact = factorial(v);
            long long invFact = modInverse(fact, MOD);
            
            res = (res * invFact) % MOD;
        }
        
        return res;
    }
};",1441393394
junbinliang,junbinliang,267,3627,cpp,"vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int d[55][55];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = 2e9;
            }
        }
        
        queue<pair<int, int>> q;
        q.push({0, 0});
        d[0][0] = 0;
        
        while(q.size()) {
            pair<int, int> p = q.front();
            q.pop();
            int r = p.first, c = p.second;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                if(d[rr][cc] > max(d[r][c] + 1, a[rr][cc] + 1)) {
                    d[rr][cc] = max(d[r][c] + 1, a[rr][cc] + 1);
                    q.push({rr, cc});
                }
            }
        }
        
        return d[n - 1][m - 1];
    }
};",1441292763
junbinliang,junbinliang,267,3628,java,"
class Solution {
    public int minTimeToReach(int[][] a) {
        int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int n = a.length, m = a[0].length;
        int[][][] d = new int[n][m][2];
        boolean[][][] st = new boolean[n][m][2];
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = 2000000000;
            }
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> {
            return x[3] - y[3];
        });
        d[0][0][0] = 0;
        pq.add(new int[]{0, 0, 0, 0});
        
        while(pq.size() > 0) {
            int[] p = pq.poll();
            int r = p[0], c = p[1], t = p[2], dis = p[3];
            if(st[r][c][t]) continue;
            st[r][c][t] = true;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(int[] di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > Math.max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = Math.max(d[r][c][t] + w, a[rr][cc] + w);
                    pq.add(new int[]{rr, cc, t ^ 1, d[rr][cc][t ^ 1]});
                }
            }
        }
        
        
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}

/*
vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
const int INF = 2e9;
int d[760][760][2];

struct P {
    int r, c, t;
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = INF;
            }
        }
        
        queue<P> q;
        q.push({0, 0, 0});
        d[0][0][0] = 0;
        while(q.size()) {
            P p = q.front(); q.pop();
            int r = p.r, c = p.c;
            int t = p.t;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = max(d[r][c][t] + w, a[rr][cc] + w);
                    q.push({rr, cc, t ^ 1});
                }
            }
        }
        
            
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
    
    
};
*/",1441305515
junbinliang,junbinliang,267,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int s1 = 0, s2 = 0;
        for(int i = 0; i < s.size(); i++) {
            if(i % 2 == 0) s1 += s[i] - '0';
            else s2 += s[i] - '0';
        }
        return s1 == s2;
    }
};",1441280910
junbinliang,junbinliang,267,3637,cpp,"const int MOD = 1e9 + 7;
int tot = 0;
using ll = long long;
long long fact[100];

ll fpow(ll x, int y){
	ll res = 1;
	while(y){
		if(y & 1) res = (res * x) % MOD;
		x = (x * x) % MOD;
		y >>= 1;
	}
	return res;
}  

ll modInverse(ll a, ll m) {
    ll m0 = m;
    ll y = 0, x = 1;
    if (m == 1)
        return 0;
    while (a > 1) {
          // q is quotient
        ll q = a / m;
        ll t = m;
        // m is remainder now, process
        // same as Euclid's algo
        m = a % m;
        a = t;
        t = y;
        // Update x and y
        y = x - q * y;
        x = t;
    }
    // Make x positive
    if (x < 0)
        x += m0;
    return x;
}


bool yes = false;
long long C[101][101];
void init() {
    if(yes) return;
    yes = true;
    C[0][0] = 1;
    for(int i = 1;i <= 100; i++) {
      C[i][0]=1;
      for(int j = 1;j <= i;j++) {
        C[i][j] = ( C[i-1][j] + C[i-1][j-1] ) % MOD;
      }
    }
}

long long dp[11][370][45];
int p[10];
int toteven = 0, totodd = 0;

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        vector<int> cnt(10);
        tot = 0;
        for(char c : s) {
            cnt[c - '0']++;
            tot += (c - '0');
        }
        
        if(tot % 2 == 1) {
            return 0;
        }
        
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= tot / 2 + 1; j++) {
                for(int k = 0; k <= (s.size() / 2 + 1); k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        
        p[0] = cnt[0];
        for(int i = 1; i < 10; i++) {
            p[i] = cnt[i] + p[i - 1];
        }
        
        toteven = s.size() / 2;
        totodd = s.size() - toteven;
        
        int ans = dfs(cnt, 0, tot / 2, (s.size() + 1) / 2);
        //cout << endl;
        return ans;
    }
    
    long long dfs(vector<int>& cnt, int i, int s, int odd) { //10 * 360 * 40
        if(i >= cnt.size()) {
            if(odd == 0 && s == 0) {
                return 1;
            }
            return 0;
        }
        if(dp[i][s][odd] != -1) {
            return dp[i][s][odd];
        }
        

        if(cnt[i] == 0) {
            return dp[i][s][odd] = dfs(cnt, i + 1, s, odd);
        }
        long long ans = 0;
        
        
        int sum = 0;
        if(i > 0) sum = p[i - 1];
        int oddtaken = totodd - odd;
        int remainEven = toteven - (sum - oddtaken);
        
        //cout << i << "" "" << s << "" "" << odd << "" "" << oddtaken << "" "" << sum << ""  "" << remainEven << endl;
        
        
        for(int x = 0; x <= min(odd, cnt[i]); x++) {
            int sum1 = x * i;
            if(sum1 <= s) {
                if(remainEven < 0 || remainEven < (cnt[i] - x)) continue;
                long long w1 = C[odd][x];
                long long w2 = C[remainEven][cnt[i] - x];
                ll w = (w1 * w2) % MOD;
                
                /*if(i == 5 || i == 6) {
                    cout << i <<"" ""  << odd << endl;
                    cout << x << ""  "" << w1 << "" "" << w2 << "" "" << w <<""  "" << dfs(cnt, i + 1, s - sum1, odd - x) << endl << endl;
                }*/
                
                ans += (w * dfs(cnt, i + 1, s - sum1, odd - x));
                ans %= MOD;
            }
        }
        //cout << i << "" "" << s << "" "" << odd << ""  "" << ans << endl;
        return dp[i][s][odd] = ans;
    }
};

//""4567""   8
//""46453"" 6",1441383288
uf21-6,uf21-6,268,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        # Initialize distance matrix with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0  # Start from top-left corner with time 0
        
        # Min-heap priority queue: each entry is (time, row, col)
        pq = [(0, 0, 0)]
        
        # Possible directions: up, right, down, left
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            time, row, col = heapq.heappop(pq)
            
            # If the current time exceeds known minimum, skip
            if time > dist[row][col]:
                continue
            
            for dr, dc in directions:
                newRow, newCol = row + dr, col + dc
                
                # Check if within bounds
                if 0 <= newRow < n and 0 <= newCol < m:
                    # Calculate the time to move to this cell
                    newTime = max(time, moveTime[newRow][newCol]) + 1
                    
                    # Update if found a shorter time to this cell
                    if newTime < dist[newRow][newCol]:
                        dist[newRow][newCol] = newTime
                        heapq.heappush(pq, (newTime, newRow, newCol))
        
        return dist[n - 1][m - 1]
",1441316581
uf21-6,uf21-6,268,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows, cols = len(moveTime), len(moveTime[0])
        
        # Initialize distance array with a large number
        dist = [[[float('inf')] * 2 for _ in range(cols)] for _ in range(rows)]
        dist[0][0][0] = 0
        
        # Min-heap priority queue to process cells in ascending time
        heap = [(0, 0, 0, 0)]  # (time, row, col, parity)
        
        # Possible moves: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            time, x, y, parity = heapq.heappop(heap)
            
            # Skip if we already have a shorter path
            if time > dist[x][y][parity]:
                continue
            
            # Explore neighboring cells
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                # Check if neighbor is within bounds
                if 0 <= nx < rows and 0 <= ny < cols:
                    next_time = max(time, moveTime[nx][ny]) + (2 if parity else 1)
                    
                    # Update distance if a shorter path is found
                    if next_time < dist[nx][ny][1 - parity]:
                        dist[nx][ny][1 - parity] = next_time
                        heapq.heappush(heap, (next_time, nx, ny, 1 - parity))
        
        return min(dist[rows - 1][cols - 1][0], dist[rows - 1][cols - 1][1])
",1441309467
uf21-6,uf21-6,268,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                odd += int(num[i])
            else:
                even += int(num[i])
        return even == odd",1441283881
uf21-6,uf21-6,268,3637,python3,"MOD = 1_000_000_007

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        E = (N + 1) // 2  # Number of even indices (0-based)
        O = N // 2         # Number of odd indices

        # Count frequency of each digit
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1

        # Calculate total sum
        total_sum = sum(d * cnt[d] for d in range(10))

        # If total_sum is odd, no balanced permutation exists
        if total_sum % 2 != 0:
            return 0

        sum_target = total_sum // 2

        # Precompute factorial and inverse factorial
        MAX = 80
        factorial = [1] * (MAX + 1)
        for i in range(1, MAX + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_fact = [1] * (MAX + 1)
        inv_fact[MAX] = pow(factorial[MAX], MOD - 2, MOD)
        for i in range(MAX - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        # Function to compute combination C(n, k) mod MOD
        def comb(n, k):
            if k > n:
                return 0
            return factorial[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD

        # Initialize DP table
        dp = [[0] * (sum_target + 1) for _ in range(E + 1)]
        dp[0][0] = 1

        for d in range(10):
            if cnt[d] == 0:
                continue
            for t in range(E, -1, -1):
                for s in range(sum_target, -1, -1):
                    if dp[t][s] == 0:
                        continue
                    for k in range(1, cnt[d] + 1):
                        if t + k > E or s + d * k > sum_target:
                            break
                        dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD

        number_of_valid_assignments = dp[E][sum_target]

        # Compute product of factorials of digit counts
        product_cnt_d_fact = 1
        for d in range(10):
            product_cnt_d_fact = product_cnt_d_fact * factorial[cnt[d]] % MOD

        # Compute the final answer
        answer = number_of_valid_assignments
        answer = answer * factorial[E] % MOD
        answer = answer * factorial[O] % MOD
        inv_product = pow(product_cnt_d_fact, MOD - 2, MOD)
        answer = answer * inv_product % MOD

        return answer
",1441395798
naresh50,naresh50,269,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 1 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323940
naresh50,naresh50,269,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 2 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323065
naresh50,naresh50,269,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int count=0;
        for(int i=0;i<num.length();i++){
            int val = (int)num.charAt(i) -48;
            if(i%2==0) count+=val;
            else  count-=val;
        }
        if(count==0) return true;
        else return false;
    }
}",1441292047
naresh50,naresh50,269,3637,java,"class Solution {
    int mod = (int)1e9 +7;
    
    public int countBalancedPermutations(String num) {
        int n = num.length();
        long halfFact1 = factorial(n/2);
        long halfFact2 = factorial((n+1)/2);

        long[] factArray = new long[81];
         long[] modArray = new long[81];
        formArray(factArray , modArray);
       

        
        int[] count  = new int[10];
        int total=0;
        for(int i=0;i<num.length();i++){
            int val=num.charAt(i)-'0';
            count[val]++;
            total+=val;
        }
        if(total%2==1) return 0;
        long[][][] dp= new long[10][810][81];
        for(int i=0;i<dp.length;i++){
            for(int j=0;j<dp[i].length;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        long ans = helper(0,total/2 , num.length()/2 , dp,count ,factArray , halfFact1 , halfFact2 ,modArray);
        ans%=mod;
        return (int)ans;
        
    }
    public long helper(int num , int sum , int rem , long[][][] dp , int[] count , long[] factArr , long h1 , long h2 , long[] modArr ){
        if(num==10){
           if(sum==0 && rem==0) return (h1*h2)%mod;
            else return 0;
        }
        if(dp[num][sum][rem]!=-1) return dp[num][sum][rem];
        long ans=0;

        int freq = count[num];
        
        for(int i=0;i<=freq;i++){
            long temp = 0;
            if(sum>=i*num && rem>=i) temp+=helper(num+1 , sum-(i*num) , rem-i ,  dp,count , factArr ,h1,h2 , modArr );
            if(i>0) temp = (temp * modArr[i]) % mod;
            if(freq-i >0) temp = (temp * modArr[freq-i]) % mod;

            ans+=temp;
            ans%=mod;
        }
        return dp[num][sum][rem] = ans%mod;
    }
    public long factorial(int n){
        long ans=1;
        for(int i=1;i<=n;i++){
            ans*=i;
            ans%=mod;
        }
        return ans;
    }
    public void formArray(long[] arr, long[] modArr){
        arr[1]=1L;
        arr[0]=1L;
        for(int i=2;i<=80;i++){
            arr[i] = (long)i*arr[i-1];
            arr[i]%=mod;
        }

        for(int i=0;i<arr.length;i++){
            modArr[i]=modInverse(arr[i]);
        }
    }
    public  long modInverse(long a) {
        return modExp(a, mod - 2);
    }

    public long modExp(long base, long exp) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }
        return res;
    }
}",1441383508
her0e1c1,her0e1c1,270,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        heappush(pq, (nt + 1, ni, nj))
                ",1441298882
her0e1c1,her0e1c1,270,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j, c = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        nc = 1 if c == 0 else 0
                        heappush(pq, (nt + 1 + c, ni, nj, nc))
                        ",1441302584
her0e1c1,her0e1c1,270,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o = e = 0
        for i, n in enumerate(num):
            if i % 2 == 0:
                e += int(n)
            else:
                o += int(n)
        return o == e",1441282100
her0e1c1,her0e1c1,270,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def dfs(i, c, c2, acc):
            if i > 10:
                return 0
            if acc > total // 2:
                return 0
            if c > N1 or c2 > N2:
                return 0
            if c == N1 and c2 == N2:
                if acc == total // 2:
                    return 1
                return 0
            rv = 0
            for k in range(C[i] + 1):  # nCr
                n1 = N1 - c
                n2 = N2 - c2
                k2 = C[i] - k
                rv += comb(n1, k) * comb(n2, k2) * dfs(i + 1, c + k, c2 + k2, acc + k * i)
                rv %= M
            return rv
        
        C = defaultdict(int)
        N1, N2 = len(num) // 2, (len(num) + 1) // 2
        total = 0
        for n in num:
            C[int(n)] += 1
            total += int(n)
        if total % 2 == 1:
            return 0
        # print(total, N1, N2, C)
        M = 10 ** 9 + 7
        return dfs(0, 0, 0, 0) % M",1441395883
Jashanpreet Singh,jashanp2005,271,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309945
Jashanpreet Singh,jashanp2005,271,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = fact ? 2 : 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309340
Jashanpreet Singh,jashanp2005,271,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    int ans = 0, ans2 = 0;
    int n = num.length();
    for(int i = 0; i < n; i++) {
        if(i % 2 == 0) 
            ans += num[i] - '0';  
        else 
            ans2 += num[i] - '0';  
    }
    return ans == ans2;
}
};",1441283829
Jashanpreet Singh,jashanp2005,271,3637,cpp,"
vector<int> fact(101), inv(101);

vector<int> v(10, 0);

class Solution {
#define int long long

const int mod = 1e9 + 7;
const int N = 100;

int n;
int tot = 0;

int binaryexpo(int a, int b) {
    int ans = 1;
    while (b > 0) {
        if (b & 1) {
            ans = (ans * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return ans;
}

void findinverse() {
    for (int i = 0; i <= N; i++) {
        inv[i] = binaryexpo(fact[i], mod - 2);
    }
}

void findfact() {
    fact[0] = 1;
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }
}

int solve(int index, int count, int sum, vector<vector<vector<int>>> &dp) {
    if (index == 10) {
        if (2 * sum == tot && count == (n+1)/2) {
            return (fact[count]%mod * fact[n - count]%mod) % mod;
        }
        return 0; 
    }

    if(dp[index][count][sum] != -1) return dp[index][count][sum];

    int ans = 0;
    for (int i = 0; i <= v[index]; i++) {
        if (count + i <= (n + 1) / 2) {
            int term = (((solve(index + 1, count + i, sum + index * i, dp) * inv[i]) % mod) * inv[v[index] - i]) % mod;
            ans = (ans + term) % mod;
        }
    }
    return dp[index][count][sum] = ans;
}

public:
    int countBalancedPermutations(string num) {
        findfact();
    findinverse();
    tot = 0;
    n = num.length();
    v.assign(10, 0);

        

    for (char c : num) {
        tot += c - '0';
        v[c - '0']++;
    }

        vector<vector<vector<int>>> dp(10, vector<vector<int>>(n/2 + 2, vector<int>(tot+1, -1)));

    return solve(0, 0, 0, dp);
}
};
#undef int
",1441389745
craggy,craggy,272,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        d = deque()
        d.append((0, 0, 0))
        vis = [[0 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        while len(d) > 0:
            t, r, c = d.popleft()
            if vis[r][c] and vis[r][c] <= t: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                d.append((max(t, moveTime[nr][nc])+1, nr, nc))
            
        return vis[len(moveTime)-1][len(moveTime[0])-1]
        ",1441300823
craggy,craggy,272,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        vis = [[-1 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        heap = [(0, 0, 0)]
        while len(heap):
            t, r, c = heappop(heap)
            if vis[r][c] != -1: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                heappush(heap, (max(t, moveTime[nr][nc])+1+(r+c)%2, nr, nc))

        return vis[len(moveTime)-1][len(moveTime[0])-1]

    

        ",1441309959
craggy,craggy,272,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        t = [0,0]
        for i in range(len(num)):
            t[i%2] += int(num[i])

        return t[0] == t[1]
        ",1441281821
craggy,craggy,272,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        M = int(1e9)+7
        cnt = Counter(num)
        fct = [1]
        for i in range(len(num)):
            fct.append((fct[-1] * (i+1))%M)
            
        inv_fct = [1] * (len(num) + 1)
        for i in range(1, len(fct)):
            inv_fct[i] = pow(fct[i], M - 2, M)

        @cache
        def get(diff_val, diff_num, i):
            if i == 10: return (fct[len(num)//2+len(num)%2] * fct[len(num)//2]) % M if ((diff_val == 0 and diff_num == (len(num) % 2))) else 0
            ret = 0
            if cnt[str(i)] == 0: return get(diff_val, diff_num, i+1)
            for j in range(cnt[str(i)]+1):
                a = j
                b = cnt[str(i)]-j
                ret = (ret + get(diff_val+i*a-i*b, diff_num+a-b, i+1) * inv_fct[j] * inv_fct[cnt[str(i)] - j]) % M


            return ret

        return get(0, 0, 0)

        ",1441396118
invertedwinger,invertedwinger,273,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<int>> dist(n, vector<int> (m,2e9));
        dist[0][0] = 0;
        set<pair<int,pair<int,int>>> s;
        s.insert({0, {0,0}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            int d = it->first, x = it->second.first, y = it->second.second;
            s.erase(it);
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    int D = max(d+1, a[x1][y1]+1);
                    if(D<dist[x1][y1]){
                        if(dist[x1][y1] < 2e9) s.erase({dist[x1][y1], {x1,y1}});
                        s.insert({D, {x1,y1}});
                        dist[x1][y1] = D;
                    }
                }
            }
        }

        return dist[n-1][m-1];
        
    }
};",1441304415
invertedwinger,invertedwinger,273,3628,cpp,"typedef long long ll;
const ll INF = 1e18;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>> (m, vector<ll> (2,INF)));
        dist[0][0][1] = INF;
        set<pair<ll,pair<pair<int,int>, int >>> s;
        s.insert({0, {{0,0}, 1}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            ll d = it->first, x = it->second.first.first, y = it->second.first.second, z = it->second.second;
            s.erase(it);
            z = 1-z;
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    ll D =max(d+z+1, 1LL*a[x1][y1]+z+1);
                    if(D<dist[x1][y1][z]){
                        if(dist[x1][y1][z] < INF) s.erase({dist[x1][y1][z], {{x1,y1},z}});
                        s.insert({D, {{x1,y1}, z}});
                        dist[x1][y1][z] = D;
                    }
                }
            }
        }

        return min(dist[n-1][m-1][0], dist[n-1][m-1][1]);
        
    }        
    
};",1441324071
invertedwinger,invertedwinger,273,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int c1 = 0, c2 = 0;
        for(int i=0; i<n; i++){
            if(i&1) c1 += num[i]-'0';
            else c2 += num[i]-'0';
        }
        return (c1 == c2);
    }
};",1441283779
invertedwinger,invertedwinger,273,3637,cpp,"typedef long long ll;
const ll mod = 1e9+7;
const ll N=45;
ll fct[N],inv[N],invfct[N];
ll ncr(ll n,ll r){
    if(n<0 || r<0 || n-r<0)return 0;
    ll ans = fct[n]*invfct[r];
    ans%=mod;
    ans = ans * invfct[n-r];
    ans%=mod;
    return ans;
}
void init(){
    fct[0]=fct[1]=1;
    inv[1]=1;
    invfct[0]=invfct[1]=1;
    for(ll i=2;i<N;i++){
        fct[i]=i*fct[i-1]%mod;
        inv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;
        invfct[i]=ll(inv[i])*invfct[i-1]%mod;
    }
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        int sum = 0;
        int n = s.length();
        for(int i=0; i<n; i++) sum += s[i]-'0';
        if(sum&1) return 0;
        int cnt[10] = {0};
        for(int i=0; i<n; i++) cnt[s[i]-'0']++;
        sum /=2;
        int x = n/2, y = n-x;
        vector<vector<ll>> ways(sum+1, vector<ll> (x+1, 0));
        ways[0][0] = 1;
        int total = 0;
        for(int k=0; k<10; k++){
            vector<vector<ll>> temp(sum+1, vector<ll> (x+1, 0));
            for(int t=0; t<=cnt[k]; t++){
                for(int sm = 0; sm <= sum; sm++){
                    for(int i=0; i<=x; i++){
                        int j = total - i;
                            int X = i+t, Y = j+(cnt[k]-t), S = sm+t*k;
                            if(S>sum || X>x || Y>y || ways[sm][i] == 0) continue;
                            ll z = (ncr(x-i, t)*ncr(y-j, cnt[k]-t))%mod;
                            temp[S][X] = (temp[S][X] + z*ways[sm][i])%mod;
                    }
                }
            }
            total += cnt[k];
            ways = temp;
        }
        return ways[sum][x];
    }
};",1441383901
Chen Jian,xiaojian9527,275,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        f = [[0] * m for _ in range(n)]

        d = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m

        seen = set()
        pq = [(0, 0, 0)]
        while pq:
            h, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if inArea(nx, ny):
                    if (nx, ny) not in seen:
                        seen.add((nx, ny))
                        t = max(h, moveTime[nx][ny])+1
                        heappush(pq, (t, nx, ny))
        return -1
        ",1441316329
Chen Jian,xiaojian9527,275,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # step: 0, 1
        n, m = len(moveTime), len(moveTime[0])
        seen = set()
        pq = [(0, 0, 0, 0)]
        d = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m
        
        while pq:
            h, step, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h

            ns = 1-step
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if not inArea(nx, ny):
                    continue

                if (nx, ny, ns) in seen:
                    continue
                seen.add((nx, ny, ns))
                nh = max(h, moveTime[nx][ny]) + step + 1
                heappush(pq, (nh, ns, nx, ny))
        return -1
        ",1441329221
Chen Jian,xiaojian9527,275,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        for i, c in enumerate(num):
            if i % 2 == 0:
                odd -= int(c)
            else:
                odd += int(c)
        return odd == 0",1441283871
Chen Jian,xiaojian9527,275,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        sm = 0
        n = len(num)
        cnt = defaultdict(int)
        for c in num:
            sm += int(c)
            cnt[int(c)] += 1
        if sm % 2: return 0

        even = (n+1) // 2
        odd = n // 2

        MOD = 10 ** 9 + 7
        @cache
        def dfs(i: int, s: int, oc: int, ec: int) -> int:
            if i == 10:
                return s == 0 and oc == 0 and ec == 0
                
            if oc < 0 or ec < 0: return 0

            if cnt[i] == 0:
                return dfs(i+1, s, oc, ec)

            ans = 0
            for j in range(0, cnt[i]+1):
                if j > oc: break
                k = cnt[i] - j
                if k > ec: continue
                # print(comb(oc, j), comb(ec, k))
                ans += comb(oc, j) * comb(ec, k) * dfs(i+1, s + j * i - k * i, oc -j, ec - k) % MOD
            return ans % MOD
            
        return dfs(0, 0, odd, even)",1441396468
eatfood,eatfood,276,3627,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=deque()
        dq.append((0,0))
        while len(dq):
            x,y=dq.popleft()
            # check to improve
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    newdist = max(dp[x][y]+1, mt[nx][ny]+1)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.append((nx,ny))
        # for i in range(n):
        #     print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441298031
eatfood,eatfood,276,3628,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
from sortedcontainers import SortedList

class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=SortedList()
        dq.add((0,0,0))
        while len(dq):
            d,x,y=dq.pop(0)
            # check self
            if d > dp[x][y]:
                continue
            # check nbrs
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    w = 1 if ((x+y)%2 == 0) else 2
                    newdist = max(d+w, mt[nx][ny]+w)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.add((newdist,nx,ny))
        for i in range(n):
            print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441306775
eatfood,eatfood,276,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        cnt=0
        for i,ch in enumerate(s):
            d = ord(ch)-ord('0')
            cnt += d if (i % 2 == 0) else -d
        return cnt==0",1441284963
eatfood,eatfood,276,3637,python3,"'''
dp[d][num slots left][tot sum]
'''
from collections import defaultdict
mod=int(1e9+7)

f = [0] * 81
f[0] = 1
for i in range(1, 81):
    f[i] = f[i-1]*i % mod
fi = [0] * 81
fi[80] = pow(f[80], mod-2, mod)
for i in range(79, -1, -1):
    fi[i] = fi[i+1] * (i+1) % mod


# print(f[:10])
# print(fi[:10])

class Solution:
    def countBalancedPermutations(self, s: str) -> int:

        def choose(n,k):
            if k==0 or k==n:
                return 1
            if k>n or k<0:
                return 0
            return (f[n] * fi[k] * fi[n-k]) % mod
                
            
        arr=[ord(ch)-ord('0') for ch in s]
        freq=defaultdict(int)
        for x in arr:
            freq[x]+=1
        sm=sum(arr)
        if sm % 2 != 0:
            return 0
        tgt=sm//2
        slots=(len(arr)+1) // 2
        slots2 = len(arr)-slots
        # need to make tgt with exactly slots numbers
        dp=[[0]*(tgt+1) for _ in range(slots+1)]

        dp[slots][0]=1 # empty string

        num_processed = 0
        for x, fx in freq.items():
            # init dp2
            dp2=[[0]*(tgt+1) for _ in range(slots+1)]
            # for ns in range(len(dp)-1, -1, -1):
            for ns in range(len(dp)):
                for sm in range(len(dp[0])):
                    if dp[ns][sm] == 0:
                        continue
                    for k in range(0, fx+1): # pick k of x to continue this value
                        if k > ns:
                            break
                        if sm + k*x > tgt:
                            break
                        # pick k from ns to put the nums into
                        w1=choose(ns, k)
                        rem2 = slots2 - (num_processed - (slots-ns))
                        w2=choose(rem2, fx-k)
                        # print(ns, sm, k, x)
                        # print('w1', ns, k, w1)
                        # print('w2', rem2, fx-k, w2)
                        dp2[ns-k][sm + k*x] += dp[ns][sm] * (w1 * w2 % mod) % mod
                        dp2[ns-k][sm + k*x] %= mod
            
            num_processed += fx
            dp,dp2=dp2,dp
            
        #     print(x, fx)
        #     for row in dp:
        #         print(row)
        # print(tgt)
        return dp[0][tgt]
        ",1441390678
codinghermit05,codinghermit05,279,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        # Initialize distance array with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        
        # Priority queue to store (time, row, col)
        # Python's heapq is used instead of Java's PriorityQueue
        pq = [(0, 0, 0)]
        dist[0][0] = 0
        
        # All four directions: up, right, down, left
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            # Get current state with minimum time
            time, row, col = heapq.heappop(pq)
            
            # Skip if we've found a better path
            if time > dist[row][col]:
                continue
            
            # Try all four directions
            for dx, dy in dirs:
                new_row = row + dx
                new_col = col + dy
                
                # Check if new position is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate new time (wait until moveTime if necessary)
                    new_time = max(time, moveTime[new_row][new_col]) + 1
                    
                    # If found better path, update and add to queue
                    if new_time < dist[new_row][new_col]:
                        dist[new_row][new_col] = new_time
                        heapq.heappush(pq, (new_time, new_row, new_col))
        
        return dist[n-1][m-1]",1441322051
codinghermit05,codinghermit05,279,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        if not moveTime or not moveTime[0]:
            return 0
            
        n, m = len(moveTime), len(moveTime[0])
        
        # Directions for movement: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # Priority queue to store (current_time, is_odd_move, row, col)
        pq = [(0, False, 0, 0)]  # Start at (0,0) with time 0
        
        # Keep track of visited states including the odd/even move status
        visited = set()
        
        while pq:
            current_time, is_odd_move, row, col = heapq.heappop(pq)
            
            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return current_time
                
            # Skip if we've seen this state
            state = (row, col, is_odd_move)
            if state in visited:
                continue
            visited.add(state)
            
            # Try all possible moves
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy
                
                # Check if move is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Move cost alternates between 1 and 2 seconds
                    move_cost = 2 if is_odd_move else 1
                    
                    # Wait until we can enter the new room
                    wait_time = max(0, moveTime[new_row][new_col] - current_time)
                    
                    # Total time includes: current time + waiting time + move cost
                    new_time = current_time + wait_time + move_cost
                    
                    # Add new state to priority queue with flipped odd/even status
                    heapq.heappush(pq, (new_time, not is_odd_move, new_row, new_col))
        
        return -1  # If no path is found
",1441300207
codinghermit05,codinghermit05,279,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Initialize variables to store sums
        even_sum = 0
        odd_sum = 0
        
        # Iterate through the string using index
        for i in range(len(num)):
            # Convert character to integer
            digit = int(num[i])
            
            # If index is even, add to even_sum
            if i % 2 == 0:
                even_sum += digit
            # If index is odd, add to odd_sum
            else:
                odd_sum += digit
        
        # Return true if sums are equal, false otherwise
        return even_sum == odd_sum",1441284044
codinghermit05,codinghermit05,279,3637,python3,"class Solution(object):
    MOD = 1000000007

    def countBalancedPermutations(self, num):
        """"""
        Count the number of balanced permutations of a given number string.
        
        :type num: str
        :rtype: int
        """"""
        # Initialize basic variables
        length = len(num)
        total_sum = sum(int(digit) for digit in num)
        counts = [0] * 10
        for digit in num:
            counts[int(digit)] += 1
        
        # Early return if sum is odd (can't be balanced)
        if total_sum % 2 != 0:
            return 0
        
        half_sum = total_sum // 2
        m = (length + 1) // 2
        
        # Precompute factorials and their inverses
        factorial = [1] * (length + 1)
        for i in range(1, length + 1):
            factorial[i] = factorial[i - 1] * i % self.MOD
        
        inv_factorial = [1] * (length + 1)
        inv_factorial[length] = self.mod_inverse(factorial[length], self.MOD)
        for i in range(length - 1, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % self.MOD
        
        # Initialize DP table for counting balanced subsets
        dp = [[0] * (half_sum + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        # Fill DP table
        for d in range(10):
            if counts[d] == 0:
                continue
                
            for k in range(m, -1, -1):
                for s in range(half_sum, -1, -1):
                    if dp[k][s] == 0:
                        continue
                        
                    for t in range(1, counts[d] + 1):
                        if k + t > m or s + d * t > half_sum:
                            break
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + 
                                               dp[k][s] * 
                                               self.comb(counts[d], t, factorial, inv_factorial, self.MOD)) % self.MOD
        
        # Calculate final result
        w = dp[m][half_sum]
        result = factorial[m] * factorial[length - m] % self.MOD
        
        for d in range(10):
            result = result * inv_factorial[counts[d]] % self.MOD
            
        result = result * w % self.MOD
        return int(result)
    
    def mod_inverse(self, a, m):
        """"""
        Calculate modular multiplicative inverse using fast exponentiation.
        """"""
        result = 1
        p = m - 2
        base = a
        
        while p > 0:
            if p & 1:
                result = result * base % m
            base = base * base % m
            p >>= 1
            
        return result
    
    def comb(self, n, k, factorial, inv_factorial, m):
        """"""
        Calculate combination (n choose k) using precomputed factorials.
        """"""
        if k > n:
            return 0
        return factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m",1441354877
yaominzh,yaominzh,280,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  
        visited = [[False] * m for _ in range(n)]
        min_heap = [(0, 0, 0)]  # (time, x, y)
        
        while min_heap:
            current_time, x, y = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if visited[x][y]:
                continue
            visited[x][y] = True
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
                    wait_time = max(current_time + 1, moveTime[nx][ny]+1)
                    heapq.heappush(min_heap, (wait_time, nx, ny))
        return -1
",1441367140
yaominzh,yaominzh,280,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
        visited = [[float('inf')] * m for _ in range(n)]
        min_heap = [(0, 0, 0, 1)]  # (time, x, y, next_move_time)
        
        while min_heap:
            current_time, x, y, move_cost = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if current_time >= visited[x][y]:
                continue
            visited[x][y] = current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    wait_time = max(current_time + move_cost, moveTime[nx][ny]+move_cost)
                    next_move_cost = 1 if move_cost == 2 else 2
                    heapq.heappush(min_heap, (wait_time, nx, ny, next_move_cost))
        
        return -1 
    
",1441380163
yaominzh,yaominzh,280,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
    
        for i in range(len(num)):
            if i % 2 == 0:  
                even_sum += int(num[i])
            else:          
                odd_sum += int(num[i])
    
        return even_sum == odd_sum
        ",1441287516
yaominzh,yaominzh,280,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        mod = 10**9 + 7

        total_counts = [0] * 10
        for ch in num:
            total_counts[int(ch)] += 1

        n = len(num)
        n_even = (n + 1) // 2  # Number of even indices (0-based)
        n_odd = n // 2         # Number of odd indices

        max_sum = sum(d * c for d, c in enumerate(total_counts))
        if max_sum % 2 != 0:
            return 0
        half_sum = max_sum // 2

        MAX_N = n + 1
        factorials = [1] * (MAX_N)
        inv_factorials = [1] * (MAX_N)

        for i in range(1, MAX_N):
            factorials[i] = (factorials[i - 1] * i) % mod

        inv_factorials[MAX_N - 1] = pow(factorials[MAX_N - 1], mod - 2, mod)
        for i in range(MAX_N - 2, -1, -1):
            inv_factorials[i] = (inv_factorials[i + 1] * (i + 1)) % mod

        # Initialize DP array
        dp = [ [0] * (n_even + 1) for _ in range(half_sum + 1) ]
        dp[0][0] = 1  # Base case

        # Fill DP array
        for d in range(10):
            c_d = total_counts[d]
            if c_d == 0:
                continue
            # Precompute combinations C(c_d, k_d)
            comb = [1]  # C(c_d, 0)
            for k_d in range(1, c_d + 1):
                comb.append((comb[-1] * (c_d - k_d + 1) * pow(k_d, mod - 2, mod)) % mod)
            # Update DP array
            for s in range(half_sum, -1, -1):
                for k in range(n_even, -1, -1):
                    val = dp[s][k]
                    if val == 0:
                        continue
                    for count in range(1, min(c_d, n_even - k) + 1):
                        new_s = s + count * d
                        new_k = k + count
                        if new_s > half_sum or new_k > n_even:
                            break
                        dp[new_s][new_k] = (dp[new_s][new_k] + val * comb[count]) % mod

        ways = dp[half_sum][n_even]

        if ways == 0:
            return 0

        perm_even = factorials[n_even]
        perm_odd = factorials[n_odd]

        total_counts_product = 1
        for cnt in total_counts:
            total_counts_product = (total_counts_product * inv_factorials[cnt]) % mod

        answer = (ways * factorials[n_even] * factorials[n_odd]) % mod
        answer = (answer * total_counts_product) % mod

        return answer

",1441347489
Jie Chen,JustJie,282,3627,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<i64, int, int>;

constexpr i64 inf = i64(1e18) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({encode(i, j), t + p, p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -1, 1);
        while (!h.empty()) {
            auto [cur, t, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441324013
Jie Chen,JustJie,282,3628,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<int, int, int>;

constexpr int inf = int(2e9) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({t + p, encode(i, j), 1 ^ 2 ^ p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -2, 2);
        while (!h.empty()) {
            auto [t, cur, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441326480
Jie Chen,JustJie,282,3636,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < s.size(); i++) {
            if (i % 2 == 0) {
                sum += (s[i] - '0');
            } else {
                sum -= (s[i] - '0');
            }
        }
        return (sum == 0);
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441323288
Jie Chen,JustJie,282,3637,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

constexpr int D = 10;
constexpr int N = 81;
constexpr int LIM = 800;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();

        vector<int> cnt(D);
        vector<int> pre(D + 1);
        vector<int> pre2(D + 1);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            int d = s[i] - '0';
            sum += d;
            cnt[d]++;
        }
        for (int d = 0; d < D; d++) {
            pre[d + 1] = pre[d] + cnt[d];
            pre2[d + 1] = pre2[d] + cnt[d] * d;
        }

        if (sum & 1) {
            return 0;
        }

        int w = sum / 2;
        int e = (n + 1) / 2;
        vector dp(e + 1, vector<Z>(w + 1));
        dp[0][0] = 1;

        int o = n - e;
        for (int d = 0; d < D; d++) {
            if (cnt[d] == 0) {
                continue;
            }
            vector ndp(n, vector<Z>(w + 1));
            for (int ec = 0; ec <= e; ec++) {
                int oc = pre[d] - ec;
                for (int eps = 0; eps <= w; eps++) {
                    int ops = pre2[d] - eps;
                    if (dp[ec][eps].val() == 0) {
                        continue;
                    }
                    // cout << ""DP GOOD: "" << ec << "" "" << eps << "" "" << ops << ""\n"";
                    for (int euse = 0; euse <= cnt[d]; euse++) {
                        int ouse = cnt[d] - euse;
                        if (ec + euse > e) {
                            // cout << ""1\n"";
                            break;
                        }
                        if (eps + euse * d > w) {
                            // cout << ""2\n"";
                            break;
                        }
                        if (oc + ouse > o) {
                            // cout << ""3\n"";
                            continue;
                        }
                        if (ops + ouse * d > w) {
                            // cout << ""4\n"";
                            continue;
                        }
                        // cout << ec + euse << "" "" << eps + euse * d << "" "" << ops + ouse * d << ""\n"";
                        ndp[ec + euse][eps + euse * d] += (dp[ec][eps] * comb.binom(e - ec, euse) * comb.binom(o - oc, ouse));
                    }
                }
            }
            dp = std::move(ndp);
        }

        return dp[e][w].val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441380513
kavascg,kavascgjmd39,283,3627,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                 
                    ll val = max((ll)a[ni][nj]+1 , abs(top.first) + 1);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441328219
kavascg,kavascgjmd39,283,3628,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                    ll x = ((top.first >= 0 )? 1: 2);
                    ll val = max((ll)a[ni][nj]+x , abs(top.first) + x);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441327440
kavascg,kavascgjmd39,283,3636,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
class Solution {
public:
    bool isBalanced(string s) {
        ll sum1 = 0, sum2 = 0;
     for(int i = 0 ; i<s.size() ; i++ ){
         if(i & 1){
             sum1 += s[i]-'0';
         }
         else {
             sum2 += s[i]-'0';
         }
     }
        return sum1 == sum2;
    }
};",1441282187
kavascg,kavascgjmd39,283,3637,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
int dp[10][81][721];
vector<ll> fac, inv_fac;
ll binexpo(ll x, ll y, ll mod) {
    ll res = 1;
    while (y > 0) {
        if (y & 1)
            res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
void precompute_factorials(ll n, ll mod) {
    fac.resize(n + 1);
    inv_fac.resize(n + 1);
    fac[0] = fac[1] = 1;
    for (ll i = 2; i <= n; i++) {
        fac[i] = fac[i - 1] * i % mod;
    }
    inv_fac[n] = binexpo(fac[n], mod - 2, mod);
    for (ll i = n - 1; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
    }
}

class Solution {
    int count(vt<int>&a, int i , int len , int sum , int n, int s){
        if(i == 10){
            if(len == n/2 && sum == s){
                return (fac[n/2]*fac[n-n/2])%mod;
            }
            return 0;
        }
        if(dp[i][len][sum] != -1){
            return dp[i][len][sum];
        }
        ll res = 0;
        for(int j = 0  ; j<a[i]+1 ; j++){
            res += (ll)count(a, i+1 , len+j , sum + j*i, n, s) * (ll)(((ll)inv_fac[j] * (ll)inv_fac[a[i]-j]) % mod); res %= mod;
        }
        return dp[i][len][sum] = res;
    }
public:
    int countBalancedPermutations(string a) {
        memset(dp, -1 , sizeof(dp));
        precompute_factorials(81, mod);
        vt<int>v(10, 0);
        ll sum = 0;
        rep(i , 0 , a.size()){
           v[a[i]-'0']++;
            sum += (a[i]-'0');
        }
        if(sum & 1){return 0;}
        sum /= 2;
        ll res = count(v, 0 , 0 ,0 , a.size(), sum  );
       
        return res;
    }
};",1441382036
leetcode_3604,leetcode_3604,284,3627,cpp,"class Solution {
public:
       typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 1;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441387316
leetcode_3604,leetcode_3604,284,3628,cpp,"class Solution {
public:
   typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 2;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441386429
leetcode_3604,leetcode_3604,284,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd(0), even(0);
        for(int i = 0; i < num.size(); ++i) {
            if(i&1) odd += num[i]-'0';
            else even += num[i]-'0';
        }
        return odd == even;
    }
};",1441389379
leetcode_3604,leetcode_3604,284,3637,cpp,"class Solution {
public:
    typedef long long LL;
    LL dp[11][81][810];
    LL mod = 1000000007;
    LL C[90][90];
    int cnt[10];
    int countBalancedPermutations(string s) {
        memset(cnt, 0, sizeof(cnt));
        int sum(0);
        for(auto ch: s) {
            ++cnt[ch - '0'];
            sum += ch - '0';
        }
        if(sum % 2 == 1) return 0;
        memset(C, 0, sizeof(C));
        C[0][0] = 1;
        for(int i = 1; i <= 80; ++i) {
            C[i][0] = 1;
            for(int j = 1; j <= 80; ++j) {
                C[i][j] = C[i-1][j] + C[i-1][j-1];
                C[i][j]  %= mod;
            }
        }
        memset(dp, 0, sizeof(dp));
        //printf(""%lld %lld\n"", C[4][2], C[5][2]);
        int n = s.size();
        dp[0][0][0] = 1;
        int t(0);
        for(int i = 0; i < 10; ++i) {
            for(int j = 0; j <= cnt[i]; ++j) {
                //printf(""%d %d %d\n"", i, j, cnt[i]);
                for(int l = 0; j + l <= n/2; ++l) {
                    for(int k = 0; k + j * i <= sum/2; ++k) {
                        if(n-n/2 - (t - l) < 0) continue;
                        // 
                        dp[i+1][l+j][k+j*i] += C[n/2 - l][j] * C[n-n/2 - (t - l)][cnt[i]-j] % mod * dp[i][l][k] % mod;
                        dp[i+1][l+j][k+j*i] %= mod;
                        //printf(""%d %d %d %d %lld %lld\n"", i, j, l, k, dp[i+1][l+j][k+j*i], dp[i][l][k]);
                    }// 1254, 2145, 5214, 5412, 
                    // 2 * 2 * 2
                }
            }
            t += cnt[i];
        }
        LL ans = dp[10][n/2][sum/2] % mod;
        int f(0);
        for(int i = 0;i < 10; ++i) if (cnt[i] > 0) ++f;
        //if (n % 2 == 0 && f > 1) ans = ans * 2 % mod;
        return ans;
    }
};",1441356783
Sk Najir,Najir581,285,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        set<pair<int, pair<int, int>>> st;
        st.insert({0, {0, 0}});
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;
        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());
            int x = it.first;
            int i = it.second.first;
            int j = it.second.second;
            if (i == n - 1 and j == m - 1)
                return max(x , v[n - 1][m - 1]);
            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 and b >= 0 and a < n and b < m and vis[a][b] == 0) {
                    st.insert({max(x + 1, v[a][b]+1), {a, b}});
                    vis[a][b] = 1;
                }
            }
        }
        return 1;
    }
};",1441318252
Sk Najir,Najir581,285,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        
        set<pair<int, pair<int, pair<int, int>>>> st;
        st.insert({0, {1, {0, 0}}});
        
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;

        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());

            int x = it.first;
            int op = it.second.first;
            int i = it.second.second.first;
            int j = it.second.second.second;

            if (i == n - 1 && j == m - 1) {
                return max(x, v[n - 1][m - 1]);
            }

            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 && b >= 0 && a < n && b < m && vis[a][b] == 0) {
                    vis[a][b] = 1;
                    if (op == 1) {
                        st.insert({max(x + 1, v[a][b] + 1), {2, {a, b}}});
                    } else {
                        st.insert({max(x + 2, v[a][b] + 2), {1, {a, b}}});
                    }
                }
            }
        }
        // Add return statement for when no path is found to the destination.
        return -1;
    }
};
",1441335699
Sk Najir,Najir581,285,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n=s.size();
        int sm1=0,sm2=0;
        for(int i=0;i<n;i++){
            if(i%2)sm1+=(s[i]-'0');
            else sm2+=(s[i]-'0');
        }
        return sm1==sm2;
    }
};",1441283378
Sk Najir,Najir581,285,3637,cpp,"const int MOD = 1e9 + 7;
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
template<const int mod>
struct mint {
    int val;
    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}
    explicit operator int() const { return val; }
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }
    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }
    mint operator-() const { return val == 0 ? 0 : mod - val; }
    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }
    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }
    mint operator++(int32_t) { mint before = *this; ++*this; return before; }
    mint operator--(int32_t) { mint before = *this; --*this; return before; }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
};
using Mint = mint<MOD>;
 
namespace comb {
    int n(0);
    vector<Mint> _fac{1}, _invfac{1}, _inv{0};
    void init(int m) {
        m = min (m, MOD - 1);
        if (m <= n) return;
        _fac.resize(m + 1); _invfac.resize(m + 1); _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) _fac[i] = _fac[i - 1] * i;
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) _invfac[i - 1] = _invfac[i] * i, _inv[i] = _invfac[i] * _fac[i - 1];
        n = m;
    }
    Mint fac(int m) { if (m > n) init(2 * m); return _fac[m]; }
    Mint invfac(int m) { if (m > n) init(2 * m); return _invfac[m]; }
    Mint inv(int m) { if (m > n) init(2 * m); return _inv[m]; }
    Mint ncr(int n, int r) { if (n < r || r < 0) return 0; return fac(n) * invfac(r) * invfac(n - r); }
}
using comb::fac;
using comb::inv;
using comb::invfac;
using comb::ncr;
// shortcut type
typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<ll> vl;
typedef vector<vl> vll;
typedef pair<int, int> pi;
typedef pair<ll, ll> pl;

// Constants
class Solution {
int dp[82][1600][60];
string s;
int odd;
int f(int i,int sm,int odnum){
    if(odnum>odd)return 0;
    if(i<0){
        if(odd==odnum){
            return sm==0;
        }
        return 0;
    }
if(dp[i][sm+1000][odnum]!=-1)return dp[i][sm+1000][odnum];
    int x=f(i-1,sm+(s[i]-'0'),odnum+1);
    int y=f(i-1,sm-(s[i]-'0'),odnum);

    return dp[i][sm+1000][odnum]=((0LL+x+y)%MOD);
    
}
vi fact;
void pre(){
    fact.resize(90);
    fact[0]=1;
    for(int i=1;i<=89;i++){
        fact[i]=(1LL*fact[i-1]*i)%MOD;
    }
}
public:

    int countBalancedPermutations(string num) {
        pre();
        s=num;
        memset(dp,-1,sizeof(dp));
        int n=s.size();
        odd=n/2;
     map<int,int>m;
        for(auto it:s){
            m[it-'0']++;
        }
      int ans= f(n-1,0,0);
        ans=max(ans,0);
        //cout<<ans<<endl;
        Mint a=ans;
        a=(a*fact[odd]*fact[n-odd]);
        for(auto it:m){
            a=(a/(Mint)fact[it.second]);
        }
        return (int)a;
        
        
    }
};",1441395990
Michael Bao,tcmmichaelb139,286,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, -1));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            ans[v.first][v.second] = dist;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                q.push({max(dist + 1, moveTime[x][y]+1), {x, y}});
            }
        }
        for (int i= 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << ans[i][j] << "" \n""[j+1 == m];
            }
        }
        return ans[n-1][m-1];
    }
};",1441313231
Michael Bao,tcmmichaelb139,286,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, 2e9));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            if (v.first == n && v.second == m) break;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                int add = v.first+v.second;
                int ndist = max(dist, moveTime[x][y]) + 1+(add&1);
                if (ans[x][y] <= ndist) continue;
                ans[x][y] = ndist;
                q.push({ndist, {x, y}});
            }
        }
        return ans[n-1][m-1];
    }
};",1441328073
Michael Bao,tcmmichaelb139,286,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int osum = 0;
        int esum = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i&1) osum += num[i]-'0';
            else esum += num[i]-'0';
        }
        return osum == esum;
    }
};",1441284864
Michael Bao,tcmmichaelb139,286,3637,cpp,"class Solution {
public:
    long long MOD = 1e9+7;
    long long add(long long a, long long b) { return (a+b)%MOD;}
    long long mult(long long a, long long b) { return a*b%MOD; }

    long long binpow(long long a, long long b) {
        long long ret = 1;
        while (b) {
            if (b & 1) ret = mult(ret, a);
            a = mult(a, a);
            b >>=1;
        }
        return ret;
    }
    long long fac[50], inv[50];
    void init() {
        fac[0] = 1;
        fac[1] = 1;
        inv[0] = 1;
        inv[1] = 1;
        for (int i = 2; i < 50; i++) {
            fac[i] = mult(i, fac[i-1]);
            inv[i] = binpow(fac[i], MOD-2);
        }
    }
    long long nCr(long long a, long long b) {
        return mult(fac[a], mult(inv[b], inv[a-b]));
    }
    int countBalancedPermutations(string num) {
        init();
        int n = num.length();
        int sum = 0;
        map<int, int> cnt;
        for (int i = 0; i < n; i++) {
            sum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        int halfsum = sum/2+1;
        if (sum & 1) return 0;
        long long dp[11][halfsum][n/2+1];
        memset(dp, 0ll, sizeof dp);
        dp[0][0][0] = 1;
        int rem = 0;
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < halfsum;j++) {
                for (int k = 0; k <= n/2; k++) {
                    for (int a = 0; a <= cnt[i]; a++) {  
                        if (j + a*i >= halfsum) break;
                        if (k + a > n/2) break;
                        int kalt = rem - k;
                        if (kalt < 0) continue;
                        if ((n+1)/2 < cnt[i]-a + kalt) continue;
                        assert(n/2-k >= a);
                        assert((n+1)/2-kalt >= cnt[i]-a);
                        // cout << i << ' ' << j << ' ' << k << ' ' << kalt << ' ' << a << ' ' << dp[i][j][k] << '\n';
                        dp[i+1][j+a*i][k+a] = add(dp[i+1][j+a*i][k+a], 
                            mult(dp[i][j][k], 
                            mult(nCr(n/2-k, a), nCr(((n+1)/2)-kalt, cnt[i]-a))));
                    }
                }
            }
            rem += cnt[i];
        }
        return dp[10][halfsum-1][n/2];
    }
};",1441389966
quynhit,quynhit,287,3627,cpp,"#include <vector>
#include <queue>
#include <limits>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int R = moveTime.size();
        int C = moveTime[0].size();
        
        vector<vector<int>> dist(R, vector<int>(C, numeric_limits<int>::max()));
        auto cmp = [](const array<int, 3>& a, const array<int, 3>& b) { return a[0] > b[0]; };
        priority_queue<array<int, 3>, vector<array<int, 3>>, decltype(cmp)> pq(cmp);
        
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        auto inside = [&](int r, int c) -> bool{
            return r >= 0 && r < R && c >= 0 && c < C;
        };
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0], row = curr[1], col = curr[2];
            if (time > dist[row][col]) continue;
            for(int dir = 0; dir < 4; dir++){
                int newRow = row + dx[dir];
                int newCol = col + dy[dir];
                
                if (inside(newRow, newCol)) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[R - 1][C - 1];
    }
};",1441329395
quynhit,quynhit,287,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size(), m = moveTime[0].size();
        auto inside = [&](int r, int c){
            return r >= 0 && r < n && c >= 0 && c < m;
        };
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, LLONG_MAX)));
        d[0][0][0] = 0;
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> q;
        q.push({0, {0, 0, 0}});
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        while (!q.empty()) {
            auto [t, v] = q. top();
            q.pop();
            int i = v[0], j = v[1], p = v[2];
            if (t > d[i][j][p]) continue;
            for(int dir = 0; dir < 4; dir++){
                int ni = i + dx[dir], nj = j + dy[dir];
                if (inside(ni, nj)) {
                    int nt = max(t, 1LL * moveTime[ni][nj]) + (p ? 2 : 1);
                    if (nt < d[ni][nj][!p]) {
                        d[ni][nj][!p] = nt;
                        q.push({nt, {ni, nj, !p}});
                    }
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
        #undef int
    }
};",1441347079
quynhit,quynhit,287,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i = 0; i < size(num); i++){
            if(i & 1){
                odd += num[i] - '0';
            } else {
                even += num[i] - '0';
            }
        }
        return even == odd;
    }
};",1441280930
quynhit,quynhit,287,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
#define int long long

int power_mod(int base, int exponent) {
    int result = 1;
    base %= MOD;
    while (exponent > 0) {
        if (exponent & 1) {
            result = result * base % MOD;
        }
        base = base * base % MOD;
        exponent >>= 1;
    }
    return result;
}

class Solution {
public:
    #undef int
    int countBalancedPermutations(string num) {
        #define int long long 
        int total_sum = 0;
        vector<int> frequency(10, 0);
        for (auto c : num) {
            frequency[c - '0']++;
            total_sum += (c - '0');
        }
        if (total_sum & 1) return 0;
        int n = size(num);
        int half_sum = total_sum / 2, half_length = (n + 1) / 2;
        vector<int> factorial(n + 1, 1);
        for (int i = 1; i <= n; i++)
            factorial[i] = factorial[i - 1] * i % MOD;
        vector<int> inverse_factorial(n + 1, 1);
        inverse_factorial[n] = power_mod(factorial[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
            inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % MOD;
        vector<vector<int>> dp(half_length + 1, vector<int>(half_sum + 1, 0));
        dp[0][0] = 1;
        for (int digit = 0; digit <= 9; digit++) {
            if (frequency[digit] == 0) continue;
            for (int count = half_length; count >= 0; count--)
                for (int sum = half_sum; sum >= 0; sum--) {
                    if (dp[count][sum] == 0) continue;
                    for (int times = 1; times <= min(frequency[digit], half_length - count); times++) {
                        if (sum + digit * times > half_sum) break;
                        int combinations = (factorial[frequency[digit]] * inverse_factorial[times] % MOD) * inverse_factorial[frequency[digit] - times] % MOD;
                        dp[count + times][sum + digit * times] = (dp[count + times][sum + digit * times] + dp[count][sum] * combinations) % MOD;
                    }
                }
        }

        int valid_assignments = dp[half_length][half_sum];
        if (valid_assignments == 0) return 0;
        int product_factorials = 1;
        for (int digit = 0; digit <= 9; digit++)
            product_factorials = product_factorials * factorial[frequency[digit]] % MOD;
        int fk_fnk = (factorial[half_length] * factorial[n - half_length]) % MOD;
        int inv_product_factorials = power_mod(product_factorials, MOD - 2);
        return (((fk_fnk * valid_assignments) % MOD) * inv_product_factorials) % MOD;
        #undef int
    }
};",1441385400
Abhi7527,Abhi7527,288,3627,cpp,"class Solution {
public:
int dirr[4]={-1,0,1,0};
int dirc[4]={0,-1,0,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>>dp(moveTime.size(),vector<int>(moveTime[0].size(),INT_MAX));
        queue<pair<int,int>>q;
        dp[0][0]=0;
        q.push({0,0});
        while(!q.empty()){
            int row=q.front().first;
            int col=q.front().second;
            q.pop();
            for(int k=0;k<4;k++){
                int rowi=row+dirr[k];
                int coli=col+dirc[k];
                if(rowi<n && coli<m && rowi>=0 && coli>=0){
                    int l=dp[row][col];
                    int b=moveTime[rowi][coli];
                    int y=max(l,b);
                    if(dp[rowi][coli]>y+1){
                        dp[rowi][coli]=y+1;
                        q.push({rowi,coli});
                    }
                }
            }
        }
        return dp[n-1][m-1];
        
    }
};",1441298215
Abhi7527,Abhi7527,288,3628,cpp,"#include <vector>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

class Solution {
public:
    int dirr[4] = {-1, 0, 1, 0};
    int dirc[4] = {0, -1, 0, 1};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, pair<int,int>>>, vector<pair<int, pair<int, pair<int,int>>>>, greater<pair<int, pair<int, pair<int,int>>>>> pq;
        
        dp[0][0] = 0;
        pq.push({0, {0, {0,1}}}); // {time, {row, col}}

        while (!pq.empty()) {
           int dis=pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second.first;
            int step=pq.top().second.second.second;
            pq.pop();

            if (row == n - 1 && col == m - 1) {
                return dis;
            }

            for (int k = 0; k < 4; ++k) {
                int newRow = row + dirr[k];
                int newCol = col + dirc[k];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(dis, moveTime[newRow][newCol]);
                    if (dp[newRow][newCol] > newTime+step) {
                        dp[newRow][newCol] = newTime+step;
                        if(step==1){
                        pq.push({ dp[newRow][newCol], {newRow, {newCol,2}}});
                        }
                        else{
                            pq.push({ dp[newRow][newCol], {newRow, {newCol,1}}});
                            
                        }
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
",1441319049
Abhi7527,Abhi7527,288,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0;
        int b=0;
        for(int i=0;i<num.size();i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        if(a==b){
            return true;
        }
        return false;
    }
};",1441283773
Abhi7527,Abhi7527,288,3637,cpp,"class Solution {
public:
int mod=1e9+7;
int l;
int lena,lenb;
vector<vector<long long>>pnc;
int yi(vector<vector<long long>>&pn,int n,int r){
    if(n==r || r==0){
        return 1;
    }
    if(pn[n][r]!=-1){
        return pn[n][r];
    }
    return pn[n][r]=(yi(pn,n-1,r)+yi(pn,n-1,r-1))%mod;
}

long long y(vector<vector<vector<long long>>>&dp,int i,int sum,int len,vector<pair<int,int>>&vec,vector<int>&p){
    
    if(i==vec.size()){
        if(sum==0){
       return 1;
    }
        return 0;
    }
    if(dp[i][sum][len]!=-1){
        return dp[i][sum][len];
    }
    long long ans=0;
    int gh=p[i]-len;
    for(int k=0;k<=vec[i].second;k++){
        
        if(len>=k && gh>=vec[i].second-k && sum>=k*vec[i].first){
            
            long long h=(pnc[len][k]*pnc[gh][vec[i].second-k])%mod;
            ans=(ans+h*(y(dp,i+1,sum-k*vec[i].first,len-k,vec,p)%mod))%mod;
        }
    }
    return dp[i][sum][len]=ans%mod;
}

    int countBalancedPermutations(string num) {
        pnc=vector<vector<long long>>(41,vector<long long>(41,-1));
        for(int i=0;i<=40;i++){
            for(int j=0;j<=40;j++){
                if(i>=j){
                     pnc[i][j]=yi(pnc,i,j);
                }
               
            }
        }
        l=num.length();
        unordered_map<int,int>mp;
        int l=0;
        for(auto it:num){
           mp[it-'0']++;
            l+=it-'0';
        }
        vector<pair<int,int>>vec;
        vector<int>p;
        int li=num.length();
        for(auto it:mp){
            p.push_back(li);
            vec.push_back({it.first,it.second});
            li-=it.second;
        }
        
        if(l%2){
            return 0;
        }
        vector<vector<vector<long long>>>dp(vec.size(),vector<vector<long long>>(l/2+1,vector<long long>(num.length()/2+1,-1)));
        return y(dp,0,l/2,num.length()/2,vec,p);
        
    }
};",1441396105
Anshuman Kanungo,PeacefulGuy,291,3627,cpp,"#include <vector>
#include <queue>
#include <climits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        vector<vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.empty()) {
            vector<int> curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};
",1441372568
Anshuman Kanungo,PeacefulGuy,291,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        // 3D array to store minimum time
        int[][][] d = new int[n][m][2];
        for (int[][] layer : d) {
            for (int[] row : layer) {
                java.util.Arrays.fill(row, Integer.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        // Priority queue stores {time, x, y, p}
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        q.offer(new int[]{0, 0, 0, 0}); // {time, x, y, p}

        // Directions for movement (down, right, up, left)
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!q.isEmpty()) {
            int[] current = q.poll();
            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (int[] dir : directions) {
                int ni = i + dir[0];
                int nj = j + dir[1];

                // Check bounds
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 1 ? 2 : 1);

                    // Update minimum time if found a better path
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        q.offer(new int[]{nt, ni, nj, 1 - p}); // Update state
                    }
                }
            }
        }

        // Return the minimum time to reach the bottom-right corner
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441345048
Anshuman Kanungo,PeacefulGuy,291,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0'; // Convert char to integer

            if (i % 2 == 0) { // Even index
                evenSum += digit;
            } else { // Odd index
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}
",1441292483
Anshuman Kanungo,PeacefulGuy,291,3637,java,"import java.util.Arrays;

class Solution {
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;

    private long powerMod(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerMod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        long totalSum = 0;
        int[] freq = new int[10];

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;

        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;

        return (int) answer;
    }
}
",1441381843
Titas,ads3k,294,3627,python3,"from heapq import heappush, heappop
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        # Array to store minimum time to reach each cell
        dp = [[float('inf')] * m for _ in range(n)]
        dp[0][0] = 0

        # Priority queue to store (current_time, row, col)
        pq = [(0, 0, 0)]

        # Directions: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while pq:
            curr_time, row, col = heappop(pq)

            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return curr_time

            # Skip if we've found a better path
            if curr_time > dp[row][col]:
                continue

            # Try all possible directions
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy

                # Check if new position is within bounds
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate waiting time if needed
                    wait_time = max(0, moveTime[new_row][new_col] - curr_time)
                    next_time = curr_time + wait_time + 1  # Add 1 for movement

                    # Update if we found a better path
                    if next_time < dp[new_row][new_col]:
                        dp[new_row][new_col] = next_time
                        heappush(pq, (next_time, new_row, new_col))

        return dp[n - 1][m - 1]
",1441303344
Titas,ads3k,294,3628,python3,"import heapq

class Solution(object):
    # Dummy functions
    def dummyFunc1(self): pass
    def dummyFunc2(self): pass
    def dummyFunc3(self): pass
    def dummyFunc4(self): pass
    def dummyFunc5(self): pass
    def dummyFunc6(self): pass
    def dummyFunc7(self): pass
    def dummyFunc8(self): pass
    def dummyFunc9(self): pass
    def dummyFunc10(self): pass

    def minTimeToReach(self, mt):
        # Dummy variables
        a1, a2, a3, a4, a5, a6, a7, a8, a9, a0 = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        n = len(mt)
        m = len(mt[0])
        
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        pq = [(0, (0, 0, 0))]

        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            if t > d[i][j][p]:
                continue

            d_idx = 0  # Loop variable for direction indexing
            while d_idx < len(directions):
                di, dj = directions[d_idx]
                ni, nj = i + di, j + dj

                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, mt[ni][nj]) + (2 if p else 1)
                    
                    if nt < d[ni][nj][1 - p]:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))

                d_idx += 1  # Increment direction index

        return min(d[n-1][m-1][0], d[n-1][m-1][1])
",1441376394
Titas,ads3k,294,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Dummy variables
        a, b, c, d, e, f, g, h, i, j = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        
        # Dummy functions
        def dummy_func1(): pass
        def dummy_func2(): pass
        def dummy_func3(): pass
        def dummy_func4(): pass
        def dummy_func5(): pass
        def dummy_func6(): pass
        def dummy_func7(): pass
        def dummy_func8(): pass
        def dummy_func9(): pass
        def dummy_func10(): pass
        
        # Actual solution
        even_sum, odd_sum = 0, 0
        idx = 0
        length = len(num)
        
        while idx < length:
            digit = int(num[idx])
            if idx % 2 == 0:
                even_sum += digit
            else:
                odd_sum += digit
            idx += 1
            
        return even_sum == odd_sum
",1441293345
Titas,ads3k,294,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact;
vector<ll> inv_fact;

// Dummy variables
ll a1, a2, a3, a4, a5, a6, a7, a8, a9, a0;

ll power_mod_func(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    int i = 1; // Loop variable for while loop
    while (i <= n) {
        fact[i] = fact[i - 1] * i % MOD;
        i++;
    }
    inv_fact.assign(n + 1, 1);
    inv_fact[n] = power_mod_func(fact[n], MOD - 2);
    i = n - 1; // Reset loop variable for another while loop
    while (i >= 0) {
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        i--;
    }
}

class Solution {
public:
    // Dummy functions
    void dummyFunc1() {}
    void dummyFunc2() {}
    void dummyFunc3() {}
    void dummyFunc4() {}
    void dummyFunc5() {}
    void dummyFunc6() {}
    void dummyFunc7() {}
    void dummyFunc8() {}
    void dummyFunc9() {}
    void dummyFunc10() {}

    int countBalancedPermutations(string num) {
        int n = num.size();
        string s1 = num; // Replacing variable names with single-character ones
        string s2 = num;

        int freq[10] = {0};
        ll total_sum = 0;
        for (char c : num) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        ll sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(sum_half + 1, 0));
        dp[0][0] = 1;

        int d = 0; // Loop variable for the outer loop
        while (d <= 9) {
            if (freq[d] == 0) {
                d++;
                continue;
            }
            int c = k; // Loop variable for the next loop
            while (c >= 0) {
                ll s = sum_half; // Reset loop variable for the innermost loop
                while (s >= 0) {
                    if (dp[c][s] == 0) {
                        s--;
                        continue;
                    }
                    int t = 1; // Loop variable for the combination
                    while (t <= min(freq[d], k - c)) {
                        if (s + (ll)d * t > sum_half) break;
                        ll comb = (fact[freq[d]] * inv_fact[t] % MOD) * inv_fact[freq[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                c--;
            }
            d++;
        }

        ll valid_assignments = dp[k][sum_half];
        if (valid_assignments == 0) return 0;

        ll prod_fact_fd = 1;
        int f = 0; // Loop variable for the product calculation
        while (f <= 9) {
            prod_fact_fd = prod_fact_fd * fact[freq[f]] % MOD;
            f++;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_prod_fact_fd = power_mod_func(prod_fact_fd, MOD - 2);
        ll answer = (fk_fnk * valid_assignments) % MOD;
        answer = (answer * inv_prod_fact_fd) % MOD;

        return (int)answer;
    }
};
",1441375573
Sagnik Goswami,sagi_1523,295,3627,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<ppi, vector<ppi>, greater<ppi>> pq;  // {time, {row, col}}

        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it.first;
            int row = it.second.first;
            int col = it.second.second;

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);
                    
                    int newTime = waitTime + 1;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, {adjRow, adjCol}});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441339781
Sagnik Goswami,sagi_1523,295,3628,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;  // {time, row, col, prevMovePt (1 or 2)}

        pq.push({0, 0, 0, 2});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it[0];
            int row = it[1];
            int col = it[2];
            int prevMoveTime = it[3];

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);

                    int timeMove = (prevMoveTime == 1) ? 2 : 1;
                    int newTime = waitTime + timeMove;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, adjRow, adjCol, timeMove});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441338982
Sagnik Goswami,sagi_1523,295,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sumEven = 0, sumOdd = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sumOdd += num[i] - '0';
            else sumEven += num[i] - '0';
        }

        return sumEven == sumOdd;
    }
};",1441281467
Sagnik Goswami,sagi_1523,295,3637,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    vector<long long> fact;
    
    void precomputeFactorials(int n) {
        fact.resize(n + 1);
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
    }
    
    long long modPow(long long base, int exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp & 1) result = (result * base) % MOD;
            base = (base * base) % MOD;
            exp >>= 1;
        }
        return result;
    }
    
    vector<vector<vector<int>>> dp;
    vector<int> freq, remFreq;
    string num;
    int n;
    
    int solve(int pos, int sumNeeded, int remLen) {
        if (sumNeeded < 0 || remLen < 0) return 0;
        if (pos == n) return (remLen == 0 && sumNeeded == 0);
        
        if (dp[pos][sumNeeded][remLen] != -1) 
            return dp[pos][sumNeeded][remLen];
        
        long long res = solve(pos + 1, sumNeeded, remLen);
        
        int digit = num[pos] - '0';
        if (remFreq[digit] > 0) {
            remFreq[digit]--;
            freq[digit]++;
            
            res = (res + solve(pos + 1, sumNeeded - digit, remLen - 1)) % MOD;
            
            freq[digit]--;
            remFreq[digit]++;
        }
        
        return dp[pos][sumNeeded][remLen] = res;
    }
    
    long long getPermutations() {
        long long evenDenominator = 1, oddDenominator = 1;
        
        for (int i = 0; i < 10; i++) {
            if (freq[i]) evenDenominator = (evenDenominator * fact[freq[i]]) % MOD;
            if (remFreq[i]) oddDenominator = (oddDenominator * fact[remFreq[i]]) % MOD;
        }
        
        long long evenWays = (fact[(n + 1) / 2] * modPow(evenDenominator, MOD - 2)) % MOD;
        long long oddWays = (fact[n / 2] * modPow(oddDenominator, MOD - 2)) % MOD;
        return (evenWays * oddWays) % MOD;
    }
    
public:
    int countBalancedPermutations(string s) {
        num = s;
        n = num.length();
        
        int sum = 0;
        freq.assign(10, 0);
        remFreq.assign(10, 0);
        
        for (char c : num) {
            sum += c - '0';
            remFreq[c - '0']++;
        }
        
        if (sum & 1) return 0;
        
        int halfSum = sum / 2;
        int evenPos = (n + 1) / 2;
        
        dp.assign(n + 1, vector<vector<int>>(halfSum + 1, vector<int>(evenPos + 1, -1)));
        precomputeFactorials(n);
        
        int ways = solve(0, halfSum, evenPos);
        if (ways == 0) return 0;
        
        return (ways * getPermutations()) % MOD;
    }
};",1441389799
Jaeha Yi,jaehayi1,296,3627,python3,"from heapq import heapify, heappush, heappop

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        '''
        greedy, sort by moveTime
        '''

        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[2e9] * m for _ in range(n)]
        dp[0][0] = 0
        heappush(pq, (0, 0, 0))

        vis = set()

        while pq:
            t, i, j = heappop(pq)

            if (i, j) in vis: continue
            vis.add((i, j))

            if i + 1 < n: 
                dp[i + 1][j] = min(dp[i + 1][j], max(dp[i][j] + 1, moveTime[i + 1][j] + 1))
                heappush(pq, (dp[i + 1][j], i + 1, j))
                
            if j + 1 < m: 
                dp[i][j + 1] = min(dp[i][j + 1], max(dp[i][j] + 1, moveTime[i][j + 1] + 1))
                heappush(pq, (dp[i][j + 1], i, j + 1))

            if i - 1 >= 0: 
                dp[i - 1][j] = min(dp[i - 1][j], max(dp[i][j] + 1, moveTime[i - 1][j] + 1))
                heappush(pq, (dp[i - 1][j], i - 1, j))

            if j - 1 >= 0: 
                dp[i][j - 1] = min(dp[i][j - 1], max(dp[i][j] + 1, moveTime[i][j - 1] + 1))
                heappush(pq, (dp[i][j - 1], i, j - 1))

            # print(pq)

        # print(dp)

        return dp[n - 1][m - 1]
                ",1441311233
Jaeha Yi,jaehayi1,296,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[[2e9] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        heappush(pq, (0, 0, 0, 0))

        vis = set()

        while pq:
            t, i, j, mode = heappop(pq)

            if (i, j, mode) in vis: continue
            vis.add((i, j, mode))
            mode2 = (mode + 1) % 2
            add = (1 if mode == 0 else 2)

            for i2, j2 in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]: 
                if i2 < 0 or j2 < 0 or i2 >= n or j2 >= m: continue
                    
                dp[i2][j2][mode2] = min(dp[i2][j2][mode2], max(dp[i][j][mode] + add, moveTime[i2][j2] + add))
                heappush(pq, (dp[i2][j2][mode2], i2, j2, mode2))

        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]) ",1441324275
Jaeha Yi,jaehayi1,296,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)): 
            x = int(num[i])
            if i % 2 == 0: 
                # print(""even"", x)
                even += x
            else: 
                odd += x

        if even == odd: 
            return True
        return False",1441282985
Jaeha Yi,jaehayi1,296,3637,python3,"import math
from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        '''
        max sum = 80 * 9 / 2 = ~ 360

        dp[sum1][i] = num ways to achieve sums1 with i numbers used in sum1

        Two options: 
            keep number i in sum1, or throw away (put in sum2)

        Space complexity: 360 * 360 * 80 = 10^7
        '''

        mod = int(1e9 + 7)
        n = len(num)
        sn = sum([int(num[i]) for i in range(n)])
        if sn % 2 != 0: return 0
        
        goal = sn // 2

        dp = [[0] * (n // 2 + 1) for _ in range(goal + 1)]
        dp[0][0] = 1
        if int(num[0]) <= goal: dp[int(num[0])][1] = 1
        
        for i in range(1, n): 
            d = int(num[i])
            for x in range(goal, -1, -1): 
                for j in range(i + 1, -1, -1): 
                    if x - d >= 0 and j - 1 >= 0 and j < (n // 2 + 1): 
                        dp[x][j] = (dp[x][j] + dp[x - d][j - 1]) 
        
        factor = (math.factorial(n // 2) * math.factorial(n - n // 2))
        res = dp[goal][n // 2] * factor
        
        c = Counter(num)
        for d in c: 
            res = res // math.factorial(c[d])
        
        return res % mod
                
                

        ",1441391166
Edwin Chen,echen5503,297,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0] = 0
        while pq:
            time, i, j = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+1
                if dist[x, y] > t:
                    dist[x, y] = t
                    heapq.heappush(pq, (t, x, y))

        return dist[n-1, m-1]
                ",1441293027
Edwin Chen,echen5503,297,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0,0] = 0
        while pq:
            time, i, j, state = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+state+1
                if dist[x, y, state^1] > t:
                    dist[x, y, state^1] = t
                    heapq.heappush(pq, (t, x, y, state^1))

        return min(dist[n-1, m-1, 0], dist[n-1, m-1, 1])
                ",1441295224
Edwin Chen,echen5503,297,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = sum(int(x) for x in num[0:n:2])
        b = sum(int(x) for x in num[1:n:2])

        return a == b",1441281001
Edwin Chen,echen5503,297,3637,python3,"M = int(1e9+7)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(int(x) for x in num)
        n = len(num)
        cnt = Counter(num)
        tot = sum(num)

        if tot % 2 != 0:
            return 0

        @cache
        def fact(n):
            return 1 if n == 0 else n*fact(n-1)

        def inv(x):
            return pow(x, M-2, M)
            
        @cache
        def dp(i, s, used):
            if i == 10:
                if s == tot//2 and (used == n//2 or used == ceil(n/2)):
                    return (fact(used) * fact(n-used)) % M
                return 0

            if used > ceil(n/2):
                return 0
            if s > tot//2:
                return 0
            if sum(cnt[x] for x in range(i, 10)) + used < n//2:
                return 0
            ans = 0
            for amt in range(0, cnt[i]+1):
                ans += dp(i+1, s+amt*i, used+amt) * inv(fact(amt)) * inv(fact(cnt[i]-amt))
                ans %= M
            return ans
            
        ans = dp(0, 0, 0)
        if n % 2 == 1:
            ans *= inv(2)
            ans %= M
        return ans",1441392050
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3627,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] travelTime) { // Renamed to match the call
        int rows = travelTime.length;
        int cols = travelTime[0].length;
        int[][] minTime = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(minTime[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));

        queue.offer(new int[]{0, 0, 0});
        minTime[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int currentTime = current[0];
            int x = current[1];
            int y = current[2];

            if (currentTime > minTime[x][y]) continue;

            for (int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int updatedTime = Math.max(currentTime, travelTime[newX][newY]) + 1;

                    if (updatedTime < minTime[newX][newY]) {
                        minTime[newX][newY] = updatedTime;
                        queue.offer(new int[]{updatedTime, newX, newY});
                    }
                }
            }
        }

        return minTime[rows - 1][cols - 1];
    }
}
",1441324048
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3628,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        // 3D dp table to store minimum time to reach each cell with both parities (0 and 1)
        int[][][] minTime = new int[rows][cols][2];
        for (int[][] row : minTime) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        minTime[0][0][0] = 0;

        // Deque for BFS-like traversal with time-based ordering
        Deque<int[]> deque = new ArrayDeque<>();
        deque.offerFirst(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        // Directions for moving up, down, left, and right
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!deque.isEmpty()) {
            int[] state = deque.pollFirst();
            int currTime = state[0];
            int row = state[1];
            int col = state[2];
            int parity = state[3];

            if (currTime > minTime[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int nextTime = Math.max(currTime, moveTime[newRow][newCol]) + (parity == 1 ? 2 : 1);

                    if (nextTime < minTime[newRow][newCol][1 - parity]) {
                        minTime[newRow][newCol][1 - parity] = nextTime;
                        if (parity == 0) {
                            deque.offerFirst(new int[]{nextTime, newRow, newCol, 1 - parity});
                        } else {
                            deque.offerLast(new int[]{nextTime, newRow, newCol, 1 - parity});
                        }
                    }
                }
            }
        }

        return Math.min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }
}
",1441312124
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';  // Convert character to integer
            
            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }
        
        return evenSum == oddSum;
    }
}
",1441283653
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3637,java,"import java.util.*;

public class Solution {
    static final int MOD = 1000000007;
    long[] fact;
    long[] invFact;

    private long powerModFunc(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerModFunc(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long totalSum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;

        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = fact[freq[d]] * invFact[t] % MOD * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = fact[k] * fact[n - k] % MOD;
        long invProdFactFd = powerModFunc(prodFactFd, MOD - 2);
        long answer = fkFnk * validAssignments % MOD * invProdFactFd % MOD;

        return (int) answer;
    }
}
",1441391551
choudharykritik,choudharykritik,299,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 1: 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441390056
choudharykritik,choudharykritik,299,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 2 : 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441388976
choudharykritik,choudharykritik,299,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sm1=0,sm2=0;
        for(int i=0;i<num.size();i+=2){
            sm1+=(num[i]-'0');
        }
        for(int i=1;i<num.size();i+=2){
            sm2+=(num[i]-'0');
        }
        if(sm1==sm2){
            return true;
        }
        return false;
    }
};",1441285033
choudharykritik,choudharykritik,299,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact, inv_fact;

ll mod_pow(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;

    inv_fact.assign(n + 1, 1);
    inv_fact[n] = mod_pow(fact[n], MOD - 2);
    for (int i = n - 1; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> f(10, 0);
        ll sum = 0;

        for (char c : num) {
            int d = c - '0';
            f[d]++;
            sum += d;
        }

        if (sum % 2 != 0) return 0;
        ll half = sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (f[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (ll s = half; s >= 0; s--) {
                    if (dp[c][s] == 0) continue;
                    for (int t = 1; t <= min(f[d], k - c); t++) {
                        if (s + (ll)d * t > half) break;
                        ll comb = (fact[f[d]] * inv_fact[t] % MOD) * inv_fact[f[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                    }
                }
            }
        }

        ll valid = dp[k][half];
        if (valid == 0) return 0;

        ll fact_prod = 1;
        for (int d = 0; d <= 9; d++) {
            fact_prod = fact_prod * fact[f[d]] % MOD;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_fact_prod = mod_pow(fact_prod, MOD - 2);
        ll ans = (fk_fnk * valid % MOD) * inv_fact_prod % MOD;

        return (int)ans;
    }
};
",1441386306
GoIsTheBestLang,__golang__,300,3627,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    dis[v] = max(d + w, moveTime[i][j] + 1)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441326693
GoIsTheBestLang,__golang__,300,3628,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    if (i + j) & 1:
                        dis[v] = max(d + w, moveTime[i][j] + 1)
                    else:
                        dis[v] = max(d + w + 1, moveTime[i][j] + 2)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441329752
GoIsTheBestLang,__golang__,300,3637,python3,"MOD = 10 ** 9 + 7

MAX = 100

fac = [0] * MAX
inv = [0] * MAX

fac[0] = 1
inv[0] = 1
for i in range(1, MAX):
    fac[i] = fac[i - 1] * i % MOD
    inv[i] = pow(fac[i], MOD-2, MOD)

def comb(n, k):
    return fac[n] * inv[k] % MOD * inv[n - k] % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        cnt = Counter(list(map(int, num)))
        tot = sum(int(ch) for ch in num)
        if tot & 1:
            return 0
        @cache
        def dfs(i, s, c):
            if s > tot // 2:
                return 0
            if i == 10:
                if s != tot // 2:
                    return 0
                if c == len(num) // 2:
                    return fac[len(num) // 2] * fac[(len(num) + 1) // 2] % MOD
                return 0
            ans = 0
            for j in range(cnt[i] + 1):
                ans += dfs(i + 1, s + j * i, c + j) * inv[j] * inv[cnt[i] - j] % MOD
                ans %= MOD
            return ans
        return dfs(0, 0, 0)
            
        
        ",1441302966
forwarding7,forwarding7,301,3627,cpp,"
class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + 1, x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + 1, x, y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + 1, x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + 1, x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441303584
forwarding7,forwarding7,301,3628,cpp,"class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 1, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, next, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + next, 3 - next,
                              x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + next, 3 - next, x,
                              y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + +next, 3 - next,
                              x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + +next, 3 - next,
                              x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441305751
forwarding7,forwarding7,301,3637,cpp,"class Solution {
  public:
    using ll = long long;
    int countBalancedPermutations(std::string num) {
        constexpr int mod = 1e9 + 7;

        int n = (int)num.size();
        ll res;

        std::vector<int> nums;
        int sum = 0;
        for (auto c : num) {
            nums.emplace_back(c - '0');
            sum += (c - '0');
        }
        if (sum % 2 == 1) {
            return 0;
        }

        int target = sum / 2;
        int target_size = (int)nums.size() / 2;
        std::vector<std::vector<int>> dp(target_size + 1,
                                         std::vector<int>(target + 1, 0));
        dp[0][0] = 1;
        for (auto number : nums) {
            for (int i = target_size; i >= 1; --i) {
                for (int j = target; j >= number; --j) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - number]) % mod;
                }
            }
        }

        auto factorialMod = [](ll n) -> ll {
            ll result = 1;
            for (ll i = 2; i <= n; ++i) {
                result = (result * i) % mod;
            }
            return result;
        };

        // 
        std::unordered_map<int, int> freq;
        for (auto number : nums) {
            freq[number]++;
        }

        // 
        ll duplicateFactor = 1;
        for (const auto &[key, value] : freq) {
            duplicateFactor = (duplicateFactor * factorialMod(value)) % mod;
        }

        auto f = dp[target_size][target];
        if (nums.size() % 2 == 0) {
            auto a = factorialMod(target_size);
            res = ((a * a) % mod * f) % mod;
        } else {
            auto a = factorialMod(target_size);
            auto b = factorialMod(target_size + 1);
            res = ((a * b) % mod * f) % mod;
        }

        res = (res * modInverse(duplicateFactor, mod)) % mod;
        return (int)(res);
    }

  private:
    // 
    ll modInverse(ll a, ll m) {
        ll m0 = m, t, q;
        ll x0 = 0, x1 = 1;
        if (m == 1)
            return 0;
        while (a > 1) {
            q = a / m;
            t = m;
            m = a % m, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0)
            x1 += m0;
        return x1;
    }
};",1441330435
arunkumar saranga,arunkumarsaranga,302,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] a) {
        int x = a.length;
        int y = a[0].length;
        int[][][] b = f(x, y);
        b[0][0][0] = 0;
        PriorityQueue<int[]> c = new PriorityQueue<>((d, e) -> Integer.compare(d[0], e[0]));
        c.offer(new int[]{0, 0, 0, 0});
        int[][] g = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!c.isEmpty()) {
            h(c, b, g, a, x, y);
        }
        
        return Math.min(b[x - 1][y - 1][0], b[x - 1][y - 1][1]);
    }
    
    private int[][][] f(int x, int y) {
        int[][][] b = new int[x][y][2];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                b[i][j][0] = Integer.MAX_VALUE;
                b[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return b;
    }
    
    private void h(PriorityQueue<int[]> c, int[][][] b, int[][] g, int[][] a, int x, int y) {
        int[] i = c.poll();
        int j = i[0];
        int k = i[1];
        int l = i[2];
        int m = i[3];
        
        if (j > b[k][l][m]) return;
        
        for (int[] n : g) {
            int o = k + n[0];
            int p = l + n[1];
            if (o >= 0 && o < x && p >= 0 && p < y) {
                int q = Math.max(j, a[o][p]) + (m == 0 ? 1 : 2);
                int r = 1 - m;
                
                if (q < b[o][p][r]) {
                    b[o][p][r] = q;
                    c.offer(new int[]{q, o, p, r});
                }
            }
        }
    }
}
",1441377032
arunkumar saranga,arunkumarsaranga,302,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        l=list(map(int,s))
        x=l[0::2]
        # print(x)
        y=l[1::2]
        # print(y)
        return sum(x)==sum(y)",1441349852
arunkumar saranga,arunkumarsaranga,302,3637,python3,"MOD = 1000000007

def p(x, y):
    z = 1
    x %= MOD
    while y > 0:
        if y & 1:
            z = z * x % MOD
        x = x * x % MOD
        y >>= 1
    return z

a = []
b = []

def b_init(m):
    global a, b
    a = [1] * (m + 1)
    for c in range(1, m + 1):
        a[c] = a[c - 1] * c % MOD
    b = [1] * (m + 1)
    b[m] = p(a[m], MOD - 2)
    for c in range(m - 1, -1, -1):
        b[c] = b[c + 1] * (c + 1) % MOD

class Solution:
    def countBalancedPermutations(self, q: str) -> int:
        m = len(q)
        n = [0] * 10
        r = 0
        for x in q:
            s = int(x)
            n[s] += 1
            r += s

        if r % 2 != 0:
            return 0
        g = r // 2
        h = (m + 1) // 2
        b_init(m)
        
        dp = [[0] * (g + 1) for _ in range(h + 1)]
        dp[0][0] = 1
        
        for s in range(10):
            if n[s] == 0:
                continue
            for t in range(h, -1, -1):
                for u in range(g, -1, -1):
                    if dp[t][u] == 0:
                        continue
                    for v in range(1, min(n[s], h - t) + 1):
                        if u + s * v > g:
                            break
                        w = (a[n[s]] * b[v] % MOD) * b[n[s] - v] % MOD
                        dp[t + v][u + s * v] = (dp[t + v][u + s * v] + dp[t][u] * w) % MOD

        x = dp[h][g]
        if x == 0:
            return 0

        y = 1
        for s in range(10):
            y = y * a[n[s]] % MOD

        z = a[h] * a[m - h] % MOD
        i_y = p(y, MOD - 2)

        result = (z * x % MOD) * i_y % MOD
        return result
",1441386739
klu2200031955,klu2200031955,303,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] d = initializeDistanceMatrix(n, m);
        PriorityQueue<Node> queue = initializeQueue();

        queue.offer(new Node(0, 0, 0, 0));

        return processQueue(queue, d, moveTime, n, m);
    }

    private int[][][] initializeDistanceMatrix(int rows, int cols) {
        int[][][] distanceMatrix = new int[rows][cols][2];
        for (int[][] row : distanceMatrix) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        distanceMatrix[0][0][0] = 0;  // Starting point
        return distanceMatrix;
    }

    private PriorityQueue<Node> initializeQueue() {
        return new PriorityQueue<>();
    }

    private int[][] getDirections() {
        return new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    }

    private int processQueue(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, int n, int m) {
        int[][] directions = getDirections();

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.time > distance[node.x][node.y][node.parity]) continue;

            updateDistances(queue, distance, moveTime, node, directions, n, m);
        }

        return Math.min(distance[n - 1][m - 1][0], distance[n - 1][m - 1][1]);
    }

    private void updateDistances(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, Node node, int[][] directions, int n, int m) {
        for (int[] dir : directions) {
            int ni = node.x + dir[0];
            int nj = node.y + dir[1];

            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                // Calculate the new time with corrected parity handling
                int newTime = Math.max(node.time, moveTime[ni][nj]) + ((node.parity == 1) ? 2 : 1);

                if (newTime < distance[ni][nj][1 - node.parity]) {
                    distance[ni][nj][1 - node.parity] = newTime;
                    queue.offer(new Node(newTime, ni, nj, 1 - node.parity));
                }
            }
        }
    }

    private static class Node implements Comparable<Node> {
        int time, x, y, parity;

        Node(int time, int x, int y, int parity) {
            this.time = time;
            this.x = x;
            this.y = y;
            this.parity = parity;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.time, other.time);
        }
    }
}
",1441331711
klu2200031955,klu2200031955,303,3636,java,"class SumCalculator {
    public int calculateEvenSum(String num) {
        int evenSum = 0;
        for (int i = 0; i < num.length(); i += 2) {
            evenSum += num.charAt(i) - '0';
        }
        return evenSum;
    }

    public int calculateOddSum(String num) {
        int oddSum = 0;
        for (int i = 1; i < num.length(); i += 2) {
            oddSum += num.charAt(i) - '0';
        }
        return oddSum;
    }
}

class Solution {
    private SumCalculator calculator = new SumCalculator();

    public boolean isBalanced(String num) {
        int evenSum = calculator.calculateEvenSum(num);
        int oddSum = calculator.calculateOddSum(num);
        return evenSum == oddSum;
    }
}
",1441335004
klu2200031955,klu2200031955,303,3637,java,"import java.util.Arrays;

class MathUtils {
    static final int MOD = 1000000007;

    static long power_mod_func(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    static class FactorialResult {
        long[] fact;
        long[] inv_fact;

        FactorialResult(long[] fact, long[] inv_fact) {
            this.fact = fact;
            this.inv_fact = inv_fact;
        }
    }

    static FactorialResult initializeFactorials(int n) {
        long[] fact = new long[n + 1];
        long[] inv_fact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        inv_fact[n] = power_mod_func(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        }
        return new FactorialResult(fact, inv_fact);
    }
}

class Solution {
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long total_sum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        long sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        MathUtils.FactorialResult factorials = MathUtils.initializeFactorials(n);
        long[] fact = factorials.fact;
        long[] inv_fact = factorials.inv_fact;

        long[][] dp = new long[k + 1][(int) (sum_half + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sum_half; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + (long) d * t > sum_half) break;
                        long comb = (fact[freq[d]] * inv_fact[t] % MathUtils.MOD) * inv_fact[freq[d] - t] % MathUtils.MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MathUtils.MOD;
                    }
                }
            }
        }

        long valid_assignments = dp[k][(int) sum_half];
        if (valid_assignments == 0) return 0;

        long prod_fact_fd = 1;
        for (int d = 0; d <= 9; d++) {
            prod_fact_fd = prod_fact_fd * fact[freq[d]] % MathUtils.MOD;
        }

        long fk_fnk = (fact[k] * fact[n - k]) % MathUtils.MOD;
        long inv_prod_fact_fd = MathUtils.power_mod_func(prod_fact_fd, MathUtils.MOD - 2);
        long answer = (fk_fnk * valid_assignments) % MathUtils.MOD;
        answer = (answer * inv_prod_fact_fd) % MathUtils.MOD;

        return (int) answer;
    }
}
",1441380869
Ratnakar Gautam,ratnakarg,304,3627,cpp,"#define ll long long
class Solution {
public:
    vector<vector<int>> dir = {{1,0} , {0,1} , {0,-1} , {-1,0}};
    bool coords(int r, int c, int n, int m){
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool check(int mid , vector<vector<int>>& mvt) {
        int n = mvt.size() , m = mvt[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        dis[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cst = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cst <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + dir[i][0], ncol = c + dir[i][1];
                if (coords(nrow, ncol, n, m)) {
                    long long tmp = max(cst + 1, 1LL*mvt[nrow][ncol] + 1);
                    if (tmp < dis[nrow][ncol] && tmp <= mid) {
                        dis[nrow][ncol] = tmp;
                        q.push({tmp , nrow , ncol});
                    }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& mvt) {
        int n = mvt.size(), m = mvt[0].size();
        long long low = 0 , high = 1e13;
        long long ans = -1;
        while(low <= high) {
            long long mid = low + (high-low) / 2;

            if(check(mid , mvt)) {
                ans = mid;
                high = mid-1;
            }
            else low = mid+1;
        } 

        return ans;
    }
};",1441369613
Ratnakar Gautam,ratnakarg,304,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441292383
Ratnakar Gautam,ratnakarg,304,3637,cpp,"#define ll long long
const int mod = 1e9+7;

class Solution {
public:
    ll modPow(ll base, ll exp, ll mod) {
        ll res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    ll inv(ll num) {
        return modPow(num, mod - 2, mod);
    }

    // int solve(vector<int>& num, int k){
    //     int n = num.size();
    
    //     vector<int> prev(k + 1, 0);
    
    //     prev[0] = 1;
    
    //     if (num[0] <= k) {
    //         prev[num[0]] = 1;
    //     }
    
    //     for (int ind = 1; ind < n; ind++) {
    //         vector<int> cur(k + 1, 0);
    
    //         cur[0] = 1;
    
    //         for (int target = 1; target <= k; target++) {
    //             int notTaken = prev[target];
    //             int taken = 0;
    //             if (num[ind] <= target) {
    //                 taken = prev[target - num[ind]];
    //             }
    
    //             cur[target] = notTaken + taken;
    //         }
    
    //         prev = cur;
    //     }
    
    //     return prev[k];
    // }

    int countBalancedPermutations(string num){
        vector<int> v;
        int n = num.size();
        map<int,int> freq;
        for(char x:num){
            v.push_back((int)x-'0');
            freq[v.back()]++;
            
        }
        int tot = accumulate(v.begin(),v.end(),0ll);
        int mod = 1e9+7;
        // vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (9*n , vector<int> (n,-1)));
        // function<int(int,int,int)> rec = [&](int i,int sum,int k){
        //     if(i==n)return (int)(k==n/2 && sum*2==tot);
        //     if(dp[i][sum][k]!=-1)return dp[i][sum][k];
        //     ll ans = 0;
        //     ans+=rec(i+1,sum,k);
        //     ans%=mod;
        //     ans+=rec(i+1,sum+v[i],k+1);
        //     ans%=mod;
        //     return dp[i][sum][k]=(int)ans;
        // };
        // ll cnt=rec(0,0,0);

        if (tot % 2 != 0) return 0;
        int halfSum = tot / 2;
         vector<vector<int>> dp(halfSum + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> next = dp;
            for (int sum = 0; sum <= halfSum; sum++){
                for (int k=0;k<=n/2;k++){
                    if(dp[sum][k]>0){
                        // next[sum][k]=(next[sum][k]+dp[sum][k])%mod;
                        if (k + 1 <= n / 2 && sum + v[i] <= halfSum){
                            next[sum + v[i]][k + 1] = (next[sum + v[i]][k + 1] + dp[sum][k]) % mod;
                        }
                    }
                }
            }
            dp = next;
        }

        ll cnt = dp[halfSum][n/2];

        // cout<<cnt<<endl;

        vector<ll> f(100);
        f[0]=1;
        for(int i=1;i<100;i++){
            f[i]=f[i-1]*i;
            f[i]%=mod;
        }
        int a = n/2 , b = n - a;
        ll ans = (((f[a]*f[b])%mod)*cnt)%mod;

        for(int i=0;i<=9;i++){
            ans*=inv(f[freq[i]]);
            ans%=mod;
        }
        return ans;
    }
};",1441357011
Sean,shaun001280,305,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        // Distance matrix to store minimum times
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        // Priority queue to store {time, {row, col}}
        priority_queue<pair<int, pair<int, int>>, 
                      vector<pair<int, pair<int, int>>>,
                      greater<pair<int, pair<int, int>>>> pq;
        
        // Directions: right, down, left, up
        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        // Start from (0,0)
        dist[0][0] = moveTime[0][0];
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            int currTime = pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second;
            pq.pop();
            
            if (currTime > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir.first;
                int newCol = col + dir.second;
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(currTime + 1, moveTime[newRow][newCol] + 1);
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};",1441395871
Sean,shaun001280,305,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum0 = 0, sum1 = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sum1 += num[i] - '0';
            else sum0 += num[i] - '0';
        }
        return sum0 == sum1;
    }
};",1441371592
Sean,shaun001280,305,3637,cpp,"class Solution {
private:
    static constexpr int MOD = 1000000007;
    vector<vector<int>> C;
    vector<int> cnt;
    int target_sum;
    unordered_map<string, int> memo;
    
    string getKey(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        return to_string(pos) + "","" + to_string(sum_odd) + "","" + 
               to_string(sum_even) + "","" + to_string(odd_spots) + "","" + 
               to_string(even_spots);
    }
    
    int dfs(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        if (pos == 10) {
            return (sum_odd == target_sum && sum_even == target_sum) ? 1 : 0;
        }
        
        string key = getKey(pos, sum_odd, sum_even, odd_spots, even_spots);
        if (memo.count(key)) {
            return memo[key];
        }
        
        if (sum_odd > target_sum || sum_even > target_sum) {
            return 0;
        }
        
        if (cnt[pos] == 0) {
            int result = dfs(pos + 1, sum_odd, sum_even, odd_spots, even_spots);
            memo[key] = result;
            return result;
        }
        
        int result = 0;
        for (int i = 0; i <= cnt[pos]; i++) {
            if (i <= odd_spots && (cnt[pos] - i) <= even_spots) {
                long long new_sum_odd = sum_odd + (long long)i * pos;
                long long new_sum_even = sum_even + (long long)(cnt[pos] - i) * pos;
                
                if (new_sum_odd <= target_sum && new_sum_even <= target_sum) {
                    long long ways = 1;
                    ways = ((long long)C[odd_spots][i] * C[even_spots][cnt[pos] - i]) % MOD;
                    ways = (ways * dfs(pos + 1, new_sum_odd, new_sum_even, 
                            odd_spots - i, even_spots - (cnt[pos] - i))) % MOD;
                    result = (result + ways) % MOD;
                }
            }
        }
        
        memo[key] = result;
        return result;
    }
    
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int n_odd = (n + 1) / 2;
        int n_even = n / 2;
        
        cnt.resize(10);
        int total_sum = 0;
        
        for (char x : num) {
            total_sum += x - '0';
            cnt[x - '0']++;
        }
        
        if (total_sum % 2 == 1) {
            return 0;
        }
        
        target_sum = total_sum / 2;
        
        C.resize(n + 1, vector<int>(n + 1));
        for (int i = 0; i <= n; i++) {
            C[i][0] = 1;
            C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        
        memo.clear();
        return dfs(0, 0, 0, n_odd, n_even);
    }
};",1441367965
roush_70700,roush_70700,306,3627,cpp,"class Solution {
public:
    vector <pair<int,int>> rc = {{1,0} , {0,1} , {0,-1} , {-1,0}};

    bool IsValid(int r, int c, int n, int m) {
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool IsPossible(int mid , vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        vector<vector<long long>> minTime(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        minTime[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cost = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cost <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + rc[i].first, ncol = c + rc[i].second;
                if (IsValid(nrow, ncol, n, m)) {
                    long long newCost = max(cost + 1, 1LL*moveTime[nrow][ncol] + 1);
                    if (newCost < minTime[nrow][ncol] && newCost <= mid) {
                        minTime[nrow][ncol] = newCost;
                        q.push({newCost , nrow , ncol});
                    }

                    // if(newCost <= mid && !vis[nrow][ncol]) {
                    //     vis[nrow][ncol] = 1;
                    //     // minTime[nrow][ncol] = newCost;
                    //     q.push({newCost , nrow , ncol});
                    // }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        long long l = 0 , r = 1e13;
        long long ans = -1;
        while(l <= r) {
            long long mid = l + (r-l) / 2;

            if(IsPossible(mid , moveTime)) {
                ans = mid;
                r = mid-1;
            }
            else l = mid+1;
        } 

        return ans;
    }
};
",1441345035
roush_70700,roush_70700,306,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441282228
roush_70700,roush_70700,306,3637,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    long long modular_power(long long base, long long exp, long long mod) {
        long long res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    long long fun(long long num) {
        return modular_power(num, mod - 2, mod);
    }

    long long solve(int sum, int n, vector<int>& temp) {
        int req = sum / 2;
        vector<vector<int>> dp(req + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> dp_next = dp;
            for (int s = 0; s <= req; s++) {
                for (int k = 0; k <= n / 2; k++) {
                    if (dp[s][k] > 0) {
                        if (k + 1 <= n / 2 && s + temp[i] <= req) {
                            dp_next[s + temp[i]][k + 1] = (dp_next[s + temp[i]][k + 1] + dp[s][k]) % mod;
                        }
                    }
                }
            }
            dp = dp_next;
        }
        return dp[req][n / 2];
    }
    int countBalancedPermutations(string num) {
        vector<int> temp;
        int n = num.size();
        unordered_map<int, int> mp;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            temp.push_back(num[i] - '0');
            mp[temp.back()]++;
            sum += temp[i];
        }

        if (sum % 2 != 0)
            return 0;

        long long cnt = solve(sum, n, temp);
        vector<long long> res(100);
        res[0] = 1;
        for (int i = 1; i < 100; i++) {
            res[i] = (res[i - 1] * i) % mod;
        }
        
        int a = n / 2, b = n - a;
        long long ans = (((res[a] * res[b]) % mod) * cnt) % mod;
        for (int i = 0; i <= 9; i++) {
            ans = (ans * fun(res[mp[i]])) % mod;
        }
        return ans;
    }
};
",1441389790
xy-li,xy-li,307,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # for i in range(len(moveTime)):
        #     for j in range(len(moveTime[0])):
        #         if i!=0 or j!=0:
        #             moveTime[i][j] += 1
        # moveTime[0][0] = 0
        
        n, m = len(moveTime), len(moveTime[0])
        start = (0, 0)
        seen = [[False] * m for _ in range(n)]
        dist = [[float('inf')] * m for _ in range(n)]
        h = [(0, 0, 0)]
        dist[0][0] = 0
        
        while h:
            d, i, j = heapq.heappop(h)
            if d > dist[i][j]:
                continue
            if i == n - 1 and j == m - 1:
                return d
            seen[i][j] = True
            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
                if 0 <= x < n and 0 <= y < m and not seen[x][y]:
                    new_dist = min(max(d, moveTime[x][y])+1, dist[x][y])
                    if new_dist < dist[x][y]:
                        dist[x][y] = new_dist
                        heapq.heappush(h, (new_dist, x, y))
            
        return dist[n - 1][m - 1]

                ",1441384467
xy-li,xy-li,307,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        digits = [int(x) for x in num]
        odd_sum = sum(digits[::2])
        even_sum = sum(digits[1::2])
        return odd_sum == even_sum
        ",1441281451
xy-li,xy-li,307,3637,python3,"M = 10**9 + 7

fraq = [1]

for i in range(80):
    fraq.append((fraq[-1] * (i+1)) % M)

fraq_inv = [pow(i, M - 2, M) for i in fraq]

# print(fraq_inv[:10])

from collections import Counter
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = [int(i) for i in num]
        cnt = Counter(nums)
        s = sum(nums)
        if s % 2 != 0:
            return 0
        n = len(nums)
        k = n // 2
        target_sum = s // 2
        
        dp = [[0] * (target_sum + 1) for _ in range(k + 1)]
        dp[0][0] = 1  # Base case: one way to get sum 0 with 0 elements

        # Fill the DP table
        for num in nums:
            # Update dp table in reverse to avoid reusing elements in the same iteration
            for j in range(k, 0, -1):
                for s in range(target_sum, num - 1, -1):
                    dp[j][s] = (dp[j][s] + dp[j - 1][s - num]) % M
                    
        res = dp[-1][-1] * fraq[n - k] * fraq[k] % M
        # print(dp[-1][-1], fraq[n - k])
        for num in cnt:
            res = (res * fraq_inv[cnt[num]]) % M
        return res
                
        
        ",1441365474
lucasomee006,lucasomee006,308,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #dijkstra's?
        distances = [[float('inf') for i in range(len(moveTime[0]))] for j in range(len(moveTime))]
        # distances[0][0] = 0
        queue = [((0, 0), 0)]
        def neighbors(i, j):
            ans = []
            if i < len(moveTime)-1:
                ans.append((i+1, j))
            if j < len(moveTime[0])-1:
                ans.append((i, j+1))
            if i > 0:
                ans.append((i-1, j))
            if j > 0:
                ans.append((i, j-1))
            return ans
            
        while len(queue):
            coords, weight = heapq.heappop(queue)
            i, j = coords
            if weight >= distances[i][j]:
                continue
            distances[i][j] = weight
            for n in neighbors(i, j):
                heapq.heappush(queue, (n, max(weight+1, moveTime[n[0]][n[1]]+1)))
        # print(neighbors(1, 1))
        # print(distances)
        return distances[-1][-1]
            
            ",1441313817
lucasomee006,lucasomee006,308,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(num[i]) for i in range(1, len(num), 2)]) == sum([int(num[i]) for i in range(0, len(num), 2)])",1441281675
lucasomee006,lucasomee006,308,3637,python3,"from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        #basically we're dividing it into 2 equal sized groups (max diff of 1)
        #and those two groups have to have the same sum
        d = defaultdict(int)
        for char in num:
            d[int(char)] += 1
        x = [factorial(d[y]) for y in d]
        a = 1
        for i in range(len(x)):
            a *= x[i]
        if len(num) % 2 == 1:
            a *= 2
        #so for each number we can put it into one of the two groups
        #so total number of permutations assuming each char is distinct, but divided by num of each char
        #factorial
        mod = 10**9 + 7
        ans = 0
        finalAns = 0
        #dp(i, curSumDif, numOneGroup) returns
        s = sum([int(char) for char in num])
        @cache
        def dp(i, curSumDif, numOneGroup):
            
            if i == len(num) and curSumDif == 0 and abs(numOneGroup) <= 1:
                return 1
            if i == len(num):
                return 0
            if abs(curSumDif) > s//2+2:
                return 0
            if abs(numOneGroup) > len(num)//2+2:
                return 0
            return dp(i+1, curSumDif+int(num[i]), numOneGroup + 1) + dp(i+1, curSumDif-int(num[i]), numOneGroup-1)
        x = dp(0, 0, 0)
        dp.cache_clear()
        perm = factorial(len(num)//2)*factorial(len(num)-len(num)//2)
        return perm * x // a % mod
        
        ",1441385645
bramar2,bramar2,310,3627,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dp(n, vector<ll>(m));
        dp[0][0] = 0;
        for(int i = 1; i < n; i++) {
            dp[i][0] = max((ll)moveTime[i][0] + 1, dp[i - 1][0] + 1);
        }
        for(int i = 1; i < m; i++) {
            dp[0][i] = max((ll)moveTime[0][i] + 1, dp[0][i - 1] + 1);
        }

        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                dp[i][j] = max({
                    (ll)moveTime[i][j] + 1,
                    min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
                });
            }
        }
        auto cmax = [&](int i, int j, ll val) {
            if(i == 0 && j == 0) return false;
            ll prev = dp[i][j];
            dp[i][j] = min((ll)moveTime[i][j] + 1, val);
            return (dp[i][j] != prev);
        };
        bool change = true;
        while(change) {
            change = false;
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < m; j++) {
                    if(i == 0 && j == 0) continue;
                    ll prev = dp[i][j];
                    ll mn = 1e16;
                    if(i > 0) {
                        mn = min(mn, dp[i-1][j] + 1);
                    }
                    if(j > 0) {
                        mn = min(mn, dp[i][j-1] + 1);
                    }
                    if(i+1 < n) {
                        mn = min(mn, dp[i+1][j] + 1);
                    }
                    if(j+1 < m) {
                        mn = min(mn, dp[i][j+1] + 1);
                    }
                    dp[i][j] = max((ll)moveTime[i][j] + 1, mn);
                    if(prev != dp[i][j]) change = true;
                }
            }
        }
        return dp.back().back();
    }
};

int main1() {
    fastio;
    return 0;
}",1441302783
bramar2,bramar2,310,3636,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                sum1 += num[i]-'0';
            }else {
                sum2 += num[i]-'0';
            }
        }
        return sum1 == sum2;
    }
};

int main1() {
    fastio;
    return 0;
}",1441290674
bramar2,bramar2,310,3637,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

vector<ll> memoFactorial {1,1,2};
long long modfactorial(long long n) {
    if(n < (ll)memoFactorial.size()) return memoFactorial[n];
    for(ll i = memoFactorial.size(); i <= n; i++) {
        memoFactorial.push_back((i * memoFactorial[i - 1]) % MOD);
    }
    return memoFactorial[n];
}

bool init() {
    fastio;
    modfactorial(210);
    return true;
}
bool y = init();

ll dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(const string& numStr) {
        int n = numStr.size();
        int freq[10] {};
        ll targetSum = 0;
        for(char c : numStr) {
            freq[c-'0']++;
            targetSum += (c-'0');
        }
        if(targetSum % 2 == 1) return 0;
        targetSum /= 2;
        
        ll targetLen = n/2;
        ll ways = (memoFactorial[targetLen] * memoFactorial[n-targetLen]) % MOD;

        vector<vector<vector<ll>>> dp(10, vector<vector<ll>>(n+1, vector<ll>(targetSum+1, -1)));
        function<ll(ll,ll,ll)> go = [&](ll i, ll len1, ll sum1) {
            if(i >= 10) {
                if(len1 == targetLen && sum1 == targetSum) {
                    // dbg(len1, sum1);
                    return ways;
                }
                return 0LL;
            }
            if(sum1 > targetSum) {
                return 0LL;
            }
            if(dp[i][len1][sum1] >= 0) return dp[i][len1][sum1];
            ll ans = 0;
            for(ll take = 0; take <= freq[i]; take++) {
                ll w = (go(i + 1, len1 + take, sum1 + take*i) * mod_exp(memoFactorial[take], MOD-2, MOD)) % MOD;
                w = (w * mod_exp(memoFactorial[freq[i]-take], MOD-2, MOD)) % MOD;
                ans = (ans + w) % MOD;
            }
            return dp[i][len1][sum1] = ans;
        };
        return go(0, 0, 0);
    }
};

int main1() {
    fastio;
    return 0;
}",1441380016
Kumar sai,E22CSEU0567,311,3627,python3,"class Solution:
    def minTimeToReach(self, alpha: List[List[int]]) -> int:
        n, m = len(alpha), len(alpha[0])
        beta = [[float('inf')] * m for _ in range(n)]
        beta[0][0] = 0
        import heapq
        gamma = [(0, 0, 0)]
        delta = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while gamma:
            theta, iota, kappa = heapq.heappop(gamma)
            if theta > beta[iota][kappa]:
                continue
            for dx, dy in delta:
                lambda_, mu = iota + dx, kappa + dy
                if 0 <= lambda_ < n and 0 <= mu < m:
                    nu = max(0, alpha[lambda_][mu] - theta)
                    xi = theta + nu + 1
                    if xi < beta[lambda_][mu]:
                        beta[lambda_][mu] = xi
                        heapq.heappush(gamma, (xi, lambda_, mu))
        
        return beta[n-1][m-1]
",1441290681
Kumar sai,E22CSEU0567,311,3628,python3,"class Solution:
    def minTimeToReach(self, sai: List[List[int]]) -> int:
        n, m = len(sai), len(sai[0])
        preksha = [[[float('inf'), 0] for _ in range(m)] for _ in range(n)]
        preksha[0][0] = [0, 0]
        gamma = [row[:] for row in sai]
        import heapq
        delta = [(0, 0, 0, 0)]
        epsilon = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while delta:
            zeta, eta, theta, iota = heapq.heappop(delta)
            if zeta > preksha[theta][iota][0]:
                continue
            for dx, dy in epsilon:
                kappa, lambda_ = theta + dx, iota + dy
                if 0 <= kappa < n and 0 <= lambda_ < m:
                    xi = 1 if eta % 2 == 0 else 2
                    nu = max(0, gamma[kappa][lambda_] - zeta)
                    omicron = zeta + nu + xi
                    rho = eta + 1
                    if omicron < preksha[kappa][lambda_][0]:
                        preksha[kappa][lambda_] = [omicron, rho]
                        heapq.heappush(delta, (omicron, rho, kappa, lambda_))
        
        return preksha[n-1][m-1][0]
",1441293005
Kumar sai,E22CSEU0567,311,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sai = sum(int(num[i]) for i in range(0, len(num), 2))
        preksha = sum(int(num[i]) for i in range(1, len(num), 2))
        
        return sai == preksha
",1441286642
beaaan,beaaan,312,3627,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 3>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + 1;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441291244
beaaan,beaaan,312,3628,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 4>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0, 1});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y, cost_to_move] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + cost_to_move;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny, cost_to_move == 1 ? 2 : 1});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441293138
beaaan,beaaan,312,3636,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  bool isBalanced(string num) {
    int n = (int)num.size();
    int sum = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        sum -= num[i] - '0';
      } else {
        sum += num[i] - '0';
      }
    }
    return sum == 0;
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441281844
Manyu,ManyuD,313,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j

                if not (0 <= x < m and 0 <= y < n) or ((x, y) in vis and vis[(x, y)] <= max(t + 1, 1 + moveTime[x][y])):
                    continue

                vis[(x, y)] = max(t + 1, 1 + moveTime[x][y])
                heapq.heappush(h, (max(t + 1, 1 + moveTime[x][y]), x, y))
            

",1441289870
Manyu,ManyuD,313,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0, True)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j, dur = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j
                
                if not (0 <= x < m and 0 <= y < n):
                    continue
                    
                next_time = max(t + (1 if dur else 2), (1 if dur else 2) + moveTime[x][y])

                if ((x, y) in vis and vis[(x, y)] <= next_time):
                    continue

                vis[(x, y)] = next_time
                heapq.heappush(h, (next_time, x, y, not dur))
                
            

",1441293154
Manyu,ManyuD,313,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:

        l = r = 0
        bit = False
        
        for i in num:
            if bit:
                l += int(i)
            else:
                r += int(i)
            bit = not bit

        return l == r
            ",1441281031
mmb L,mammothb,314,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0)]
        while h:
            time, i, j = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j))
",1441292192
mmb L,mammothb,314,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0, 0)]
        while h:
            time, i, j, move = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1 + move
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j, (move + 1) % 2))
",1441294258
mmb L,mammothb,314,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281209
David Yee,yeedaKing,315,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+1
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l))

        return 0",1441293091
David Yee,yeedaKing,315,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 1)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j, flag = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+flag
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l, 2 if flag == 1 else 1))

        return 0",1441294688
David Yee,yeedaKing,315,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sum1 = sum2 = 0
        for i in range(len(num)):
            if i%2:
                sum1 += int(num[i])

            else:
                sum2 += int(num[i])

        return sum1 == sum2",1441280847
killer-whale,killer-whale,316,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start)]
        dist = defaultdict(lambda: inf, {start: 0})
        while h:
            cost, node = heappop(h)
            if dist[node] != cost:
                continue
            if node == target:
                return cost
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx] + 1
                    nw = max(w, cost + 1)
                    if dist[ny, nx] > nw:
                        dist[ny, nx] = nw
                        heappush(h, (nw, (ny, nx)))",1441290248
killer-whale,killer-whale,316,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start, 1)]
        dist = defaultdict(lambda: inf, {(start, 1): 0})
        while h:
            cost, node, cnt = heappop(h)
            if dist[node, cnt] != cost:
                continue
            if node == target:
                return cost
            cnt += 1
            cnt %= 2
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx]
                    nw = max(w, cost) + cnt + 1
                    #print(cnt, nw)
                    if dist[(ny, nx), cnt] > nw:
                        dist[(ny, nx), cnt] = nw
                        heappush(h, (nw, (ny, nx), cnt))",1441294773
killer-whale,killer-whale,316,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o=e=0
        for i, x in enumerate(num):
            if i % 2:
                o += int(x)
            else:
                e += int(x)
        return o==e",1441290328
SirTechnical,SirTechnical,317,3627,cpp,"struct State {
    int i;
    int j;
    int t;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, 0x3f3f3f3f));
        dist[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0});
        while (!pq.empty()) {
            auto [i,j,t] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+1;
                if (tt < dist[ti][tj]) {
                    dist[ti][tj] = tt;
                    pq.push({ti,tj,tt});
                }
            }
        }
        return dist[N-1][M-1];
    }
};",1441291831
SirTechnical,SirTechnical,317,3628,cpp,"struct State {
    int i;
    int j;
    int t;
    int d;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

inline int alt(int d) {
    if (d == 1) return 2;
    return 1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist1(N, vector<int>(M, 0x3f3f3f3f));
        vector<vector<int>> dist2(N, vector<int>(M, 0x3f3f3f3f));
        dist1[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0,1});
        while (!pq.empty()) {
            auto [i,j,t,d] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+d;
                if (d == 1) {
                    if (tt < dist2[ti][tj]) {
                        dist2[ti][tj] = tt;
                        pq.push({ti,tj,tt,2});
                    }
                } else {
                    if (tt < dist1[ti][tj]) {
                        dist1[ti][tj] = tt;
                        pq.push({ti,tj,tt,1});
                    }
                }
                
            }
        }
        return min(dist1[N-1][M-1], dist2[N-1][M-1]);
    }
};",1441294968
SirTechnical,SirTechnical,317,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sa = 0;
        int sb = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i%2 == 0) sa += num[i]-'0';
            else sb += num[i]-'0';
        }
        return sa == sb;
    }
};",1441280907
Sanjay Grover,SanjayGrover,318,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0)]
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + 1 + waitTime
                    
                    if newTime < visited[nx][ny]:
                        visited[nx][ny] = newTime
                        heapq.heappush(pq, (newTime, nx, ny))
        
        return -1",1441289381
Sanjay Grover,SanjayGrover,318,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0, 1)]
        visited = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        visited[0][0][1] = 0
        
        while pq:
            time, x, y, nextMoveTime = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + nextMoveTime + waitTime
                    
                    alter = 2 if nextMoveTime == 1 else 1
                    
                    if newTime < visited[nx][ny][alter - 1]:
                        visited[nx][ny][alter - 1] = newTime
                        heapq.heappush(pq, (newTime, nx, ny, alter))
        
        return -1",1441295001
Sanjay Grover,SanjayGrover,318,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int even = 0;
        int odd = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i % 2 == 0) even += num.charAt(i) - '0';
            else odd += num.charAt(i) - '0';
        }
        return odd == even;
    }
}",1441283075
Andwerp,Andwerp,319,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> q;
        q.push({0, {0, 0}});
        vector<vector<bool>> v(n, vector<bool>(m, false));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.first;
            int c = q.top().second.second;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c] || d[r][c] != cur_t) {
                continue;
            }
            v[r][c] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int next_t = max(mt[nr][nc] + 1, cur_t + 1);
                if(next_t < d[nr][nc] && !v[nr][nc]) {
                    d[nr][nc] = next_t;
                    q.push({-next_t, {nr, nc}});
                }
            }
        }
        return d[n - 1][m - 1];
    }
};",1441291525
Andwerp,Andwerp,319,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        //i, j, move parity
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2e9)));
        d[0][0][0] = 0;
        priority_queue<pair<int, pair<int, pair<int, int>>>> q;
        q.push({0, {0, {0, 0}}});
        vector<vector<vector<bool>>> v(n, vector<vector<bool>>(m, vector<bool>(2, false)));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.second.first;
            int c = q.top().second.second.second;
            int p = q.top().second.first;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c][p] || d[r][c][p] != cur_t) {
                continue;
            }
            v[r][c][p] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                int np = p == 1? 0 : 1;
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int inc = p == 0? 1 : 2;
                int next_t = max(mt[nr][nc] + inc, cur_t + inc);
                if(next_t < d[nr][nc][np] && !v[nr][nc][np]) {
                    d[nr][nc][np] = next_t;
                    q.push({-next_t, {np, {nr, nc}}});
                }
            }
        }
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};",1441295219
Andwerp,Andwerp,319,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.size(); i++){
            sum += (num[i] - '0') * (i % 2 == 0? 1 : -1);
        }
        return sum == 0;
    }
};",1441281071
Raymond Jones Jr.,TheRealRaymondJones,320,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    heapq.heappush(heap,(waitTime,nr,nc))
        return -1
            ",1441293065
Raymond Jones Jr.,TheRealRaymondJones,320,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0, False))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c, has_extra_step = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    if has_extra_step:
                        waitTime += 1
                    heapq.heappush(heap,(waitTime,nr,nc, not has_extra_step))
        return -1",1441295429
Raymond Jones Jr.,TheRealRaymondJones,320,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                evens += int(digit)
            else:
                odds += int(digit)
        return evens == odds",1441281456
IvanHugh,ivanc-e,324,3627,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0)]
        
        while heap:  
            current_time, x, y = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + 1  
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny))  
        
        return -1",1441293828
IvanHugh,ivanc-e,324,3628,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0, 0)]
        
        while heap:  
            current_time, x, y, cnt = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + (1 if cnt % 2 == 0 else 2)
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny, cnt+1))  
        
        return -1",1441296218
IvanHugh,ivanc-e,324,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
        ",1441281390
Wilsano,Wilsano,325,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;
        pq.push({0, 0, 0});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441294111
Wilsano,Wilsano,325,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>>> pq;
        pq.push({0, 0, 0, 1});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c, cost] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + cost;
                    int next_cost = (cost == 1) ? 2 : 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc, next_cost});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441296324
Wilsano,Wilsano,325,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int weight = 1;
        for(int i = 0; i < num.length(); ++i){
            sum += (num[i] - '0') * weight;
            weight *= -1;
        }
        return sum == 0;
    }
};",1441281006
Fuad Qarayev,fuad720,326,3627,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m];
        bool vis[n][m];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j] = 2e9;
                vis[i][j] = 0;
            }
        }
        dist[0][0] = 0;
        pq.push({0,{0,0}});
        while(pq.size()) {
            auto [x,y] = pq.top().second;
            pq.pop();
            if(vis[x][y])continue;
            vis[x][y] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny] > max(moveTime[nx][ny]+1, dist[x][y]+1)) {
                        dist[nx][ny] = max(moveTime[nx][ny]+1, dist[x][y]+1);
                        pq.push({-dist[nx][ny], {nx, ny}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441293590
Fuad Qarayev,fuad720,326,3628,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, array<int,3>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m][2];
        bool vis[n][m][2];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j][0] = dist[i][j][1] =  2e9;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }
        dist[0][0][0] = 0;
        pq.push({0,{0,0,0}});
        while(pq.size()) {
            auto [x,y,w] = pq.top().second;
            pq.pop();
            if(vis[x][y][w])continue;
            vis[x][y][w] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny][w^1] > max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w)) {
                        dist[nx][ny][w^1] = max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w);
                        pq.push({-dist[nx][ny][w^1], {nx, ny, w^1}});
                    }
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441296391
Fuad Qarayev,fuad720,326,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0;i<num.size();i+=2) {
            sum+=num[i]-'0';
        }
        for(int i = 1;i<num.size();i+=2) {
            sum-=num[i]-'0';
        }
        return (sum==0);
    }
};",1441282333
Roushan Kumar Singh,r-tron19,327,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0)))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1, moveTime[x][y]+1)
                s.add((T, (x, y)))
        
        return -1",1441294937
Roushan Kumar Singh,r-tron19,327,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0), 0))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord, ext = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1 + ext, moveTime[x][y]+1+ext)
                s.add((T, (x, y), ext ^ 1))
        
        return -1",1441296682
Roushan Kumar Singh,r-tron19,327,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o, e = 0, 0
        for i,el in enumerate(num):
            if i%2:
                o += int(el)
            else:
                e += int(el)
        return o == e",1441281649
cro_poder,cro_poder,328,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX));
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        
        while (!pq.empty()) {
            auto [curr, i, j] = pq.top();
            pq.pop();
            if (i == n - 1 && j == m - 1) return curr;  
            
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = max(curr + 1, 1+moveTime[ni][nj]);
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj);
                    }
                }
            }
        }
        return -1;
    }
};
",1441292077
cro_poder,cro_poder,328,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX)); 
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0, 1); 
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!pq.empty()) {
            auto [curr, i, j, moveCost] = pq.top();
            pq.pop();
            
            if (i == n - 1 && j == m - 1) return curr;  
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = moveCost+max(curr, moveTime[ni][nj]);
                    int nextMoveCost = (moveCost == 1) ? 2 : 1;  
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj, nextMoveCost);
                    }
                }
            }
        }
        
        return -1;   
    }
};
",1441296768
cro_poder,cro_poder,328,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s1 = 0, s2 = 0;
        
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s1 += num[i] - '0';  
            } else {
                s2 += num[i] - '0';   
            }
        }
        
        return s1 == s2;
    }
};
",1441281358
Leonyhenn,leonyhenn,329,3627,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+1 if moveTime[dx][dy] > time else time+1
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy))
        return
                
                    
            
        
        ",1441294685
Leonyhenn,leonyhenn,329,3628,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0,1),(0,0,0,2)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y,step) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+step if moveTime[dx][dy] > time else time+step
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy,2 if step == 1 else 1))
        return
                
                    
            
        
        ",1441296987
Leonyhenn,leonyhenn,329,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281088
Jeel27,Jeel27,330,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0)]
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            current_time, x, y = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    next_time = arrival_time + 1
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny))
        
        return -1",1441289971
Jeel27,Jeel27,330,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0, 0)]  # (time, x, y, step)
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while heap:
            current_time, x, y, step = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    move_cost = 1 if step % 2 == 0 else 2
                    next_time = arrival_time + move_cost
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny, step + 1))

        return -1",1441291277
Jeel27,Jeel27,330,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum",1441281450
Burger Monstah,WRWRW,331,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0)]
        v = {}
        while h:
            t, r, c = heapq.heappop(h)
            # print(t, r, c)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + 1, rr, cc))",1441291563
Burger Monstah,WRWRW,331,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0, 1)]
        v = {}
        while h:
            
            # print(h)
            t, r, c, cost = heapq.heappop(h)
            # print(t, r, c, cost)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + cost, rr, cc, 1 if cost == 2 else 2))",1441297068
Burger Monstah,WRWRW,331,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        
        for i, c in enumerate(num):
            if i % 2 == 0:
                a += int(c)
            else:
                a -= int(c)
        return a == 0
                
        ",1441281726
Denis Rozhkov,rozhkov,333,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows = len(moveTime)
        cols = len(moveTime[0])
        H = [(0, 0, 0)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = set([(0, 0)])
        while H:
            tm, r, c = heapq.heappop(H)
            if r == rows - 1 and c == cols - 1:
                return tm
            for dr, dc in dirs:
                new_r, new_c = r + dr, c + dc
                if 0 <= new_r < rows and 0 <= new_c < cols and (new_r, new_c) not in visited:
                    visited.add((new_r, new_c))
                    heapq.heappush(H, (max(tm, moveTime[new_r][new_c]) + 1, new_r, new_c))
        ",1441295774
Denis Rozhkov,rozhkov,333,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows = len(moveTime)
        cols = len(moveTime[0])
        H = [(0, 0, 0, 0)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = set([(0, 0)])
        while H:
            tm, r, c, inc = heapq.heappop(H)
            if r == rows - 1 and c == cols - 1:
                return tm
            for dr, dc in dirs:
                new_r, new_c = r + dr, c + dc
                if 0 <= new_r < rows and 0 <= new_c < cols and (new_r, new_c) not in visited:
                    visited.add((new_r, new_c))
                    heapq.heappush(H, (max(tm, moveTime[new_r][new_c]) + 1 + inc, new_r, new_c, 1 - inc))
        ",1441297595
Denis Rozhkov,rozhkov,333,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(x) for i, x in enumerate(num) if i % 2]) == sum([int(x) for i, x in enumerate(num) if not i % 2])
        ",1441283906
Hriday03,Hriday03,334,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        pq = [(0, 0, 0)]
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        
        while pq:
            curr_time, row, col = heapq.heappop(pq)
            
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(curr_time, moveTime[new_row][new_col])
                    arrival_time = wait_time + 1
                    
                    if arrival_time < min_time[new_row][new_col]:
                        min_time[new_row][new_col] = arrival_time
                        heapq.heappush(pq, (arrival_time, new_row, new_col))
        
        return -1",1441291046
Hriday03,Hriday03,334,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        pq = [(0, 0, 0, 1)]
        min_time = {}
        
        while pq:
            curr_time, row, col, next_move_time = heapq.heappop(pq)
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(curr_time, moveTime[new_row][new_col])
                    move_duration = 1 if next_move_time == 1 else 2
                    arrival_time = wait_time + move_duration
                    new_move_time = 2 if next_move_time == 1 else 1
                    
                    state = (new_row, new_col, new_move_time)
                    
                    if state not in min_time or arrival_time < min_time[state]:
                        min_time[state] = arrival_time
                        heapq.heappush(pq, (arrival_time, new_row, new_col, new_move_time))
        
        return -1",1441297620
Hriday03,Hriday03,334,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        esum, osum = 0, 0
        
        for i in range(len(num)):
            if i % 2 == 0:
                esum += int(num[i])
            else:
                osum += int(num[i])
                
        return esum == osum",1441282861
Avichal Dubey,dubeyavichal999,335,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        int n=moveTime.size(), m=moveTime[0].size();
        vector<vector<int>> vis(n,vector<int>(m,INT_MAX));
        vis[0][0]=0;
        pq.push({0,0,0});
        int dr[4]={-1,1,0,0};
        int dc[4]={0,0,-1,1};
        while(!pq.empty()){
            int time=pq.top()[0];
            int i=pq.top()[1];
            int j=pq.top()[2];
            pq.pop();
            for(int k=0;k<4;k++){
                int nr=i+dr[k],nc=j+dc[k];
                if(nr>=0 && nr<n && nc>=0 && nc<m){
                    int timeto=max(time,moveTime[nr][nc])+1;
                    if(vis[nr][nc]==INT_MAX || timeto<vis[nr][nc]){
                        pq.push({timeto,nr,nc});
                        vis[nr][nc]=timeto;
                    }
                }
            }
        }
        return vis[n-1][m-1];
    }
};",1441295317
Avichal Dubey,dubeyavichal999,335,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        int n=moveTime.size(), m=moveTime[0].size();
        vector<vector<int>> vis(n,vector<int>(m,INT_MAX));
        vis[0][0]=0;
        pq.push({0,0,0,1});
        int dr[4]={-1,1,0,0};
        int dc[4]={0,0,-1,1};
        while(!pq.empty()){
            int time=pq.top()[0];
            int i=pq.top()[1];
            int j=pq.top()[2];
            int add=pq.top()[3];
            pq.pop();
            for(int k=0;k<4;k++){
                int nr=i+dr[k],nc=j+dc[k];
                if(nr>=0 && nr<n && nc>=0 && nc<m){
                    int timeto=max(time,moveTime[nr][nc])+add;
                    int nadd=add==1?2:1;
                    if(vis[nr][nc]==INT_MAX || timeto<vis[nr][nc]){
                        pq.push({timeto,nr,nc,nadd});
                        vis[nr][nc]=timeto;
                    }
                }
            }
        }
        return vis[n-1][m-1];
    }
};",1441297859
Avichal Dubey,dubeyavichal999,335,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        bool flag=true;
        int curr=0;
        for(char c:num){
            if(flag) curr+=(c-'0');
            else curr-=(c-'0');
            flag=!flag;
        }
        return curr==0;
    }
};",1441283238
Marmaduke,Marmaduke,336,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        int m = A.size();
        int n = A[0].size();
        const int big = 2e9;
        vector<vector<int>> B(m, vector<int>(n,big));
        typedef array<int,3> a3;
        priority_queue<a3, vector<a3>, std::greater<a3>> pq;
        B[0][0] = 0;
        pq.push({0,0,0});
        vector<pair<int,int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        while(!pq.empty())
        {
            auto v = pq.top();
            pq.pop();
            int t = v[0];
            int i = v[1];
            int j = v[2];
            for(auto &u : dir)
            {
                int a = u.first + i;
                int b = u.second + j;
                if(0 <= a && a < m && 0 <= b && b < n)
                {
                    int e = A[a][b] <= t ? t+1 : A[a][b] + 1;
                    if(e < B[a][b])
                    {
                        B[a][b] = e;
                        pq.push({e,a,b});
                    }
                }
            }
        }
        
        return B[m-1][n-1];
    }
};",1441295894
Marmaduke,Marmaduke,336,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        int m = A.size();
        int n = A[0].size();
        const int big = 2e9;
        vector<vector<int>> B(m, vector<int>(n,big));
        typedef array<int,3> a3;
        priority_queue<a3, vector<a3>, std::greater<a3>> pq;
        B[0][0] = 0;
        pq.push({0,0,0});
        vector<pair<int,int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        while(!pq.empty())
        {
            auto v = pq.top();
            pq.pop();
            int t = v[0];
            int i = v[1];
            int j = v[2];
            int f = (i+j) % 2 == 0 ? 1 : 2;
            for(auto &u : dir)
            {
                int a = u.first + i;
                int b = u.second + j;
                if(0 <= a && a < m && 0 <= b && b < n)
                {
                    int e = A[a][b] <= t ? t+f : A[a][b] + f;
                    if(e < B[a][b])
                    {
                        B[a][b] = e;
                        pq.push({e,a,b});
                    }
                }
            }
        }
        
        return B[m-1][n-1];
    }
};",1441297936
Marmaduke,Marmaduke,336,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        vector<int> c(2,0);
        for(int i = 0; i < n; i++)
        {
            int x = num[i] - '0';
            c[i%2]+=x;
        }
        return c[0] == c[1];
    }
};",1441281297
w0w0,w0w0,337,3627,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        m, n = len(mt), len(mt[0])

        pq = [[0, (0, 0)]]
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0
        while pq:
            t, (i, j) = heappop(pq)
            if i == m - 1 and j == n - 1:
                return t
            for ii, jj in (
                (i - 1, j),
                (i + 1, j),
                (i, j - 1),
                (i, j + 1)
            ):
                if 0 <= ii < m and 0 <= jj < n:
                    new_t = max(t + 1, mt[ii][jj] + 1)
                    if new_t < time[ii][jj]:
                        time[ii][jj] = new_t
                        heappush(pq, (new_t, (ii, jj)))",1441291761
w0w0,w0w0,337,3628,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        m, n = len(mt), len(mt[0])

        pq = [[0, 1, (0, 0)]]
        time1 = [[inf] * n for _ in range(m)]
        time2 = [[inf] * n for _ in range(m)]
        time1[0][0] = 0
        while pq:
            t, d, (i, j) = heappop(pq)
            new_d = 3 - d
            if i == m - 1 and j == n - 1:
                return t
            for ii, jj in (
                (i - 1, j),
                (i + 1, j),
                (i, j - 1),
                (i, j + 1)
            ):
                if 0 <= ii < m and 0 <= jj < n:
                    new_t = max(t + d, mt[ii][jj] + d)
                    if new_d == 1:
                        if new_t < time1[ii][jj]:
                            time1[ii][jj] = new_t
                            heappush(pq, (new_t, new_d, (ii, jj)))
                    else:
                        if new_t < time2[ii][jj]:
                            time2[ii][jj] = new_t
                            heappush(pq, (new_t, new_d, (ii, jj)))",1441297986
w0w0,w0w0,337,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        n = len(num)
        e = 0
        o = 0
        for i in range(0, n, 2):
            e += int(num[i])
        for i in range(1, n, 2):
            o += int(num[i])

        return e == o",1441281245
Akash Singh ,8081808345akash_singh,338,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
       int n = mt.size();
        int m = mt[0].size();   
        vector<vector<int>> mnt(n, vector<int>(m, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        mnt[0][0] = 0;
        
        vector<pair<int, int>> ds = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; 
        while (!pq.empty()) {
            auto [ct, x, y] = pq.top();
            pq.pop();
            
            if (x == n - 1 && y == m - 1) {
                return ct;
            } 
            for (auto [dx, dy] : ds) {
                int nx = x + dx, ny = y + dy;   
                if (nx >= 0 && ny >= 0 && nx < n && ny < m) {
                    int wt = max(mt[nx][ny] - ct, 0);
                    int nt = ct + 1 + wt;
                    
                    if (nt < mnt[nx][ny]) {
                        mnt[nx][ny] = nt;
                        pq.emplace(nt, nx, ny);
                    }
                }
            }
        }
        return -1;  
    }
};",1441292427
Akash Singh ,8081808345akash_singh,338,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();   
        vector<vector<int>> vz = mt;
        vector<vector<int>> mnt(n, vector<int>(m, INT_MAX)); 
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        mnt[0][0] = 0;  
        vector<pair<int, int>> ds = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.empty()) {
            auto [ct, x, y, st] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) {
                return ct;
            }
            for (auto [dx, dy] : ds) {
                int nx = x + dx, ny = y + dy;
                if (nx >= 0 && ny >= 0 && nx < n && ny < m) {
                    int wt = max(vz[nx][ny] - ct, 0);
                    int nt = ct + st + wt;
                    int nst = (st == 1) ? 2 : 1;
                    
                    if (nt < mnt[nx][ny]) {
                        mnt[nx][ny] = nt;
                        pq.emplace(nt, nx, ny, nst);
                    }
                }
            }
        }
        
        return -1;
    }
};",1441298024
Akash Singh ,8081808345akash_singh,338,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0) {
                es += d;
            } else {
                os += d;
            }
        }
        
        return es == os;
    }
};",1441284986
Narathip Hongthawee,opalXDnaja123,340,3627,cpp,"#define F first
#define S second

typedef pair<int, int> pii;
typedef pair<int, pii> pipii;

int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int dist[n][m];
        bool visited[n][m];
        priority_queue<pipii, vector<pipii>, greater<pipii>> pq;
        fill_n(dist[0], n * m, 2e9);
        fill_n(visited[0], n * m, false);
        dist[0][0] = 0;
        pq.emplace(dist[0][0], make_pair(0, 0));
        while (!pq.empty()) {
            int nowd = pq.top().F;
            int x = pq.top().S.F;
            int y = pq.top().S.S;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            if (x == n - 1 && y == m - 1) {
                return nowd;
            }
            visited[x][y] = true;
            for (int i = 0; i < 4; i++) {
                int tox = x + dx[i];
                int toy = y + dy[i];
                if (tox < 0 || toy < 0 || tox > n - 1 || toy > m - 1) {
                    continue;
                }
                int tod = max(nowd, moveTime[tox][toy]) + 1;
                if (dist[tox][toy] > tod && !visited[tox][toy]) {
                    dist[tox][toy] = tod;
                    pq.emplace(dist[tox][toy], make_pair(tox, toy));
                }
            }
            
        }
        return -1;
    }
};",1441294261
Narathip Hongthawee,opalXDnaja123,340,3628,cpp,"#define F first
#define S second

typedef pair<int, int> pii;
typedef pair<int, pii> pipii;
typedef pair<bool, pipii> pbpipii;

int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int dist[2][n][m];
        bool visited[2][n][m];
        priority_queue<pbpipii, vector<pbpipii>, greater<pbpipii>> pq;
        fill_n(dist[0][0], 2 * n * m, 2e9);
        fill_n(visited[0][0], 2 * n * m, false);
        dist[0][0][0] = 0;
        pq.emplace(false, make_pair(dist[0][0][0], make_pair(0, 0)));
        while (!pq.empty()) {
            bool cur = pq.top().F;
            int nowd = pq.top().S.F;
            int x = pq.top().S.S.F;
            int y = pq.top().S.S.S;
            pq.pop();
            if (visited[cur][x][y]) {
                continue;
            }
            if (x == n - 1 && y == m - 1) {
                return nowd;
            }
            visited[cur][x][y] = true;
            for (int i = 0; i < 4; i++) {
                int tox = x + dx[i];
                int toy = y + dy[i];
                if (tox < 0 || toy < 0 || tox > n - 1 || toy > m - 1) {
                    continue;
                }
                int tod = max(nowd, moveTime[tox][toy]) + ((cur) + 1);
                if (dist[cur][tox][toy] > tod && !visited[cur][tox][toy]) {
                    dist[cur][tox][toy] = tod;
                    pq.emplace(cur ^ 1, make_pair(dist[cur][tox][toy], make_pair(tox, toy)));
                }
            }
            
        }
        return -1;
    }
};",1441298112
Narathip Hongthawee,opalXDnaja123,340,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0, sum2 = 0;
        bool flg = 0;
        for (auto e : num) {
            if (flg) {
                sum += (e - '0');
                flg = 0;
                continue;
            }
            sum2 += (e - '0');
            flg = 1;
        }
        return (sum == sum2);
    }
};",1441281258
zeningc,zeningc,344,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dir = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        
        pq.offer(new int[] {0, 0, 0});
        Set<String> set = new HashSet<>();
        while (!pq.isEmpty())   {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            int t = cur[2];
            String key = x + ""_"" + y;
            if (set.contains(key))
                continue;
            set.add(key);
            if (x == m - 1 && y == n - 1)
                return t;
            
            for (int[] d : dir) {
                int nx = x + d[0];
                int ny = y + d[1];
                String nKey = nx + ""_"" + ny;
                if (nx < 0 || nx >= m || ny < 0 || ny >= n || set.contains(nKey))
                    continue;
                pq.offer(new int[] {nx, ny, Math.max(t + 1, moveTime[nx][ny] + 1)});
            }
        }
        
        return -1;
    }
}",1441290938
zeningc,zeningc,344,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dir = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        
        pq.offer(new int[] {0, 0, 0, 1});
        Set<String> set = new HashSet<>();
        while (!pq.isEmpty())   {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            int t = cur[2];
            int curTurn = cur[3];
            String key = x + ""_"" + y + ""_"" + curTurn;
            if (set.contains(key))
                continue;
            set.add(key);
            
            
            if (x == m - 1 && y == n - 1)
                return t;
            for (int[] d : dir) {
                int nx = x + d[0];
                int ny = y + d[1];
                int nxtTurn = curTurn == 1 ? 2 : 1;
                String nKey = nx + ""_"" + ny + ""_"" + nxtTurn;
                if (nx < 0 || nx >= m || ny < 0 || ny >= n || set.contains(nKey))
                    continue;
                pq.offer(new int[] {nx, ny, Math.max(t + curTurn, moveTime[nx][ny] + curTurn), nxtTurn});
            }
        }
        
        return -1;
    }
}",1441298372
zeningc,zeningc,344,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int a = 0;
        int b = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i % 2 == 0)
                a += num.charAt(i) - '0';
            else
                b += num.charAt(i) - '0';
        }
        return a == b;
    }
}",1441281004
gan14008,gan14008,345,3627,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        m, n = len(g), len(g[0])
        visited = [[float('inf')] * n for _ in range(m)]
        q = [(0, 0, 0)]
        visited[0][0] = 0
        
        while q:
            t, i, j = heapq.heappop(q)
            if i == m - 1 and j == n - 1:
                break
            
            for x, y in (i, j + 1), (i + 1, j), (i, j - 1), (i - 1, j):
                if 0 <= x < m and 0 <= y < n:
                    arrived = max(t, g[x][y])
                    if arrived + 1 < visited[x][y]:
                        visited[x][y] = arrived + 1
                        heapq.heappush(q, (visited[x][y], x, y))

        return visited[m - 1][n - 1]
",1441296476
gan14008,gan14008,345,3628,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        m, n = len(g), len(g[0])
        visited = [[float('inf')] * n for _ in range(m)]
        q = [(0, 0, 0, 0)]
        visited[0][0] = 0
        
        while q:
            t, s, i, j = heapq.heappop(q)
            if i == m - 1 and j == n - 1:
                break
            
            for x, y in (i, j + 1), (i + 1, j), (i, j - 1), (i - 1, j):
                if 0 <= x < m and 0 <= y < n:
                    arrived = max(t, g[x][y]) + (s & 1) + 1
                    if arrived < visited[x][y]:
                        visited[x][y] = arrived
                        heapq.heappush(q, (visited[x][y], s ^ 1, x, y))

        return visited[m - 1][n - 1]
",1441298401
gan14008,gan14008,345,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        q = [0, 0]
        
        for i, x in enumerate(num):
            q[i & 1] += int(x)
        
        return q[0] == q[1]",1441280915
domick,dominic89231,348,3627,python3,"class Solution:
    def minTimeToReach(self, M: List[List[int]]) -> int:
        m,n = len(M), len(M[0])
        Q = []
        heappush(Q, (0, 0, 0))
        seen = set()
        D = [(0,1),(0,-1),(1,0),(-1,0)]
        while Q:
            t, i, j = heappop(Q)
            print(t, i, j)
            if i == (m-1) and j == (n-1):
                return t
            if (i, j) not in seen:
                seen.add((i, j))
                for d in D:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < m and 0 <= nj < n:
                        new_t = max(t, M[ni][nj]) + 1
                        heappush(Q, (new_t, ni, nj))
        return -1
            ",1441296433
domick,dominic89231,348,3628,python3,"class Solution:
    def minTimeToReach(self, M: List[List[int]]) -> int:
        m,n = len(M), len(M[0])
        Q = []
        heappush(Q, (0, 1, 0, 0))
        seen = set()
        D = [(0,1),(0,-1),(1,0),(-1,0)]
        while Q:
            t, s, i, j = heappop(Q)
            if i == (m-1) and j == (n-1):
                return t
            if (s, i, j) not in seen:
                seen.add((s, i, j))
                for d in D:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < m and 0 <= nj < n:
                        new_t = max(t, M[ni][nj]) + s
                        new_s = 1 if s == 2 else 2
                        heappush(Q, (new_t, new_s, ni, nj))
        return -1",1441298709
domick,dominic89231,348,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = s2 = 0
        for i in range(len(num)):
            if i % 2 == 0:
                s1 += int(num[i])
            else:
                s2 += int(num[i])
        return s1 == s2",1441282368
Jose Coves,jcoves,350,3627,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = sz(g), m = sz(g[0]);
        auto dp = vv(n, m, oo);
        min_pq<array<int, 3>> pq;
        dp[0][0] = 0;
        pq.push({dp[0][0], 0, 0});
        while(!pq.empty()){
            auto [d, x, y] = pq.top(); pq.pop();
            // if(dp[i][j] < d) continue;
            if(dp[x][y] != d) continue;
            forn(k, 4){
                int nx = x + DX[k], ny = y + DY[k];
                if(nx < 0 or nx >= n or ny < 0 or ny >= m) continue;
                int nd = max(d, g[nx][ny]) + 1;
                if(nd >= dp[nx][ny]) continue;
                dp[nx][ny] = nd;
                pq.push({nd, nx, ny});
            }
        }
        return dp[n-1][m-1];
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vvi g; cin >> g;
    out(sol.minTimeToReach(g));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1441294903
Jose Coves,jcoves,350,3628,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = sz(g), m = sz(g[0]);
        auto dp = vv(2, n, m, oo);
        min_pq<array<int, 4>> pq;
        dp[0][0][0] = 0;
        pq.push({dp[0][0][0], 0, 0, 0});
        while(!pq.empty()){
            auto [d, c, x, y] = pq.top(); pq.pop();
            // if(dp[i][j] < d) continue;
            if(dp[c][x][y] != d) continue;
            forn(k, 4){
                int nx = x + DX[k], ny = y + DY[k];
                if(nx < 0 or nx >= n or ny < 0 or ny >= m) continue;
                int nd = max(d, g[nx][ny]) + 1 + c;
                int nc = 1 - c;
                if(nd >= dp[nc][nx][ny]) continue;
                dp[nc][nx][ny] = nd;
                pq.push({nd, nc, nx, ny});
            }
        }
        return min(dp[0][n-1][m-1], dp[1][n-1][m-1]);
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vvi g; cin >> g;
    out(sol.minTimeToReach(g));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1441298971
Jose Coves,jcoves,350,3636,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    bool isBalanced(string s) {
        vi a(2);
        int n = sz(s);
        forn(i, n){
            int x = s[i] - '0';
            a[i%2] += x;
        }
        return a[0] == a[1];
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;

}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1441282077
