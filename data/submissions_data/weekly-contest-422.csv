username,userslug,contest_rank,question_id,language,code,submission_id
uwi,uwi,1,3627,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur] + 1, moveTime[nr][nc]+1);
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441290571
uwi,uwi,1,3628,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur], moveTime[nr][nc]) + (r+c)%2+1;
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441292405
uwi,uwi,1,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        long bal = 0;
        for(int i = 0;i < num.length();i++){
            bal = -bal + num.charAt(i) - '0';
        }
        return bal == 0;
    }
}",1441280931
uwi,uwi,1,3637,java,"	class Solution {
		public int countBalancedPermutations(String num) {
			int[] f = new int[10];
			int s = 0;
			for(char c : num.toCharArray()){
				f[c-'0']++;
				s += c-'0';
			}
			if(s % 2 != 0)return 0;
			final int mod = 1000000007;
			s /= 2;

			int n = num.length();
			long[][] dp = new long[n/2+1][s+1];
			int[][] fif = enumFIF(1000, mod);
			dp[0][0] = (long)fif[0][n/2] * fif[0][n-n/2] % mod;
			for(int i = 0;i <= 9;i++){
				long[][] ndp = new long[n/2+1][s+1];
				for(int j = n/2;j >= 0;j--){
					for(int k = s;k >= 0;k--){
						if(dp[j][k] == 0)continue;
						for(int t = 0;t <= f[i] && k+i*t <= s && j+t <= n/2;t++){
							ndp[j+t][k+i*t] += dp[j][k] * fif[1][t] % mod * fif[1][f[i]-t];
							ndp[j+t][k+i*t] %= mod;
						}
					}
				}
				dp = ndp;
			}
			return (int)dp[n/2][s];
		}

		public static int[][] enumFIF(int n, int mod) {
			int[] f = new int[n + 1];
			int[] invf = new int[n + 1];
			f[0] = 1;
			for (int i = 1; i <= n; i++) {
				f[i] = (int) ((long) f[i - 1] * i % mod);
			}
			long a = f[n];
			long b = mod;
			long p = 1, q = 0;
			while (b > 0) {
				long c = a / b;
				long d;
				d = a;
				a = b;
				b = d % b;
				d = p;
				p = q;
				q = d - c * q;
			}
			invf[n] = (int) (p < 0 ? p + mod : p);
			for (int i = n - 1; i >= 0; i--) {
				invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);
			}
			return new int[][]{f, invf};
		}

	}
",1441300564
green_pig,green_pig,2,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291673
green_pig,green_pig,2,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + k + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291255
green_pig,green_pig,2,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280737
green_pig,green_pig,2,3637,python3,"M = 10**9+7
F = [1] * 100
for i in range(1, len(F)):
    F[i] = F[i-1]*i%M
I = [pow(x, -1, M) for x in F]
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        a = [0] * 10
        for n in map(int, num):
            a[n] += 1
        s, t = len(num[::2]), len(num[1::2])
        @cache
        def f(i, d, m, n):
            if m > s or n > t: return 0
            if i == 10:
                return int(d == 0)
            r = 0
            for j in range(a[i]+1):
                k = a[i] - j
                r += I[j] * I[k] * f(i+1, d+i*(j-k), m+j, n+k) % M
            return r % M
        return F[s] * F[t] * f(0, 0, 0, 0) % M
",1441305429
Chris Ho,Chris_ho,3,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        pq = [(0, 0, 0)]
        
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            curr_time, row, col = heapq.heappop(pq)
            
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(moveTime[new_row][new_col] - curr_time, 0)
                    next_time = curr_time + 1 + wait_time
                    
                    if next_time < visited[new_row][new_col]:
                        visited[new_row][new_col] = next_time
                        heapq.heappush(pq, (next_time, new_row, new_col))
        
        return -1",1441299988
Chris Ho,Chris_ho,3,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        min_time = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        min_time[0][0][0] = 0
        heap = [(0, 0, 0, 0)]
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
        while heap:
            current_time, i, j, parity = heapq.heappop(heap)
            
            if current_time > min_time[i][j][parity]:
                continue
            
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < m:
                    move_duration = 1 if parity == 0 else 2
                    start_time = max(current_time, moveTime[ni][nj])
                    arrival_time = start_time + move_duration
                    new_parity = 1 - parity
                    if arrival_time < min_time[ni][nj][new_parity]:
                        min_time[ni][nj][new_parity] = arrival_time
                        heapq.heappush(heap, (arrival_time, ni, nj, new_parity))
                            
        return min(min_time[n - 1][m - 1][0], min_time[n - 1][m - 1][1])
",1441307226
Chris Ho,Chris_ho,3,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = sum(int(x) for x in num[0::2])
        y = sum(int(x) for x in num[1::2])
        return x==y
        
        ",1441280968
Chris Ho,Chris_ho,3,3637,python3,"MOD = 10**9 + 7
from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        cnt_d = [0] * 10
        total_sum = sum(map(int, num))
        for ch in num:
            cnt_d[int(ch)] += 1
        if total_sum % 2 != 0:
            return 0
        S = total_sum // 2
        NE = (N + 1) // 2
        NO = N // 2
        fac = [1] * (N + 1)
        for i in range(1, N + 1):
            fac[i] = fac[i - 1] * i % MOD
        inv_fac = [1] * (N + 1)
        inv_fac[N] = pow(fac[N], MOD - 2, MOD)
        for i in range(N, 0, -1):
            inv_fac[i - 1] = inv_fac[i] * i % MOD
        def C(n, k):
            if k < 0 or k > n:
                return 0
            return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD
        dp = defaultdict(int)
        dp[(0, 0)] = 1
        for d in range(10):
            cnt = cnt_d[d]
            if cnt == 0:
                continue
            dp_new = dp.copy()
            for (s1, c1), ways1 in dp.items():
                max_k = min(cnt, NE - c1)
                for k in range(1, max_k + 1):
                    s = s1 + k * d
                    c = c1 + k
                    ways = ways1 * C(cnt, k) % MOD
                    dp_new[(s, c)] = (dp_new.get((s, c), 0) + ways) % MOD
            dp = dp_new
        total_ways = 0
        for (s, c), ways in dp.items():
            if c == NE and s == S:
                total_ways = (total_ways + ways) % MOD
        total_permutations = total_ways * fac[NE] % MOD * fac[NO] % MOD
        for d in range(10):
            total_permutations = total_permutations * inv_fac[cnt_d[d]] % MOD
        return total_permutations
",1441302114
superfearless,superfearless,4,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        import heapq
        n, m = len(moveTime), len(moveTime[0])
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if t > dist[x][y]:
                continue
            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    t_move = max(t, moveTime[nx][ny])
                    t_neighbor = t_move + 1
                    if dist[nx][ny] > t_neighbor:
                        dist[nx][ny] = t_neighbor
                        heapq.heappush(heap, (t_neighbor, nx, ny))
        return dist[n-1][m-1]        ",1441288089
superfearless,superfearless,4,3628,python3,"class Solution:
	def minTimeToReach(S,moveTime):
		D=moveTime;E,F=len(D),len(D[0]);N=float('inf');A=[[[N]*2 for A in range(F)]for A in range(E)];G=[(0,0,0,0)];A[0][0][0]=0
		while G:
			K,L,M,H=heapq.heappop(G)
			if A[L][M][H]<K:continue
			for(O,P)in[(-1,0),(1,0),(0,-1),(0,1)]:
				B,C=L+O,M+P
				if 0<=B<E and 0<=C<F:
					Q=1 if H==0 else 2;R=max(K,D[B][C]);I=R+Q;J=(H+1)%2
					if I<A[B][C][J]:A[B][C][J]=I;heapq.heappush(G,(I,B,C,J))
		return min(A[E-1][F-1])      ",1441295837
superfearless,superfearless,4,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                even_sum += int(d)
            else:
                odd_sum += int(d)
        return even_sum == odd_sum       ",1441287048
superfearless,superfearless,4,3637,python3,"class Solution:
	def countBalancedPermutations(c,num):
		A=10**9+7;from math import comb;from collections import defaultdict as S;I=[0]*10;J=0;C=len(num);B=C//2;V=C-B
		for W in num:D=int(W);I[D]+=1;J+=D
		if J%2!=0:return 0
		X=J//2;Y=B*9;G=[S(int)for A in range(B+1)];G[0][0]=1;F=[1]*(C+1);K=[1]*(C+1)
		for E in range(1,C+1):F[E]=F[E-1]*E%A
		K[C]=pow(F[C],A-2,A)
		for E in range(C-1,-1,-1):K[E]=K[E+1]*(E+1)%A
		for D in range(10):
			L=I[D]
			if L==0:continue
			M=[S(int)for A in range(B+1)]
			for H in range(B+1):
				for T in G[H]:
					Z=G[H][T]
					for N in range(0,min(L,B-H)+1):
						O=H+N;P=T+N*D
						if O<=B and P<=Y:a=comb(L,N);M[O][P]=(M[O][P]+Z*a)%A
			G=M
		U=G[B].get(X,0)
		if U==0:return 0
		b=F[V]*F[B]%A;Q=1
		for D in range(10):Q=Q*F[I[D]]%A
		R=U*b%A;R=R*pow(Q,A-2,A)%A;return R        ",1441292392
LayCurse,LayCurse,5,3627,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441295459
LayCurse,LayCurse,5,3628,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1 + t;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1 + t;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441294873
LayCurse,LayCurse,5,3636,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  bool isBalanced(string A){
    int i;
    int N = A.size();
    int res = 0;
    for(i=(0);i<(N);i+=(2)){
      res += A[i] - '0';
    }
    for(i=(1);i<(N);i+=(2)){
      res -= A[i] - '0';
    }
    return res == 0;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   bool isBalanced(string A) {
//     int N = A.size(), res = 0;
//     rep(i,0,N,2) res += A[i] - '0';
//     rep(i,1,N,2) res -= A[i] - '0';
//     return res == 0;
//   }
// };
",1441281284
LayCurse,LayCurse,5,3637,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
template<class T> struct Comb{
  int mem_fact;
  T*factri;
  T*ifactri;
  int mem_dfact;
  T*dfactri;
  int mem_pw2;
  int mem_pw3;
  int mem_pw10;
  int mem_rep1;
  T*pw2c;
  T*pw3c;
  T*pw10c;
  T*rep1c;
  int mem_ipw2;
  int mem_ipw3;
  int mem_ipw10;
  T*ipw2c;
  T*ipw3c;
  T*ipw10c;
  Comb(){
    mem_fact = 0;
    mem_dfact = 0;
    mem_pw2 = mem_pw3 = mem_pw10 = mem_rep1 = 0;
    mem_ipw2 = mem_ipw3 = mem_ipw10 = 0;
  }
  inline void expand_fact(int k){
    int i;
    if(k <= mem_fact){
      return;
    }
    chmax(k, 2 * mem_fact);
    if(mem_fact == 0){
      factri = (T*)malloc(k * sizeof(T));
      ifactri = (T*)malloc(k * sizeof(T));
      factri[0] = 1;
      for(i=(1);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(0);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    else{
      factri = (T*)realloc(factri, k * sizeof(T));
      ifactri = (T*)realloc(ifactri, k * sizeof(T));
      for(i=(mem_fact);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(mem_fact);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    mem_fact = k;
  }
  inline T fac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return factri[k];
  }
  inline T ifac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return ifactri[k];
  }
  inline T C(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[b] * ifactri[a-b];
  }
  inline T P(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[a-b];
  }
  inline T H(int a, int b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    if(mem_fact < a+b){
      expand_fact(a+b);
    }
    return C(a+b-1, b);
  }
  inline T Multinomial(int sz, int a[]){
    int i;
    int s = 0;
    T res;
    for(i=(0);i<(sz);i++){
      s += a[i];
    }
    if(mem_fact < s+1){
      expand_fact(s+1);
    }
    res = factri[s];
    for(i=(0);i<(sz);i++){
      res *= ifactri[a[i]];
    }
    return res;
  }
  inline T Multinomial(int a){
    return 1;
  }
  inline T Multinomial(int a, int b){
    if(mem_fact < a+b+1){
      expand_fact(a+b+1);
    }
    return factri[a+b] * ifactri[a] * ifactri[b];
  }
  inline T Multinomial(int a, int b, int c){
    if(mem_fact < a+b+c+1){
      expand_fact(a+b+c+1);
    }
    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];
  }
  inline T Multinomial(int a, int b, int c, int d){
    if(mem_fact < a+b+c+d+1){
      expand_fact(a+b+c+d+1);
    }
    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];
  }
  inline T Catalan(int n){
    if(n < 0){
      return 0;
    }
    if(mem_fact < 2*n+1){
      expand_fact(2*n+1);
    }
    return factri[2*n] * ifactri[n] * ifactri[n+1];
  }
  inline T Catalan(int n, int m, int k){
    if(k <= 0){
      return C(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C(n+m, m) - C(n+m, k-1);
  }
  inline T Catalan_s(long long n, long long m, long long k){
    if(k <= 0){
      return C_s(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C_s(n+m, m) - C_s(n+m, k-1);
  }
  inline T C_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    if(b > a - b){
      b = a - b;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
      res /= i + 1;
    }
    return res;
  }
  inline T P_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
    }
    return res;
  }
  inline T H_s(long long a, long long b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    return C_s(a+b-1, b);
  }
  inline T per_s(long long n, long long k){
    T d;
    int m;
    if(n < 0 || k < 0){
      return 0;
    }
    if(n == k  &&  k == 0){
      return 1;
    }
    if(n == 0 || k == 0){
      return 0;
    }
    if(k==1){
      return 1;
    }
    if(k==2){
      d = n / 2;
      return d;
    }
    if(k==3){
      d = (n-1) / 6;
      m = (n-1) % 6;
      if(m==0){
        return 3 * d * d + d;
      }
      if(m==1){
        return 3 * d * d + 2 * d;
      }
      if(m==2){
        return 3 * d * d + 3 * d + 1;
      }
      if(m==3){
        return 3 * d * d + 4 * d + 1;
      }
      if(m==4){
        return 3 * d * d + 5 * d + 2;
      }
      if(m==5){
        return 3 * d * d + 6 * d + 3;
      }
    }
    assert(0 && ""per_s should be k <= 3"");
    return -1;
  }
  inline void expand_dfact(int k){
    int i;
    if(k <= mem_dfact){
      return;
    }
    chmax(k, 3);
    chmax(k, 2 * mem_dfact);
    if(mem_dfact==0){
      dfactri = (T*)malloc(k * sizeof(T));
      dfactri[0] = dfactri[1] = 1;
      for(i=(2);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    else{
      dfactri = (T*)realloc(dfactri, k * sizeof(T));
      for(i=(mem_dfact);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    mem_dfact = k;
  }
  inline void expand_pw2(int k){
    int i;
    if(k <= mem_pw2){
      return;
    }
    chmax(k, 2 * mem_pw2);
    if(mem_pw2==0){
      pw2c = (T*)malloc(k * sizeof(T));
      pw2c[0] = 1;
      for(i=(1);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    else{
      pw2c = (T*)realloc(pw2c, k * sizeof(T));
      for(i=(mem_pw2);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    mem_pw2 = k;
  }
  inline void expand_ipw2(int k){
    int i;
    if(k <= mem_ipw2){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw2);
    if(mem_ipw2==0){
      ipw2c = (T*)malloc(k * sizeof(T));
      ipw2c[0] = 1;
      ipw2c[1] = ipw2c[0] / 2;
      for(i=(1);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    else{
      ipw2c = (T*)realloc(ipw2c, k * sizeof(T));
      for(i=(mem_ipw2);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    mem_ipw2 = k;
  }
  inline void expand_pw3(int k){
    int i;
    if(k <= mem_pw3){
      return;
    }
    chmax(k, 2 * mem_pw3);
    if(mem_pw3==0){
      pw3c = (T*)malloc(k * sizeof(T));
      pw3c[0] = 1;
      for(i=(1);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    else{
      pw3c = (T*)realloc(pw3c, k * sizeof(T));
      for(i=(mem_pw3);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    mem_pw3 = k;
  }
  inline void expand_ipw3(int k){
    int i;
    if(k <= mem_ipw3){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw3);
    if(mem_ipw3==0){
      ipw3c = (T*)malloc(k * sizeof(T));
      ipw3c[0] = 1;
      ipw3c[1] = ipw3c[0] / 3;
      for(i=(1);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    else{
      ipw3c = (T*)realloc(ipw3c, k * sizeof(T));
      for(i=(mem_ipw3);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    mem_ipw3 = k;
  }
  inline void expand_pw10(int k){
    int i;
    if(k <= mem_pw10){
      return;
    }
    chmax(k, 2 * mem_pw10);
    if(mem_pw10==0){
      pw10c = (T*)malloc(k * sizeof(T));
      pw10c[0] = 1;
      for(i=(1);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    else{
      pw10c = (T*)realloc(pw10c, k * sizeof(T));
      for(i=(mem_pw10);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    mem_pw10 = k;
  }
  inline void expand_ipw10(int k){
    int i;
    if(k <= mem_ipw10){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw10);
    if(mem_ipw10==0){
      ipw10c = (T*)malloc(k * sizeof(T));
      ipw10c[0] = 1;
      ipw10c[1] = ipw10c[0] / 10;
      for(i=(1);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    else{
      ipw10c = (T*)realloc(ipw10c, k * sizeof(T));
      for(i=(mem_ipw10);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    mem_ipw10 = k;
  }
  inline void expand_rep1(int k){
    int i;
    if(k <= mem_rep1){
      return;
    }
    chmax(k, 2 * mem_rep1);
    if(mem_rep1==0){
      rep1c = (T*)malloc(k * sizeof(T));
      rep1c[0] = 0;
      for(i=(1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    else{
      rep1c = (T*)realloc(rep1c, k * sizeof(T));
      for(i=(mem_rep1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    mem_rep1 = k;
  }
  inline T dfac(int k){
    if(k >= 0){
      if(mem_dfact < k+1){
        expand_dfact(k+1);
      }
      return dfactri[k];
    }
    if(k==-1){
      return 1;
    }
    k = - k - 2;
    if(k % 4 == 1){
      return 1 / (-dfac(k));
    }
    return 1 / dfac(k);
  }
  inline T pw2(int k){
    if(k >= 0){
      if(mem_pw2 < k+1){
        expand_pw2(k+1);
      }
      return pw2c[k];
    }
    else{
      k = -k;
      if(mem_ipw2 < k+1){
        expand_ipw2(k+1);
      }
      return ipw2c[k];
    }
  }
  inline T pw3(int k){
    if(k >= 0){
      if(mem_pw3 < k+1){
        expand_pw3(k+1);
      }
      return pw3c[k];
    }
    else{
      k = -k;
      if(mem_ipw3 < k+1){
        expand_ipw3(k+1);
      }
      return ipw3c[k];
    }
  }
  inline T pw10(int k){
    if(k >= 0){
      if(mem_pw10 < k+1){
        expand_pw10(k+1);
      }
      return pw10c[k];
    }
    else{
      k = -k;
      if(mem_ipw10 < k+1){
        expand_ipw10(k+1);
      }
      return ipw10c[k];
    }
  }
  inline T repunit(int k){
    if(mem_rep1 < k+1){
      expand_rep1(k+1);
    }
    return rep1c[k];
  }
}
;
template<> inline Modint Comb<Modint>::C_s(long long a, long long b){
  long long i;
  Modint res;
  Modint d;
  if(b < 0 || b > a){
    return 0;
  }
  if(b > a - b){
    b = a - b;
  }
  res = d = 1;
  for(i=(0);i<(b);i++){
    res *= a - i;
    d *= i + 1;
  }
  return res / d;
}
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
Modint dp[50][2000];
Modint nx[50][2000];
Comb<Modint> comb;
class Solution{
  public:
  int countBalancedPermutations(string A){
    int i, k;
    int N = A.size();
    int x;
    int y;
    int mx;
    int g;
    int c;
    int u;
    int xx;
    int yy;
    x = N / 2;
    y = N - x;
    u = 0;
    g =max_L(x, y)* 9 + 4;
    mx = g * 2 + 1;
    int h[10] = {};
    for(i=(0);i<(N);i++){
      h[A[i]-'0']++;
    }
    for(i=(0);i<(x+1);i++){
      int j;
      for(j=(0);j<(mx);j++){
        dp[i][j] = 0;
      }
    }
    dp[x][g] = 1;
    for(k=(0);k<(10);k++){
      if(h[k]){
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            nx[i][j] = 0;
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            if(dp[i][j]){
              int m;
              for(m=(0);m<(h[k]+1);m++){
                xx = i;
                yy = N - u - i;
                if(xx < m || yy < h[k]-m){
                  continue;
                }
                nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
              }
            }
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            dp[i][j] = nx[i][j];
          }
        }
        u += h[k];
      }
    }
    return dp[0][g];
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// Modint dp[50][2000], nx[50][2000];
// Comb<Modint> comb;
// 
// class Solution {
// public:
//   int countBalancedPermutations(string A) {
//     int N = A.size();
//     int x, y, mx, g, c, u, xx, yy;
//     x = N / 2;
//     y = N - x;
//     u = 0;
//     g = max(x,y) * 9 + 4;
//     mx = g * 2 + 1;
// 
//     int h[10] = {};
//     rep(i,N) h[A[i]-'0']++;
// 
//     rep(i,x+1) rep(j,mx) dp[i][j] = 0;
//     dp[x][g] = 1;
// 
//     rep(k,10) if(h[k]){
//       rep(i,x+1) rep(j,mx) nx[i][j] = 0;
// 
//       rep(i,x+1) rep(j,mx) if(dp[i][j]) rep(m,h[k]+1){
//         xx = i;
//         yy = N - u - i;
//         if(xx < m || yy < h[k]-m) continue;
//         nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
//       }
// 
//       rep(i,x+1) rep(j,mx) dp[i][j] = nx[i][j];
//       u += h[k];
//     }
// 
//     return dp[0][g];
//   }
// };
",1441310437
Yiming Li,lympanda,7,3627,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295795
Yiming Li,lympanda,7,3628,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+z+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295250
Yiming Li,lympanda,7,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1,sum2,i;
        sum1=0;sum2=0;
        for (i=0;i<num.length();i++)
            {
                if (i%2==0) sum1+=num[i]-'0';
                else sum2+=num[i]-'0';
            }
        if (sum1==sum2) return true;
        else return false;
    }
};",1441281135
Yiming Li,lympanda,7,3637,cpp,"#define _int64 long long
#define mo 1000000007

int inited=0;

#define faclim 310000

_int64 fac[faclim];
_int64 invfac[faclim];

_int64 pow1(int x,int y)
{
	int i;
	_int64 ret;
	ret=1;
	for (i=30;i>=0;i--)
	{
		ret=ret*ret%mo;
		if (((1<<i)&y)!=0) ret=ret*x%mo;
	}
	return ret;
}
_int64 inv(int x)
{
	return pow1(x,mo-2);
}
_int64 c(int x,int y)
{
	return fac[x]*invfac[y]%mo*invfac[x-y]%mo;
}
void init()
{
	int i;
	fac[0]=1;
	for (i=1;i<faclim;i++)
		fac[i]=fac[i-1]*i%mo;
	invfac[faclim-1]=inv(fac[faclim-1]);
	for (i=faclim-1;i>0;i--)
		invfac[i-1]=invfac[i]*i%mo;
}

_int64 d[2][2100][50];

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (inited==0)
        {
            init();
            inited=1;
        }
        int cnt[10];
        int i,j,k,o,rem,nn,now,n1,n2;
        memset(cnt,0,sizeof(cnt));
        for (i=0;i<num.length();i++)
            cnt[num[i]-'0']++;
        memset(d[0],0,sizeof(d[0]));
        nn=(num.length()+1)/2;
        d[0][1000][nn]=1;
        rem=num.length();
        now=0;
        for (i=0;i<10;i++) {
            memset(d[1-now],0,sizeof(d[1-now]));
            for (j=0;j<2100;j++)
                for (k=0;k<=nn;k++) {
                    if (d[now][j][k]==0) continue;
                    //cout<<""i,j,k:""<<i<<"" ""<<j<<"" ""<<k<<"" ""<<d[now][j][k]<<endl;
                    n1=k;n2=rem-k;
                    for (o=0;o<=cnt[i];o++) {
                        if (o>n1) continue;
                        if (cnt[i]-o>n2) continue;
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]+=d[now][j][k]*c(n1,o)%mo*c(n2,cnt[i]-o);
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]%=mo;
                    }
                }
            rem-=cnt[i];
            now=1-now;
        }
        return d[now][1000][0];
    }
};",1441310647
Rakesh_Reddy7,Naruto_x,8,3627,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0: return -1
        m = len(moveTime[0])
        if m == 0: return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[float('inf')] * m for i in range(n)]
        t2[0][0] = 0
        pq = [(0, 0, 0)] 
        while pq:
            curt, x, y = heapq.heappop(pq)
            
            if x == n - 1 and y == m - 1:
                return int(curt)
            
            if curt > t2[x][y]:
                continue
            
            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    at = max(curt, moveTime[nx][ny]) + 1

                    if at < t2[nx][ny]:
                        t2[nx][ny] = at
                        heapq.heappush(pq, (at, nx, ny))
        
        return -1
",1441309684
Rakesh_Reddy7,Naruto_x,8,3628,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0:
            return -1
        m = len(moveTime[0])
        if m == 0:
            return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[[float('inf')] * 2 for i in range(m)] for j in range(n)]
        t2[0][0][0] = 0
        pq = [(0, 0, 0, 0)]  

        while pq:
            curt, x, y, z = heapq.heappop(pq)

            if x == n - 1 and y == m - 1:
                return int(curt)

            if curt > t2[x][y][z]:
                continue

            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    m1 = 1 if z == 0 else 2
                    t1 = max(curt, moveTime[nx][ny]) + m1
                    pp = 1 - z

                    if t1 < t2[nx][ny][pp]:
                        t2[nx][ny][pp] = t1
                        heapq.heappush(pq, (t1, nx, ny, pp))

        return -1
",1441310581
Rakesh_Reddy7,Naruto_x,8,3636,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        
        for i in range(len(num)):
            k = int(num[i])
            
            if i % 2 == 0:
                evens += k
            else:
                odds += k
                
        return evens == odds
",1441311289
Rakesh_Reddy7,Naruto_x,8,3637,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

mod = 10**9 + 7

def pow_mod(a, b):
    res = 1
    a %= mod
    while b > 0:
        if b & 1:
            res = res * a % mod
        a = a * a % mod
        b >>= 1
    return res

class Factorials:
    def __init__(self, n):
        self.fact = [1] * (n + 1)
        for i in range(1, n + 1):
            self.fact[i] = self.fact[i - 1] * i % mod
        self.invf = [1] * (n + 1)
        self.invf[n] = pow_mod(self.fact[n], mod - 2)
        for i in range(n - 1, -1, -1):
            self.invf[i] = self.invf[i + 1] * (i + 1) % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        tot = 0
        for ch in num:
            freq[int(ch)] += 1
            tot += int(ch)

        if tot % 2 != 0:
            return 0

        tsum = tot // 2
        k = (n + 1) // 2
        l = n // 2
        factorial = Factorials(n)
        fact = factorial.fact
        invf = factorial.invf

        dp = [[0] * (k + 1) for i in range(tsum + 1)]
        dp[0][0] = 1

        for d in range(10):
            if freq[d] == 0:
                continue
            for s in range(tsum, -1, -1):
                for c in range(k, -1, -1):
                    if dp[s][c] == 0:
                        continue
                    for t in range(1, freq[d] + 1):
                        if s + t * d > tsum or c + t > k:
                            break
                        dp[s + t * d][c + t] = (dp[s + t * d][c + t] + dp[s][c] * ((fact[freq[d]] * invf[t] % mod) * invf[freq[d] - t] % mod)) % mod

        validx = dp[tsum][k]
        if validx == 0:
            return 0

        ifreq = 1
        for d in range(10):
            if freq[d] > 0:
                ifreq = ifreq * invf[freq[d]] % mod

        ans = validx * fact[k] % mod
        ans = ans * fact[l] % mod
        ans = ans * ifreq % mod

        return ans
",1441308446
arignote,arignote,10,3627,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[3]);;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + 1, poll[1] - 1, poll[2] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + 1, poll[1], poll[2] - 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + 1, poll[1], poll[2] + 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + 1, poll[1] + 1, poll[2] });
            }
        }
    }
}",1441307297
arignote,arignote,10,3628,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[] { 0, 0, 0, 1 });;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + poll[3], poll[1] - 1, poll[2], 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + poll[3], poll[1], poll[2] - 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + poll[3], poll[1], poll[2] + 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + poll[3], poll[1] + 1, poll[2], 3 - poll[3] });
            }
        }
    }
}",1441307185
arignote,arignote,10,3636,java,"class Solution {

    public boolean isBalanced(String num) {
        int sum = 0;
        for (int i = 0; i < num.length(); i++) {
            sum += (i % 2 > 0 ? 1 : -1) * (num.charAt(i) - '0');
        }
        return sum == 0;
    }
}",1441307472
arignote,arignote,10,3637,java,"class Solution {

    public int countBalancedPermutations(String num) {
        int count[] = new int[10], sum = 0, f[][] = new int[num.length() + 1][num.length() + 1], dp[][][] = new int[11][num.length() / 2 + 1][361];
        for (char c : num.toCharArray()) {
            count[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 0) {
            for (int i = 0; i <= num.length(); i++) {
                for (int j = f[i][0] = f[i][i] = dp[0][0][0] = 1; j < i; j++) {
                    f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % 1000000007;
                }
            }
            for (int i = 0, s = 0, t = 0; i < 10; s += i * count[i], t += count[i++]) {
                for (int j = 0; j <= t && j <= num.length() / 2; j++) {
                    for (int k = 0; k <= s && k <= sum / 2; k++) {
                        for (int l = 0; dp[i][j][k] > 0 && l <= count[i] && l + j <= num.length() / 2 && l * i + k <= sum / 2; l++) {
                            dp[i + 1][j + l][l * i + k] = (int) ((dp[i + 1][j + l][l * i + k] + (long) dp[i][j][k] * f[num.length() / 2 - j][l] % 1000000007 * f[num.length() - num.length() / 2 - t + j][count[i] - l] % 1000000007) % 1000000007);
                        }
                    }
                }
            }
        }
        return dp[10][num.length() / 2][sum / 2];
    }
}",1441307111
Nguyen Quang Long,mbfibat,11,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 1), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441295120
Nguyen Quang Long,mbfibat,11,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 3 - t), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441294784
Nguyen Quang Long,mbfibat,11,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum_0 = 0, sum_1 = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = (num[i] - '0');
            if (i % 2) sum_1 += d;
            else sum_0 += d;
        }
        return (sum_0 == sum_1);
    }
};",1441280868
Nguyen Quang Long,mbfibat,11,3637,cpp,"const int mod = 1e9 + 7;

int fact[101], re_fact[101];

int qp(int a, int b) {
    if (b == 0) return 1;
    int tmp = qp(a, b / 2);
    if (b % 2 == 0) return 1LL * tmp * tmp % mod;
    return 1LL * a * tmp % mod * tmp % mod;
}

int f[11][81][721];
bool g[11][81][721];

class Solution {
private:
    int tot_cnt = 0;
    int occ[10];
    int tot_sum = 0;
    int sz1 = 0, sz2 = 0;
public:
    int dp(int pos, int cnt1, int sum1) {
        if (pos >= 10) {
            int sum2 = tot_sum - sum1;            
            int cnt2 = tot_cnt - cnt1;
            if (cnt1 == sz1 && cnt2 == sz2 && sum1 == sum2)
                return 1LL * fact[cnt1] * fact[cnt2] % mod;
            return 0;
        }

        if (g[pos][cnt1][sum1])
            return f[pos][cnt1][sum1];

        int ans = 0;
        for (int i = 0; i <= occ[pos]; i++) {
            int val = 1LL * dp(pos + 1, cnt1 + i, sum1 + pos * i) * re_fact[i] % mod * re_fact[occ[pos] - i] % mod;
            ans = (ans + val) % mod;
        }
        g[pos][cnt1][sum1] = true;
        return f[pos][cnt1][sum1] = ans;
    }

    int countBalancedPermutations(string num) {
        fact[0] = 1;
        for (int i = 1; i <= 100; i++)
            fact[i] = 1LL * fact[i - 1] * i % mod;
        re_fact[100] = qp(fact[100], mod - 2);
        for (int i = 100; i >= 1; i--)
            re_fact[i - 1] = 1LL * re_fact[i] * i % mod;

        for (int i = 0; i <= 9; i++) occ[i] = 0;
        
        for (char c : num) {
            occ[c - '0']++;
            tot_sum += (c - '0');
        }
        tot_cnt = num.size();
        sz1 = (tot_cnt + 1) / 2;
        sz2 = tot_cnt /2;
        
        for (int i = 0; i <= 9; i++)
            for (int j = 0; j <= tot_cnt; j++)
                for (int l = 0; l <= tot_sum; l++)
                    g[i][j][l] = false;
        return dp(0, 0, 0);
    }
};",1441314636
BERNARD BRAHIMCHA,BERNARB01,12,3627,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441315189
BERNARD BRAHIMCHA,BERNARB01,12,3628,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p ^ 1;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441314619
BERNARD BRAHIMCHA,BERNARB01,12,3636,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  bool isBalanced(string s) {
    int n = int(s.length());
    int se = 0, so = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        so += int(s[i] - '0');
      } else {
        se += int(s[i] - '0');
      }
    }
    return (se == so);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441307439
BERNARD BRAHIMCHA,BERNARB01,12,3637,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int N = 102;
const int md = int(1e9) + 7;

int iv[N], f1[N], f2[N], p2[N], ip2[N];

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

inline int C(int n, int k) {
  if (k < 0 || n < k) return 0;
  return mul(f1[n], mul(f2[k], f2[n - k]));
}

inline int nck(int n, int k) {
  int r = 1;
  for (int i = 1; i <= k; i++) {
    r = mul(r, mul(n - i + 1, inv(i)));
  }
  return r;
}

void bldmd() {
  iv[1] = 1;
  for (int i = 2; i < N; i++) {
    iv[i] = md - mul(md / i, iv[md % i]);
  }
  f1[0] = f2[0] = p2[0] = ip2[0] = 1;
  for (int i = 1; i < N; i++) {
    f1[i] = mul(f1[i - 1], i);
    f2[i] = mul(f2[i - 1], iv[i]);
    p2[i] = (p2[i - 1] << 1);
    if (p2[i] >= md) p2[i] -= md;
    ip2[i] = mul(ip2[i - 1], iv[2]);
  }
}

int ne, f;
int sum;
int cnt[10];
int dp[10][402][41];

int sol(int i, int j, int k) {
  if (i == 10) {
    if (j != sum || k != ne) {
      return 0;
    }
    return f;
  }
  int& ret = dp[i][j][k];
  if (ret != -1) {
    return ret;
  }
  ret = 0;
  for (int u = 0; u <= cnt[i]; u++) {
    if (j + u * i <= sum && k + u <= ne) {
      add(ret, mul(mul(f2[u], f2[cnt[i] - u]), sol(i + 1, j + u * i, k + u)));
    }
  }
  return ret;
}

class Solution {
 public:
  int countBalancedPermutations(string s) {
    bldmd();
    for (int i = 0; i < 10; i++) {
      cnt[i] = 0;
    }
    int n = int(s.length());
    sum = 0;
    for (char c : s) {
      sum += int(c - '0');
      ++cnt[int(c - '0')];
    }
    if (sum & 1) {
      return 0;
    }
    sum /= 2;
    ne = n / 2;
    int no = n - ne;
    f = mul(f1[ne], f1[no]);
    memset(dp, -1, sizeof dp);
    return sol(0, 0, 0);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441305879
LucasLyu,Lucas595,13,3627,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0) ]
    
        while heap:
            t, x, y = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 1
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny))
    
        return -1
        
        ",1441291623
LucasLyu,Lucas595,13,3628,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0, 1) ]
    
        while heap:
            t, x, y, odd = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 2 - odd
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny, 1 - odd))
    
        return -1
        
        ",1441307713
LucasLyu,Lucas595,13,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        diff = 0
        for i, k in enumerate(num):
            if i & 1:
                diff += int(k)
            else:
                diff -= int(k)
        return not diff
        ",1441282133
LucasLyu,Lucas595,13,3637,python3,"from math import comb
from collections import defaultdict


MOD = int(1e9 + 7)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        counts = [0] * 10
        N = len(num)
        for ch in num:
            counts[int(ch)] += 1

        total_sum = sum(d * counts[d] for d in range(10))
        if total_sum & 1:
            return 0

        target_sum = total_sum // 2
        N_even = (N + 1) // 2
        N_odd = N // 2

        max_N = N + 1
        factorials = [1] * max_N
        inv_factorials = [1] * max_N
        for i in range(1, max_N):
            factorials[i] = factorials[i - 1] * i % MOD

        inv_factorials[-1] = pow(factorials[-1], MOD - 2, MOD)
        for i in range(max_N - 2, -1, -1):
            inv_factorials[i] = inv_factorials[i + 1] * (i + 1) % MOD

        total_counts_fact = 1
        for c in counts:
            total_counts_fact = total_counts_fact * factorials[c] % MOD

        memo = {}

        def dp(d, s, c):
            key = (d, s, c)
            if key in memo:
                return memo[key]
            if s > target_sum or c > N_even:
                return 0
            if d == 10:
                if s == target_sum and c == N_even:
                    return 1
                else:
                    return 0
            res = 0
            for k in range(counts[d] + 1):
                s_new = s + k * d
                c_new = c + k
                if s_new > target_sum or c_new > N_even:
                    break
                ways = comb(counts[d], k)
                res = (res + dp(d + 1, s_new, c_new) * ways) % MOD
            memo[key] = res
            return res

        total_ways = dp(0, 0, 0) * factorials[N_even] % MOD
        total_ways = total_ways * factorials[N_odd] % MOD
        total_ways = total_ways * pow(total_counts_fact, MOD - 2, MOD) % MOD
        return total_ways
        ",1441315468
Ma Lin,Ma_Lin,14,3627,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f;
    int m, n, res, MAX = 2000000000;
    bool done[100][100];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d;
        set<pair<int, pair<int, int>>> S;
        f = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[i][j] = MAX;
                done[i][j] = false;
            }
                
        f[0][0] = 0;
        S.insert({0, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[i][j] || f[i][j] == MAX) continue;
            if (f[i][j] != d) continue;
            done[i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[nx][ny]){
                    v = max(a[nx][ny] + 1, f[i][j] + 1);
                    if (v < f[nx][ny]){
                        f[nx][ny] = v;
                        S.insert({v, {nx, ny}});
                    }
                }
            }
        }

        return f[m - 1][n - 1];
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441293809
Ma Lin,Ma_Lin,14,3628,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f[2];
    int m, n, res, MAX = 2000000000;
    bool done[2][800][800];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d, q;
        set<pair<pair<int, int>, pair<int, int> > > S;
        f[0] = a;
        f[1] = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[0][i][j] = f[1][i][j] = MAX;
                done[0][i][j] = done[1][i][j] = false;
            }
                
        f[0][0][0] = 0;
        S.insert({{0, 0}, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first.first;
            q = S.begin()->first.second;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[q][i][j] || f[q][i][j] == MAX) continue;
            if (f[q][i][j] != d) continue;
            done[q][i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[1 - q][nx][ny]){
                    v = max(a[nx][ny] + (q + 1), f[q][i][j] + (q + 1));
                    if (v < f[1 - q][nx][ny]){
                        f[1 - q][nx][ny] = v;
                        S.insert({{v, 1 - q}, {nx, ny}});
                    }
                }
            }
        }

        return min(f[0][m - 1][n - 1], f[1][m - 1][n - 1]);
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441299307
Ma Lin,Ma_Lin,14,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int x = 0, i;
        for (i = 0; i < s.size(); ++i)
            if (i % 2 == 0) x += s[i] - '0';
            else x -= s[i] - '0';
        
        return x == 0;
    }
};",1441280955
Ma Lin,Ma_Lin,14,3637,cpp,"class Solution {
public:
    int f[2][90][1600];
    int countBalancedPermutations(string s) {
        int mo = 1000000007;
        int C[100][100], n = s.size(), i, j, k, mid, yj, p[2], ge[10], old, now = 0, d, t, nk;
        C[0][0] = 1;
        for (i = 1; i <= n; ++i){
            C[i][0] = C[i][i] = 1;
            for (j = 1; j < i; ++j)
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mo;
        }
        
        p[0] = p[1] = 0;
        for (i = 0; i < 10; ++i) ge[i] = 0;
        for (i = 0; i < n; ++i){
            ++p[i % 2];
            ++ge[s[i] - '0'];
        }
        
        mid = n * 9;
        for (j = 0; j <= p[0]; ++j)
            for (k = 0; k <= mid + mid; ++k)
                f[now][j][k] = 0;
        f[now][0][mid] = 1;
        yj = 0;
        for (i = 0; i < 10; ++i){
            old = now;
            now = 1 - now;
            for (j = 0; j <= p[0]; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    f[now][j][k] = 0;
            for (j = 0; j <= p[0] && j <= yj; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    if (f[old][j][k] > 0){
                        for (d = 0; d <= ge[i]; ++d)
                            if (j + d <= p[0] && yj - j + (ge[i] - d) <= p[1]){
                                t = (1LL * C[p[0] - j][d] * C[p[1] - (yj - j)][ge[i] - d]) % mo;
                                t = (1LL * t * f[old][j][k]) % mo;
                                nk = k + d * i - (ge[i] - d) * i;
                                f[now][j + d][nk] = (f[now][j + d][nk] + t) % mo;
                            }
                    }
            yj += ge[i];
        }
        
        return f[now][p[0]][mid];
    }
};",1441316423
plevande,plevande,15,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time = [[float('inf') for j in range(m)] for i in range(n)]
        true_time[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0])
        while len(H) > 0:
            t, x, y = heapq.heappop(H)
            if true_time[x][y]==t:
                for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                    if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                        t2 = max(t+1, moveTime[x2][y2]+1)
                        if t2 < true_time[x2][y2]:
                            true_time[x2][y2] = t2 
                            heapq.heappush(H, [t2, x2, y2])
        return true_time[n-1][m-1]",1441290714
plevande,plevande,15,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time1 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0, 2])
        while len(H) > 0:
            t, x, y, my_case = heapq.heappop(H)
            if my_case==1:
                if true_time1[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+2, moveTime[x2][y2]+2)
                            if t2 < true_time2[x2][y2]:
                                true_time2[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 2])
            else:
                if true_time2[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+1, moveTime[x2][y2]+1)
                            if t2 < true_time1[x2][y2]:
                                true_time1[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 1])
        return min(true_time1[n-1][m-1], true_time2[n-1][m-1])",1441296393
plevande,plevande,15,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a1 = 0 
        a2 = 0 
        n = len(num)
        for i in range(n):
            if i % 2==0:
                a1+=int(num[i])
            else:
                a2+=int(num[i])
        return a1==a2",1441281094
plevande,plevande,15,3637,python3,"p = 10**9+7
binom = [[1], [1, 1]]
for i in range(81):
    row = binom[-1]
    new_row = [1]
    for j in range(len(row)-1):
        new_row.append((row[j]+row[j+1]) % p)
    new_row.append(1)
    binom.append(new_row)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int, num))
        if s % 2==1:
            return 0
        my_count = [0 for i in range(10)]
        for x in num:
            my_count[int(x)]+=1
        target = s//2
        poss = {(0, n//2, n-n//2): 1}
        for i in range(10):
            new_poss = {}
            c = my_count[i]
            for a, b, b2 in poss:
                for x in range(c+1):
                    if b2-(c-x) >=0 and b-x >= 0 and a+x*i <= target:
                        new_a = a+x*i
                        new_b = b-x
                        new_b2 = b2-(c-x)
                        new_ways = (poss[(a, b, b2)]*binom[b][x]*binom[b2][c-x]) % p
                        if (new_a, new_b, new_b2) not in new_poss:
                            new_poss[(new_a, new_b, new_b2)] = 0
                        new_poss[(new_a, new_b, new_b2)]+=new_ways 
                        new_poss[(new_a, new_b, new_b2)]%=p 
            poss = new_poss
        if (target, 0, 0) not in poss:
            return 0
        return poss[(target, 0, 0)]
        """"""
        how many ways are there
        to get target in n
        """"""",1441310112
BarryBondsOfLC,BarryBondsOfLC,19,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310608
BarryBondsOfLC,BarryBondsOfLC,19,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt == 1 ? 2 : 1});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310295
BarryBondsOfLC,BarryBondsOfLC,19,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for (int i = 0; i < num.size(); ++i) {
            (i % 2 ? o : e) += num[i] - '0';
        }
        return e == o;
    }
};",1441305906
BarryBondsOfLC,BarryBondsOfLC,19,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int MOD = 1e9 + 7;

ll mul(ll a, ll b) { return a * b % MOD; }

ll power(ll base, ll exp = MOD - 2) {
    ll res = 1, y = base;
    while (exp) {
        if (exp & 1)
            res = mul(res, y);
        y = mul(y, y);
        exp >>= 1;
    }
    return res;
}

struct Math {
    vector<ll> fact, inv;

    Math(int n = 1) {
        fact.resize(n + 1);
        inv.resize(n + 1);
        fact[0] = inv[0] = 1;
        for (int i = 1; i <= n; i++)
            fact[i] = mul(fact[i - 1], i);
        inv[n] = power(fact[n]);
        for (int i = n; i > 1; i--)
            inv[i - 1] = mul(inv[i], i);
    }

    ll comb(int n, int k) {
        if (n < k)
            return 0;
        return mul(mul(fact[n], inv[k]), inv[n - k]);
    }

    ll perm(int n, int k) {
        if (n < k)
            return 0;
        return mul(fact[n], inv[n - k]);
    }

    ll multi(vector<int> v) {
        ll res = fact[accumulate(v.begin(), v.end(), 0)];
        for (int i : v)
            res = mul(res, inv[i]);
        return res;
    }

} math(100005);

class Solution {
public:
    int countBalancedPermutations(string S) {
        int n = S.size();
        vector<int> fm(10);
        int total = 0;
        for (auto c : S) {
            ++fm[c - '0'];
            total += c - '0';
        }
        if (total % 2)
            return 0;
        int T = total / 2;
        int E = (n + 1) / 2, O = n - E;
        vector p_dp(T + 1, vector(E + 1, 0LL));
        p_dp[0][0] = 1;
        for (int d = 0; d < 10; ++d) {
            vector c_dp(T + 1, vector(E + 1, 0LL));
            for (int s = 0; s <= T; ++s) {
                for (int c = 0; c <= E; ++c) {
                    if (p_dp[s][c] == 0)
                        continue;
                    for (int k = 0; k <= fm[d] && k <= E - c && s + k * d <= T;  ++k) {
                        c_dp[s + k * d][c + k] += p_dp[s][c] * math.inv[k] % MOD * math.inv[fm[d] - k] % MOD % MOD;
                        c_dp[s + k * d][c + k] %= MOD;
                    }
                }
            }
            p_dp = move(c_dp);
        }
        return p_dp[T][E] * math.fact[E] % MOD * math.fact[O] % MOD;
    }
};",1441305590
dirigibility,dirigibility,20,3627,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,0,0)]
        visited = set()
        while True:
            t,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (i0,j0) in visited:
                continue
            visited.add((i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+1,i,j))",1441294813
dirigibility,dirigibility,20,3628,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,1,0,0)]
        visited = set()
        while True:
            t,dt,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (dt,i0,j0) in visited:
                continue
            visited.add((dt,i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (3-dt,i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+dt,3-dt,i,j))",1441296704
dirigibility,dirigibility,20,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])",1441281104
dirigibility,dirigibility,20,3637,python3,"mod = 10**9+7
@cache
def fac(n):
    return (n*fac(n-1))%mod if n else 1
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if (s := sum(map(int,num)))%2:
            return 0
        c = Counter(map(int,num))
        @cache
        def f(d,need,need_sum):
            if need < 0 or need_sum < 0:
                return 0
            if d == 10:
                return int(need == need_sum == 0)
            return sum(pow(fac(take)*fac(c[d]-take),-1,mod)*f(d+1,need-take,need_sum-d*take) for take in range(0,c[d]+1))%mod
        try:
            l = len(num)
            return (f(0,l//2,s//2)*fac(l//2)*fac(l-l//2))%mod
        finally:
            f.cache_clear()",1441317496
physics0523,physics0523,21,3627,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int clk=max(od.first,moveTime[nx][ny])+1;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441292885
physics0523,physics0523,21,3628,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int dlt;
                if((x+y)%2==0){dlt=1;}
                else{dlt=2;}
                int clk=max(od.first,moveTime[nx][ny])+dlt;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441295080
physics0523,physics0523,21,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int h=0;
        for(int i=0;i<num.size();i++){
            if(i%2){h+=(num[i]-'0');}
            else{h-=(num[i]-'0');}
        }
        return (h==0);
    }
};",1441281668
physics0523,physics0523,21,3637,cpp,"#define mod 1000000007

int md(int x){
    if(x>=mod){return x-mod;}
    return x;
}

int mul(long long x,long long y){
    return (x*y)%mod;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<vector<int>> nCr(105,vector<int>(105,0));
        nCr[0][0]=1;
        for(int i=1;i<105;i++){
            for(int j=0;j<=i;j++){
                if(j>0){nCr[i][j]+=nCr[i-1][j-1];}
                nCr[i][j]=md(nCr[i][j]);
                if(j<i){nCr[i][j]+=nCr[i-1][j];}
                nCr[i][j]=md(nCr[i][j]);
            }
        }
        // for(int i=0;i<5;i++){
        //     for(int j=0;j<5;j++){cout << nCr[i][j] << "" "";}
        //     cout << ""\n"";
        // }
        
        vector<int> bk(10,0);
        for(auto &nx : num){
            bk[nx-'0']++;
        }
        int rem=num.size();
        int ofs=400;
        int n=num.size();
        int x=(n+1)/2;
        int y=n/2;
        vector<vector<vector<int>>> dp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
        dp[x][y][ofs]=1;
        for(int tr=0;tr<10;tr++){
            vector<vector<vector<int>>> ndp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
            for(int cx=0;cx<=x;cx++){
                int cy=rem-cx;
                if(!(0<=cy && cy<=y)){continue;}
                for(int i=0;i<800;i++){
                    if(dp[cx][cy][i]==0){continue;}
                    for(int sx=0;sx<=bk[tr];sx++){
                        int sy=bk[tr]-sx;
                        int nx=cx-sx;
                        int ny=cy-sy;
                        if(!(0<=nx && nx<=x)){continue;}
                        if(!(0<=ny && ny<=y)){continue;}
                        int dlt=tr*(sx-sy);
                        int mv=dp[cx][cy][i];
                        // cout << x << "" "" << y << "" "" << i << "" -> "" << nx << "" "" << ny << "" "" << i+dlt << ""\n"";
                        // cout << mv << "" "" << nCr[cx][sx] << "" "" << nCr[cy][sy] << ""\n"";
                        mv=mul(mv,nCr[cx][sx]);
                        mv=mul(mv,nCr[cy][sy]);
                        ndp[nx][ny][i+dlt]=md(ndp[nx][ny][i+dlt]+mv);
                    }
                }
            }
            rem-=bk[tr];
            dp=ndp;
        }
        
        return dp[0][0][ofs]%mod;
    }
};",1441310947
ssk4988,ssk4988,22,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, i, j = heappop(heap)
            # print(i, j, t)
            if i == n-1 and j == m-1: return t
            if (i, j) in seen: continue
            seen.add((i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, (1 + max(moveTime[i1][j1], t), i1, j1))",1441295578
ssk4988,ssk4988,22,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, p, i, j = heappop(heap)
            # print(i, j, p, t)
            if i == n-1 and j == m-1: return t
            if (p, i, j) in seen: continue
            seen.add((p, i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, ((2 if p == 1 else 1) + max(moveTime[i1][j1], t), 1-p, i1, j1))",1441298603
ssk4988,ssk4988,22,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(v) for i,v in enumerate(num) if i % 2 == 0]) == sum([int(v) for i,v in enumerate(num) if i % 2 == 1])",1441281276
ssk4988,ssk4988,22,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        freq = [0] * 10
        for d in num:
            freq[int(d)] += 1
        mod = 1000000007
        @cache
        def combmod(n, k):
            return comb(n, k) % mod
        @cache
        def dp(dig, lefteven, leftodd, evmodd):
            if dig == 10:
                return 1 if evmodd == 0 and lefteven == 0 and leftodd == 0 else 0
            ans = 0
            for toeven in range(0, 1 + min(lefteven, freq[dig])):
                toodd = freq[dig] - toeven
                if toodd > leftodd: continue
                res = dp(dig+1, lefteven - toeven, leftodd - toodd, evmodd + (toeven - toodd) * dig)
                ways = (combmod(lefteven, toeven) * combmod(leftodd, toodd)) % mod
                ans = (ans + res * ways) % mod
            return ans
        n = len(num)
        return dp(0, n // 2, n - n // 2, 0)",1441311262
Balakrishnan Varadarajan,balakrishnan_v,23,3627,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> min_times(n,vector<int>(m,-1));
        vector<vector<bool>> done(n,vector<bool>(m,false));
        set<vector<int>> Q;
        Q.insert({0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j]) continue;
            done[i][j]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj]!=-1 && min_times[ni][nj]<=nt) continue;
                if (min_times[ni][nj]!=-1) {
                    Q.erase({min_times[ni][nj],ni,nj});
                }
                min_times[ni][nj]=nt;
                Q.insert({nt,ni,nj});
            }
        }
        return ans;
    }
};",1441317168
Balakrishnan Varadarajan,balakrishnan_v,23,3628,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<vector<int>>> min_times(n,vector<vector<int>>(m,vector<int>(2,-1)));
        vector<vector<vector<bool>>> done(n,vector<vector<bool>>(m,vector<bool>(2,false)));
        set<vector<int>> Q;
        Q.insert({0,0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            int p = it->at(3);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j][p]) continue;
            done[i][j][p]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+p+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj][1-p]!=-1 && min_times[ni][nj][1-p]<=nt) continue;
                if (min_times[ni][nj][1-p]!=-1) {
                    Q.erase({min_times[ni][nj][1-p],ni,nj,1-p});
                }
                min_times[ni][nj][1-p]=nt;
                Q.insert({nt,ni,nj,1-p});
            }
        }
        return ans;
    }
};",1441314130
Balakrishnan Varadarajan,balakrishnan_v,23,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0=0;
        int s1=0;
        int n=num.size();
        for(int i=0;i<n;i++) {
            int d=num[i]-'0';
            if (i%2==0) s0+=d;
            else s1+=d;
        }
        return s0==s1;
    }
};",1441318653
Balakrishnan Varadarajan,balakrishnan_v,23,3637,cpp,"#define MODD 1000000007
#define NUM_DIGS 10
#define MAXN 80
#define ll long long
class Solution {
public:
    
    ll fact[MAXN+2];
    ll factinv[MAXN+2];
    
    int dp[NUM_DIGS+1][MAXN+2][MAXN*9];
    
    int Solve(const vector<int>& counts, int d, int num_even_left, int sum_even_left) {
        if (d==NUM_DIGS) {
            return num_even_left==0 && sum_even_left==0;
        }
        
        if (dp[d][num_even_left][sum_even_left]!=-1) return dp[d][num_even_left][sum_even_left];
        
        ll ans = 0;
        for(int x=0;x<=min(num_even_left,counts[d]);x++) {
            if (sum_even_left-x*d<0) break;
            ans += Solve(counts, d+1, num_even_left-x,sum_even_left-x*d) * factinv[x]%MODD*factinv[counts[d]-x]%MODD;
            ans %= MODD;
        }
        return dp[d][num_even_left][sum_even_left]=ans;
    }
    
    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }

    

    int countBalancedPermutations(string num) {
        
        
        int n=num.size();
        fact[0]=factinv[0]=1;
        for(int i=1;i<=n;i++) {
            fact[i]=fact[i-1]*i%MODD;
            factinv[i]=modpow(fact[i],MODD-2);
        }
        vector<int> counts(10,0);
        int s=0;
        for(char c : num) {
            counts[c-'0']++;
            s += c-'0';
        }
        if (s&1) return 0;
        
        int num_odd_pos=0;
        int num_even_pos=0;
        for(int i=0;i<n;i++) {
            if (i%2) num_odd_pos++;
            else num_even_pos++;
        }
        
        for(int d=0;d<=NUM_DIGS;d++) {
            for(int num_even_left=0;num_even_left<=num_even_pos;num_even_left++) {
                for(int sum_even_left=0;sum_even_left<=s/2;sum_even_left++) {
                    dp[d][num_even_left][sum_even_left]=-1;
                }
            }
        }
        
        ll ans = Solve(counts, 0, num_even_pos, s/2);
        ans = ans*fact[num_odd_pos]%MODD*fact[num_even_pos]%MODD;
        
        // split each digit
        
        return ans;
        
    }
};",1441298327
leetgoat_dot_dev,leetgoat_dot_dev,26,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c to min time
        heap = [(0, 0, 0)] # time, r, c
        while heap:
            time, r, c = heapq.heappop(heap)
            if minDists[(r, c)] <= time:
                continue
            minDists[(r, c)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newTime = max(time + 1, moveTime[newR][newC] + 1)
                if newTime >= minDists[(newR, newC)]:
                    continue
                heapq.heappush(heap, (newTime, newR, newC))
        return minDists[(len(moveTime) - 1, len(moveTime[0]) - 1)]
            ",1441293052
leetgoat_dot_dev,leetgoat_dot_dev,26,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c, parity to min time
        heap = [(0, 0, 0, 0)] # time, r, c, parity
        while heap:
            time, r, c, parity = heapq.heappop(heap)
            if minDists[(r, c, parity)] <= time:
                continue
            minDists[(r, c, parity)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newDelta = 1 if parity == 0 else 2
                newTime = max(time + newDelta, moveTime[newR][newC] + newDelta)
                # if newTime >= minDists[(newR, newC)]:
                #     continue
                heapq.heappush(heap, (newTime, newR, newC, parity^1))
        return min(
            minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 0)],
             minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 1)],
        )
            ",1441295559
leetgoat_dot_dev,leetgoat_dot_dev,26,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i in range(len(num)):
            if i % 2 == 0:
                evens += int(num[i])
            else:
                odds += int(num[i])
        return evens == odds",1441280912
leetgoat_dot_dev,leetgoat_dot_dev,26,3637,python3,"# template by: https://github.com/agrawalishaan/leetcode

# n in the constructor is basically the biggest number we will operate on. So for instance finding n! % MOD. But also things like interleaving two sequences of length 500 and length 700 would require n=1200. To be safe, can always just put a big number like 1e5.
class ModCalc:
    def __init__(self, n, primeMod):
        self.n = n
        self.mod = primeMod # If this is not prime, anything using modInv may break (fermat's little theorem)
        # O(n) time to build a factorial mod array
        self.factorialsWithMod = self._buildFactorialsWithMod()
        # O(n) time to build an inverse factorial mod array
        self.inverseFactorialsWithMod = self._buildInverseFactorialsWithMod()

    # ********** STUFF WITH FACTORIALS **********

    # O(n) time to build a factorial mod array
    def _buildFactorialsWithMod(self):
        factorialsWithMod = [1] # 0 factorial is 1
        for factorial in range(1, self.n + 1):
            factorialsWithMod.append(factorialsWithMod[-1] * factorial % self.mod)
        return factorialsWithMod

    # O(n) time to build an inverse factorial mod array
    def _buildInverseFactorialsWithMod(self):
        inverseFactorialsWithMod = [1] * (self.n + 1)
        inverseFactorialsWithMod[self.n] = self.modInv(self.factorialsWithMod[self.n])
        for i in range(self.n - 1, 0, -1):
            inverseFactorialsWithMod[i] = inverseFactorialsWithMod[i + 1] * (i + 1) % self.mod
        return inverseFactorialsWithMod

    # Gets (x! % MOD)
    # O(1) time
    def getFactorialWithMod(self, factorial):
        return self.factorialsWithMod[factorial]

    # Gets (1/x! % MOD)
    # O(1) time
    def getInverseFactorialWithMod(self, inverseFactorial):
        return self.inverseFactorialsWithMod[inverseFactorial]

    # Given two sequences of length X and Y, such as ""123"" and ""4567"", find the # of ways to interleave them.  Note we don't care about the actual items in each sequence, we just care about the # of ways we can interleave the two. We don't even get the actual sequences themselves, just their lengths.
    # O(1) time
    def interleaveTwoSequencesWithMod(self, length1, length2):
        # Interleaving a sequence of length 3 and 4 would be like 7!/(3!4!), which is 7! * (1/3!) * (1/4!)
        combinedLength = length1 + length2
        if combinedLength >= len(self.factorialsWithMod):
            raise ValueError(f""To interleave {length1} and {length2} items, we need at least {combinedLength + 1} items in the factorial array."")
        numerator = self.getFactorialWithMod(combinedLength)
        denominator1 = self.getInverseFactorialWithMod(length1)
        denominator2 = self.getInverseFactorialWithMod(length2)
        return self.modMultiply(numerator, denominator1, denominator2)


    # Calculates the # of ways to select k items from n unique items. Order does not matter.
    # Formula for C(n, k) = n! / (k!(n-k)!)
    # Denominator is 1/k! * 1/(n-k)!
    # O(1) time
    def nChooseKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator1 = self.getInverseFactorialWithMod(k)
        denominator2 = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator1, denominator2)

    # Calculates the # of ways to select k items from n unique items. Order matters.
    # Formula for P(n, k) = n! / (n-k)!
    # Denominator is 1/(n-k)!
    # O(1) time
    def nPermuteKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator)

    # Calculate the # of ways to distribute n identical items into k distinct buckets (relates to stars and bars)
    # Formula for allowing empty buckets is C(n+k-1, k-1), which is: (n+k-1)! * 1/(n-1)! * 1/k!
    # Formula for NOT allowing empty buckets is C(n-1, k-1), which is: (n-1)! * 1/(n-k)! * 1/k!
    # O(1) time
    def waysToPutIdenticalItemsIntoDistinctBucketsWithMod(self, items, buckets, allowEmptyBuckets=True):
        if allowEmptyBuckets:
            return self.nChooseKWithMod(items + buckets - 1, buckets - 1)
        return self.nChooseKWithMod(items - 1, buckets - 1)

    # Putting n distinct items into k distinct buckets is just k options for the first item, k for the second, etc, so k^n. This is if we allow empty buckets. If we don't allow empty buckets, we need Stirling numbers of the second kind.
    # O(log items) time due to modPow, but modPow can be cached
    def waysToPutDistinctItemsIntoDistinctBucketsAllowingEmptyWithMod(self, items, buckets):
        return self.modPow(buckets, items)

    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        # need to figure out how to do this in O(1) if it is possible lol
        pass

    # ********** NO FACTORIALS NEEDED **********

    # Multiples k numbers together
    # O(k) time
    def modMultiply(self, *args):
        result = 1
        for num in args:
            result = (result * num) % self.mod
        return result

    # Calculates base^exponent % MOD
    # Can add caching if we are using the same base a lot. But if we are using one instance of the ModCalc class across all test cases, maybe that would MLE? I think no cache by default is better, since it is very fast already.
    # O(log exponent) time (even without caching)
    # @cache # uncomment to cache
    def modPow(self, base, exponent):
        return pow(base, exponent, self.mod)

    # Gets 1/x % MOD
    # Could cache this, if we are calling the same range of numbers a lot. If this class is created once across all test cases, could maybe MLE? Also num needs to be coprime to MOD.
    # O(log MOD) time
    # @cache # uncomment to cache
    def modInv(self, num):
        return self.modPow(num, self.mod - 2)


class MoreAdvancedStirlingStuff:
    def __init__(self, maxPossibleDistinctItemCount, maxPossibleBucketCount, mod):
        self.maxPossibleDistinctItemCount = maxPossibleDistinctItemCount
        self.maxPossibleBucketCount = maxPossibleBucketCount
        self.mod = mod

        # # Build a basic modCalc so we can get factorial mods
        self.modCalc = ModCalc(maxPossibleBucketCount, mod)

        # O(maxPossibleDistinctItemCount * maxPossibleBucketCount) build time
        self.stirling2Dp = self._buildStirling2Dp()

    def _buildStirling2Dp(self):
        dp = [[0] * (self.maxPossibleBucketCount + 1) for _ in range(self.maxPossibleDistinctItemCount + 1)]
        dp[0][0] = 1
        for i in range(1, self.maxPossibleDistinctItemCount + 1):
            for j in range(1, self.maxPossibleBucketCount + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % self.mod
        return dp

    # Calculate the # of ways to distribute n distinct items into k identical non-empty buckets. For instance with items 'A' and 'B' and 2 buckets, there's only one way, since the buckets are identical.
    # This is stirling2 numbers.
    # O(1) time
    def waysToPutDistinctItemsIntoIdenticalNonemptyBucketsWithMod(self, items, buckets):
        return self.stirling2Dp[items][buckets]

    # Calculate the # of ways to distribute n distinct items into k distinct non-empty buckets.
    # O(1) time
    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        waysAssumingIdenticalBuckets = self.stirling2Dp[items][buckets]
        bucketOrderings = self.modCalc.getFactorialWithMod(buckets)
        return self.modCalc.modMultiply(waysAssumingIdenticalBuckets, bucketOrderings)

    
calc = ModCalc(10000, 10**9 + 7)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        c = Counter(int(l) for l in num)
        
        evens = len(num) // 2
        odds = len(num) - evens
        
        M = 10**9 + 7
        
        @cache
        def dp(digit, evenSurplus, evensUsed, oddsUsed):
            if digit == 10:
                return 1 if not evenSurplus else 0
            
            resHere = 0
            for distributeToOdds in range(c[digit] + 1):
                newOdds = oddsUsed + distributeToOdds
                if newOdds > odds:
                    break
                distributeToEvens = c[digit] - distributeToOdds
                newEvens = evensUsed + distributeToEvens
                if newEvens > evens:
                    continue
                oddGain = distributeToOdds * digit
                evenGain = distributeToEvens * digit
                evenNet = evenGain - oddGain
                
                oddSpotsLeft = odds - oddsUsed
                evenSpotsLeft = evens - evensUsed
                
                waysToDistributeOdds = calc.nChooseKWithMod(oddSpotsLeft, distributeToOdds)
                waysToDistEvens = calc.nChooseKWithMod(evenSpotsLeft, distributeToEvens)
                resHere += calc.modMultiply(dp(digit + 1, evenSurplus + evenNet, newEvens, newOdds), waysToDistributeOdds, waysToDistEvens)
            return resHere % M
        
        a = dp(0,0,0,0)
        dp.cache_clear()
        return a
            
            
            ",1441306558
Chinnu,chinnu11,27,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&t){
        int n=t.size(),m=t[0].size();
        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};
        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));
        dist[0][0]=0;
        
        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<>>q;
        q.emplace(0,0,0);
        
        while(!q.empty()){
            auto[ct,i,j]=q.top();q.pop();
            if(i==n-1&&j==m-1)return ct;
            if(ct>dist[i][j])continue;
            
            for(auto[di,dj]:d){
                int ni=i+di,nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m){
                    int ns=max(ct,t[ni][nj]);
                    int at=ns+1;
                    if(at<dist[ni][nj]){
                        dist[ni][nj]=at;
                        q.emplace(at,ni,nj);
                    }
                }
            }
        }
        return -1;
    }
};",1441287083
Chinnu,chinnu11,27,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n=t.size(), m=t[0].size();
        vector<pair<int,int>> d={{-1,0},{1,0},{0,-1},{0,1}};
        const int inf=INT_MAX;
        vector<int> dist(n*m*2,inf);
        dist[0]=0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;
        q.emplace(0,0);
        
        while(!q.empty()) {
            auto [c,s]=q.top(); q.pop();
            int p=s%2, pos=s/2, i=pos/m, j=pos%m;
            if(i==n-1&&j==m-1) return c;
            if(c>dist[s]) continue;
            
            for(auto &[di,dj]:d) {
                int ni=i+di, nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m) {
                    int st=max(c,t[ni][nj]), dur=p==0?1:2, nt=st+dur, np=1-p;
                    int ns=(ni*m+nj)*2+np;
                    if(nt<dist[ns]) {
                        dist[ns]=nt;
                        q.emplace(nt,ns);
                    }
                }
            }
        }
        return -1;
    }
};",1441290452
Chinnu,chinnu11,27,3636,cpp,"class Solution{
public:
    bool isBalanced(string n){
        int e=0,o=0;
        for(int i=0;i<n.size();++i){
            int d=n[i]-'0';
            if(i%2==0)e+=d;
            else o+=d;
        }
        return e==o;
    }
};
",1441281159
Chinnu,chinnu11,27,3637,cpp,"typedef long long ll;
const int M=1'000'000'007;

ll pmod(ll x,ll y,ll m){
    ll r=1;
    x%=m;
    while(y>0){
        if(y&1)r=r*x%m;
        x=x*x%m;
        y>>=1;
    }
    return r;
}

ll inv(ll x,ll m){
    return pmod(x,m-2,m);
}

int cBalPerms(string num){
    int n=num.size();
    vector<ll>f(n+1,1),invf(n+1,1);
    for(int i=1;i<=n;i++)f[i]=f[i-1]*i%M;
    invf[n]=inv(f[n],M);
    for(int i=n-1;i>=0;i--)invf[i]=invf[i+1]*(i+1)%M;

    int fr[10]={0};
    ll ts=0;
    for(char c:num)fr[c-'0']++,ts+=(c-'0');
    if(ts%2!=0)return 0;
    ll tgt=ts/2;
    int k=(n+1)/2,m=n-k;

    vector<vector<ll>>dp(tgt+1,vector<ll>(k+1,0));
    dp[0][0]=1;

    for(int d=0;d<=9;d++){
        if(fr[d]==0)continue;
        vector<vector<ll>>d2(tgt+1,vector<ll>(k+1,0));
        for(int s=0;s<=tgt;s++){
            for(int c=0;c<=k;c++){
                if(dp[s][c]==0)continue;
                for(int a=0;a<=fr[d]&&a+c<=k;a++){
                    if(s+d*a>tgt)break;
                    ll comb=f[fr[d]]*invf[a]%M*invf[fr[d]-a]%M;
                    d2[s+d*a][c+a]=(d2[s+d*a][c+a]+dp[s][c]*comb)%M;
                }
            }
        }
        dp=d2;
    }

    ll assign=dp[tgt][k];
    if(assign==0)return 0;

    ll prod_f=1;
    for(int d=0;d<=9;d++)prod_f=prod_f*f[fr[d]]%M;

    ll fk=f[k],fm=f[m],invp=inv(prod_f,M);
    ll tot=assign*fk%M*fm%M*invp%M;

    return (int)tot;
}

class Solution{
public:
    int countBalancedPermutations(string num){
        return cBalPerms(num);
    }
};
",1441313189
Larry,LarryNY,28,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + 1:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + 1
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441290449
Larry,LarryNY,28,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                p = 2 - ((nx + ny) % 2)
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + p:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + p
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441293459
Larry,LarryNY,28,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        N = len(num)
        
        a = [0] * 2
        for i in range(N):
            a[i % 2] += int(num[i])
            
        return a[0] == a[1]",1441280862
Larry,LarryNY,28,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        arr = [int(x) for x in num]
        N = len(arr)
        f = [0] * 10
        for x in arr:
            f[x] += 1

        fact = [1]
        ifact = [pow(1, -1, MOD)]
        for i in range(1, N + 1):
            fact.append((fact[-1] * i) % MOD)
            ifact.append(pow(fact[-1], -1, MOD))

        numer = 1
        if N % 2 == 0:
            numer = (fact[(N // 2)] * fact[(N // 2)]) % MOD
        else:
            numer = (fact[((N + 1) // 2)] * fact[(N // 2)]) % MOD
            
        @cache
        def go(index, delta_count, delta_sum):
            if index == len(f):
                if delta_sum != 0:
                    return 0

                if N % 2 == 0:
                    if delta_count != 0:
                        return 0
                    return 1
                else:
                    if delta_count == 1:
                        return 1
                    return 0
        
            total = 0
            for i in range(f[index] + 1):
                left = i
                right = f[index] - i
                total += go(index + 1, delta_count + (left - right), delta_sum + (left - right) * index) * ifact[left] * ifact[right]
                total %= MOD
            return total % MOD
        
        return (go(0, 0, 0) * numer) % MOD",1441320693
Nguyễn Thảo,nguyenquocthao00,30,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + 1, i2,j2))
            
        ",1441292016
Nguyễn Thảo,nguyenquocthao00,30,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            added = 1 if (i+j)%2==0 else 2
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + added, i2,j2))
            
        
        ",1441294941
Nguyễn Thảo,nguyenquocthao00,30,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x,y = 0,0
        for i,ch in enumerate(num):
            if i%2==0: x+=int(ch)
            else: y+=int(ch)
        return x==y
        ",1441281098
Nguyễn Thảo,nguyenquocthao00,30,3637,python3,"MOD = 10**9 + 7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        count=[0]*10
        for ch in num: count[int(ch)]+=1
        s= sum(i*v for i,v in enumerate(count))
        if s%2==1: return 0
        # target=s//2
        @lru_cache(None)
        def dp(v,n,t):
            if v<0: return 0 if (n!=0 or t!=0) else 1
            if count[v]==0: return dp(v-1,n,t)
            n2,s2 = len(num)-n, s-t
            for v2 in range(9, v,-1):
                n2-=count[v2]
                s2-=count[v2]*v2
            if n<0 or t<0 or n2<0 or s2<0: return 0
            res=0
            for i in range(count[v]+1):
                res += math.comb(n, i) * math.comb(n2, count[v]-i) * dp(v-1, n-i, t-i*v)
            return res%MOD
        return dp(9, len(num)//2, s//2)
            
        ",1441321719
hxu10,hxu10,31,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                newt = max(t, moveTime[newi][newj]) + 1
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]
            
        
        
        ",1441293045
hxu10,hxu10,31,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                    
                
                newt = max(t, moveTime[newi][newj]) + 2 - (i+j+1) % 2 
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]",1441298013
hxu10,hxu10,31,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s1 = num[::2]
        s2 = num[1::2]
        
        tot1 = 0
        for c in s1:
            tot1 += int(c)
            
        tot2 = 0
        for c in s2:
            tot2 += int(c)
            
        return tot1==tot2
    ",1441281054
hxu10,hxu10,31,3637,python,"

M = 10**9 + 7

def fastfrac(a,b):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M


factor = [1]
invfactor = [1]

for _ in range(100):
    factor.append(factor[-1]*len(factor)%M)
    invfactor.append(fastfrac(1,factor[-1])%M)
    

                     
    
    
    
    
    
    

class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        
        
        fre = [0]*10
        
        s = 0
        
        for c in num:
            fre[int(c)] += 1
            s += int(c) 
            
            
        if s%2==1:
            return 0
        
        

        
        
        
            
            
            
        target = len(num) // 2
        
        tsum = s // 2
        
        
    
        
        
        dic = {}
        
        def getnext(index,totc,totnum):
            
            
            if index==10:
                if totc==target and totnum==tsum:
                    return 1
                return 0
            
            if totc > target or totnum > tsum:
                return 0
            
            
            #print(index,totc,totnum)
            
            if (index,totc,totnum) in dic:  
                return dic[(index,totc,totnum)]
            
            
            res = 0
            for d in range(fre[index]+1):
                xi = invfactor[d] * invfactor[fre[index]-d] 
                res += getnext(index+1, totc+d, totnum+d*index) * xi % M
                res %= M
                
            dic[(index,totc,totnum)] = res
            return res
        
        ans = getnext(0,0,0) * factor[target] * factor[len(num)-target] % M
        
        
        

        
        return ans 
                
            
             
            
            
        
                
            
            
            ",1441322214
kzyKT,kzyKT,32,3627,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<ll,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m];
    rep(i,n)rep(j,m) d[i][j]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(0,P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F;
      if(d[x][y]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+1;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1);
          if(d[xx][yy]>cc) {
            d[xx][yy]=cc;
            que.push(PP(cc,P(xx,yy)));
          }
        }
      }
    }
    return d[n-1][m-1];
  }
};
",1441291418
kzyKT,kzyKT,32,3628,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<P,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m][2];
    rep(i,n)rep(j,m)rep(k,2) d[i][j][k]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(P(0,0),P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F.F,k=p.F.S;
      if(d[x][y][k]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+k+1,kk=(k+1)%2;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1+k);
          if(d[xx][yy][kk]>cc) {
            d[xx][yy][kk]=cc;
            que.push(PP(P(cc,kk),P(xx,yy)));
          }
        }
      }
    }
    return min(d[n-1][m-1][0],d[n-1][m-1][1]);
  }
};
",1441293902
kzyKT,kzyKT,32,3636,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  bool isBalanced(string s) {
    ll c[2];mem(c);
    rep(i,s.size()) c[i%2]+=s[i]-'0';
    return c[0]==c[1];
  }
};
",1441281289
kzyKT,kzyKT,32,3637,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;


void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;
  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}
  *c=r0;*a=a0;*b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll fact[2100],fact_inv[2100];

void init() {
  fact[0]=1;
  REP(i,1,2100) fact[i]=fact[i-1]*i%MAX;
  fact_inv[2050]=get_inv(fact[2050],MAX);
  rrep(i,2050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;
}

ll nCr(ll N,ll K){
  if(K<0||K>N)return 0;
  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;
}

ll dp[11][44][444];
class Solution {
public:
  int countBalancedPermutations(string s) {
    init();
    ll n=s.size();
    ll c[26],sum=0;
    mem(c);
    rep(i,n) c[s[i]-'0']++;
    rep(i,10) sum+=i*c[i];
    if(sum%2) return 0;
    ll n1=n/2+n%2,n2=n/2,e=0;
    rep(i,11)rep(j,n1+1)rep(k,400) dp[i][j][k]=0;
    dp[0][0][0]=1;
    rep(i,10) {
      rep(j,n1+1) {
        rep(k,400) {
          rep(l,c[i]+1) {
            if(j+l>n1||k+l*i>400) break;
            ll nn=e-j;
            if(n2-nn<0) continue;
            dp[i+1][j+l][k+l*i]+=dp[i][j][k]*nCr(n1-j,l)%MAX*nCr(n2-nn,c[i]-l);
            dp[i+1][j+l][k+l*i]%=MAX;
          }
        }
      }
      e+=c[i];
    }
    return dp[10][n1][sum/2];
  }
};",1441309238
nimish7866,nimish7866,33,3627,cpp,"
    
    class Solution {
public:


int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = moveTime.size();
        int m = moveTime[0].size();
        

        vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        

        vector<vector<long long>> arrival(n, vector<long long>(m, LLONG_MAX));
        arrival[0][0] = 0; 
        

        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>, 
                      greater<>> pq;
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            auto [currentTime, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            

            if (currentTime > arrival[row][col]) continue;
            

            for (const auto& [dx, dy] : directions) {
                int newRow = row + dx;
                int newCol = col + dy;
                

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {

                    long long nextTime = max(currentTime, (long long)moveTime[newRow][newCol]);
                    nextTime += 1;  
                    

                    if (nextTime < arrival[newRow][newCol]) {
                        arrival[newRow][newCol] = nextTime;
                        pq.push({nextTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return (int)arrival[n-1][m-1];
}
    };
        
    
",1441297861
nimish7866,nimish7866,33,3628,cpp,"class Solution {
public:
    typedef pair<long long, pair<int, int>> P;

    long long minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        vector<pair<int, int>> dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(m, vector<long long>(2, LLONG_MAX)));

        dp[0][0][0] = 0;

        priority_queue<pair<long long, tuple<int, int, int>>, vector<pair<long long, tuple<int, int, int>>>, greater<>> pq;
        pq.push({0, {0, 0, 0}});

        while (!pq.empty()) {
            auto [curT, state] = pq.top();
            auto [r, c, mv] = state;
            pq.pop();

            if (curT > dp[r][c][mv % 2]) continue;

            for (const auto& [dx, dy] : dir) {
                int nr = r + dx;
                int nc = c + dy;

                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int mvTime = (mv % 2 == 0) ? 1 : 2;
                    long long nextT = max(curT, (long long)mt[nr][nc]);
                    nextT += mvTime;

                    if (nextT < dp[nr][nc][(mv + 1) % 2]) {
                        dp[nr][nc][(mv + 1) % 2] = nextT;
                        pq.push({nextT, {nr, nc, (mv + 1) % 2}});
                    }
                }
            }
        }

        return (int)min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441300894
nimish7866,nimish7866,33,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

    for (size_t i = 0; i < num.length(); ++i) {
        int digit = num[i] - '0';  
        if (i % 2 == 0) {
            es += digit;  
        } else {
            os += digit;  
        }
    }

    return es == os;
    }
};",1441281030
nimish7866,nimish7866,33,3637,cpp,"using ll = long long;
using vll = vector<ll>;
using vvll = vector<vll>; 

class Solution {
public:
    const int MOD = 1'000'000'007; 

    int countBalancedPermutations(string n) {
        int L = n.size();
        int E = (L + 1) / 2;
        int O = L / 2;

        string v = n;
        int cnt[10] = {0};
        countDigits(n, cnt);

        ll total = calcTotal(cnt);
        if (total % 2 != 0) return 0;

        ll target = total / 2;

        vll fact = preFact();
        vll invFact = preInvFact(fact);

        vvll dp = initDP(E, target); 
        fillDP(dp, cnt, fact, invFact, E, target); 

        return calcAns(dp, E, target, cnt, L); 
    }

private:
    void countDigits(const string& n, int* cnt) {
        for (char ch : n) cnt[ch - '0']++;
    }

    ll calcTotal(int* cnt) {
        ll sum = 0;
        for (int d = 0; d < 10; d++) {
            sum += (ll)d * cnt[d];
        }
        return sum;
    }

    vll preFact() {
        const int MAX = 80;
        vll fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    vll preInvFact(const vll& fact) {
        const int MAX = 80;
        vll invFact(MAX + 1, 1);
        invFact[MAX] = power(fact[MAX], MOD - 2, MOD);
        for (int i = MAX - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
        return invFact;
    }

    ll comb(int a, int b, const vll& fact, const vll& invFact) {
        if (b > a) return 0;
        return fact[a] * invFact[b] % MOD * invFact[a - b] % MOD;
    }

    vvll initDP(int E, ll target) {
        vvll dp(E + 1, vll(target + 1, 0));
        dp[0][0] = 1;
        return dp;
    }

    void fillDP(vvll& dp, int* cnt, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            updateDP(dp, cnt[d], d, fact, invFact, E, target); 
        }
    }

    void updateDP(vvll& dp, int digitCount, int digit, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int t = E; t >= 0; t--) {
            for (ll s = target; s >= 0; s--) {
                if (dp[t][s] == 0) continue;
                for (int k = 1; k <= digitCount && t + k <= E && s + (ll)digit * k <= target; k++) {
                    dp[t + k][s + (ll)digit * k] = (dp[t + k][s + (ll)digit * k] + dp[t][s] * comb(digitCount, k, fact, invFact)) % MOD;
                }
            }
        }
    }

    int calcAns(const vvll& dp, int E, ll target, int* cnt, int L) { 
        ll valid = dp[E][target];
        ll prodFact = calcProductFact(cnt);
        ll ans = (valid * preFact()[E] % MOD * preFact()[L / 2] % MOD) * power(prodFact, MOD - 2, MOD) % MOD;
        return (int)ans;
    }

    ll calcProductFact(int* cnt) {
        ll prodFact = 1;
        for (int d = 0; d < 10; d++) {
            prodFact = prodFact * preFact()[cnt[d]] % MOD;
        }
        return prodFact;
    }

    ll power(ll b, ll e, ll m) {
        ll r = 1; 
        b %= m;
        while (e > 0) {
            if (e & 1) r = r * b % m;
            b = b * b % m; 
            e >>= 1;
        }
        return r;
    }
};",1441316156
Zejun Wu,watashi,34,3627,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 1;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441293776
Zejun Wu,watashi,34,3628,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 2 - (xx + yy) % 2;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441298622
Zejun Wu,watashi,34,3636,cpp,"class Solution {
public:
  bool isBalanced(string num) {
    int s = 0, f = 1;
    for (char c : num) {
      s += (c - '0') * f;
      f *= -1;
    }
    return s == 0;
  }
};",1441281479
Zejun Wu,watashi,34,3637,cpp,"class Solution {
  static constexpr int64_t MOD = 1000000007;

  // a * x + b * y = gcd(a, b) >= 0
  long long extGcd(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
      x = a >= 0 ? 1 : -1;
      y = 0;
      return abs(a);
    }
    else {
      int g = extGcd(b, a % b, y, x);
      y -= a / b * x;
      return g;
    }
  }

  // ASSUME: gcd(a, m) == 1
  long long modInv(long long a, long long m) {
    long long x, y;
    extGcd(a, m, x, y);
    return (x % m + m) % m;
  }

public:
  int countBalancedPermutations(string num) {
    vector<int64_t> fac(800), inv(800);
    fac[0] = inv[0] = 1;
    for (int i = 1; i < inv.size(); ++i) {
      fac[i] = fac[i - 1] * i % MOD;
      inv[i] = modInv(fac[i], MOD);
    }

    int s = 0;
    vector<int> c(10, 0);
    for (char ch : num) {
      ++c[ch - '0'];
      s += ch - '0';
    }
    if (s % 2 != 0) {
      return 0;
    }

    int n = num.length();
    int m = n / 2;
    int z = 0;
    s /= 2;
    vector<vector<int64_t>> dp(m + 1, vector<int64_t>(s + 1, 0));
    dp[0][0] = 1;
    for (int x = 0; x < 10; ++x) {
      vector<vector<int64_t>> pre(m + 1, vector<int64_t>(s + 1, 0));
      pre.swap(dp);
      for (int y = 0; y <= c[x]; ++y) { // 80
        for (int i = y; i <= m; ++i) {
          for (int j = x * y; j <= s; ++j) {
            dp[i][j] += pre[i - y][j - x * y] * inv[y] % MOD * inv[c[x] - y] % MOD;
          }
        }
      }
      for (auto& i : dp) {
        for (auto& j : i) {
          j %= MOD;
        }
      }
    }

    int64_t ret = dp[m][s];
    for (int i = 1; i <= m; ++i) {
      ret = ret * i % MOD;
    }
    for (int i = 1; i <= n - m; ++i) {
      ret = ret * i % MOD;
    }
    return (int)ret;
  }
};",1441316290
SayA,usaya,36,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        dist = [[float('inf') for _ in range(m)] for _ in range(n)]
        dist[0][0] = 0
        
        hp = [(0, 0, 0)] # (time, x, y)
        while hp:
            t, x, y = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(hp, (nt, nx, ny))
        return -1",1441293531
SayA,usaya,36,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        
        dp = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        hp = [(0, 0, 0, 0)] # (time, x, y, z)
        
        while hp:
            t, x, y, z = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dp[x][y][z]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + (1 if z == 0 else 2)
                    nz = 1 - z
                    if nt < dp[nx][ny][nz]:
                        dp[nx][ny][nz] = nt
                        heappush(hp, (nt, nx, ny, nz))
        return -1",1441301029
SayA,usaya,36,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = s2 = 0
        for idx, d in enumerate(num):
            if idx % 2 == 0:
                s1 += ord(d) - ord('0')
            else:
                s2 += ord(d) - ord('0')
        return s1 == s2",1441288801
SayA,usaya,36,3637,python3,"MOD = 10**9 + 7
MAXN = 85

fact = [1] * (MAXN + 1)
for i in range(1, MAXN + 1):
    fact[i] = fact[i-1] * i % MOD

inv = [1] * (MAXN + 1)
inv[MAXN] = pow(fact[MAXN], MOD-2, MOD)
for i in range(MAXN, 0, -1):
    inv[i-1] = inv[i] * i % MOD

comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for i in range(MAXN + 1):
    comb[i][0] = 1
    for j in range(1, i + 1):
        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for d in num:
            cnt[int(d)] += 1
        cnt_e, cnt_o = (n + 1) // 2, n // 2

        s = sum(int(ch) for ch in num)
        if s & 1:
            return 0
        hs = s // 2

        @cache
        def dfs(d, r_e, r_s):
            if d == 10:
                if r_e ==0 and r_s ==0:
                    return 1
                else:
                    return 0
            res = 0
            for t in range(0, min(cnt[d], r_e) + 1):
                if t * d > r_s:
                    continue
                res = (res + dfs(d + 1, r_e - t, r_s - t * d) * comb[cnt[d]][t]) % MOD
            return res

        ans = dfs(0, cnt_e, hs) * fact[cnt_e] * fact[cnt_o] % MOD
        for d in range(10):
            ans = ans * inv[cnt[d]] % MOD
        return ans",1441323871
funsquared,funsquared,37,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))
        
            ",1441323726
funsquared,funsquared,37,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1 + (r + c) % 2
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))",1441323530
funsquared,funsquared,37,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))",1441323951
funsquared,funsquared,37,3637,python3,"MAX = 80
MOD = 10 ** 9 + 7

fact = [1]
for x in range(1, MAX + 1):
    fact.append(fact[-1] * x % MOD)
inv_fact = [None] * (MAX + 1)
inv_fact[MAX] = pow(fact[MAX], -1, MOD)
for x in range(MAX - 1, -1, -1):
    inv_fact[x] = inv_fact[x + 1] * (x + 1) % MOD

def choose(n, k):
    if n < k:
        return 0
    return fact[n] * inv_fact[n - k] % MOD * inv_fact[k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        S = sum(map(int, num))
        if S % 2 == 1:
            return 0
        cnt = [0] * 10
        for d in map(int, num):
            cnt[d] += 1
        target = S // 2
        @cache
        def count(d, o, e, s):
            if d == 10:
                return int(s == target)
            res = 0
            for c in range(min(cnt[d], o) + 1):
                if cnt[d] - c > e:
                    continue
                res = (res + choose(o, c) * choose(e, cnt[d] - c) % MOD * count(d + 1, o - c, e - (cnt[d] - c), s + c * d) % MOD) % MOD
            return res
        return count(0, n // 2, (n + 1) // 2, 0)",1441323285
Ethan,ethanrao,38,3627,cpp,"#include<bits/stdc++.h>>
using namespace std;

class Solution {
public:
    int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    queue<tuple<int, int, int>> q;
    
    int bfs(vector<vector<int>>& cost) {
        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 1e9+3000));
        dp[0][0] = 0;
        
        while (!q.empty()) {
            auto [x, y, t] = q.front();
            q.pop();
            for (int i=0;i<4;i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
                    int tt = max(cost[xx][yy], t);
                    if (tt + 1 < dp[xx][yy]) {
                        q.push({xx, yy, tt + 1});
                        dp[xx][yy] = tt + 1;
                    }
                    else continue;
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        q.push({0, 0, 0});
        return bfs(moveTime);
    }
};
",1441315400
Ethan,ethanrao,38,3628,cpp,"class Solution {
public:
    int a[755][755], n, m, dis[755][755][2];
    struct node{
        int x, y, z, d;
    };
    struct cmp{
        bool operator()(node x, node y){
            return x.d > y.d;      
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        m = moveTime[0].size();
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                a[i][j] = moveTime[i - 1][j - 1];
        priority_queue <node, std::vector <node>, cmp> q;
        q.push((node){1, 1, 0, 0});
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                dis[i][j][0] = dis[i][j][1] = 1.5e9;
        dis[1][1][0] = 0;
        while(q.size()){
            node u = q.top(); q.pop();
            if(u.d > dis[u.x][u.y][u.z]) continue;
            if(u.x > 1){
                int d = std::max(u.d, a[u.x - 1][u.y]) + u.z + 1;
                if(d < dis[u.x - 1][u.y][u.z ^ 1]){
                    dis[u.x - 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x - 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.x < n){
                int d = std::max(u.d, a[u.x + 1][u.y]) + u.z + 1;
                if(d < dis[u.x + 1][u.y][u.z ^ 1]){
                    dis[u.x + 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x + 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.y > 1){
                int d = std::max(u.d, a[u.x][u.y - 1]) + u.z + 1;
                if(d < dis[u.x][u.y - 1][u.z ^ 1]){
                    dis[u.x][u.y - 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y - 1, u.z ^ 1, d});
                }
            }
            if(u.y < m){
                int d = std::max(u.d, a[u.x][u.y + 1]) + u.z + 1;
                if(d < dis[u.x][u.y + 1][u.z ^ 1]){
                    dis[u.x][u.y + 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y + 1, u.z ^ 1, d});
                }
            }
        }
        return std::min(dis[n][m][0], dis[n][m][1]);
    }
};",1441324125
Ethan,ethanrao,38,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ct1 = 0, ct2 = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                ct1 += digit;
            } else {
                ct2 += digit;
            }
        }
        
        return ct1 == ct2;
    }
};
",1441310208
Ethan,ethanrao,38,3637,cpp,"class Solution {
public:
    int n, n1, n2;
    const int mod = 1e9 + 7;
    int c[10];
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    int C[85][85], f[11][85][361];
    int countBalancedPermutations(string num) {
        n = num.size();
        n1 = n2 = 0;
        int S = 0;
        for(int i = 0; i < n; ++i){
            if(i % 2 == 0) ++n1;
            else ++n2;
            ++c[num[i] - '0'];
            S += num[i] - '0';
        }
        if(S % 2){
            return 0;
        }
        C[0][0] = 1;
        for(int i = 1; i <= n; ++i)
            for(int j = 0; j <= i; ++j){
                if(j == 0) C[i][j] = 1;
                else C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
            }
        f[0][0][0] = 1;
        int s = 0;
        for(int i = 1; i <= 10; ++i){
            int t = c[i - 1];
            for(int sum = 0; sum <= 360; ++sum){
                for(int j = 0; j <= n1; ++j){
                    for(int k = 0; k <= j && k <= t; ++k){
                        int pn1 = j - k, pn2 = s - pn1, sa = k * (i - 1);
                        if(pn2 < 0 || pn2 > n2 || sa > sum) continue;
                        f[i][j][sum] = add(f[i][j][sum], mul(f[i - 1][pn1][sum - sa], mul(C[n1 - pn1][k], C[n2 - pn2][t - k])));
                    } 
                }
            }
            s += t;
        }
        return f[10][n1][S / 2];
    }
};",1441309618
zaneyu2005,zaneyu2005,41,3627,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int x=z/m,y=z%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[a*m+b]<=max(arr[a][b],dist[z])+1){
                    continue;
                }
                dist[a*m+b]=max(arr[a][b],dist[z])+1;
                pq.push({dist[a*m+b],a*m+b});
            }
        }
        return dist[n*m-1];
    }
    
};",1441292757
zaneyu2005,zaneyu2005,41,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(2*n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int st=z%2;
            int x=(z/2)/m,y=(z/2)%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[(a*m+b)*2+1-st]<=max(arr[a][b],dist[z])+(st+1)){
                    continue;
                }
                dist[(a*m+b)*2+1-st]=max(arr[a][b],dist[z])+st+1;
                pq.push({dist[(a*m+b)*2+1-st],(a*m+b)*2+1-st});
            }
        }
        return min(dist[2*(n*m-1)],dist[2*n*m-1]);
    }
    
};",1441296463
zaneyu2005,zaneyu2005,41,3636,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
class Solution {
public:
    bool isBalanced(string s) {
        int n=sz(s);
        int sum=0;
        REP(i,n){
            if(i%2) sum+=s[i]-'0';
            else sum-=s[i]-'0';
        }
        return (sum==0);
    }
};",1441280925
zaneyu2005,zaneyu2005,41,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dp[100][1000],ndp[100][1000];
int c[100][100];
class Solution {
public:
    int countBalancedPermutations(string num) {
        REP(i,50) REP(j,1000) dp[i][j]=ndp[i][j]=0;
        REP(i,100){
            c[i][0]=1;
            REP1(j,i){
                c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;
            }
        }
        dp[0][0]=1;
        int cnt[10];
        REP(i,10) cnt[i]=0;
        int s=0;
        for(auto x:num){
            cnt[x-'0']++;
            s+=(x-'0');
        }
        if(s%2){
            return 0;
        }
        s/=2;
        int o=sz(num)/2;
        int e=sz(num)-o;
        int pf=0;
        REP(i,10){
            REP(a,o+1) REP(b,s+1) ndp[a][b]=0;
            REP(a,o+1){
                REP(b,s+1){
                    if(!dp[a][b]) continue;
                    REP(j,cnt[i]+1){
                        if(a+j>o or b+j*i>s) continue;
                        ndp[a+j][b+j*i]+=1LL*dp[a][b]*c[o-a][j]%MOD*c[e-(pf-a)][cnt[i]-j]%MOD;
                        if(ndp[a+j][b+j*i]>=MOD) ndp[a+j][b+j*i]-=MOD;
                    }
                }
            }
            pf+=cnt[i];
            REP(a,o+1) REP(b,s+1) dp[a][b]=ndp[a][b];
        }
        return dp[o][s];
    }
};",1441312046
Ayush,as_313,42,3627,python3,"import heapq

class Solution:
    def is_valid(self, i, j, n, m):
        return 0 <= i < n and 0 <= j < m
    
    def get_neighbors(self, r, c, n, m):
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if self.is_valid(nr, nc, n, m):
                yield nr, nc
    
    def init_distance(self, n, m):
        return [[float('inf')]*m for _ in range(n)]
    
    def process_node(self, t, r, c, g, d, q):
        if t > d[r][c]:
            return
        
        n, m = len(g), len(g[0])
        for nr, nc in self.get_neighbors(r, c, n, m):
            new_time = max(t, g[nr][nc]) + 1
            if new_time < d[nr][nc]:
                d[nr][nc] = new_time
                heapq.heappush(q, (new_time, nr, nc))
    
    def minTimeToReach(self, g):
        n, m = len(g), len(g[0])
        d = self.init_distance(n, m)
        q = [(0, 0, 0)]
        d[0][0] = 0
        
        while q:
            t, r, c = heapq.heappop(q)
            self.process_node(t, r, c, g, d, q)
            
        return d[n-1][m-1]",1441325790
Ayush,as_313,42,3628,python3,"class Solution:
    def minTimeToReach(self, t: List[List[int]]) -> int:
        n, m = len(t), len(t[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        q = [(0, 0, 0, 2)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def is_within_bounds(a, b): return 0 <= a < n and 0 <= b < m
        
        def calculate_next_time(x, a, b, nv): return max(x, t[a][b]) + nv
        
        def explore_neighbors(x, r, c, v):
            for i, j in dirs:
                a, b = r + i, c + j
                if is_within_bounds(a, b):
                    nv = 1 if v == 2 else 2
                    y = calculate_next_time(x, a, b, nv)
                    if y < d[a][b]: 
                        d[a][b] = y
                        heappush(q, (y, a, b, nv))
        
        while q:
            x, r, c, v = heappop(q)
            if r == n - 1 and c == m - 1: return x
            if x > d[r][c]: continue
            explore_neighbors(x, r, c, v)
        
        return d[n-1][m-1]
",1441301088
Ayush,as_313,42,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i, d in enumerate(num):
            if i % 2 == 0: e += int(d)
            else: o += int(d)
        return e == o
",1441284192
Ayush,as_313,42,3637,python3,"class Solution:
    def countBalancedPermutations(self, s):
        MOD = 10**9 + 7
        
        def power_mod(x, y):
            r, x = 1, x % MOD
            while y:
                if y & 1: r = r * x % MOD
                x, y = x * x % MOD, y >> 1
            return r
        
        n = len(s)
        f = [1] + [0] * n
        v = [1] + [0] * n
        for i in range(1, n + 1): f[i] = f[i-1] * i % MOD
        v[n] = power_mod(f[n], MOD - 2)
        for i in range(n-1, -1, -1): v[i] = v[i+1] * (i+1) % MOD
        
        c = [s.count(str(i)) for i in range(10)]
        total = sum(int(ch) for ch in s)
        if total % 2: return 0
        
        k, target = (n + 1) // 2, total // 2
        dp = [[0] * (target + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d, cnt in enumerate(c):
            new_dp = [[0] * (target + 1) for _ in range(k + 1)]
            for i in range(k + 1):
                for j in range(target + 1):
                    if dp[i][j]:
                        for x in range(min(cnt, k - i) + 1):
                            if j + d * x <= target:
                                new_dp[i + x][j + d * x] = (
                                    new_dp[i + x][j + d * x] + 
                                    dp[i][j] * v[x] % MOD * v[cnt - x]
                                ) % MOD
            dp = new_dp
        
        return f[k] * f[n-k] % MOD * dp[k][target] % MOD
",1441319728
scanhex,scanhex,45,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441295664
scanhex,scanhex,45,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + t + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441294951
scanhex,scanhex,45,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(i) for i in str(num)[::2]]) == sum([int(i) for i in str(num)[1::2]])",1441296619
scanhex,scanhex,45,3637,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int countBalancedPermutations(string num) {
    int ceven = num.size() / 2, codd = num.size() - ceven;
    int n = num.size();
    vector<vector<int>> c(n + 1, vector<int>(n + 1));
    c[0][0] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 0; j <= i; ++j)
        c[i][j] = ((j == 0 ? 0 : c[i - 1][j - 1]) + c[i - 1][j]) % mod;
    const int MX = 2 * 100 * 9;
    const int ZERO = MX / 2;
    vector<vector<int>> dp(ceven + 1, vector<int>(MX));
    dp[0][ZERO] = 1;
    int totcnt = 0;
    for (int i = 0; i < 10; ++i) {
      int cnt = 0;
      for (char ch : num)
        if (ch - '0' == i)
          ++cnt;
      auto dpp = vector<vector<int>>(ceven + 1, vector<int>(MX));
      for (int j = ceven; j >= 0; --j) {
        for (int k = ceven; k >= 0; --k) {
          if (j + k > ceven || k > cnt)
            continue;
          for (int l = 0; l < MX; ++l) {
            if (dp[j][l] == 0)
              continue;
            int nodd = cnt - k;
            int totodd = totcnt - j;
            int nl = l + (k - nodd) * i;
            if (nl < 0 || nl >= MX)
              continue;
            dpp[j + k][nl] += 1LL * dp[j][l] * c[j + k][k] % mod *
                             c[totodd + nodd][nodd] % mod;
            if (dpp[j + k][nl] >= mod)
              dpp[j + k][nl] -= mod;
          }
        }
      }
      dp = dpp;
      totcnt += cnt;
    }
    return dp[ceven][ZERO];
  }
};
",1441314395
Shuqi Shang,sshang,46,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        seen = set()
        
        while q:
            t, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1, ni, nj))",1441291881
Shuqi Shang,sshang,46,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0, 0)]
        seen = set()
        
        while q:
            t, state, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1 + state, 1 - state, ni, nj))",1441294899
Shuqi Shang,sshang,46,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        odd, even = 0, 0
        for i, c in enumerate(num):
            if i % 2:
                odd += int(c)
            else:
                even += int(c)
        return odd == even",1441281285
Shuqi Shang,sshang,46,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        mod = 10 ** 9 + 7
        
        n = len(num)
        size = n // 2
        
        total = 0
        cnter = {}
        l = []
        for c in num:
            digit = int(c)
            total += digit
            
            if digit in cnter:
                cnter[digit] += 1
            else:
                cnter[digit] = 1
                bisect.insort(l, digit)
                
        l.reverse()
        presum = [0]
        precnt = [0]
        for num in l:
            cnt = cnter[num]
            precnt.append(precnt[-1] + cnt)
            presum.append(presum[-1] + num * cnt)
            
        if total % 2:
            return 0
        
        target = total // 2
        
        @lru_cache(None)
        def dfs(i, cur_size, cur):
            if i == len(l):
                if cur_size == size and cur == target:
                    return 1
                else:
                    return 0
                
            op_size = precnt[i] - cur_size
                
            num = l[i]
            cnt = cnter[num]
            res = 0
            for j in range(cnt + 1):
                ncur_size = cur_size + j
                ncur = cur + j * num
                nop_size = precnt[i+1] - ncur_size
                nop_sum = presum[i+1] - ncur
                
                if ncur_size <= size and nop_size <= n - size and ncur <= target and nop_sum <= target:
                    mul = (math.comb(size - cur_size, j) % mod) * (math.comb(n - size - op_size, cnt - j) % mod) % mod
                    res += dfs(i+1, ncur_size, ncur) * mul % mod
            return res % mod
            
        return dfs(0, 0, 0)",1441327864
Milind Gupta,milind0110,48,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + 1;
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny});
                }
            }
        }
        return -1;
    }
};",1441298834
Milind Gupta,milind0110,48,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,4>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y,turn] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + (turn == 0 ? 1 : 2);
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny,turn ^ 1});
                }
            }
        }
        return -1;
    }
};",1441297775
Milind Gupta,milind0110,48,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int ans = 0;
        int n = (int)s.size();
        for(int i = 0; i < n; i++){
            if(i & 1){
                ans += s[i] - '0';
            } else {
                ans -= s[i] - '0';
            }
        }
        return (ans == 0);
    }
};",1441281507
Milind Gupta,milind0110,48,3637,cpp,"const int N = 100;
const int mod = 1e9 + 7;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }
template <class T> using V = vector<T>;
template <class T> using VV = V<V<T>>;

template <uint MD> struct ModInt {
    using M = ModInt;
    const static M G;
    uint v;
    ModInt(ll _v = 0) { set_v(_v % MD + MD); }
    M& set_v(uint _v) {
        v = (_v < MD) ? _v : _v - MD;
        return *this;
    }
    explicit operator bool() const { return v != 0; }
    M operator-() const { return M() - *this; }
    M operator+(const M& r) const { return M().set_v(v + r.v); }
    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }
    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }
    M operator/(const M& r) const { return *this * r.inv(); }
    M& operator+=(const M& r) { return *this = *this + r; }
    M& operator-=(const M& r) { return *this = *this - r; }
    M& operator*=(const M& r) { return *this = *this * r; }
    M& operator/=(const M& r) { return *this = *this / r; }
    bool operator==(const M& r) const { return v == r.v; }
    M pow(ll n) const {
        M x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    M inv() const { return pow(MD - 2); }
    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }
};
using Mint = ModInt<mod>;
template<> const Mint Mint::G = Mint(3);

// template <class Mint> void nft(bool type, V<Mint>& a) {
//     int n = int(a.size()), s = 0;
//     while ((1 << s) < n) s++;
//     assert(1 << s == n);

//     static V<Mint> ep, iep;
//     while (int(ep.size()) <= s) {
//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));
//         iep.push_back(ep.back().inv());
//     }
//     V<Mint> b(n);
//     for (int i = 1; i <= s; i++) {
//         int w = 1 << (s - i);
//         Mint base = type ? iep[i] : ep[i], now = 1;
//         for (int y = 0; y < n / 2; y += w) {
//             for (int x = 0; x < w; x++) {
//                 auto l = a[y << 1 | x];
//                 auto r = now * a[y << 1 | x | w];
//                 b[y | x] = l + r;
//                 b[y | x | n >> 1] = l - r;
//             }
//             now *= base;
//         }
//         swap(a, b);
//     }
// }

// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {
//     assert(false);
//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer
//     int n = int(a.size()), m = int(b.size());
//     if (!n || !m) return {};
//     int lg = 0;
//     while ((1 << lg) < n + m - 1) lg++;
//     int z = 1 << lg;
//     auto a2 = a, b2 = b;
//     a2.resize(z);
//     b2.resize(z);
//     nft(false, a2);
//     nft(false, b2);
//     for (int i = 0; i < z; i++) a2[i] *= b2[i];
//     nft(true, a2);
//     a2.resize(n + m - 1);
//     Mint iz = Mint(z).inv();
//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;
//     return a2;
// }

Mint fact[N];
Mint inv[N];
void precalc(){
    fact[0] = 1;
    for(int i = 1; i < N; i++){
        fact[i] = fact[i - 1];
        fact[i] *= i;
    }
    for(int i = 0; i < N; i++){
        inv[i] = 1;
        inv[i] /= fact[i];
    }
}
Mint ncrmodp(int n,int r){
    if(n < 0 || n < r)
        return 0;
    return fact[n]*inv[n-r]*inv[r];
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        precalc();
        int n = (int)s.length();
        const int mx = 10;
        vector<int> cnt(mx);
        int sum = 0;
        for(auto i : s){
            cnt[i - '0']++;
            sum += (i - '0');
        }
        if(sum & 1) return 0;
        sum /= 2;
        int len = n / 2;
        vector<vector<Mint>> dp(len + 1,vector<Mint>(sum + 1));
        dp[0][0] = fact[len] * fact[n - len];
        for(int i = 0; i < mx; i++){
            vector<vector<Mint>> ndp(len + 1,vector<Mint>(sum + 1));
            for(int clen = 0; clen <= len; clen++){
                for(int csum = 0; csum <= sum; csum++){
                    for(int take = 0; take <= cnt[i]; take++){
                        if(take + clen > len) break;
                        int nsum = csum + take * i;
                        if(nsum > sum) break;
                        ndp[clen + take][nsum] += dp[clen][csum] * inv[take] * inv[cnt[i] - take];
                    }
                }
            }
            swap(dp,ndp);
        }
        // for(int i = 0; i <= len; i++){
        //     for(int j = 0; j <= sum; j++){
        //         cout << i << "" "" << j << "" "" << dp[i][j].v << ""\n"";
        //     }
        // }
        return dp[len][sum].v;

    }
};",1441328324
07dishwasherbob8,07dishwasherbob8,50,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1, moveTime[tx][ty] + 1), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441328119
07dishwasherbob8,07dishwasherbob8,50,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1 + ((x + y) & 1), moveTime[tx][ty] + 1 + ((x + y) & 1)), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441327239
07dishwasherbob8,07dishwasherbob8,50,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for(int i = 1; i < num.size(); i+=2) {
            s0 += num[i] - '0';
        }
        for(int i = 0; i < num.size(); i+=2) {
            s1 += num[i] - '0';
        }
        return s0 == s1;
    }
};",1441329956
07dishwasherbob8,07dishwasherbob8,50,3637,cpp,"typedef long long ll;
typedef long double ld;

template<class T>
constexpr T power(T a, ll b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

//Modular Division currently uses Little Fermat's Theorem, so won't work for nonprime p. 
template<int P>
struct Mint {
    int x;
    constexpr Mint(): x{} {}
    constexpr Mint(ll x): x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if(P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if(x < 0) {
            x += getMod();
        }
        if(x >= getMod()) { //not sure why this is needed
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    constexpr Mint operator-() const {
        Mint res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr Mint inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr Mint &operator*=(Mint rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr Mint &operator+=(Mint rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr Mint &operator-=(Mint rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr Mint &operator/=(Mint rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr Mint operator*(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr Mint operator+(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr Mint operator-(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr Mint operator/(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, Mint &a) {
        ll v;
        is >> v;
        a = Mint(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const Mint &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(Mint lhs, Mint rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(Mint lhs, Mint rhs) {
        return lhs.val() != rhs.val();
    }
};

constexpr int P = 1000000007;
using Z = Mint<P>;

class Solution {

public:
    int countBalancedPermutations(string num) {
        vector<Z> factorials(800);
        vector<Z> ifactorials(800);
        factorials[0] = 1;
        ifactorials[0] = 1;
        for(int i = 1; i < 800; i++) {
            factorials[i] = factorials[i-1] * i;
            ifactorials[i] = 1 / factorials[i];
        }

        vector<int> cnts(10);
        int sum = 0;
        for(char c : num) {
            cnts[c - '0']++;
            sum += c - '0';
        }

        
        if(sum & 1) {
            return 0;
        }
        
        // cout << ""sum : "" << sum << '\n';

        vector<vector<Z>> dp(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));
        vector<vector<Z>> next(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));

        dp[0][0] = 1;

        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    next[j][k] = 0;
                }
            }
            
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    for(int l = 0; l + j <= num.size() / 2 && k + (i * l) <= sum / 2 && l <= cnts[i]; l++) {
                        next[l+j][k + i * l] += dp[j][k] * ifactorials[l] * ifactorials[cnts[i] - l];
                    }
                }
            }
            // cout << ""i : "" << i << '\n';
            // for(int j = 0; j <= num.size() / 2; j++) {
            //     for(int k = 0; k <= sum / 2; k++) {
            //         // cout << ""i : "" << i << "" j : "" << j << "" k : "" << k << "" val : "" << dp[j][k] << '\n';
            //         cout << next[j][k] << "" "";
            //     }
            //     cout << '\n';
            // }
            swap(dp,next);
        }
        return (dp[num.size() / 2][sum / 2] * factorials[num.size() / 2] * factorials[(num.size() + 1) / 2]).x;
    }
};",1441315453
wuaws,wuaws,51,3627,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int>,vector<tuple<ll,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        vpi dirs={{-1,0},{1,0},{0,-1},{0,1}};
        const ll INF=1e18;
        mll d(n,vll(m,INF));
        d[0][0]=0;
        pq pq;
        pq.emplace(0,0,0);
        
        while(!pq.empty()){
            auto[t,i,j]=pq.top();
            pq.pop();
            
            if(i==n-1&&j==m-1)return(int)t;
            
            if(t>d[i][j])continue;
            
            for(auto&[di,dj]:dirs){
                int ni=i+di,nj=j+dj;
                
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                
                ll at=max(t,(ll)mt[ni][nj])+1;
                if(at<d[ni][nj]){
                    d[ni][nj]=at;
                    pq.emplace(at,ni,nj);
                }
            }
        }
        return -1;
    }
};",1441329816
wuaws,wuaws,51,3628,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int,int>,vector<tuple<ll,int,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        mll d0(n,vll(m,1e18)),d1(n,vll(m,1e18));
        d0[0][0]=0;
        pq pq;
        pq.emplace(0,0,0,0);
        vector<pair<int,int>> dirs={{-1,0},{1,0},{0,-1},{0,1}};
        
        while(!pq.empty()){
            auto[t,i,j,p]=pq.top(); pq.pop();
            if(i==n-1&&j==m-1)return t;
            if((p==0&&t>d0[i][j])||(p==1&&t>d1[i][j]))continue;

            for(auto& d:dirs){
                int ni=i+d.first,nj=j+d.second;
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                ll ts=max((ll)t,(ll)mt[ni][nj]),at=ts+(p==0?1:2);
                int np=1-p;
                if((np==0&&at<d0[ni][nj])||(np==1&&at<d1[ni][nj])){
                    (np==0?d0[ni][nj]:d1[ni][nj])=at;
                    pq.emplace(at,ni,nj,np);
                }
            }
        }
        return -1;
    }
};",1441329602
wuaws,wuaws,51,3636,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution {
public:
    bool isBalanced(string num) {
        int e=0,o=0;
        FOR(i,0,num.length()){
            int d=num[i]-'0';
            if(i%2==0) e+=d;
            else o+=d;
        }
        return e==o;
    }
};",1441330062
wuaws,wuaws,51,3637,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

const int MOD=1e9+7;

ll fast_power(ll x,ll y,ll mod){
    ll r=1; x%=mod;
    while(y>0){
        if(y&1)r=r*x%mod;
        x=x*x%mod; y>>=1;
    }
    return r;
}

class Solution {
public:
    int countBalancedPermutations(string n){
        int c[10]={0}; ll s=0;
        for(char d:n){c[d-'0']++; s+=d-'0';}
        if(s&1)return 0;
        ll t=s/2; int sz=n.size(),e=(sz+1)/2,o=sz/2;
        
        vector<ll> f(sz+1,1),ivf(sz+1,1);
        FOR(i,1,sz+1)f[i]=f[i-1]*i%MOD;
        ivf[sz]=fast_power(f[sz],MOD-2,MOD);
        FORD(i,sz,0)ivf[i]=ivf[i+1]*(i+1)%MOD;
        
        vector<pair<int,int>>d;
        FOR(dg,0,10)if(c[dg])d.PB({dg,c[dg]});
        
        mll dp(t+1,vector<ll>(e+1,0));
        dp[0][0]=1;
        
        FORE(dg,d){
            mll ndp(t+1,vector<ll>(e+1,0));
            FOR(k,0,t+1)FOR(m,0,e+1)if(dp[k][m]){
                int mx=min(dg.S,e-m);
                FOR(x,0,mx+1){
                    ll nk=k+x*dg.F; if(nk>t)continue;
                    int nm=m+x;
                    ndp[nk][nm]=(ndp[nk][nm]+dp[k][m]*ivf[x]%MOD*ivf[dg.S-x]%MOD)%MOD;
                }
            }
            dp=ndp;
        }
        
        ll a=(t<=t&&e<=e)?dp[t][e]:0;
        
        return (int)(f[e]*f[o]%MOD*a%MOD);
    }
};",1441329386
Meng-Hsuan Wu,meng-hsuan,55,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + 1, tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441305853
Meng-Hsuan Wu,meng-hsuan,55,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + (1 if (tr + tc) % 2 else 2), tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441307123
Meng-Hsuan Wu,meng-hsuan,55,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) * (1 if i % 2 else -1) for i in range(n)) == 0",1441282661
Meng-Hsuan Wu,meng-hsuan,55,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(ch) for ch in num) % 2:
            return 0
        
        MODULI = 10 ** 9 + 7
        n = len(num)
        no = n >> 1
        ne = n - no
        C = Counter(num)
        
        choose = [[1]]
        for n_ in range(1, n + 1):
            choose.append([1])
            for r in range(1, n_):
                choose[-1].append((choose[-2][r - 1] + choose[-2][r]) % MODULI)
            choose[-1].append(1)
        #for i in choose:
        #    print(i)
        
        curr = {(ne, no, 0): 1}
        for i in range(10):
            prev = curr
            curr = collections.defaultdict(int)
            qty = C[str(i)]
            
            for ce in range(qty + 1):
                co = qty - ce
                dbal = (ce - co) * i
                
                for pe, po, pbal in prev:
                    if pe >= ce and po >= co:
                        curr[key := (pe - ce, po - co, pbal + dbal)] += prev[(pe, po, pbal)] * choose[pe][ce] % MODULI * choose[po][co] % MODULI
                        curr[key] %= MODULI
        
        return curr[(0, 0, 0)]
    ",1441331806
haohao,cchao,56,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 3>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        vector<vector<int>> d(n, vector<int>(m, inf));
        d[0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2];
            if (dis != d[x][y]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir];
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + 1;
                if (nd < d[tx][ty]) {
                    d[tx][ty] = nd;
                    q.push({nd, tx, ty});
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441295427
haohao,cchao,56,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 4>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0, 0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        int d[n][m][2];
        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {
            d[i][j][0] = d[i][j][1] = inf;
        }
        d[0][0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2], z = t[3];
            if (dis != d[x][y][z]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir], tz = z ^ 1;
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + (z + 1);
                if (nd < d[tx][ty][tz]) {
                    d[tx][ty][tz] = nd;
                    q.push({nd, tx, ty, tz});
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441301451
haohao,cchao,56,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        return sum(int(x) for x in num[0::2]) == sum(int(x) for x in num[1::2])",1441283080
haohao,cchao,56,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for c in num:
            cnt[ord(c) - ord('0')] += 1

        mod = 10 ** 9 + 7
        inv = lambda x : pow(x, mod - 2, mod)
        fac = [1] * 100
        ifac = [1] * 100
        for i in range(1, len(fac)):
            fac[i] = fac[i-1] * i % mod
            ifac[i] = inv(fac[i])
        
        @cache
        def f(cap1, cap2, diff, index):
            if cap1 < 0 or cap2 < 0:
                return 0
            if cap1 == 0 and cap2 == 0:
                return diff == 0
            ans = 0
            for i in range(cnt[index] + 1):
                j = cnt[index] - i
                if cap1 >= i and cap2 >= j:
                    m1 = fac[cap1] * ifac[i] * ifac[cap1 - i]
                    m2 = fac[cap2] * ifac[j] * ifac[cap2 - j]
                    r = f(cap1 - i, cap2 - j, diff + index * (i - j), index + 1)
                    r = r * m1 % mod
                    r = r * m2 % mod
                    ans = (ans + r) % mod
            return ans % mod
        return f(n//2, n-n//2, 0, 0)",1441332143
Ernest Lu,ernestlu,57,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 1);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441318385
Ernest Lu,ernestlu,57,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 2);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441317334
Ernest Lu,ernestlu,57,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = (int)num.size();
        vector<int> a(n);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
            if (i % 2 == 0)
                sum += a[i];
        }
        const int sum_2 = accumulate(a.begin(), a.end(), 0);
        if (sum + sum == sum_2)
            return true;
        return false;
    }
};",1441319837
Ernest Lu,ernestlu,57,3637,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        // * even! * odd!
        // divide by how many we choose at each level?
        // maintain sum

        int n = (int)num.size();
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
        }

        const int tot = accumulate(a.begin(), a.end(), 0);
        if (tot % 2 == 1) {
            return 0;
        }
        const int target = tot / 2;

 

        vector<int> f(10);
        for (auto u : a)
            f[u]++;

        const int B = n + 101;
        vector<mint> fac(B, 1), inv(B, 1);
        for (int i = 1; i < B; i++)
            fac[i] = fac[i - 1] * i;
        inv[B - 1] = fac[B - 1].pow();
        for (int i = B - 2; i >= 0; i--)
            inv[i] = inv[i + 1] * (i + 1);

        const int even = n / 2, odd = n - even;
        vector dp(even + 1, vector<mint>(target + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            vector new_dp(even + 1, vector<mint>(target + 1, 0));
            for (int num_vals = 0; num_vals <= even; num_vals++) {
                for (int val = 0; val <= target; val++) {
                    for (int fc = 0; fc <= f[i]; fc++) {
                        mint ways_t = inv[fc] * inv[f[i] - fc];
                        const int new_val = val + fc * i;
                        if (num_vals + fc <= even and new_val <= target) {
                            new_dp[num_vals + fc][new_val] += dp[num_vals][val] * ways_t;
                        }
                    }
                }
            }
            swap(dp, new_dp);
        }
        
        const mint ans = dp[even][target] * fac[even] * fac[odd];
        return ans.x;
    }
};",1441299220
Xiaomeng Yang,yangxm,58,3627,cpp,"#define X first
#define Y second

constexpr int MAX = 64;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti3 = tuple<int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX];
priority_queue<Ti3, vector<Ti3>, greater<Ti3>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y] = 0;
  que.emplace(0, src.X, src.Y);
  while (!que.empty()) {
    auto [d, x, y] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y];
    }
    if (d > dis[dst.X][dst.Y]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y]) + 1;
      if (dis[xx][yy] > dis[x][y] + w) {
        dis[xx][yy] = dis[x][y] + w;
        que.emplace(dis[xx][yy], xx, yy);
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441295829
Xiaomeng Yang,yangxm,58,3628,cpp,"#define X first
#define Y second

constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti4 = tuple<int, int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX][2];
priority_queue<Ti4, vector<Ti4>, greater<Ti4>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y][0] = 0;
  que.emplace(0, src.X, src.Y, 0);
  while (!que.empty()) {
    auto [d, x, y, k] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y][k];
    }
    if (d > dis[dst.X][dst.Y][k]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y][k]) + k + 1;
      if (dis[xx][yy][k ^ 1] > dis[x][y][k] + w) {
        dis[xx][yy][k ^ 1] = dis[x][y][k] + w;
        que.emplace(dis[xx][yy][k ^ 1], xx, yy, (k ^ 1));
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441299693
Xiaomeng Yang,yangxm,58,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      int n = num.length(), x = 0, y = 0;
      for (int i = 0; i < n; ++i) {
        int v = num[i] - '0';
        if (i & 1) {
          x += v;
        } else {
          y += v;
        }
      }
      return x == y;
    }
};",1441281670
Xiaomeng Yang,yangxm,58,3637,cpp,"constexpr int MAXM = 128;
constexpr int MAXN = 1024;
constexpr int MOD = 1000000007;

using i64 = long long;

int cnt[16];
i64 c[MAXM][MAXM], dp[MAXM][MAXN];

void Init() {
  memset(c, 0, sizeof(c));
  for (int i = 0; i < MAXM; ++i) {
    c[i][0] = 1;
    for (int j = 1; j <= i; ++j) {
      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
    }
  }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
      static bool init = []() {
        Init();
        return true;
      }();
      
      int n = num.length(), m = 0;
      memset(cnt, 0, sizeof(cnt));
      for (char ch : num) {
        int x = ch - '0';
        m += x;
        ++cnt[x];
      }
      
      if (m & 1) {
        return false;
      }
      
      memset(dp, 0, sizeof(dp));
      for (int i = 0; i <= cnt[0]; ++i) {
        dp[i][0] = 1;
      }
      int v = cnt[0], w = 0;
      for (int i = 1; i < 10; ++i) {
        if (cnt[i] == 0) {
          continue;
        }
        v += cnt[i];
        w += cnt[i] * i;
        for (int j = v; j >= 0; --j) {
          for (int k = w; k >= 0; --k) {
            i64 sum = 0;
            for (int d = 0; d <= j && d <= cnt[i] && d * i <= k; ++d) {
              int p = j, q = v - j;
              i64 cur = c[p][d] * c[q][cnt[i] - d] % MOD;
              sum = (sum + dp[j - d][k - d * i] * cur) % MOD;
            }
            dp[j][k] = sum;
          }
        }
      }
      return dp[(n + 1) / 2][m / 2];
    }
};",1441327081
raincoat911,raincoat911,60,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<int>> dp(r, vector<int>(c, INT_MAX));
        dp[0][0] = 0;
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq;
        pq.push({0,0,0});
        vector<vector<bool>> seen(r, vector<bool>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2];
            if (seen[i][j]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j] = true;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y]) continue;
                int nt = max(t, moveTime[x][y]) + 1;
                if (dp[x][y] > nt) {
                    dp[x][y] = nt;
                    pq.push({nt, x, y});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441294180
raincoat911,raincoat911,60,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<array<int, 2>>> dp(r, vector<array<int, 2>>(c, {INT_MAX, INT_MAX}));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> pq;
        pq.push({0,0,0,0});
        vector<vector<array<bool, 2>>> seen(r, vector<array<bool, 2>>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2], z = p[3];
            if (seen[i][j][z]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j][z] = true;
            int nz = z ^ 1;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y][nz]) continue;
                int nt = max(t, moveTime[x][y]) + (z == 0 ? 1 : 2);
                if (dp[x][y][nz] > nt) {
                    dp[x][y][nz] = nt;
                    pq.push({nt, x, y, nz});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441298517
raincoat911,raincoat911,60,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0,  e = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return o == e;
    }
};",1441281089
raincoat911,raincoat911,60,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int l = num.size(), o = (l + 1) / 2, e = l - o, s = 0;
        vector<int> arr(10);
        for (char c : num) {
            arr[c - '0']++;
            s += c - '0';
        }
        if (s & 1) return 0;
        int n = 0;
        vector<vector<int>> dp(s / 2 + 1, vector<int>(o + 1));
        arr2.resize(o + 1, vector<int>(o + 1));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            // cout << i << endl;
            if (arr[i] == 0) continue;
            vector<vector<int>> dp2(s / 2 + 1, vector<int>(o + 1));
            for (int j = 0; j < dp.size(); j++) {
                for (int d = 0; d <= o; d++) {
                    if (dp[j][d] == 0) continue;
                    for (int k = 0; k <= arr[i] && d + k <= o && j + k * i < dp.size(); k++) {
                        if (e - (n - d) < arr[i] - k) continue;
                        // cout << i << "" "" << j << "" "" << k << "" "" << d << endl;
                        // cout << j + k * i << "" "" << d + k << "" "" << o - d << "" "" << k << "" "" << e - (n - d) << "" "" << arr[i] - k << endl;
                        dp2[j + k * i][d + k] += (((long)dp[j][d] * cnk(o - d, k)) % M * cnk(e - (n - d), arr[i] - k)) % M;
                        dp2[j + k * i][d + k] %= M;
                        // cout << ""done"" << endl;
                    }
                }
            }
            swap(dp, dp2);
            n += arr[i];
        }
        // cout << ""aaa"" << endl;
        return dp.back().back();
    }
    
private:
    int M = 1e9 + 7;
    vector<vector<int>> arr2;
    
    int cnk(int n, int k) {
        // cout << n << "" "" << k << endl;
        if (n == k || k == 0) return 1;
        if (arr2[n][k]) return arr2[n][k];
        return arr2[n][k] = (cnk(n - 1, k - 1) + cnk(n - 1, k)) % M;
    }
};",1441328822
OTTFF,OTTFF,62,3627,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

class Solution {
public:
typedef array<int, 3> A3;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        vector<vector<int>> dis(n, vector<int>(m, INF));
        vector<vector<int>> vis(n, vector<int>(m, 0));

        priority_queue<A3, vector<A3>, greater<A3>> qu;
        dis[0][0] = 0;
        qu.push({0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny] = qu.top(); qu.pop();
            if (vis[nx][ny]) continue;
            vis[nx][ny] = 1;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny]) + 1;
                if (dis[x][y] <= nd) {
                    continue;
                }
                dis[x][y] = nd;
                qu.push({nd, x, y});
            }
        }

        return dis[n - 1][m - 1];
    }
};",1441298205
OTTFF,OTTFF,62,3628,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

const int M = 755;
int dis[M][M][2];
int vis[M][M][2];

class Solution {
public:
typedef array<int, 4> A4;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        // vector<vector<int>> dis(n, vector<int>(m, INF));
        // vector<vector<int>> vis(n, vector<int>(m, 0));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dis[i][j][0] = dis[i][j][1] = INF;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }

        priority_queue<A4, vector<A4>, greater<A4>> qu;
        dis[0][0][0] = 0;
        qu.push({0, 0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny, nt] = qu.top(); qu.pop();
            if (vis[nx][ny][nt]) continue;
            vis[nx][ny][nt] = 1;

            // cout << nx << ' ' << ny << ' ' << nt << ' ' << dis[nx][ny][nt] << endl;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y][nt]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny][nt]) + (nt ? 2 : 1);
                if (dis[x][y][nt ^ 1] <= nd) {
                    continue;
                }
                dis[x][y][nt ^ 1] = nd;
                qu.push({nd, x, y, nt ^ 1});
            }
        }

        return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441304611
OTTFF,OTTFF,62,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int i = 0;
        for (char c : num) {
            if (i & 1) {
                sum += c - '0';
            } else {
                sum -= c - '0';
            }
            i++;
        }
        return sum == 0;
    }
};",1441281671
OTTFF,OTTFF,62,3637,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

vector<Mint> inv, fa, ifa;
void init_mod(int n) {
    inv.assign(n + 1, Mint(1));
    fa.assign(n + 1, Mint(1));
    ifa.assign(n + 1, Mint(1));
    for(int i = 2; i <= n; i++) {
        fa[i] = fa[i-1] * i;
        inv[i] = Mint(Mint::MO - Mint::MO / i) * inv[Mint::MO % i];
        ifa[i] = inv[i] * ifa[i-1];
    }
}
inline Mint C(int n,int m) {
  return (m<0 || n<m) ? Mint(0) : fa[n]*ifa[m]*ifa[n-m]; }
inline Mint A(int n,int m) { return fa[n]*ifa[n-m]; }

const int M = 85;
int f = 0;
void init() {
    if (f) return;
    f = 1;
    init_mod(M);
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        
        int n = s.length();
        int sum = 0;
        vector<int> cnt(10);
        for (int i = 0; i < n; i++) {
            sum += s[i] - '0';
            cnt[s[i] - '0']++;
        }
        if (sum & 1) {
            return 0;
        } 

        int m = n / 2;
        int tar = sum / 2;

        vector<vector<Mint>> dp(m + 1, vector<Mint>(tar + 1)), tmp(m + 1, vector<Mint>(tar + 1));
        dp[0][0] = 1;

        int tot = 0;
        for (int v = 0; v < 10; v++) {
            swap(dp, tmp);
            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= tar; j++) {
                    dp[i][j] = 0;
                }
            }

            for (int sel = 0; sel <= cnt[v]; sel++) {
                for (int i = 0; i + sel <= m; i++) {
                    for (int j = 0; j + v * sel <= tar; j++) {
                        dp[i + sel][j + v * sel] += tmp[i][j] * C(m - i, sel) * C(n - m - (tot - i), cnt[v] - sel);
                    }
                }
            }

            tot += cnt[v];
        }

        return dp[m][tar].x;
    }
};",1441322604
Wanjun Li,wjli,63,3627,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					tt = max(moveTime[xx][yy] + 1, t + 1);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};",1441291066
Wanjun Li,wjli,63,3628,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt, dt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					if ((xx + yy) & 1) dt = 1;
					else dt = 2;
					tt = max(moveTime[xx][yy] + dt, t + dt);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};

",1441292925
Wanjun Li,wjli,63,3636,cpp,"


// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	bool isBalanced(string num) {
		int n = num.size(), i, j, k;
		VI s(2, 0);
		FOR(i, n) s[i & 1] += num[i] - '0';
		return s[0] == s[1];
	}
};
",1441281367
Wanjun Li,wjli,63,3637,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class factorial {
public:
    LL MAXX, MOD;
    VL f, ff;

    factorial(LL maxx = 200010, LL mod = 998244353) {
        MAXX = maxx;
        MOD = mod;

        f.RSZ(MAXX);
        ff.RSZ(MAXX);

        f[0] = 1;
        for (int i = 1; i < MAXX; i++) f[i] = (f[i - 1] * i) % MOD;
        for (int i = 0; i < MAXX; i++) ff[i] = mul_inv(f[i], MOD);
    }

    long long mul_inv(long long a, long long b)
    {
        long long b0 = b, t, q;
        long long x0 = 0, x1 = 1;
        if (b == 1) return 1;
        while (a > 1) {
            q = a / b;
            t = b, b = a % b, a = t;
            t = x0, x0 = x1 - q * x0, x1 = t;
        }
        if (x1 < 0) x1 += b0;
        return x1;
    }

    long long division(long long a, long long b) {		// (a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p
        long long ans, inv;
        inv = mul_inv(b, MOD);
        ans = ((a % MOD) * inv) % MOD;
        return ans;
    }

    LL calcc(LL n, LL a) {
        if (n == a) return 1;
        if (n == 0) return 0;
        if (n < a) return 0;
        LL ans = (f[n] * ff[a]) % MOD;
        ans = (ans * ff[n - a]) % MOD;
        return ans;
    }

    LL calcp(LL n, LL a) {
        LL ans = (f[n] * ff[n - a]) % MOD;
        return ans;
    }

    LL ball_in_box(LL box, LL ball) {    // # of ways of putting k balls to n boxes; boxes can be empty
        if (box == 0) return (ball == 0);
        LL ans = calcc(ball + box - 1, ball);
        return ans;
    }


    LL exp(LL base, LL n, LL MODD = -1) {
        LL mod;
        if (MODD == -1) mod = MOD;
        else mod = MODD;

        base %= mod;
        LL ans = 1, x = base, MAXLEVEL = 60, i;

        for (i = 0; i < MAXLEVEL; i++) {
            if ((1LL << i) > n) break;
            if ((1LL << i) & n) ans = (ans * x) % mod;
            x = (x * x) % mod;
        }
        return ans;
    }

    LL exp_abc(LL a, LL b, LL c) {  // a ^ (b ^ c) $ MOD where b and c can be very big
        // https://www.geeksforgeeks.org/find-power-power-mod-prime/#
        // Fermat's Little: a ^ (MOD - 1) = 1 % MOD
        // a ^ (b ^ c) % MOD = a ^ (b ^ c % (MOD - 1)) % MOD

        LL bc = exp(b, c, MOD - 1);
        LL ans = exp(a, bc);
        return ans;
    }


    LL sum_arithmetic_sequence(LL first_item, LL difference, LL n) {
        LL ans, last = (first_item + difference * (n - 1)) % MOD;
        ans = ((first_item + last) * n / 2) % MOD;

        return ans;
    }

    LL sum_geometry_sequence(LL first_item, LL ratio, LL n) {
        LL ans;

        if (ratio == 1) ans = (first_item * n) % MOD;
        else if (n == 1) ans = first_item;
        else {
        https://www.mathsisfun.com/algebra/sequences-sums-geometric.html
            LL rn = exp(ratio, n);
            ans = (first_item * (1 - rn + MOD)) % MOD;
            ans = division(ans, 1 - ratio + MOD) % MOD;
        }
        return ans;
    }
};

class Solution {
public:
	int countBalancedPermutations(string num) {
		LL n = num.length(), i, j, k, ans = 0, MOD = 1000000007, s, m, ss, sss, cc;
		VL ct(10, 0);
		s = 0;
		FOR(i, n) {
			ct[num[i] - '0']++;
			s += num[i] - '0';
		}
        factorial f(n + 100, MOD);

		if (s & 1) return 0;
        ss = s / 2;

		m = n / 2;

		// dp[digit][ct][sum] = # of ways
        VVL dp(m + 1, VL(ss + 1, 0)), dp2 = dp; 
        cc = 0;
        dp[0][0] = 1;
        FOR(i, 10) {
            if (ct[i] == 0) continue;
            cc += ct[i];
            swap(dp, dp2);
            dp.assign(m + 1, VL(ss + 1, 0));

            FOR(j, m + 1) {
                FOR(k, ss + 1) {
                    if (dp2[j][k] == 0) continue;

                    sss = k;
                    FOR(v, ct[i] + 1) {
                        if ((v + j > m) || (sss > ss)) break;
                        
                        LL x = (f.calcc(j + v, v) * f.calcc(cc - (j + v), (ct[i] - v))) % MOD;
						dp[j + v][sss] = (dp[j + v][sss] + dp2[j][k] * x) % MOD;
                        sss += i;
                    }
                }
            }

            k = 0;
        }

        ans = dp[m][ss];

		ans %= MOD;
		return ans;
	}
};

",1441316234
Kishan Jaiswal,kishan_jaiswal,64,3627,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) { return {dx, dy}; }

    vector<pair<int, int>> getDirections() {
        return {addDirection(-1, 0), addDirection(1, 0), addDirection(0, -1),
                addDirection(0, 1)};
    }

    int maxSum(int a, int b) { return max(a, b) + 1; }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();

        vector<vector<int>> minTime(
            rows, vector<int>(cols, numeric_limits<int>::max()));
        minTime[0][0] = 0;

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            queue;
        queue.push({0, 0, 0});

        auto directions = getDirections();

        while (!queue.empty()) {
            auto [currentTime, x, y] = queue.top();
            queue.pop();

            if (x == rows - 1 && y == cols - 1) {
                return currentTime;
            }

            if (currentTime > minTime[x][y]) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int newX = x + dx;
                int newY = y + dy;

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int newTime = maxSum(currentTime, moveTime[newX][newY]);

                    if (newTime < minTime[newX][newY]) {
                        minTime[newX][newY] = newTime;
                        queue.push({newTime, newX, newY});
                    }
                }
            }
        }

        return -1;
    }
};",1441321018
Kishan Jaiswal,kishan_jaiswal,64,3628,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) {
    return {dx, dy};
}

vector<pair<int, int>> getDirections() {
    return {addDirection(1, 0), addDirection(-1, 0), addDirection(0, 1), addDirection(0, -1)};
}

int calculateNextTime(int time, int moveTime, int moveDuration) {
    return max(time, moveTime) + moveDuration;
}

int minTimeToReach(vector<vector<int>>& moveGrid) {
    int rows = moveGrid.size(), cols = moveGrid[0].size();
    vector<vector<array<int, 2>>> minDist(rows, vector<array<int, 2>>(cols, {numeric_limits<int>::max(), numeric_limits<int>::max()}));
    
    minDist[0][0][0] = 0;
    
    priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> queue;
    queue.push({0, 0, 0, 0});

    auto directions = getDirections();

    while (!queue.empty()) {
        auto [time, x, y, parity] = queue.top();
        queue.pop();

        if (x == rows - 1 && y == cols - 1) {
            return time;
        }

        if (time > minDist[x][y][parity]) {
            continue;
        }

        int moveDuration = (parity == 0) ? 1 : 2;

        for (auto [dx, dy] : directions) {
            int newX = x + dx;
            int newY = y + dy;

            if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                int nextTime = calculateNextTime(time, moveGrid[newX][newY], moveDuration);
                int nextParity = 1 - parity;

                if (nextTime < minDist[newX][newY][nextParity]) {
                    minDist[newX][newY][nextParity] = nextTime;
                    queue.push({nextTime, newX, newY, nextParity});
                }
            }
        }
    }

    return -1;
}
};",1441322853
Kishan Jaiswal,kishan_jaiswal,64,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long  cnt=1;
        int n=num.size();
        long long  sum1=0;
        long long  sum2=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                sum1+=(num[i]-'0')%10;
            }else{
                sum2+=(num[i]-'0')%10;
            }
        }
        return sum1==sum2?true:false;
    }
};",1441301786
Kishan Jaiswal,kishan_jaiswal,64,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

using namespace std;

class Solution {
public:
    int countBalancedPermutations(string n) {
        const int MOD = 1000000007;
        int length = n.length();
        int totalSum = 0;
        vector<int> digitCount(10, 0);
        
        for (char digit : n) {
            digitCount[digit - '0']++;
            totalSum += (digit - '0');
        }
        if (totalSum % 2 != 0) return 0;
        
        int halfSum = totalSum / 2;
        int halfLength = (length + 1) / 2;
        vector<long> factorials(length + 1);
        factorials[0] = 1;
        
        for (int i = 1; i <= length; i++) 
            factorials[i] = multiply(factorials[i - 1], i, MOD);
        
        vector<long> inverseFactorials(length + 1);
        inverseFactorials[length] = calculateModInverse(factorials[length], MOD);
        
        for (int i = length - 1; i >= 0; i--) 
            inverseFactorials[i] = multiply(inverseFactorials[i + 1], (i + 1), MOD);
        
        vector<vector<long>> dpTable(halfLength + 1, vector<long>(halfSum + 1, 0));
        dpTable[0][0] = 1;

        for (int digit = 0; digit <= 9; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int k = halfLength; k >= 0; k--) {
                for (int s = halfSum; s >= 0; s--) {
                    if (dpTable[k][s] == 0) continue;
                    for (int t = 1; t <= digitCount[digit] && k + t <= halfLength && s + digit * t <= halfSum; t++) {
                        dpTable[k + t][s + digit * t] = add(dpTable[k + t][s + digit * t], multiply(dpTable[k][s], computeCombination(digitCount[digit], t, factorials, inverseFactorials, MOD), MOD), MOD);
                    }
                }
            }
        }

        long ways = dpTable[halfLength][halfSum];
        long result = multiply(factorials[halfLength], factorials[length - halfLength], MOD);
        
        for (int digit = 0; digit <= 9; digit++) {
            result = multiply(result, inverseFactorials[digitCount[digit]], MOD);
        }
        
        result = multiply(result, ways, MOD);
        return static_cast<int>(result);
    }

private:
    long add(long a, long b, int mod) {
        return (a + b) % mod;
    }

    long multiply(long a, long b, int mod) {
        return (a * b) % mod;
    }

    long calculateModInverse(long a, int mod) {
        long result = 1;
        long exponent = mod - 2;
        long base = a;
        while (exponent > 0) {
            if ((exponent & 1) == 1) {
                result = multiply(result, base, mod);
            }
            base = multiply(base, base, mod);
            exponent >>= 1;
        }
        return result;
    }

    long computeCombination(int n, int k, const vector<long>& factorials, const vector<long>& invFactorials, int mod) {
        if (k > n) return 0;
        return multiply(factorials[n], multiply(invFactorials[k], invFactorials[n - k], mod), mod);
    }
};
",1441329757
SheenYangYun,SheenYangYun,65,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vvi dp = init(n, m);
        dp[0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(stateStart(0, 0, 0));
        vector<int> directions = { -1, 0, 1, 0, -1 };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (ff(current, n, m)) return current.time;
            if (fff(current, dp)) continue;
            children(current, moveTime, dp, pq, directions, n, m);
        }
        return -1;
    }

private:
    vvi init(int n, int m) {
        return vvi(n, vector<int>(m, INT32_MAX));
    }

    State stateStart(int time, int x, int y) {
        return State{ time, x, y };
    }

    bool ff(const State& state, int n, int m) {
        return state.x == n - 1 && state.y == m - 1;
    }

    bool fff(const State& state, const vvi& dp) {
        return state.time > dp[state.x][state.y];
    }

    bool chek(int x, int y, int n, int m) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    void children(const State& current, const vvi& moveTime, 
                         vvi& dp, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vector<int>& directions, int n, int m) {
        for(int k = 0; k < 4; ++k){
            int newX = current.x + directions[k];
            int newY = current.y + directions[k + 1];
            if(chek(newX, newY, n, m)){
                int newTime = max(current.time, moveTime[newX][newY]) + 1;
                if(newTime < dp[newX][newY]){
                    dp[newX][newY] = newTime;
                    pq.push(stateStart(newTime, newX, newY));
                }
            }
        }
    }
};

",1441321118
SheenYangYun,SheenYangYun,65,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
    int p;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vvi> dist = init(n, m);
        dist[0][0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(start(0, 0, 0, 0));
        vvi dirs = { {1,0},{-1,0},{0,1},{0,-1} };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (solved(current, n, m)) return current.time;
            if (possible(current, dist)) continue;
            chuildren(current, moveTime, dist, pq, dirs, n, m);
        }
        return -1;
    }

private:
    vector<vvi> init(int n, int m) {
        return vector<vvi>(n, vvi(m, vector<int>(2, INT32_MAX)));
    }

    State start(int time, int x, int y, int p) {
        return State{ time, x, y, p };
    }

    bool solved(const State& state, int n, int m) {
        return state.x == n -1 && state.y == m -1;
    }

    bool possible(const State& state, const vector<vvi>& dist) {
        return state.time > dist[state.x][state.y][state.p];
    }

    bool check(int x, int y, int n, int m) {
        return x >=0 && x <n && y >=0 && y <m;
    }

    void chuildren(const State& current, const vvi& moveTime, 
                         vector<vvi>& dist, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vvi& dirs, int n, int m) {
        int moveDuration = current.p == 0 ? 1 : 2;
        for(auto &d : dirs){
            int nx = current.x + d[0];
            int ny = current.y + d[1];
            if(check(nx, ny, n, m)){
                int nextTime = max(current.time, moveTime[nx][ny]) + moveDuration;
                int nextP = current.p == 0 ? 1 : 0;
                if(nextTime < dist[nx][ny][nextP]){
                    dist[nx][ny][nextP] = nextTime;
                    pq.push(start(nextTime, nx, ny, nextP));
                }
            }
        }
    }
};
",1441314554
SheenYangYun,SheenYangYun,65,3636,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    bool isBalanced(const string &num)
    {
        int cnt1 = 0;
        int cnt2 = 0;

        for (int i = 0; i < num.size(); ++i)
        {
            int digit = num[i] - '0';
            if (i & 1)
            {
                cnt2 += digit;
                continue;
            }

            cnt1 += digit;
        }

        return cnt1 == cnt2;
    }
};
",1441323172
SheenYangYun,SheenYangYun,65,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int freq[10] = {0};
        for (char c : num)
        {
            freq[c - '0']++;
        }

        int n = num.size();
        int nEven = (n + 1) / 2;
        int nOdd = n / 2;

        ll sum = 0;
        for (int d = 0; d < 10; d++)
        {
            sum += (ll)d * freq[d];
        }

        if (sum & 1)
        {
            return 0;
        }

        ll des = sum / 2;

        vector<vector<ll>> dp(nEven + 1, vector<ll>(des + 1, 0));
        dp[0][0] = 1;

        vector<ll> fact(n + 1, 1);
        for (int i = 1; i <= n; i++)
        {
            fact[i] = fact[i - 1] * i % MOD;
        }

        auto pow_mod = [&](ll a, ll b) -> ll
        {
            ll res = 1;
            a %= MOD;
            while (b > 0)
            {
                if (b & 1)
                {
                    res = res * a % MOD;
                }
                a = a * a % MOD;
                b >>= 1;
            }
            return res;
        };

        vector<ll> invFact(n + 1, 1);
        invFact[n] = pow_mod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
        {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }

        ll inFact = 1;
        for (int d = 0; d < 10; d++)
        {
            inFact = inFact * invFact[freq[d]] % MOD;
        }

        for (int d = 0; d < 10; d++)
        {
            int c = freq[d];
            if (c == 0)
                continue;

            for (int k = nEven; k >= 0; k--)
            {
                for (ll s = des; s >= 0; s--)
                {
                    if (dp[k][s] == 0)
                    {
                        continue;
                    }

                    int max_m = min(c, nEven - k);
                    for (int m = 1; m <= max_m; m++)
                    {
                        ll newK = k + m;
                        ll newS = s + (ll)d * m;
                        if (newS > des)
                        {
                            break;
                        }

                        ll comb_val = fact[c] * invFact[m] % MOD;
                        comb_val = comb_val * invFact[c - m] % MOD;

                        dp[newK][newS] = (dp[newK][newS] + dp[k][s] * comb_val) % MOD;
                    }
                }
            }
        }

        ll ans = dp[nEven][des];
        if (ans != 0)
        {

            ans = ans * fact[nEven] % MOD;
            ans = ans * fact[nOdd] % MOD;
            ans = ans * inFact % MOD;

            return (int)(ans);
        }

        return 0;
    }
};
",1441307925
Tin,tin_le,67,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, std::greater<array<ll, 3>>> minHeap;
        minHeap.push({0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<ll>> dp(n, vector<ll>(m, INF));
        dp[0][0] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)(cost + 1), (ll)moveTime[row][col] + 1);
                if(newCost < dp[row][col]) {
                    dp[row][col] = newCost;
                    minHeap.push({newCost, row, col});
                }
            }
        }
        return -1;
    }
};",1441296900
Tin,tin_le,67,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, std::greater<array<ll, 4>>> minHeap;
        minHeap.push({0, 0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        dp[0][0][0] = dp[0][0][1] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j, k] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j][k]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)cost, (ll)moveTime[row][col]) + (k == 0 ? 1 : 2);
                if(newCost < dp[row][col][!k]) {
                    dp[row][col][!k] = newCost;
                    minHeap.push({newCost, row, col, !k});
                }
            }
        }
        return -1;
    }
};",1441301018
Tin,tin_le,67,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        int n = num.size();
        for(int i = 0; i < n; i++) {
            if(i & 1) odd += num[i] - '0';
            else even += num[i] - '0';
        }
        return odd == even;
    }
};",1441280985
Tin,tin_le,67,3637,cpp,"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗
//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝
//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░
//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░
//░░░██║░░░██║██║░╚███║  ███████╗███████╗
//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vvpll vt<vpll>
#define vvvll vt<vvll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
class Combinatoric {    
    public: 
    int n;  
    vll fact, inv;   
    Combinatoric(int n) {   
        this->n = n;    
        fact.rsz(n + 1), inv.rsz(n + 1);
        init();
    }
        
    void init() {   
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {   
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        inv[n] = modExpo(fact[n], MOD - 2, MOD);
        for(int i = n - 1; i >= 0; i--) {   
            inv[i] = (inv[i + 1] * (i + 1)) % MOD;
        }
    }
    
    ll choose(ll a, ll b) {  
		if(a < b) return 0;
        return fact[a] * inv[b] % MOD * inv[a - b] % MOD;
    }
};
class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        int freq[10] = {};
        for(auto& x : s) {
            freq[x - '0']++;
        }
        ll sm = 0;
        for(int i = 0; i <= 9; i++) {
            sm += (ll)i * freq[i];
        }
        if(sm % 2) return 0;
        ll target = sm / 2;
        int k = (n + 1) / 2, l = n / 2;
        Combinatoric comb(n + 1);
        vector<vector<ll>> dp(k + 1, vector<ll>(target + 1));
        dp[0][0] = 1;
        for(int d = 0; d <= 9; d++) {
            if(freq[d] == 0) continue;
            for(int c = k; c >= 0; c--) {
                for(ll S = target; S >= 0; S--) {
                    if(dp[c][S] == 0) continue;
                    for(int cnt = 1; cnt <= freq[d] && cnt <= k - c; cnt++) {
                        if(S + d * cnt > target) break;
                        auto& A = dp[c + cnt][S + d * cnt];
                        A = (A + dp[c][S] * comb.choose(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        ll prod = 1;
        for(int d = 0; d <= 9; d++) {
            prod = prod * comb.fact[freq[d]] % MOD;
        }
        return (dp[k][target]) * comb.fact[k] % MOD * comb.fact[l] % MOD * modExpo(prod, MOD - 2, MOD) % MOD;
    }
};",1441323448
despair of athkatla,nibbas,68,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        vis = [[math.inf] * m for _ in range(n)]
        heap = [(0, 0, 0)]
        vis[0][0] = 0
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if x == n-1 and y == m-1:
                return t
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(heap, (nt, nx, ny))",1441292174
despair of athkatla,nibbas,68,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        INF = math.inf
        dist = [[INF]*m for _ in range(n)]
        dist[0][0] = 0
        heap = []
        heappush(heap, (0, 0, 0, 0))
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y, p = heappop(heap)
            if x == n-1 and y == m-1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0<=nx<n and 0<=ny<m:
                    d = 1 if p ==0 else 2
                    nt = max(t, moveTime[nx][ny]) + d
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(heap, (nt, nx, ny, 1 - p))
        return -1",1441298863
despair of athkatla,nibbas,68,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441282709
despair of athkatla,nibbas,68,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
  
  const long long INF = 9223372036854775807;

  #ifndef ONLINE_JUDGE
  #define WATCH(key, val)                                                        \
    printf(""Watched %s ->  %s \n"", key, std::to_string(val).c_str());
  #define WATCH_CONTAINER(key, val)                                              \
    printf(""Watched %s : "", key);                                                \
    for (auto e : val)                                                           \
      printf("" %s"", std::to_string(e).c_str());                                  \
    printf(""\n"");
  #define WATCH_MAP(map)                                                         \
    printf(""Watching Map\n"");                                                    \
    for (auto e : map)                                                           \
      printf(""%s -> %s\n"", std::to_string(e.first).c_str(),                      \
            std::to_string(e.second).c_str());                                  \
    printf(""\n"");
  #else
  #define WATCH(key, val)                                                        \
    do {                                                                         \
    } while (false);
  #define WATCH_CONTAINER(key, val)                                              \
    do {                                                                         \
    } while (false);
  #define WATCH_MAP(map)                                                         \
    do {                                                                         \
    } while (false);
  #endif

  #ifdef FAST_EXECUTION
  #pragma GCC optimize(""O3"")
  #pragma comment(linker, ""/stack:247474112"")
  #endif

  #define REP(n) for(int t=0; t<n; t++)
  #define FOR(i, n) for (i = 0; i < n; i++)
  #define FFOR(i, j, n) for(i = j; j < n; j++)
  #define FOR_S(i, n, k) for (i = 0; i < n; i += k)
  #define RFOR(i, n) for (i = n - 1; i >= 0; i--)
  #define RFOR_S(i, n, k) for (i = n - 1; i >= 0; i -= k)
  #define MAX_OF(x, y) ((x > y) ? x : y)
  #define MIN_OF(x, y) ((x > y) ? y : x)
  #define MIN_IN(A) *(std::min_element(A.begin(), A.end()));
  #define MAX_IN(A) *(std::max_element(A.begin(), A.end()));
  #define MAX_AT(A) (std::max_element(A.begin(), A.end()) - A.begin());
  #define MIN_AT(A) (std::min_element(A.begin(), A.end()) - A.begin());
  #define TESTCASE                                                              \
    int testcase;                                                               \
    std::cin>>testcase;                                                         \
    while(testcase--)
  #define GCD(a,b) std::__gcd(a,b);
  #define LCM(a,b) (a)*((b)/std::__gcd(a,b));
  #define SORT(A) std::sort(A.begin(), A.end());
  #define RSORT(A) std::sort(A.rbegin(), A.rend());
  #define REVERSE(A) std::reverse(A.begin(), A.end());
  #define ANY(container, result, condition)                                      \
    result = false;                                                              \
    for (const auto &e : container)                                              \
      if (condition(e)) {                                                        \
        result = true;                                                           \
        break;                                                                   \
      }
  #define ALL(container, result, condition)                                      \
    result = true;                                                               \
    for (const auto &e : container)                                              \
      if (!condition(e)) {                                                       \
        result = false;                                                          \
        break;                                                                   \
      }
  #ifdef INTERACTIVE_MODE
  #define iprint(...)                                                            \
    printf(__VA_ARGS__);                                                         \
    fflush(stdout);
  #else
  #define iprint(...) printf(__VA_ARGS__);
  #endif

  #define LL long long
  #define L long
  #define ULL unsigned long long
  #define I int
  #define D double
  #define UI unsigned int
  #define VEC(i) std::vector<i>
  #define MAP(a, b) std::map<a, b>
  #define UMAP(a, b) std::unordered_map<a, b>
  #define SET(a) std::set<a>
  #define USET(a) std::unordered_set<a>
  #define MSET(a) std::multiset<a>
  #define STR std::string
  #define PAIR(a,b) std::pair<a,b>
  #define PAIRI std::pair<int, int>
  #define READ_INT(var) scanf(""%d"", &var)
  #define READ_STR(var) std::cin >> var
  #define READ_LONG(var) scanf(""%lld"", &var)
  #define WRITE_INT(var) printf(""%d"", var)
  #define WRITE_LONG(var) printf(""%lld"", var)
  #define WRITE_STR(var) std::cout << var
  #define WRITE_VEC_LL(val)                                                      \
    for (auto e : val)                                                           \
      printf(""%lld "", e);
  #define WRITE_VEC_I(val)                                                       \
    for (auto e : val)                                                           \
      printf(""%d "", e);
      
  #define pb push_back
  #define eb emplace_back


class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> cnt(10, 0);
        int S = 0;
        for (char ch : s) {
            cnt[ch - '0']++;
            S += (ch - '0');
        }
        
        if (S % 2 != 0) return 0;
        
        int T = S / 2;
        int K = (n + 1) / 2;
    
        vector<long long> F(n + 1, 1), IF(n + 1, 1);
        for (int i = 1; i <= n; i++) F[i] = F[i - 1] * i % MOD;

        auto pw = [&](ll a, ll b) -> ll {
            ll R = 1;
            a %= MOD;
            while (b > 0) {
                if (b & 1) R = R * a % MOD;
                a = a * a % MOD;
                b >>= 1;
            }
            return R;
        };
        
        IF[n] = pw(F[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) IF[i] = IF[i + 1] * (i + 1) % MOD;
        
        vector<vector<long long>> dp(K + 1, vector<long long>(T + 1, 0));
        dp[0][0] = 1;
        
        for (int d = 0; d <= 9; d++) {
            if (cnt[d] == 0) continue;
            for (int t = K; t >= 0; t--) {
                for (int s = T; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int x = 1; x <= min(cnt[d], K - t) && s + x * d <= T; x++) {
                        dp[t + x][s + x * d] = (dp[t + x][s + x * d] + dp[t][s] * F[cnt[d]] % MOD * IF[x] % MOD * IF[cnt[d] - x] % MOD) % MOD;
                    }
                }
            }
        }
        
        ll R = dp[K][T] * F[K] % MOD * F[n - K] % MOD;
        for (int d = 0; d <= 9; d++) {
            R = R * IF[cnt[d]] % MOD;
        }
        
        return (int)R;
    }
};
",1441316716
Lucky Orb,megurine,69,3627,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + 1, xx, yy))
        # print(f)
        return f[n - 1][m - 1]
        ",1441300238
Lucky Orb,megurine,69,3628,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + (x + y) % 2 + 1, xx, yy))
        print(f)
        return f[n - 1][m - 1]
""""""
[[0,58],[27,69]]
71
""""""",1441304557
Lucky Orb,megurine,69,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        return sum(map(int, s[::2])) == sum(map(int, s[1::2]))",1441281574
Lucky Orb,megurine,69,3637,cpp,"#include <bits/stdc++.h>

#ifdef MEGURINE
#include ""algo/debug.h""
#include ""algo/debug_lc.h""
#else
#define debug(...) 42
#endif

using namespace std;

auto __fast_io__ = [] {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

#define itr(it) begin(it), end(it)

// @formatter:off
template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a;
        swap(a, m);
        u -= t * v;
        swap(u, v);
    }
    assert(m == 1);
    return u;
}

template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() :
        value() {}

    template <typename U>
    Modular(const U &x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U &x) {
        Type v;
        if (-mod() <= x && x < mod())
            v = static_cast<Type>(x);
        else
            v = static_cast<Type>(x % mod());
        if (v < 0)
            v += mod();
        return v;
    }

    const Type &operator()() const { return value; }

    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }

    constexpr static Type mod() { return T::value; }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= mod())
            value -= mod();
        return *this;
    }

    Modular &operator-=(const Modular &other) {
        if ((value -= other.value) < 0)
            value += mod();
        return *this;
    }

    template <typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template <typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }
    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(
        const Modular &rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }

    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type &abs(const Modular &x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename U>
    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename V, typename U>
    friend V &operator>>(V &stream, Modular<U> &number);

    template <typename V>
    operator V() { return (V)value; }

private:
    Type value;
};

template <typename T>
bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }

template <typename T, typename U>
bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }

template <typename T, typename U>
bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }

template <typename T>
bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T>
bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }

template <typename T>
Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T>
Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T>
Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T>
Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> power(const Modular<T> &a, const U &b) {
    if (b < 0)
        return 1 / power(a, -b);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1)
            res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}

template <typename T>
bool IsZero(const Modular<T> &number) {
    return number() == 0;
}

template <typename T>
string to_string(const Modular<T> &number) {
    return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U &operator<<(U &stream, const Modular<T> &number) {
    return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U &operator>>(U &stream, Modular<T> &number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}

//using ModType = int;
//
//struct VarMod { static ModType value; };
//ModType VarMod::value;
//ModType &md = VarMod::value;
//using Mint = Modular<VarMod>;

// constexpr int md = 998244353;
constexpr int md = 1e9 + 7;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
// @formatter:on

vector<Mint> fact;
vector<Mint> inv_fact;

Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int)fact.size() < n + 1) {
        if (fact.empty()) {
            fact = inv_fact = {1};
            continue;
        }
        fact.push_back(fact.back() * (int)fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        int m = 0, k1 = (s.size() + 1) / 2, k2 = s.size() - k1;
        vector<int> cnt(10);
        for (char x : s)
            m += x - '0', cnt[x - '0']++;
        if (m % 2)
            return 0;
        m /= 2;
        if (m == 0)
            return 1;
        vector f(k2 + 1, vector<Mint>(m + 1));
        f[0][0] = 1;
        int p = 0, q = 0;
        for (int x = 0; x < 10; ++x) {
            if (!cnt[x]) continue;
            vector h(k2 + 1, vector<Mint>(m + 1));
            p += cnt[x], q += cnt[x] * x;
            for (int i = 0; i <= k2 && i + cnt[x] <= p; ++i) {
                for (int j = 0; j <= m; ++j) {
                    for (int k = 0; k <= cnt[x]; ++k) {
                        int ii = i + k, jj = j + x * k;
                        if (ii <= k2 && jj <= m && p - ii <= k1 && q - jj <= m) {
                            h[ii][jj] += f[i][j] * C(k2 - i, k) * C(k1 - (p - cnt[x] - i), cnt[x] - k);
                        }
                    }
                }
            }
            h.swap(f);
        }
        return f[k2][m];
    }
};

#ifdef MEGURINE

int main() {
    freopen(""../input.txt"", ""r"", stdin);
    freopen(""../output.txt"", ""w"", stdout);
    clock_t start_time = clock();
    int T;
    cin >> T;
    getchar();
    while (T--) {
        Solution sol;
        test<string>(sol, &Solution::countBalancedPermutations);
    }
    cout << ""\nExecution Time: "" << static_cast<double>(clock() - start_time) / CLOCKS_PER_SEC * 1000 << ""ms"" << endl;
    return 0;
}

#endif
",1441330841
4dalols,4dalols,70,3627,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441317045
4dalols,4dalols,70,3628,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1+(cx+cy)%2; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441316390
4dalols,4dalols,70,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int t=0,i=1;
        for (auto r:s) {
            t+=i*(r-'0');
            i=-i;
        }
        return t==0;
    }
};",1441318720
4dalols,4dalols,70,3637,cpp,"class Solution {
public:
    const int MX = 100;
    long long F[101], Fi[101], mod=1e9+7;
     
    long long pw(long long b, long long e) {
    	int x=1;
    	while (e) {
    		if (e%2) x=x*b%mod; 
    		b=b*b%mod; 
    		e/=2; 
    	}
    	return x;
    }
     
    long long nCk(int n, int k) {
        if (k>n||k<0) return 0;
        return F[n]*Fi[k]%mod*Fi[n-k]%mod;
    }
     
    void initC() {
    	F[0]=1;
    	for (int i = 1; i <= MX; i++) F[i]=F[i-1]*i%mod;
        Fi[MX]=pw(F[MX],mod-2);
    	for (int i = MX; i; i--) Fi[i-1]=Fi[i]*i%mod;
    }
     
    int countBalancedPermutations(string s) {
        int n= s.size(); 
        initC();
        int t=0;
        map<int,int> m; 
        for (auto r:s) {
            m[r-'0']++;
            t+=r-'0'; 
        }
        if (t%2) return 0;
        vector<vector<long long>> dp(n+1,vector<long long>(t+1)); dp[0][0]=1; 
        int x=0;
        for (auto [a,b]:m) {
            x+=b;
        vector<vector<long long>> dp2(n+1,vector<long long>(t+1));
            // cout << a << "" "" << b << endl; 
            for (int i = 0; i <= b; i++) {
                for (int j = n; j>=i; j--) {
                    for (int k=t;k>=a*i;k--) {
                        (dp2[j][k]+=dp[j-i][k-a*i]*nCk(j,i)%mod*nCk(x-j,b-i))%=mod;
                    }
                }
            }
            dp=dp2;
        // for (auto r:dp) {
        //     for (int j:r) cout << j << "" ""; cout << ""\n"";
        // } cout << ""\n"";
        }
        return dp[(n+1)/2][t/2]; 
    }
};",1441307470
Brijesh Siwach,Dhongee,71,3627,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 1 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};",1441337879
Brijesh Siwach,Dhongee,71,3628,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 2 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};
",1441336728
Brijesh Siwach,Dhongee,71,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int s1 = 0,s2=0;
        for(int i = 0 ; i < n; i++){
            if(i%2) s1+=(s[i]-'0');
            else s2+=(s[i]-'0');
        }
        return s1==s2;
    }
};",1441339150
Brijesh Siwach,Dhongee,71,3637,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:

    ll binpow(ll a,ll b,const int mod){
        ll res=1;
        while(b>0) {
            if(b&1) res=res*a%mod;
            b>>=1;
            a=a*a%mod;
        }
        return res;
    }

    int countBalancedPermutations(string s) {
        int n = s.size();
        const int mod=1e9+7;
        vector<ll> fact(n+1,1);
        vector<ll> inv(n+1);
        for(int i = 1; i <= n; i++){
            fact[i] = fact[i-1] * i % mod;
        }
        for(int i = 0; i <= n; i++){
            inv[i] = binpow(fact[i], mod-2, mod);
        }   

        auto mul = [&](ll x,ll y)->ll{
            return (x%mod * y%mod)%mod;
        };
        auto add = [&](ll x,ll y)->ll{
            return (x%mod + y%mod)%mod;
        };

        vector<ll>f(10);
        int sum = 0;
        for(auto x: s) {
            f[x-'0']++;
            sum += (x-'0');
        }
        const int M = 8e2;
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (n+1, vector<ll> (M, -1)));

        function<ll(int,int,int)>go=[&](int pos,int ot, int ost) -> ll{
            if(pos==10) {
                if(ot != (n+1)/2) return 0;
                if(ost != sum - ost) return 0;
                return mul(fact[ot], fact[n-ot]);
            }

            if(dp[pos][ot][ost] == -1) {
                ll ans = 0;
                for(int i = 0; i <= f[pos]; i++){
                    ll val = mul(inv[i], inv[f[pos]-i]);

                    ans = add(ans, mul(go(pos+1,ot+i,ost+i*pos),val));
                }
                dp[pos][ot][ost]=ans;
            }
            return dp[pos][ot][ost];
        };

        ll ans = go(0, 0, 0);

        return ans;

    }
};
",1441315427
Rastsislau Matusevich,rastsislau,72,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int move_time = max(t, moveTime[new_x][new_y]) + 1;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441301173
Rastsislau Matusevich,rastsislau,72,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int cost = (x + y) % 2 + 1;
                        int move_time = max(t, moveTime[new_x][new_y]) + cost;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441305087
Rastsislau Matusevich,rastsislau,72,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector <int> sum(2,0);
        int i=0;
        for (auto x: num)
            {
                sum[i%2]+=(x-'0');
                i++;
            }
        return sum[0] == sum[1];
    }
};",1441281746
Rastsislau Matusevich,rastsislau,72,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10**9 + 7
        counts = [0] * 10
        total_sum = 0
    
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total_sum += d
    
        if total_sum % 2 != 0:
            return 0
    
        n_even = (n + 1) // 2 
        n_odd = n // 2 
    
        max_s = n_even * 9
    
        max_fact = n + 1
        fact = [1] * (max_fact)
        inv_fact = [1] * (max_fact)
        for i in range(1, max_fact):
            fact[i] = (fact[i - 1] * i) % MOD
        inv_fact[max_fact - 1] = pow(fact[max_fact - 1], MOD - 2, MOD)
        for i in range(max_fact - 2, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
    
        comb_cache = {}
        def nCk(n, k):
            if k < 0 or k > n:
                return 0
            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD
    
        dp = [ [0] * (n_even + 1) for _ in range(total_sum // 2 + 1) ]
        dp[0][0] = 1
    
        for d in range(10):
            c_d = counts[d]
            if c_d == 0:
                continue
            dp_new = [row[:] for row in dp]
            for c in range(1, c_d + 1):
                comb_cd_c = nCk(c_d, c)
                delta_s = c * d
                for s in range(total_sum // 2 - delta_s + 1):
                    for k in range(n_even - c +1):
                        dp_new[s + delta_s][k + c] = (dp_new[s + delta_s][k + c] + dp[s][k] * comb_cd_c) % MOD
            dp = dp_new
    
        total_ways = dp[total_sum // 2][n_even]
        if total_ways == 0:
            return 0
    
        numerator = (total_ways * fact[n_even] % MOD) * fact[n_odd] % MOD
        denom = 1
        for c in counts:
            denom = (denom * fact[c]) % MOD
    
        answer = numerator * pow(denom, MOD - 2, MOD) % MOD
        return answer
        ",1441332810
PyIsTheBestLang,PyIsTheBestLang,76,3627,python3,"
def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        dis = [[math.inf] * n for _ in range(m)]
        dis[0][0] = 0
        stack = [(0, 0, 0)]
        while stack:
            d, i, j = heappop(stack)
            
            if dis[i][j] < d:
                continue
            
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0<=a+i<m and 0<=b+j<n:
                    dj = max(d + 1, moveTime[i+a][j+b]+1)
                    if dj < dis[a+i][b+j]:
                        dis[a+i][b+j] = dj
                        heappush(stack, (dj, a+i, j+b))
        ans = dis[-1][-1]
        return ans ",1441302684
PyIsTheBestLang,PyIsTheBestLang,76,3628,python3,"
def max(a, b):
    return a if a > b else b




class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        k = 2
        dis = [[[math.inf] * k for _ in range(n)] for _ in range(m)]
        dis[0][0][0] = 0
        stack = [(0, 0, 0, 0)]
        while stack:
            d, s, i, j = heappop(stack)

            if dis[i][j][s] < d:
                continue
   
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0 <= a + i < m and 0 <= b + j < n:
                    if s == 0:
                        dj = max(d+s+1, moveTime[i + a][j + b]+1)
                    else:
                        dj = max(d+ s + 1, moveTime[i + a][j + b]+2)  
                        
                    if dj < dis[a + i][b + j][(s+1)%2]:
                        dis[a + i][b + j][(s+1)%2] = dj
                        heappush(stack, (dj, (s+1)%2, a + i, j + b))
        ans = min(dis[-1][-1])
        return ans ",1441309881
PyIsTheBestLang,PyIsTheBestLang,76,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) for i in range(1, n, 2)) ==  sum(int(num[i]) for i in range(0, n, 2))",1441302566
PyIsTheBestLang,PyIsTheBestLang,76,3637,python3,"import math
from functools import lru_cache
from itertools import accumulate


# from sortedcontainers import SortedList
# sys.set_int_max_str_digits(0)  # for big number in leet code


def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


mod = 10 ** 9 + 7


class Combinatorics:
    def __init__(self, n, mod):
        assert mod > n
        self.n = n + 10
        self.mod = mod

        self.perm = [1]
        self.rev = [1]
        self.inv = [0]
        self.fault = [0]

        self.build_perm()
        self.build_rev()
        self.build_inv()
        self.build_fault()
        return

    def build_perm(self):
        self.perm = [1] * (self.n + 1)  # (i!) % mod
        for i in range(1, self.n + 1):
            self.perm[i] = self.perm[i - 1] * i % self.mod
        return

    def build_rev(self):
        self.rev = [1] * (self.n + 1)  # pow(i!, -1, mod)
        self.rev[-1] = pow(self.perm[-1], -1, self.mod)  # GcdLike().mod_reverse(self.perm[-1], self.mod)
        for i in range(self.n - 1, 0, -1):
            self.rev[i] = (self.rev[i + 1] * (i + 1) % self.mod)  # pow(i!, -1, mod)
        return

    def build_inv(self):
        self.inv = [0] * (self.n + 1)  # pow(i, -1, mod)
        self.inv[1] = 1
        for i in range(2, self.n + 1):
            self.inv[i] = (self.mod - self.mod // i) * self.inv[self.mod % i] % self.mod
        return

    def build_fault(self):
        self.fault = [0] * (self.n + 1)  # fault permutation
        self.fault[0] = 1
        self.fault[2] = 1
        for i in range(3, self.n + 1):
            self.fault[i] = (i - 1) * (self.fault[i - 1] + self.fault[i - 2])
            self.fault[i] %= self.mod
        return

    def comb(self, a, b):
        if a < b:
            return 0
        res = self.perm[a] * self.rev[b] * self.rev[a - b]  # comb(a, b) % mod = (a!/(b!(a-b)!)) % mod
        return res % self.mod

    def factorial(self, a):
        res = self.perm[a]  # (a!) % mod
        return res % self.mod

    def inverse(self, n):
        res = self.perm[n - 1] * self.rev[n] % self.mod  # pow(n, -1, mod)
        return res

    def catalan(self, n):
        res = (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod
        return res


cb = Combinatorics(200, mod)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        @lru_cache(None)
        def dfs(i, k, pre):
            if k > odd or (m - odd) > even:
                return 0
            if i == 10:
                return pre == 0
            
            
            res = 0
            rest_odd = odd-k
            rest_even = post[-1] - post[i]-rest_odd
            for xx in range(cnt[i] + 1):
                res += dfs(i + 1, k + xx, pre + xx * i - (cnt[i] - xx) * i)*cb.comb(rest_odd, xx)*cb.comb(rest_even, cnt[i]-xx)
            return res % mod

        num = sorted(num)
        m = len(num)
  
        cnt = [0] * 10
        odd = m // 2 + m % 2
        even = m - odd
        for x in num:
            cnt[int(x)] += 1
        post = list(accumulate(cnt, initial=0))
        ans = dfs(0, 0, 0)
        return ans
",1441320219
Xiong_Jiangkai,xlyy,77,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y = q[0]
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n and visited[x_new][y_new] == -1:
                    t_max = max(t, moveTime[x_new][y_new]) + 1
                    visited[x_new][y_new] = t_max
                    heapq.heappush(q, (t_max, x_new, y_new))
        return visited[-1][-1] ",1441316739
Xiong_Jiangkai,xlyy,77,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0, 1)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y, dt = q[0]
            dt_new = 2 if dt == 1 else 1
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n:
                    t_max = max(t, moveTime[x_new][y_new])
                    if (visited[x_new][y_new] == -1 or visited[x_new][y_new] > t_max + dt):
                        visited[x_new][y_new] = t_max + dt
                        heapq.heappush(q, (t_max + dt, x_new, y_new, dt_new))
        return visited[-1][-1] ",1441313622
Xiong_Jiangkai,xlyy,77,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        n = len(num)
        sum1 = sum2 = 0
        for i in range(0, n, 2):
            sum1 += int(num[i])
        for i in range(1, n, 2):
            sum2 += int(num[i])
        return sum1 == sum2",1441281965
Xiong_Jiangkai,xlyy,77,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = int(1e9)+ 7
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
    
        counts = [0] * 10
        total = 0
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total += d
    
        if total %2 != 0:
            return 0
        S = total // 2
    
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] *i % MOD
    
        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


        
        dp_prev = [[0] * (n_even + 1) for _ in range(S + 1)]
        dp_prev[0][0] = 1
        for d in range(10):
            c_d = counts[d]
            if c_d ==0:
                dp_curr = [row[:] for row in dp_prev]
            else:
                dp_curr = [[0] * (n_even + 1) for _ in range(S + 1)]
                k_min = max(0, c_d - n_odd)
                for s in range(S + 1):
                    for c in range(n_even + 1):
                        val = dp_prev[s][c]
                        if val == 0:
                            continue
                        for k in range(k_min, min(c_d, n_even - c) + 1):
                            new_s = s + d * k
                            if new_s > S:
                                continue
                            new_c = c + k
                            if new_c > n_even:
                                continue
                            add_val = val * inv_fact[k] % MOD
                            add_val = add_val * inv_fact[c_d - k] % MOD
                            dp_curr[new_s][new_c] = (dp_curr[new_s][new_c] + add_val) % MOD
                dp_prev = dp_curr
    
        dp_final = dp_prev[S][n_even]
        res = fact[n_even] * fact[n_odd] % MOD
        res = res * dp_final % MOD
        return res",1441334143
Meet Brahmbhatt,MeetBrahmbhatt,78,3627,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 1;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334615
Meet Brahmbhatt,MeetBrahmbhatt,78,3628,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 2;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334276
Meet Brahmbhatt,MeetBrahmbhatt,78,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < (int) s.size(); i++) {
            sum += (s[i] - '0') * (i & 1 ? -1 : 1);
        }
        return !sum;
    }
};",1441322261
Meet Brahmbhatt,MeetBrahmbhatt,78,3637,cpp,"constexpr int32_t MOD = 1e9 + 7;
// constexpr int32_t MOD = 998244353;

struct Mint {
    int val;
    Mint(long long v = 0) {
        if (v < 0) {
            v = v % MOD + MOD;
        }
        if (v >= MOD) {
            v %= MOD;
        }
        val = v;
    }
    static int mod_inv(int a, int m = MOD) {
        int g = m, r = a, x = 0, y = 1;
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
        return x < 0 ? x + m : x;
    }
    explicit operator int() const {
        return val;
    }
    Mint& operator+=(const Mint &other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    Mint& operator-=(const Mint &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    typedef unsigned long long ull;
    ull fast_mod(ull a, ull b, ull M = MOD) {
        long long ret = a * b - M * ull(1.L / M * a * b);
        return ret + M * (ret < 0) - M * (ret >= (long long)M);
    }
    Mint& operator*=(const Mint &other) {
        val = fast_mod((ull) val, other.val);
        return *this;
    }
    Mint& operator/=(const Mint &other) {
        return *this *= other.inv();
    }
    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }
    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }
    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }
    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }
    Mint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
    Mint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }
    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }
    Mint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
    bool operator==(const Mint &other) const { return val == other.val; }
    bool operator!=(const Mint &other) const { return val != other.val; }
    Mint inv() const {
        return mod_inv(val);
    }
    Mint pow(long long p) const {
        assert(p >= 0);
        Mint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            a *= a;
            p >>= 1;
        }
        return result;
    }
    friend ostream& operator<<(ostream &stream, const Mint &m) {
        return stream << m.val;
    }
    friend istream& operator >> (istream &stream, Mint &m) {
        return stream >> m.val;
    }
};

const int32_t N = 100;
bool done = false;
Mint FAC[N + 1], INV[N + 1];

void calc() {
    if (done) {
        return;
    }
    done = true;
    FAC[0] = 1;
    for (int i = 1; i <= N; i++) {
        FAC[i] = (FAC[i - 1] * i);
    }
    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);
    for (int i = N - 1; i >= 0; i--) {
        INV[i] = (INV[i + 1] * (i + 1));
    }
}
Mint ncr(int n, int r) {
    if (r < 0) return 0;
    if (n < r) return 0;
    if (r == 0) return 1;
    Mint a = FAC[n] * INV[r] * INV[n - r];
    return a;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        calc();
        int n = (int) s.size();
        
        vector<int> freq(10);
        for (auto i : s) {
            freq[i - '0']++;
        }
        
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += freq[i] * i;
        }
        
        if (sum & 1) {
            return 0;
        }
        
        sum /= 2;
        vector<vector<Mint>> dp((n / 2) + 1, vector<Mint>(sum + 1));
        dp[0][0] = 1;
        
        for (int i = 0; i < 10; i++) {
            vector<vector<Mint>> ndp(n / 2 + 1, vector<Mint>(sum + 1));
            for (int prev_take = 0; prev_take <= n / 2; prev_take++) {
                for (int take = 0; take <= freq[i] && prev_take + take <= n / 2; take++) {
                    for (int prev_sum = 0; prev_sum + take * i <= sum; prev_sum++) {
                        int new_sum = prev_sum + take * i;
                        int new_take = prev_take + take;
                        ndp[new_take][new_sum] += dp[prev_take][prev_sum] * INV[take] * INV[freq[i] - take];
                    }
                }
            }
            
            dp = ndp;
        }
        
        Mint ans = dp[n / 2][sum] * FAC[n / 2] * FAC[(n + 1) / 2];
        return ans.val;
    }
};",1441321938
Dylan Smith,DylanSmith,79,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + 1;
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441293304
Dylan Smith,DylanSmith,79,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + ((r + c) % 2 == 0 ? 1 : 2);
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441294311
Dylan Smith,DylanSmith,79,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0, o = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2 == 0) {
                e += num[i] - '0';
            } else {
                o += num[i] - '0';
            }
        }
        return e == o;
    }
};",1441281042
Dylan Smith,DylanSmith,79,3637,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

int mod = 1000000007;

ll exGCD(ll a, ll b, ll &x, ll &y) {
    if (a == 0) { x = 0; y = 1; return b; }
    ll g = exGCD(b % a, a, x, y);
    ll t = x; x = y - b / a * x; y = t;
    return g;
}

int mInv(int n) {
    ll x, y, g = exGCD(n, mod, x, y);
    if (g != 1) return 0;
    return (x % mod + mod) % mod;
}

vector<int> factArr = {1}, factInvArr = {1};
int fact(int n) {
    while (sz(factArr) <= n)
        factArr.pb((int)((ll)factArr[sz(factArr) - 1] * sz(factArr) % mod));
    return factArr[n];
}

int factInv(int n) {
    fact(n);
    while (sz(factInvArr) <= n)
        factInvArr.pb(mInv(factArr[sz(factInvArr)]));
    return factInvArr[n];
}

int choose(int n, int k) {
    if (k < 0 || k > n) return 0;
    return (int)((ll)fact(n) * factInv(k) % mod * factInv(n - k) % mod);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int sum = 0;
        for (char c : num) sum += c - '0';
        if (sum % 2 == 1) return 0;
        vector<vector<ll>> dp((int)num.size() / 2 + 1, vector<ll>(sum / 2 + 1, 0)), nxt = dp;
        dp[0][0] = 1;
        vector<int> freq(10, 0);
        for (char c : num) freq[c - '0']++;
        int pre = 0;
        for (int k = 0; k < 10; k++) {
            for (int i = 0; i <= num.size() / 2; i++) fill(all(nxt[i]), 0);
            for (int l = 0; l <= freq[k]; l++) {
                for (int i = 0; i + l <= (int)num.size() / 2; i++) {
                    int n = (ll)choose(i + l, l) * choose(pre - i + freq[k] - l, freq[k] - l) % mod;
                    for (int j = 0; j + k * l <= sum / 2; j++) {
                        nxt[i + l][j + k * l] += (ll)dp[i][j] * n % mod;
                    }
                }
            }
            for (int i = 0; i <= num.size() / 2; i++) {
                for (int j = 0; j <= sum / 2; j++) {
                    nxt[i][j] %= mod;
                }
            }
            pre += freq[k];
            swap(dp, nxt);
        }
        return dp[(int)num.size() / 2][sum / 2];
    }
};",1441327844
Liwei Cai,cai_lw,80,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m);
        pq.push({0,0,0});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=it.i*m+it.j;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it2.t,moveTime[it2.i][it2.j])+1;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441295706
Liwei Cai,cai_lw,80,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool p;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m*2);
        pq.push({0,0,0,false});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=(it.i*m+it.j)*2+it.p;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it.t,moveTime[it2.i][it2.j])+(it.p?2:1);
                it2.p=!it.p;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441297773
Liwei Cai,cai_lw,80,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s[2]{0,0};
        for(int i=0;i<num.size();i++)
            s[i%2]+=num[i]-'0';
        return s[0]==s[1];
    }
};",1441280960
Liwei Cai,cai_lw,80,3637,cpp,"class Solution {
    static constexpr int P=1'000'000'007;
    struct State{
        int n1,n2,step,diff;
        bool operator<(const State& rhs)const{
            return tuple(n1,n2,step,diff)<tuple(rhs.n1,rhs.n2,rhs.step,rhs.diff);
        }
    };
    int solve(const State& st,const int (&cnt)[10],const int (&rem)[10],const vector<vector<int>>& binom,map<State,int>& mem){
        if(st.step==10)
            return st.diff==0;
        if(abs(st.diff)>rem[st.step])
            return 0;
        auto [it,inserted]=mem.emplace(st,0);
        if(!inserted)
            return it->second;
        int& ans=it->second;
        for(int c1=0;c1<=cnt[st.step];c1++){
            int c2=cnt[st.step]-c1;
            if(c1>st.n1||c2>st.n2)
                continue;
            int coef=1ll*binom[st.n1][c1]*binom[st.n2][c2]%P;
            State nxt=st;
            nxt.n1-=c1;
            nxt.n2-=c2;
            nxt.step++;
            nxt.diff+=st.step*(c2-c1);
            ans+=1ll*coef*solve(nxt,cnt,rem,binom,mem)%P;
            if(ans>=P)
                ans-=P;
        }
        return ans;
    }
public:
    int countBalancedPermutations(string num) {
        int cnt[10]{};
        for(char c:num)
            cnt[c-'0']++;
        int rem[10];
        rem[9]=cnt[9]*9;
        for(int i=8;i>=0;i--)
            rem[i]=rem[i+1]+cnt[i]*i;
        int n=num.size();
        int n1=n/2,n2=n-n1;
        vector<vector<int>> binom(n2+1,vector<int>(n2+1));
        for(int i=0;i<=n2;i++){
            binom[i][0]=binom[i][i]=1;
            for(int j=1;j<i;j++){
                binom[i][j]=binom[i-1][j-1]+binom[i-1][j];
                if(binom[i][j]>=P)
                    binom[i][j]-=P;
            }
        }
        map<State,int> mem;
        return solve(State{n1,n2,0,0},cnt,rem,binom,mem);
    }
};",1441335423
ocavue,ocavue,81,3627,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        result = [[MAX_TIME] * n for _ in range(m)]

        result[0][0] = 0

        heap = [(0, 0, 0)]

        while heap:
            time, i, j = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    new_time = start_time + 1
                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        heapq.heappush(heap, (new_time, ii, jj))

        return result[m - 1][n - 1]
 ",1441296531
ocavue,ocavue,81,3628,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        # print(""m"", m, ""n"", n)
        result1 = [[MAX_TIME] * n for _ in range(m)]
        result2 = [[MAX_TIME] * n for _ in range(m)]

        result2[0][0] = 0

        heap = [(0, 0, 0, 1)]

        while heap:
            time, i, j, next_move = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    # assert next_move in [1, 2]
                    new_time = start_time + next_move

                    result = result1 if next_move == 1 else result2

                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        # print(f""result {ii} {jj} {new_time} -> {(next_move) % 2 + 1}"")
                        heapq.heappush(heap, (new_time, ii, jj, (next_move) % 2 + 1))

        # print(""result1"", result1)
        # print(""result2"", result2)

        return min(result1[m - 1][n - 1], result2[m - 1][n - 1])

 ",1441316045
ocavue,ocavue,81,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = 0
        o = 0
        for i, char in enumerate(num):
            dig = int(char)
            if i % 2 == 0:
                e += dig 
            else:
                o += dig 
        return e == o",1441281980
ocavue,ocavue,81,3637,python3,"from functools import cache
import math

MOD = 10**9 + 7


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        total_sum = sum(int(c) for c in num)
        if total_sum % 2 != 0:
            return 0

        counter = [0] * 10
        for c in num:
            d = int(c)
            counter[d] += 1

        assert sum(counter) == len(num)

        n = len(num)
        e = n // 2
        o = n - e

        @cache
        def dp(i: int, e_available: int, o_available: int, diff: int) -> int:
            if i == 10:
                assert e_available == 0 and o_available == 0, f""e_available: {e_available}, o_available: {o_available}""
                return 1 if diff == 0 else 0

            total_result = 0
            for e_pick in range(0, e_available + 1):
                o_pick = counter[i] - e_pick
                if 0 <= e_pick <= e_available and 0 <= o_pick <= o_available:
                    result = 1
                    result *= math.comb(e_available, e_pick)
                    result %= MOD
                    result *= math.comb(o_available, o_pick)
                    result %= MOD
                    result *= dp(i + 1, e_available - e_pick, o_available - o_pick, diff + (o_pick - e_pick) * i)
                    result %= MOD
                    total_result += result
            return total_result % MOD

        return dp(0, e, o, 0)

 ",1441342495
nemokwy,nemokwy,82,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        ret = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0))
        ret[0][0] = 0
        while h:
            t, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m and ret[u][v] > max(moveTime[u][v]+1, t+1):
                    ret[u][v] = max(moveTime[u][v]+1, t+1)
                    heappush(h, (ret[u][v], u, v))
        return ret[-1][-1]",1441292753
nemokwy,nemokwy,82,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        r0 = [[inf] * m for _ in range(n)]
        r1 = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0, 0))
        r0[0][0] = 0
        while h:
            t, p, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m:
                    if p == 0:
                        if r1[u][v] > max(moveTime[u][v]+1, t+1):
                            r1[u][v] = max(moveTime[u][v]+1, t+1)
                            heappush(h, (r1[u][v], 1, u, v))
                    else:
                        if r0[u][v] > max(moveTime[u][v]+2, t+2):
                            r0[u][v] = max(moveTime[u][v]+2, t+2)
                            heappush(h, (r0[u][v], 0, u, v))
        if r0[-1][-1] == inf:
            return r1[-1][-1]
        if r1[-1][-1] == inf:
            return r0[-1][-1]
        return max(r0[-1][-1], r1[-1][-1])",1441309614
nemokwy,nemokwy,82,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a, b = 0, 0
        for i,c in enumerate(num):
            if i & 1:
                a += int(c)
            else:
                b += int(c)
        return a == b",1441281344
nemokwy,nemokwy,82,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        ret = 0
        d = [0] * 10
        s = 0
        for i, c in enumerate(num):
            d[int(c)] += 1
            s += int(c)
        if s & 1:
            return 0
        v = s // 2
        @lru_cache(None)
        def C(n, m):
            a = 1
            for i in range(m):
                a = a * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD
            return a

        @lru_cache(None)
        def chk(tp, tq, p, q, t):
            if t == 0:
                if tp or tq:
                    return 0
                return 1
            ret = 0
            for i in range(d[t]+1):
                if tp < i * t or tq < (d[t]-i) * t:
                    continue
                ret += C(p, i) * C(q, d[t]-i) * chk(tp - i * t, tq - (d[t]-i) * t, p - i, q - (d[t]-i), t - 1) % MOD
            # print(tp, tq, p, q, t, ret)
            return ret % MOD
        return chk(v, s - v, len(num) // 2,len(num) - len(num) // 2, 9)",1441336421
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0):0}
        h = [(0,0,0)]
        while h:
            c,x,y = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and (nx,ny) not in dist:
                    dist[nx,ny] = max(1 + moveTime[nx][ny], 1 + c)
                    heapq.heappush(h, (dist[nx,ny], nx, ny))
                ",1441290546
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0,0):0}
        h = [(0,0,0,0)]
        while h:
            c,x,y,p = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            if dist[(x,y,p)] != c:
                continue
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and dist.get((nx,ny,1-p), inf) > p + 1 + max(moveTime[nx][ny], c):
                    dist[nx,ny,1-p] = p + 1 + max(moveTime[nx][ny], c)
                    heapq.heappush(h, (dist[nx,ny,1-p], nx, ny, 1-p))
                ",1441294236
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ret = 0
        for i in range(len(num)):
            x = int(num[i])
            if i % 2:
                ret += x
            else:
                ret -= x
        return ret == 0",1441280896
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3637,python3,"MOD = 10**9+7

@cache
def comb(x, y):
    if y == 0 or y == x:
        return 1
    return (comb(x-1, y-1) + comb(x-1, y)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        SM = 0
        l = [0] * 10
        tot = [0] * 10
        tc = [0] * 10
        for x in num:
            l[int(x)] += 1
            SM += int(x)
        if SM % 2:
            return 0
        for i in range(10):
            tot[i] = (0 if i == 0 else tot[i-1]) + l[i] * i
            tc[i] = (0 if i == 0 else tc[i-1]) + l[i]
        # print(tot)
        # print(tc)
        # print(l)
        
        @cache
        def dp(idx, ct, sm):
            # print(idx, ct, sm)
            if idx == -1:
                # print(idx, ct, sm)
                return int(ct == 0 and sm == 0)
            ct2 = tc[idx] - ct
            sm2 = tot[idx] - sm
            # print(idx, ct, sm, ct2, sm2)
            ret = 0
            for t in range(l[idx] + 1):
                # print(t, l[idx] - t > ct2, sm > (idx) * t, sm2 > (idx) * (l[idx] - t))
                if t > ct or l[idx] - t > ct2 or sm < (idx) * t or sm2 < (idx) * (l[idx] - t):
                    continue
                v = dp(idx-1, ct - t, sm - (idx) * t)
                ret += comb(ct, t) * comb(ct2, l[idx] - t) * v % MOD
                ret %= MOD
                # print(idx, ct, sm, ret)
            return ret

        return dp(9, (len(num)+1)//2, SM//2)
                
                ",1441343521
thedude7181,thedude7181,85,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, row, col = heappop(q)
            if (row, col) in vis:
                continue
            vis.add((row, col))
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1, moveTime[nrow][ncol] + 1), nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441297537
thedude7181,thedude7181,85,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, movecost, row, col = heappop(q)
            if (row, col, movecost) in vis:
                continue
            vis.add((row, col, movecost))
            new_movecost = (movecost + 1) % 2 
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1 + movecost, moveTime[nrow][ncol] + 1 + movecost), new_movecost, nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441305265
thedude7181,thedude7181,85,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0 
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return odd == even",1441287722
thedude7181,thedude7181,85,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def helper(d, s, ecnt, ocnt):
            if s < 0:
                return 0
            if ecnt < 0:
                return 0
            if ocnt < 0:
                return 0
            if d > 9:
                return s == 0
            res = 0
            for i in range(digit_cnts[d] + 1):
                res += comb(ecnt, i) * helper(d + 1, s - (d * i), ecnt - i, ocnt - (digit_cnts[d] - i)) * comb(ocnt, digit_cnts[d] - i)
            return res % mod

        target_cnt = len(num) // 2
        mod = 1_000_000_007
        num = [int(n) for n in num]
        sum_ = sum(num)
        if sum_ % 2 != 0:
            return 0
        target_s = sum_ // 2
        digit_cnts = Counter(num)
        res = helper(0, target_s, (len(num) + 1) // 2, len(num) // 2)
        helper.cache_clear()
        return res",1441343532
Ethan,Ethan038,86,3627,cpp,"
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    int minTimeToReach(vector<vi>& mvtm) {
        return [](vector<vi>& mvtm) -> int {
            int n = mvtm.size();
            int m = mvtm[0].size();
            
            vector<vll> dis(n, vll(m, LLONG_MAX));
            dis[0][0] = 0;
            
            priority_queue<pair<ll, pi>, 
                          vector<pair<long long, pair<int, int>>>, 
                          greater<>> pq;
            pq.push({0, {0, 0}});
            
            vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            
            while (!pq.empty()) {
                auto [currtm, cor] = pq.top();
                auto [x, y] = cor;
                pq.pop();
                
                if (currtm > dis[x][y]) continue;
                
                for (auto [dx, dy] : dirs) {
                    int nex = x + dx;
                    int ny = y + dy;
                    
                    if (nex >= 0 && nex < n && ny >= 0 && ny < m) {
                        long long waitTime = max(0LL, mvtm[nex][ny] - currtm);
                        long long ntm = currtm + waitTime + 1;
                        
                        if (ntm < dis[nex][ny]) {
                            dis[nex][ny] = ntm;
                            pq.push({ntm, {nex, ny}});
                        }
                    }
                }
            }
            
            return dis[n-1][m-1];
        }(mvtm);
    }
};",1441292430
Ethan,Ethan038,86,3628,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;
int a[N]; 
bool c[N]; 

class Solution {
public:
   int minTimeToReach(vector<vi>& mt) {
       int n = mt.size();
       int m = mt[0].size();
       
       vector<vll> ans(n, vll(m, LLONG_MAX));
       ans[0][0] = 0;
       
       priority_queue<pair<ll, vi>, vector<pair<ll, vi>>, greater<>> pq;
       pq.push({0, {0, 0, 0}});
       
       auto chk = mt;
       
       vector<pi> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
       
       auto isValid = [&](int x, int y) -> bool {
           return x >= 0 && x < n && y >= 0 && y < m;
       };
       
       auto nxtmv = [](int mvtyp) -> int {
           return 1 - mvtyp; 
       };
       
       auto gcst = [](int mvtyp) -> int {
           return (mvtyp == 0) ? 1 : 2;
       };
       
       auto getm = [](long long xrrtm, int tartime, int mvcst) -> long long {
           return max((long long)tartime, xrrtm) + mvcst;
       };
       
       while(!pq.empty()) {
           auto [time, pos] = pq.top();
           auto x = pos[0], y = pos[1], mvtyp = pos[2];
           pq.pop();
           
           if(time > ans[x][y]) continue;
           
           for(auto [dx, dy] : dirs) {
               int nx = x + dx;
               int ny = y + dy;
               
               if(isValid(nx, ny)) {
                   int mvcst = gcst(mvtyp);
                   ll ntm = getm(time, chk[nx][ny], mvcst);
                   
                   if(ntm < ans[nx][ny]) {
                       ans[nx][ny] = ntm;
                       pq.push({ntm, {nx, ny, nxtmv(mvtyp)}});
                   }
               }
           }
       }
       
       return ans[n-1][m-1];
   }
};
",1441302877
Ethan,Ethan038,86,3636,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    bool isBalanced(string num) {
        return [](string num) -> bool {
            int evenSum = 0, oddSum = 0;
            rep(i, 0, num.length()) {
                (i % 2 == 0) ? evenSum += num[i] - '0' : oddSum += num[i] - '0';
            }
            return evenSum == oddSum;
        }(num);
    }
};",1441288482
Ethan,Ethan038,86,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;

class Solution { 
public: 
   const int MOD = 1e9 + 7;

   ll countBalancedPermutations(string num) {
       auto solv4 = [](ll x, ll y, ll mod) -> ll {
           ll res = 1;
           x %= mod;
           while(y > 0) {
               if(y & 1) res = res * x % mod;  x = x * x % mod;   y >>= 1;
           }
           return res;
       };
       
       auto solv2 = [&](vll& fc, vll& kp, int maxN) {
           fc.resize(maxN + 1, 1);
           rep(i,1,maxN+1) fc[i] = fc[i-1] * i % MOD;
           kp.resize(maxN + 1, 1);
           kp[maxN] = solv4(fc[maxN], MOD - 2, MOD);
           for(int i = maxN-1; i >= 0; --i) kp[i] = kp[i+1] * (i+1) % MOD; };auto km = num; auto sp = num;
       
       auto solv3 = [](const string& s) -> pair<array<int,10>, ll> {
           array<int,10> cnt{};
           ll sum = 0;
           for(char c : s) {
               cnt[c-'0']++;
               sum += (c-'0');
           }
           return {cnt, sum};
       };
       
       int L = num.length();
       auto [cnts, tsum] = solv3(num);
       
       if(tsum % 2) return 0;
       
       ll smevn = tsum / 2;
       int k = (L + 1) / 2;
       
       vll fc, kp;
       solv2(fc, kp, L);
       
       auto solvdp = [&](int d, const vector<vll>& pdp, int cntd) -> vector<vll> {
           vector<vll> tmdp(k + 1, vll(smevn + 1, 0));
           rep(c,0,k+1) {
               rep(s,0,smevn+1) {
                   if(pdp[c][s] == 0) continue;
                   int maxA = min(cntd, k - c);
                   rep(aD,0,maxA+1) {
                       ll nec = c + aD;   ll nws = s + (ll)d * aD;    if(nws > smevn) continue;
                       tmdp[nec][nws] = (tmdp[nec][nws] + 
                           pdp[c][s] * kp[aD] % MOD *   kp[cntd - aD] % MOD) % MOD;
                   }
               }
           }
           return tmdp;
       };

       vector<vll> pdp(k + 1, vll(smevn + 1, 0));  pdp[0][0] = 1;
       
       rep(d,0,10) {
           pdp = solvdp(d, pdp, cnts[d]);
       }
       
       ll vlid = pdp[k][smevn];
       ll anas = fc[k] * fc[L - k] % MOD;
       anas = anas * vlid % MOD;
       
       return (int)anas;
   }
};
",1441343539
Only My Railgun,Quar,89,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0)] # t, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1
                    yield tt, rr, cc
        
        while heap:
            t, ir, ic = heappop(heap)
            
            for tt, rr, cc in get_neighbor(t, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]

            ",1441293619
Only My Railgun,Quar,89,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0, 0)] # t, additional_time, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, dt, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1 + dt
                    yield tt, 1 - dt, rr, cc
        
        while heap:
            t, d, ir, ic = heappop(heap)
            
            for tt, dd, rr, cc in get_neighbor(t, d, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, dd, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]
",1441296911
Only My Railgun,Quar,89,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = str(num)
        even = sum(int(s[i]) for i in range(0, len(s), 2))
        odd = sum(int(s[i]) for i in range(1, len(s), 2))
        return even == odd
",1441281831
Only My Railgun,Quar,89,3637,python3,"from math import comb
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        cnt = [0] * 10
        for c in num:
            cnt[int(c)] += 1
            
        total_sum = sum(x * c for x, c in enumerate(cnt))
        
        if total_sum % 2 == 1:
            return 0
        
        target_sum = total_sum // 2
        
        MODULO = 10**9 + 7
        
        @cache
        def dp(i, rem_even, rem_odd, rem_even_sum):
            if rem_even == 0:
                if rem_even_sum != 0:
                    return 0
                ret = 1
                for j in range(i, 10):
                    ret = ret * comb(rem_odd, cnt[j]) % MODULO
                    rem_odd -= cnt[j]
                return ret
            
            if rem_even_sum > 0 and rem_even == 0:
                return 0
            
            if 0 < rem_even_sum < i:
                return 0
            
            ret = 0
            max_even_take = cnt[i] if i == 0 else min(cnt[i], rem_even_sum // i)
            max_even_take = min(max_even_take, rem_even)
            
            for even_take in range(0, max_even_take + 1):
                odd_take = cnt[i] - even_take
                if odd_take > rem_odd:
                    continue
                coeff = (comb(rem_even, even_take) % MODULO) * (comb(rem_odd, odd_take) % MODULO) % MODULO
                rest = dp(i + 1, rem_even - even_take, rem_odd - odd_take, rem_even_sum - i * even_take)
                ret += coeff * rest % MODULO
            
            return ret % MODULO
        
        n_odd = len(num) // 2
        n_even = len(num) - n_odd
        
        return dp(0, n_even, n_odd, target_sum)
                
            
                
        ",1441338510
carlostagosaku,carlostagosaku,90,3627,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 1
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441300648
carlostagosaku,carlostagosaku,90,3628,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 2
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441299342
carlostagosaku,carlostagosaku,90,3636,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

class Solution:
    def isBalanced(self, num: str) -> bool:
        X = list(num)
        X = [int(x) for x in X]
        if sum(x for x in X[1::2])==sum(x for x in X[0::2]):
            return True
        else:
            return False  ",1441302147
carlostagosaku,carlostagosaku,90,3637,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

mod = 10**9 + 7
CC = combination(10**6,mod)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        S = list(num)
        S = [int(x) for x in S]
        W = sum(S)
        if W%2==1:
            return 0
        n = len(S)
        target = W//2
        m = n//2
        dp = [[0]*(target+2) for _ in range(m+1)]
        dp[0][0] = 1
        for s in S:
            for i in range(target,-1,-1):
                for j in range(m-1,-1,-1):
                    dp[j+1][min(i+s,target+1)] = (
                        dp[j+1][min(i+s,target+1)]
                        + dp[j][i]
                    )%mod
        ans = 1
        C = Counter(S)
        
        ans = dp[m][target]*CC.fact[m]*CC.fact[n-m]%mod
        # print(dp,C)
        for v in C.values():
            ans = (ans * CC.factinv[v])%mod

        return ans",1441325130
aqxa2k,aqxa2k,91,3627,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<int>> d(n, vector<int>(m, -1)); 
        d[0][0] = 0; 

        set<array<int, 3>> st; 
        st.insert({d[0][0], 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny] == -1) {
                        d[nx][ny] = max(t + 1, a[nx][ny] + 1); 
                        st.insert({d[nx][ny], nx, ny}); 
                    }
                }
            }
        }

        return d[n - 1][m - 1]; 
        
    }
};",1441296110
aqxa2k,aqxa2k,91,3628,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2000000000))); 
        d[0][0][0] = 0; 

        set<array<int, 4>> st; 
        st.insert({0, 0, 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0], z = c[3]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny][z ^ 1] == 2000000000) {
                        d[nx][ny][z ^ 1] = max(t + 1 + z, a[nx][ny] + 1 + z); 
                        st.insert({d[nx][ny][z ^ 1], nx, ny, z ^ 1}); 
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]); 
        
    }
};",1441300647
aqxa2k,aqxa2k,91,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> c(2, 0); 
        for (int i = 0; i < num.size(); ++i) {
            c[i % 2] += (num[i] - '0'); 
        }
        return c[0] == c[1]; 
    }
};",1441281197
aqxa2k,aqxa2k,91,3637,cpp,"template <typename T>
T inverse(T a, T m) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = m / a;
		m -= t * a; swap(a, m);
		u -= t * v; swap(u, v);
	}
	assert(m == 1);
	return u;
}

template<class T>
T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

template <typename T>
class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {

    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));

        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
            long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
            value = normalize(value * rhs.value - q * mod());
            return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
            value = normalize(value * rhs.value);
            return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
};
template <typename T> bool operator>(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value > rhs.value; }
template <typename T, typename U> bool operator>(const Modular<T>& lhs, U rhs) { return lhs > Modular<T>(rhs); }
template <typename T, typename U> bool operator>(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) > rhs; }

template <typename T> bool operator>=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value >= rhs.value; }
template <typename T, typename U> bool operator>=(const Modular<T>& lhs, U rhs) { return lhs >= Modular<T>(rhs); }
template <typename T, typename U> bool operator>=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) >= rhs; }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
template <typename T, typename U> bool operator<(const Modular<T>& lhs, U rhs) { return lhs < Modular<T>(rhs); }
template <typename T, typename U> bool operator<(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) < rhs; }

template <typename T> bool operator<=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value <= rhs.value; }
template <typename T, typename U> bool operator<=(const Modular<T>& lhs, U rhs) { return lhs <= Modular<T>(rhs); }
template <typename T, typename U> bool operator<=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) <= rhs; }

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string ss) {
        vector<int> a; 
        for (char c: ss) a.push_back(c - '0'); 

        int s = accumulate(a.begin(), a.end(), 0); 
        if (s % 2) return 0; 

        int n = a.size(); 
        vector<int> f(10, 0); 
        for (int i = 0; i < n; ++i) f[a[i]]++; 

        s /= 2;  
        
        vector<vector<Mint>> dp(n + 1, vector<Mint>(s + 1, Mint(0))); 
        dp[0][0] = 1; 

        int hv = 0; 
        for (int v = 0; v < 10; ++v) {
            vector<vector<Mint>> dp2(n + 1, vector<Mint>(s + 1, Mint(0))); 
            
            for (int c = 0; c <= f[v]; ++c) {
                for (int i = 0; i + c <= n; ++i) {
                    for (int j = 0; j + (c * v) <= s; ++j) {
                        dp2[i + c][j + (c * v)] += dp[i][j] * C(i + c, c) * C(hv - i + f[v] - c, f[v] - c); 
                    }
                }
            }

            hv += f[v]; 
            dp = dp2; 
        }

        int ans = (int)dp[n / 2][s]; 
        return ans; 
        // return (dp[n / 2][s]) % md; 
    }
};",1441333231
user5860c,user5860c,92,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 1;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441345728
user5860c,user5860c,92,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 2;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441344214
user5860c,user5860c,92,3636,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
class Solution {
public:
    bool isBalanced(string v) {
        int o1 = 0;
        int o2 = 0;
        FOR(i, sz(v)) {
            if (i%2) {
                o1 += v[i] - '0';
            } else {
                o2 += v[i] - '0';
            }
        }
        return o1 == o2;
    }
};",1441346769
user5860c,user5860c,92,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;


// N ~ 10^6
class Combinations {
public:
  vector<mint> inv, fact, ifact;

  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};

Combinations comb(1000);

mint best[11][82*10][82];

class Solution {
public:
    int countBalancedPermutations(string v) {
        int sum = 0;
        vi cnt(10);
        for (auto x : v) {
            sum += (x-'0');
            cnt[x-'0']++;
        }
        if (sum%2) return 0;
        for (int i=0;i<=10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    best[i][s][k] = 0;
                }
            }
        }
        best[0][0][0] = 1;
        int placed = 0;
        for (int i=0;i<10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    for (int j=0;j<=cnt[i] && s + j * i <= sum/2;++j) {
                        if (best[i][s][k].x == 0) continue;
                        //cout << i << "" "" << k << "" "" << j << "" "" << s << "" "" << endl;
                        //cout << i+1 << "" "" << s + j * (i) << "" "" << k + j << endl;
                        best[i+1][s + j * (i)][k+j] += 
                            best[i][s][k] * ( comb.comb(k+j,j) * comb.comb(placed-k+cnt[i]-j, cnt[i]-j));
                        //cout << best[i][s][k] * ( comb.comb(k+j,j) + comb.comb(placed-k+cnt[i]-j, cnt[i]-j)) << endl;
                    }
                }
            }
            placed += cnt[i];
        }
        mint ret = best[10][sum/2][(sz(v)+1)/2];
        return ret.x;
    }
};",1441318305
Abhishek Choudhary,theabbie,94,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441294424
Abhishek Choudhary,theabbie,94,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1 if even else 2
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441293690
Abhishek Choudhary,theabbie,94,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = [0, 0]
        for i in range(len(num)):
            s[i % 2] += int(num[i])
        return s[0] == s[1]",1441295519
Abhishek Choudhary,theabbie,94,3637,python3,"M = 10 ** 9 + 7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        f = [1] * (n + 1)
        rf = [1] * (n + 1)
        for i in range(1, n + 1):
            f[i] = i * f[i - 1]
            f[i] %= M
            rf[i] = pow(f[i], M - 2, M)
        ctr = [0] * 10
        s = 0
        for c in num:
            s += int(c)
            ctr[int(c)] += 1
        if s & 1:
            return 0
        cache = [[[-1] * ((s // 2) + 1) for _ in range(n + 1)] for _ in range(10)]
        def dp(d, l, rem):
            if d > 9:
                return int(l == 0 and rem == 0)
            if cache[d][l][rem] != -1:
                return cache[d][l][rem]
            res = 0
            for take in range(ctr[d] + 1):
                if take > l or d * take > rem:
                    continue
                res += rf[take] * rf[ctr[d] - take] * dp(d + 1, l - take, rem - d * take)
                res %= M
            cache[d][l][rem] = res
            return res
        return (f[n // 2] * f[n - (n // 2)] * dp(0, n // 2, s // 2)) % M",1441348952
furuyarei,furuyarei,95,3627,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            d, x, y = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny) not in dist or max(d, a[nx][ny]) + 1 < dist[(nx, ny)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + 1, nx, ny))
                        dist[(nx, ny)] = max(d, a[nx][ny]) + 1
        return dist[(m - 1, n - 1)]
        ",1441293432
furuyarei,furuyarei,95,3628,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0, 1)]
        dist = {(0, 0, 1): 0}
        while q:
            d, x, y, cost = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny, 3 - cost) not in dist or max(d, a[nx][ny]) + cost < dist[(nx, ny, 3 - cost)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + cost, nx, ny, 3 - cost))
                        dist[(nx, ny, 3 - cost)] = max(d, a[nx][ny]) + cost
        return min(dist.get((m - 1, n - 1, 1), inf), dist.get((m - 1, n - 1, 2), inf))",1441297122
furuyarei,furuyarei,95,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        p = q = 0
        for i, ch in enumerate(num):
            if i % 2 == 0:
                p += int(ch)
            else:
                q += int(ch)
        return p == q",1441286385
furuyarei,furuyarei,95,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        
        @cache
        def C(n, k):
            if n < k:
                return 0
            if k == 0:
                return 1
            return (C(n - 1, k - 1) + C(n - 1, k)) % MOD

        @cache
        def S2(n, k):
            # print(n + k - 1, k - 1)
            return C(n + k - 1, k - 1)

        c = Counter(int(d) for d in num)
        # print(c)
        
        @cache
        def f(x, p1, p2, diff):
            if x == 10:
                return int(p1 == p2 == diff == 0)

            alloc = c.get(x, 0)
            ans = 0
            for q1 in range(alloc + 1):
                q2 = alloc - q1
                if q1 > p1 or q2 > p2:
                    continue
                coef = S2(q1, p1 - q1 + 1) * S2(q2, p2 - q2 + 1) % MOD
                ans += coef * f(x + 1, p1 - q1, p2 - q2, diff + (q1 - q2) * x) % MOD
            #     print(f""coef = {q1} {p1 - q1 + 1} {q2} {p2 - q2 + 1} = {S2(q1, p1 - q1 + 1)} {S2(q2, p2 - q2 + 1)}"")
            #     print(f""from = {x + 1} {p1 - q1} {p2 - q2} {diff + (q1 - q2) * x}"")
            # print(f""{x} {p1} {p2} {diff} = {ans}"")
            return ans % MOD

        l = len(num)
        ans = f(0, (l + 1) // 2, l // 2, 0)
        C.cache_clear()
        S2.cache_clear()
        f.cache_clear()
        return ans",1441349069
Nicholas,nicholask_17,97,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
using pii=pair <int,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m];
        bool visited[n][m];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                dist[i][j]=2e9;
                visited[i][j]=0;
            }
        }
        priority_queue <pair <int,pii>,vector <pair <int,pii> >,greater <pair <int,pii> > > pq;
        dist[0][0]=0; pq.push({0,{0,0}});
        while (!pq.empty()){
            pair <int,pii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first][tp.second.second]) continue;
            visited[tp.second.first][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first+dx[dir],ny=tp.second.second+dy[dir];
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny]) continue;
                if (max(tp.first,moveTime[nx][ny])+1<dist[nx][ny]){
                    dist[nx][ny]=max(tp.first,moveTime[nx][ny])+1;
                    pq.push({dist[nx][ny],{nx,ny}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441298407
Nicholas,nicholask_17,97,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using pii=pair <int,int>;
        using tii=pair <pii,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m][2];
        bool visited[n][m][2];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                for (int k=0; k<2; k++){
                    dist[i][j][k]=2e9;
                    visited[i][j][k]=0;
                }
            }
        }
        priority_queue <pair <int,tii>,vector <pair <int,tii> >,greater <pair <int,tii> > > pq;
        dist[0][0][0]=0; pq.push({0,{{0,0},0}});
        while (!pq.empty()){
            pair <int,tii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first.first][tp.second.first.second][tp.second.second]) continue;
            visited[tp.second.first.first][tp.second.first.second][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first.first+dx[dir],ny=tp.second.first.second+dy[dir],nz=1-tp.second.second;
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny][nz]) continue;
                if (max(tp.first,moveTime[nx][ny])+(nz==1?1:2)<dist[nx][ny][nz]){
                    dist[nx][ny][nz]=max(tp.first,moveTime[nx][ny])+(nz==1?1:2);
                    pq.push({dist[nx][ny][nz],{{nx,ny},nz}});
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441303421
Nicholas,nicholask_17,97,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0,sum2=0;
        for (int i=0; i<num.size(); i++){
            if (i%2==0) sum1+=num[i]-'0';
            else sum2+=num[i]-'0';
        }
        return sum1==sum2;
    }
};",1441281077
Nicholas,nicholask_17,97,3637,cpp,"class Solution {
public:
    const long long mod=1e9+7LL;
    long long f[100],inv[100],finv[100];
    void init(){
        f[0]=f[1]=inv[0]=inv[1]=finv[0]=finv[1]=1;
        for (int i=2; i<100; i++){
            f[i]=f[i-1]*i%mod;
            inv[i]=inv[mod%i]*(mod-mod/i)%mod;
            finv[i]=finv[i-1]*inv[i]%mod;
        }
    }
    long long ncr(int n,int r){
        if (n<r||r<0) return 0;
        return f[n]*finv[n-r]%mod*finv[r]%mod;
    }
    int countBalancedPermutations(string num) {
        init();
        int n=num.size();
        int sum=0;
        for (char i:num) sum+=i-'0';
        if (sum%2) return 0;
        int cnt[10];
        for (int i=0; i<10; i++) cnt[i]=0;
        for (char i:num) cnt[(i-'0')]++;
        int dp[11][41][1500];
        for (int i=0; i<11; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++) dp[i][j][k]=0;
            }
        }
        dp[0][0][750]=1;
        int done=0;
        for (int i=0; i<10; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++){
                    if (!dp[i][j][k]) continue;
                    for (int l=0; l<=cnt[i]&&j+l<41; l++){
                        long long way=ncr((n+1)/2-j,l)*ncr(n/2-(done-j),cnt[i]-l)%mod;
                        if (k+i*l-(cnt[i]-l)*i>=0&&k+i*l-(cnt[i]-l)*i<1500){
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]+=way*dp[i][j][k]%mod;
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]%=mod;
                        }
                    }
                }
            }
            done+=cnt[i];
        }
        int ans=0;
        for (int i=0; i<41; i++) ans=(ans+dp[10][i][750])%mod;
        return ans;
    }
};",1441322955
Dhruv Pasricha,pasricha_dhruv,99,3627,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441317612
Dhruv Pasricha,pasricha_dhruv,99,3628,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = h == 1 ? 2 : 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441316521
Dhruv Pasricha,pasricha_dhruv,99,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i = 0; i < n; ++i)
        {
            num[i] -= '0';
            if(i % 2 == 0) sum1 += num[i];
            else sum2 += num[i];
        }
        return sum1 == sum2;
    }
};",1441281493
Dhruv Pasricha,pasricha_dhruv,99,3637,cpp,"#define int long long

const int N = 1e2 + 10, MOD = 1e9 + 7, mod = 1e9 + 7;
 
int fact[N + 1], invFact[N + 1];
 
// x^n % MOD
int power(int x, int n)
{
    if(n == 0)
    {
        return 1;
    }
 
    if(n % 2 == 0)
    {
        int ans = power(x, n / 2);
        ans = (ans * ans) % MOD;
        return ans;
    }
 
    return (x * power(x, n - 1)) % MOD;
}
 
// mod inverse
int modInverse(int x)
{
    return power(x, MOD - 2);
}
 
void pre()
{
    fact[0] = 1;
    for(int i = 1; i <= N; ++i)
    {
        fact[i] = (i * fact[i - 1]) % MOD;
    }
 
    for(int i = 0; i <= N; ++i)
    {
        invFact[i] = modInverse(fact[i]);
    }
}
 
int Binomial(int n, int r)
{
    if(r > n or n < 0 or r < 0) return 0;

    int ans = fact[n];
    ans *= invFact[n - r];
    ans %= MOD;
    ans *= invFact[r];
    ans %= MOD;
    return ans;
}
 
int freq[10], dp[10][42][410];

int solve(int cur, int remOddPlaces, int remEvenPlaces, int remOddSum, int remEvenSum)
{
    if(remOddPlaces < 0 or remEvenPlaces < 0 or remOddSum < 0 or remEvenSum < 0)
        return 0;
    
    if(cur == -1)
    {
        return 1;
    }

    if(dp[cur][remOddPlaces][remOddSum] != -1) return dp[cur][remOddPlaces][remOddSum]; 

    int ans = 0;
    for(int even = 0; even <= freq[cur]; ++even)
    {
        int odd = freq[cur] - even;

        int curAns = (Binomial(remOddPlaces, odd) * Binomial(remEvenPlaces, even)) % mod;
        curAns *= solve(cur - 1, remOddPlaces - odd, remEvenPlaces - even, remOddSum - odd * cur, remEvenSum - even * cur);
        curAns %= mod;

        ans += curAns;
        ans %= mod;
    }

    return dp[cur][remOddPlaces][remOddSum] = ans;
}

class Solution {
public:
    int countBalancedPermutations(string num) {

        pre();
        memset(freq, 0, sizeof(freq));
        memset(dp, -1, sizeof(dp));
    
        int sum = 0;
        for(auto it : num)
        {
            sum += it - '0';
            freq[it - '0']++;
        }
    
        if(sum % 2 == 1)
        {
            return 0;
        }

        int n = num.size();

        return solve(9, (n + 1) / 2, n / 2, sum / 2, sum / 2);
    }
};

#undef int",1441343833
Behrooz Sepehry,sepehry,100,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj

        node0 = (0, 0)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))

        return visited_dist[(n - 1, m - 1)]
",1441295828
Behrooz Sepehry,sepehry,100,3628,python3,"
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j, odd = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj, not odd

        node0 = (0, 0, True)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (node2[2] + max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))
        sol = float('inf')

        if (n - 1, m - 1, False) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, False)])
        if (n - 1, m - 1, True) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, True)])

        return sol
",1441311181
Behrooz Sepehry,sepehry,100,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])
",1441281738
Behrooz Sepehry,sepehry,100,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cc = collections.Counter(num)
        F = [cc[str(ii)] for ii in range(10)]

        mod = ((10 ** 9) + 7)

        @functools.lru_cache(None)
        def dp(d, rem_odd, rem_even, balance):
            if d == -1:
                return rem_odd == 0 and rem_even == 0 and balance == 0
            f = F[d]
            min_f_odd = max(0, f - rem_even)
            max_f_odd = min(rem_odd, f)
            vvv = 0
            for f_odd in range(min_f_odd, max_f_odd + 1):
                f_even = f - f_odd
                vvv += ((math.comb(rem_odd, f_odd) % mod) * (math.comb(rem_even, f_even) % mod) * dp(d - 1,
                                                                                                     rem_odd - f_odd,
                                                                                                     rem_even - f_even,
                                                                                                     balance + (
                                                                                                                 f_odd - f_even) * d)) % mod
                vvv %= mod

            return vvv

        n2 = n // 2
        sol = dp(9, n2, n - n2, 0)
        dp.cache_clear()
        return sol % mod
",1441343869
Aryan470,Aryan470,102,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, i, j = heapq.heappop(q)
            if i == n-1 and j == m-1:
                return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                # check the time at which we can reach this guy
                this_reach = max(curr_time + 1, moveTime[u][v] + 1)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, u, v))
    
                ",1441291107
Aryan470,Aryan470,102,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, True, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, first_move, i, j = heapq.heappop(q)
            # if i == n-1 and j == m-1:
                # return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                delta_time = 1 if first_move else 2
                # check the time at which we can reach this guy
                this_reach = max(curr_time + delta_time, moveTime[u][v] + delta_time)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, not first_move, u, v))
        
        return reach_time[(n-1,m-1)]
    
                ",1441294437
Aryan470,Aryan470,102,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            dig = int(num[i])
            if i % 2 == 0:
                es += dig
            else:
                os += dig
        return es == os",1441280972
Aryan470,Aryan470,102,3637,python3,"from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # sum of digs has to be 2k
        # how many ways can we choose n//2 digs with sum k
        # then how many ways can we permute those
        sum_digs = sum(int(c) for c in num)
        if sum_digs % 2 != 0:
            return 0
        
        target_sum = sum_digs // 2
        num_to_choose = len(num) // 2
        # first n digits with sum k
        # choose z digits with sum k
        # sum can be up to 80 * 9 and num digs can be up to 80
        # dp[i][k] = num sets of i digits with sum k

        max_sum = target_sum
        dp = [[0 for j in range(max_sum+1)] for i in range(num_to_choose + 1)]
        dp[0][0] = 1

        for i in range(len(num)):
            dig = int(num[i])
            for num_dig in range(num_to_choose, 0, -1):
                for k in range(dig, max_sum+1):
                    if k - dig >= 0:
                        dp[num_dig][k] += dp[num_dig - 1][k - dig]
        num_partitions = dp[num_to_choose][target_sum]
        # if 2 * num_to_choose == len(num):
            # num_partitions //= 2
        # print(dp)
        # print(num_partitions)
        # now given this, for each partition we can make some permutations
        # how many ways can we permute num_to_choose numbers * (n - num_to_choose) // (num 0! * num 1! * num 2!)
        def fact(x):
            prod = 1
            for u in range(2,x+1):
                prod *= u
            return prod
            
        ans = num_partitions * fact(num_to_choose) * fact(len(num) - num_to_choose)
        # print(ans)
        digcnt = Counter(int(c) for c in num)
        for dig, cnt in digcnt.items():
            if cnt > 1:
                ans //= fact(cnt)
        return ans % (10**9 + 7)",1441338715
Remineva,Remineva,103,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= di < m and 0 <= dj < n:
                    new = max(t, moveTime[di][dj]) + 1
                    if new < time[di][dj]:
                        time[di][dj] = new
                        heappush(h, (new, di, dj))

",1441301058
Remineva,Remineva,103,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0, True)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j, flag = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            if flag:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 1
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, False))
            else:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 2
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, True))
",1441309971
Remineva,Remineva,103,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        flag = True
        for c in num:
            if flag:
                s += int(c)
            else:
                s -= int(c)
            flag = not flag
        return s == 0",1441280982
Remineva,Remineva,103,3637,python3,"M = 10 ** 9 + 7
def ncr(n, r, p):
    num = den = 1 
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p
m = 100 + 1
fac = [1] * m
for i in range(2, m):
    fac[i] = fac[i-1] * i % M

inv = [1] * m
inv[-1] = pow(fac[-1], M - 2, M)
for i in range(m - 2, 1, -1):
    inv[i] = inv[i+1] * (i + 1) % M
    
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        s = 0
        cnt = [0] * 10
        for c in num:
            curr = int(c)
            s += curr
            cnt[curr] += 1
        if s & 1:
            return 0
        s //= 2
        n = len(num)
        m = (n + 1) // 2
        
        dp = [[0] * (s + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        for digit in range(10):
            temp = cnt[digit]
            if temp == 0:
                continue
            
            for i in range(m, -1, -1):
                for j in range(s, -1, -1):
                    if dp[i][j] == 0:
                        continue
                    for di in range(1, min(temp, m - i) + 1):
                        dj = di * digit
                        if j + dj > s:
                            break
                        dp[i + di][j + dj] += dp[i][j] * ncr(temp, di, M)
                        dp[i + di][j + dj] %= M
        res = dp[-1][-1]
        f = 1
        for digit in range(10):
            f = f * fac[cnt[digit]] % M
        inv_f = pow(f, M - 2, M)
        
        res *= fac[m] * fac[n - m]
        res %= M
        res *= inv_f
        res %= M
        return res

        ",1441345758
M Kawa,mkawa222,107,3627,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            nd=max(d+1,mt[ni][nj]+1)
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441297946
M Kawa,mkawa222,107,3628,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            cost=((i^j)&1)+1
            nd=max(d,mt[ni][nj])+cost
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441315942
M Kawa,mkawa222,107,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s=0
        p=1
        for c in num:
            s+=int(c)*p
            p=-p
        return s==0

",1441285811
M Kawa,mkawa222,107,3637,python3,"def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

md = 10**9+7
n_max = 200
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        aa = list(map(int, num))
        s = sum(aa)
        if s & 1: return 0
        s >>= 1
        n = len(aa)
        m = n//2
        em = n-m
        cnt = [0]*10
        for a in aa: cnt[a] += 1
        dp = [[0]*(s+1) for _ in range(m+1)]
        dp[0][0] = 1
        si = sj = 0
        for a in range(10):
            if cnt[a] == 0: continue
            ndp = [[0]*(s+1) for _ in range(m+1)]
            for i in range(m+1)[::-1]:
                ei = si-i
                for j in range(s+1):
                    pre = dp[i][j]
                    if pre == 0: continue
                    ej = sj-j
                    for c in range(cnt[a]+1):
                        ec = cnt[a]-c
                        if i+c > m or ei+ec > em or j+a*c > s or ej+a*ec > s: continue
                        ndp[i+c][j+a*c] += pre*nCr(m-i, c)%md*nCr(em-ei, ec)%md
                        ndp[i+c][j+a*c] %= md
            dp = ndp
            si += cnt[a]
            sj += cnt[a]*a
        return dp[-1][-1]%md
",1441353918
PankajGhodla,PankajGhodla,108,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c))

        return -1",1441291398
PankajGhodla,PankajGhodla,108,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c, move = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + move + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + move + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c, (move+1)%2 ))

        return -1",1441293810
PankajGhodla,PankajGhodla,108,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even = odd = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281353
PankajGhodla,PankajGhodla,108,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        counter = Counter()
        
        totalSum = 0
        for digit in num: 
            totalSum += int(digit)
            counter[int(digit)] += 1
        prefix = [0]*10
        prefix[0] = counter[0]
        for i in range(1, 10):
            prefix[i] = prefix[i-1] + counter[i] 
        # print(prefix)
        n = len(num)
        @cache
        def solve(digit, count, total):
            # print(digit, count, total)
            if digit == 10:
                # print(digit, count, total)
                return (count == n//2) and total*2 == totalSum
            ans = solve(digit+1, count, total) * math.comb(prefix[digit] - count, counter[digit])
            # print(math.comb(prefix[digit], counter[digit]), (prefix[digit], counter[digit]), digit)
            for i in range(counter[digit]):
                remaining = prefix[digit] - (count + i + 1)
                ans += solve(digit+1, count+i+1, total + digit*(i+1)) * math.comb(count+i+1, i+1) * math.comb(remaining, counter[digit] - (i+1))
                # print(math.comb(remaining, counter[digit] - (i+1)), math.comb(count+i+1, i+1), (count+i+1, i+1))
            return ans % MOD
        return solve(0, 0, 0)
            
            
            ",1441347745
cm_fast,cm_fast,109,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441297393
cm_fast,cm_fast,109,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    steps++;
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441296687
cm_fast,cm_fast,109,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0;
        int sum2=0;
        for(int i=0;i<(int)(num.size());i++)
        {
            if(i%2)
            {
                sum1+=(int)(num[i]-'0');
            }
            else
                
            {
                sum2+=(int)(num[i]-'0');
            }
            
        }
        return (sum1==sum2);
    }
};",1441282765
cm_fast,cm_fast,109,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
const int MAX_N = 80; // Maximum possible n as per constraints

ll gcd_custom(ll a, ll b)
{
    if (b == 0)
        return a;
    return gcd_custom(b, a % b);
}

ll add(ll x, ll y)
{
    x += y;
    while (x >= MOD)
        x -= MOD;
    while (x < 0)
        x += MOD;
    return x;
}

ll mul(ll x, ll y)
{
    return (x * y) % MOD;
}

ll binpow(ll x, ll y)
{
    ll z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

ll inv(ll x)
{
    return binpow(x, MOD - 2);
}

ll divide(ll x, ll y)
{
    return mul(x, inv(y));
}

ll fact_arr[81];
ll inv_fact_arr[81];

void precalc()
{
    fact_arr[0] = 1;
    for (ll i = 1; i <= 80; i++)
    {
        fact_arr[i] = mul(fact_arr[i - 1], i);
    }
    // Precompute inverse factorials
    inv_fact_arr[80] = divide(1, fact_arr[80]);
    for (ll i = 79; i >= 0; i--)
    {
        inv_fact_arr[i] = mul(inv_fact_arr[i + 1], i + 1);
    }
}

ll C(ll n, ll k)
{
    if (k > n || k < 0)
        return 0;
    return mul(fact_arr[n], mul(inv_fact_arr[k], inv_fact_arr[n - k]));
}

class Solution
{
public:
    
    ll memo_table[11][81][801]; 

    Solution()
    {
        for(int i=0;i<11;i++)
        {
            for(int j=0;j<81;j++)
            {
                 for(int k=0;k<801;k++)
                 {
                     memo_table[i][j][k] = -1;
                 }
            }
                
                    
        }
            
    }

    ll helper(int digit, int remaining_count, ll remaining_sum, const vector<ll> &original_freq)
    {
        if (remaining_count == 0 && remaining_sum == 0)
            return 1;
        if (digit > 9 || remaining_count < 0 || remaining_sum < 0)
            return 0;
        if (memo_table[digit][remaining_count][remaining_sum] != -1)
            return memo_table[digit][remaining_count][remaining_sum];
        ll total = 0;
        for (ll k = 0; k <= original_freq[digit] && k <= remaining_count && (ll)digit * k <= remaining_sum; k++)
        {
            total = add(total, mul(C(original_freq[digit], k), helper(digit + 1, remaining_count - k, remaining_sum - (ll)digit * k, original_freq)));
            total %= MOD;
        }
        return memo_table[digit][remaining_count][remaining_sum] = total;
    }

    ll countBalancedPermutations(string s)
    {
        precalc();
        ll n = s.size();
        if (n < 2)
            return 0;
        vector<ll> original_freq(10, 0);
        ll total_sum = 0;
        for (char c : s)
        {
            original_freq[c - '0']++;
            total_sum += (ll)(c - '0');
        }
        if (total_sum % 2 != 0)
            return 0;
        ll sum_p = total_sum / 2;
        int p = (n + 1) / 2;
        int q = n / 2;
        memset(memo_table, -1, sizeof(memo_table));
        ll ways = helper(0, p, sum_p, original_freq);
        if (ways == 0)
            return 0;
        ll fact_p = fact_arr[p];
        ll fact_q = fact_arr[q];
        ll denom = 1;
        for (int d = 0; d <= 9; d++)
        {
            denom = mul(denom, fact_arr[original_freq[d]]);
        }
        ll numerator = mul(mul(ways, fact_p), fact_q);
        ll denom_inv = inv(denom);
        ll result = mul(numerator, denom_inv);
        return result;
    }
};
",1441347789
Anupam Shah,user9218i,110,3627,cpp,"class Solution {
public:
    typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    vector<ll> dijkstra(vector<vector<pair<ll, ll>>> &G, ll v)
    {
        vector<ll> ans(G.size(), INF);
        ans[v] = 0;
        priority_queue<pair<ll, ll>> que;
        que.push({0, v});
        while (!que.empty())
        {
            auto [x, u] = que.top();
            que.pop();
            if (-x > ans[u])
                continue;
            for (auto [v, w] : G[u])
                if (ans[u] + w < ans[v])
                    ans[v] = ans[u] + w, que.push({-ans[v], v});
        }
        return ans;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        
        priority_queue<pair<ll, pair<ll,ll>>> que;
        que.push({0, {0, 0}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, ux = it.second.first, uy = it.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, {xx,yy}});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441301349
Anupam Shah,user9218i,110,3628,cpp,"class Solution {
public:
        typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<ll, pair<ll, pair<ll, ll>>>> que;
        que.push({0, {1, {0, 0}}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, p = it.second.first, ux = it.second.second.first, uy = it.second.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + p;
                    ll np = 1;
                    
                    if(p == 1)  np = 2;  
                    else np = 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, { np, {xx,yy} }});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441310479
Anupam Shah,user9218i,110,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for(int i = 0; i < num.length(); i ++)
            if(i % 2)   o += num[i] - '0';
            else e += num[i] - '0';
        return o == e;
    }
};",1441281198
Anupam Shah,user9218i,110,3637,cpp,"class Solution {
public:
    typedef long long ll;
    ll MOD = 1000000007;
    
    ll power(ll a, ll b, ll m) {
        ll ans = 1;
        while(b) {
            if(b & 1)
                ans = (ans * a) % m;
            b /= 2;
            a = (a * a) % m;
        }
        return ans;
    }
    
    ll go(ll ind, ll tk, ll csum, ll& sum, ll& req, ll& n, vector<ll>& f, vector<ll>& ff, vector<ll>& iff, vector<vector<vector<ll>>>& dp) {
        //cout << ind << "" "" << ind << "" ""<< tk << "" ""<< csum << endl;
        if(ind == 10) {
            if(tk == req and csum == sum) {
                //cout << ""YY"" << endl;
                return (ff[req] * ff[n-req]) % MOD;
            }
            return 0;
        }
        if(tk > req)    return 0;
        if(csum > sum)    return 0;
        
        if(dp[ind][tk][csum] != -1)     return dp[ind][tk][csum];
        
        ll ans = 0;
        for(ll i = 0; i <= f[ind]; i ++) {
            if(tk + i <= req and (csum + ( i * ind )) <= sum) {
                ll curr = (iff[i] * iff[f[ind] - i]) % MOD; 
                ans += curr * go(ind + 1, tk + i, csum + (i*ind), sum, req, n, f, ff, iff, dp);
                ans %= MOD;
            }
        }
        
        return dp[ind][tk][csum] = ans;
    }
    int countBalancedPermutations(string num) {
        ll sum = 0;
        vector<ll> f(10, 0);
        for(auto it : num) {
            //cout << it-'0' << endl;
            sum += (it - '0');
            f[it - '0'] ++;
        }
        if(sum % 2)     return 0;
        sum /= 2;
        
        vector<ll> ff(100, 1);
        vector<ll> iff(100, 1);
        
        for(int i = 0; i < 100; i ++)  {
            if(i)   ff[i] = ff[i-1] * i;
            ff[i] %= MOD;
            
            iff[i] = power(ff[i], MOD-2, MOD);
        }
        
        ll n = num.length();
        ll req = n/2;
        
        //cout << sum << "" -> "" << req << endl;
        
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (req+1, vector<ll> (sum+1, -1)));
        
        ll ans = go(0, 0, 0, sum, req, n, f, ff, iff, dp);
        return ans%MOD;
    }
};",1441354520
user5976fh,user5976fh,111,3627,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + 1, moveTime[newB][newC] + 1);
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC});
                        }
                }
            }
            
        }
        return -1;
    }
};",1441293815
user5976fh,user5976fh,111,3628,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,4>> q;
        q.push({0,0,0,1});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        vector<vector<int>> maxD2 = maxD;
        // let q[3] represent if move takes 1 or move takes 2
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c,d] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + d, moveTime[newB][newC] + d);
                    // based on D check which table to use
                    if (d == 1){
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                    else{
                        if (newT < maxD2[newB][newC]){
                            maxD2[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                        
                }
            }
            
        }
        return -1;
    }
};",1441297442
user5976fh,user5976fh,111,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); ++i){
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
            
        }

        return sum == 0;
    }
};",1441281034
user5976fh,user5976fh,111,3637,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;

    long long powerMod(long long x, long long y, long long modVal) {
        long long res = 1;
        x %= modVal;
        while (y > 0) {
            if (y & 1) res = res * x % modVal;
            x = x * x % modVal;
            y >>= 1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size();
        int freq[10] = {0};
        long long totalSum = 0;

        for (char c : num) {
            freq[c - '0']++;
            totalSum += (c - '0');
        }

        if (totalSum % 2 != 0) return 0;
        long long sumEven = totalSum / 2;
        int halfN = (n + 1) / 2;
        int maxLimit = 160;

        vector<long long> fact(maxLimit + 1, 1);
        for (int i = 1; i <= maxLimit; i++) fact[i] = fact[i - 1] * i % mod;

        vector<long long> invFact(maxLimit + 1, 1);
        invFact[maxLimit] = powerMod(fact[maxLimit], mod - 2, mod);
        for (int i = maxLimit - 1; i >= 0; i--) invFact[i] = invFact[i + 1] * (i + 1) % mod;

        vector<vector<long long>> comb(10, vector<long long>());
        for (int d = 0; d < 10; d++) {
            comb[d].resize(freq[d] + 1, 0);
            for (int x = 0; x <= freq[d]; x++) {
                comb[d][x] = (fact[freq[d]] * invFact[x] % mod) * invFact[freq[d] - x] % mod;
            }
        }

        long long productFreqFact = 1;
        for (int d = 0; d < 10; d++) {
            productFreqFact = productFreqFact * fact[freq[d]] % mod;
        }

        vector<vector<long long>> dpPrev(sumEven + 1, vector<long long>(halfN + 1, 0));
        dpPrev[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            vector<vector<long long>> dpNext(sumEven + 1, vector<long long>(halfN + 1, 0));
            for (long long s = 0; s <= sumEven; s++) {
                for (int c = 0; c <= halfN; c++) {
                    if (dpPrev[s][c] == 0) continue;
                    for (int x = 0; x <= freq[d]; x++) {
                        if (s + (long long)x * d > sumEven) break;
                        if (c + x > halfN) continue;
                        dpNext[s + x * d][c + x] = (dpNext[s + x * d][c + x] + dpPrev[s][c] * comb[d][x]) % mod;
                    }
                }
            }
            dpPrev = dpNext;
        }

        long long F = dpPrev[sumEven][halfN];
        long long invProductFreqFact = powerMod(productFreqFact, mod - 2, mod);
        long long totalPerms = fact[n] * invProductFreqFact % mod;
        long long answer = F * fact[halfN] % mod;
        answer = answer * fact[n - halfN] % mod;
        answer = answer * invProductFreqFact % mod;

        return (int)answer;
    }
};",1441356070
Harttle,harttle,112,3627,javascript,"/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(Infinity))
    while (heap.size()) {
        const [t, x, y] = heap.pop()
        if (dist[x][y] !== Infinity) continue
        dist[x][y] = t
        for (const [nx, ny] of [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]) {
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny] !== Infinity) continue
            const nt = Math.max(t + 1, moveTime[nx][ny] + 1)
            heap.push([nt, nx, ny])
        }
    }
    return dist[N - 1][M - 1]
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441297717
Harttle,harttle,112,3628,javascript,"const diffs = [0, 1, 0, -1, 0]
/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    const saw = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    while (heap.size()) {
        const [t, x, y, alt] = heap.pop()
        if (dist[x][y][alt] !== Infinity) continue
        dist[x][y][alt] = t
        const nalt = 1 - alt
        for (let i = 0; i < 4; i++) {
            const nx = x + diffs[i], ny = y + diffs[i + 1]
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny][nalt] !== Infinity) continue
            const nt = Math.max(t + 1 + alt, moveTime[nx][ny] + 1 + alt)
            if (nt < saw[nx][ny][nalt]) {
                saw[nx][ny][nalt] = nt
                heap.push([nt, nx, ny, nalt])
            }
        }
    }
    return Math.min(...dist[N - 1][M - 1])
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441315111
Harttle,harttle,112,3636,javascript,"/**
 * @param {string} num
 * @return {boolean}
 */
var isBalanced = function(nums) {
    const sums = [0, 0]
    for (let i = 0; i < nums.length; i++) sums[i % 2] += +nums[i]
    // console.log(sums)
    return sums[0] === sums[1]
};",1441284175
Harttle,harttle,112,3637,javascript,"const MOD = 1e9 + 7
var MODn = BigInt(MOD);
var _Ann = [1n];
/**
 * @param {string} num
 * @return {number}
 */
var countBalancedPermutations = function(num) {
    const digits = [...num].map(x => +x)
    const N = digits.length
    const EVEN = Math.ceil(N / 2)
    const ODD = N - EVEN
    const sum = digits.reduce((sum, d) => sum + d, 0)
    if (sum % 2) return 0
    const counts = Array(10).fill(0)
    for (const d of digits) counts[d]++
    const halfSum = sum / 2
    const memo = new Map()
    const comb = dfs(halfSum, 0, ODD)
    let ans = prod(comb, factorial(EVEN), factorial(ODD))
    // console.log('comb', comb, `fact(${EVEN})`, factorial(EVEN), `fact(${ODD})`, factorial(ODD))
    for (const count of counts) {
        if (count < 2) continue
        const fact = factorial(count)
        ans = prod(ans, modInverse(fact))
    }
    return ans
    function dfs(sum, begin, count) {
        if (sum < 0 || count < 0) return 0
        if (begin === N) return sum === 0 && count === 0 ? 1 : 0
        const key = sum * 10000 + begin * 100 + count
        if (memo.has(key)) return memo.get(key)
        let ans = 0
        ans += dfs(sum - digits[begin], begin + 1, count - 1)
        ans += dfs(sum, begin + 1, count)
        ans %= MOD
        memo.set(key, ans)
        return ans
    }
};
function prod(a, ...args) {
    if (!args.length) return a
    const prev = prod(...args)
    return Number(BigInt(a) * BigInt(prev) % MODn)
}
// src/euclidean.ts
function gcdExtended(a, b) {
  if (b === 0)
    return [a, 1, 0];
  const [gcd, x1, y1] = gcdExtended(b, a % b);
  return [gcd, y1, x1 - Math.floor(a / b) * y1];
}
function modInverse(a, M = MOD) {
  const [gcd, x] = gcdExtended(a, M);
  if (gcd !== 1)
    throw new Error(""inverse not exist"");
  return (x % M + M) % M;
}

// src/binomial.ts
function factorial(N) {
  const Nn = BigInt(N);
  for (let n = BigInt(_Ann.length); n <= Nn; n++)
    _Ann.push(_Ann[_Ann.length - 1] * n % MODn);
  return Number(_Ann[Number(N)]);
}
function factorialSeq(N) {
  factorial(N);
  return _Ann.slice(0, N + 1).map((x) => Number(x));
}
function pascalsTriangle(N) {
  const C = [[1n]];
  for (let n = 1; n <= N; ++n) {
    C.push(Array(n + 1));
    C[n][0] = C[n][n] = 1n;
    for (let k = 1; k < n; ++k) {
      C[n][k] = (C[n - 1][k - 1] + C[n - 1][k]) % MODn;
    }
  }
  for (let n = 0; n <= N; n++)
    for (let k = 0; k <= n; k++)
      C[n][k] = Number(C[n][k]);
  return C;
}
function combination(n, k) {
  const deno = modMultiply(factorial(k), factorial(n - k));
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function arrangement(n, k) {
  const deno = factorial(n - k);
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function modMultiply(a, b) {
  return Number(BigInt(a) * BigInt(b) % MODn);
}",1441343449
Dhruva N L,dhruva05,113,3627,cpp,"class Solution {
public:
     int n, m;
    const long long INF = 1e18;
    vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    
    void initArrival(vector<vector<long long>>& arr) {
        for (int i = 0; i < n; i++) {
            fill(arr[i].begin(), arr[i].end(), INF);
        }
        arr[0][0] = 0;
    }
    
    bool isValid(int x, int y) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return 0;
        m = moveTime[0].size();
        vector<vector<long long>> arr(n, vector<long long>(m));
        initArrival(arr);
        
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        while (!pq.empty()) {
            auto [curTime, x, y] = pq.top();
            pq.pop();
            
            if (x == n - 1 && y == m - 1) return (int)curTime;
            if (curTime > arr[x][y]) continue;

            for (auto &[dx, dy] : dirs) {
                int nx = x + dx, ny = y + dy;
                if (isValid(nx, ny)) {
                    long long newTime = max(curTime, (long long)moveTime[nx][ny]) + 1;
                    if (newTime < arr[nx][ny]) {
                        arr[nx][ny] = newTime;
                        pq.emplace(newTime, nx, ny);
                    }
                }
            }
        }
        return -1;
    }
};",1441318569
Dhruva N L,dhruva05,113,3628,cpp,"class Solution {
    typedef long long ll;
    const ll INF = 1e18;
    
    int n, m;

    int encode(int i, int j, int parity) {
        return (i * m + j) * 2 + parity;
    }

    tuple<int, int, int> decode(int id) {
        int p = id % 2;
        int temp = id / 2;
        int j = temp % m;
        int i = temp / m;
        return {i, j, p};
    }

    void updateTime(priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> &pq,
                    vector<vector<vector<ll>>> &arrTimes, int i, int j, int p, ll arr) {
        if (arr < arrTimes[i][j][p]) {
            arrTimes[i][j][p] = arr;
            pq.push({arr, encode(i, j, p)});
        }
    }

public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return -1;
        m = moveTime[0].size();
        if (m == 0) return -1;

        vector<vector<vector<ll>>> arrTimes(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;

        arrTimes[0][0][0] = 0;
        pq.push({0, encode(0, 0, 0)});
        
        vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!pq.empty()) {
            auto [currTime, id] = pq.top(); pq.pop();
            auto [i, j, p] = decode(id);
            
            if (i == n - 1 && j == m - 1) return (int)currTime;
            if (currTime > arrTimes[i][j][p]) continue;

            for (auto &[di, dj] : dirs) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    ll moveDur = (p == 0) ? 1 : 2;
                    ll startTime = max(currTime, (ll)moveTime[ni][nj]);
                    ll arr = startTime + moveDur;
                    int np = 1 - p;
                    updateTime(pq, arrTimes, ni, nj, np, arr);
                }
            }
        }
        
        return -1;
    }
};",1441335644
Dhruva N L,dhruva05,113,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

        for (int i = 0; i < num.length(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0)
                es += d;
            else
                os += d;
        }

        return es == os;
    }
};",1441291195
Dhruva N L,dhruva05,113,3637,java,"class Solution {
    private static final int MOD = 1_000_000_007;

    private long powerMod(long x, long y, long mod) {
        long res = 1;
        x %= mod;
        while (y > 0) {
            if ((y & 1) == 1) {
                res = res * x % mod;
            }
            x = x * x % mod;
            y >>= 1;
        }
        return res;
    }

    private void computeFactAndInvFact(long[] fact, long[] invFact, int maxN) {
        fact[0] = 1;
        for (int i = 1; i <= maxN; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[maxN] = powerMod(fact[maxN], MOD - 2, MOD);
        for (int i = maxN - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    private long calculateDigitCountsAndSum(String num, int[] digitCount) {
        long totalSum = 0;
        for (char ch : num.toCharArray()) {
            digitCount[ch - '0']++;
            totalSum += (ch - '0');
        }
        return totalSum;
    }

    private long[][] initializeDpArray(int halfLen, int halfSum) {
        long[][] dp = new long[halfLen + 1][halfSum + 1];
        dp[0][0] = 1;
        return dp;
    }

    private long processDp(int halfLen, int halfSum, int[] digitCount, long[] invFact, long[][] dp) {
        for (int d = 0; d < 10; d++) {
            int countD = digitCount[d];
            long[][] tempDp = new long[halfLen + 1][halfSum + 1];

            for (int c = 0; c <= halfLen; c++) {
                for (int s = 0; s <= halfSum; s++) {
                    if (dp[c][s] == 0) continue;
                    int maxA = Math.min(countD, halfLen - c);

                    for (int aD = 0; aD <= maxA; aD++) {
                        int newC = c + aD;
                        long newS = s + (long) d * aD;
                        if (newS > halfSum) continue;
                        tempDp[newC][(int) newS] = (tempDp[newC][(int) newS] + dp[c][s] * invFact[aD] % MOD * invFact[countD - aD] % MOD) % MOD;
                    }
                }
            }
            dp = tempDp;
        }
        return dp[halfLen][halfSum];
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] digitCount = new int[10];
        long totalSum = calculateDigitCountsAndSum(num, digitCount);

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int halfLen = (n + 1) / 2;

        long[] fact = new long[n + 1];
        long[] invFact = new long[n + 1];
        computeFactAndInvFact(fact, invFact, n);

        long[][] dp = initializeDpArray(halfLen, (int) halfSum);
        long validAssignments = processDp(halfLen, (int) halfSum, digitCount, invFact, dp);

        long answer = fact[halfLen] * fact[n - halfLen] % MOD;
        answer = answer * validAssignments % MOD;

        return (int) answer;
    }
}",1441356821
rarelytested,rarelytested,114,3627,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = 1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441356900
rarelytested,rarelytested,114,3628,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = (x+y)%2+1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441355901
rarelytested,rarelytested,114,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s0 += num[i] - '0';
            } else {
                s1 += num[i] - '0';
            }
        }
        return s0 == s1;
    }
};",1441282560
rarelytested,rarelytested,114,3637,cpp,"class Solution {
   public:
#define MOD 1000000007
    long long C[100][100];
    void init() {
        C[0][0] = 1;
        for (int i = 1; i < 100; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        vector<int> cnt(10, 0);
        for (int i = 0; i < num.size(); i++) {
            sum += num[i] - '0';
            cnt[num[i] - '0']++;
        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        init();

        int n0 = (num.size() + 1) / 2;
        int n1 = num.size() - n0;
        vector<vector<vector<long long>>> dp(
            10,
            vector<vector<long long>>(sum + 1, vector<long long>(n0 + 1, 0)));
        int tot = 0;
        for (int i = 0; i < 10; i++) {
            if (i == 0) {
                for (int j = 0; j <= cnt[i]; j++) {
                    if (j > n0) {
                        break;
                    }
                    dp[i][0][j] = C[n0][j] * C[n1][cnt[i] - j] % MOD;
                }
                tot += cnt[i];
                continue;
            }
            for (int j = 0; j <= sum; j++) {
                for (int k = 0; k <= n0; k++) {
                    if (dp[i - 1][j][k] == 0) {
                        continue;
                    }
                    for (int l = 0; l <= cnt[i]; l++) {
                        if (j + l * i > sum || k + l > n0) {
                            break;
                        }
                        if (n1 - (tot-k) < 0) {
                            continue;
                        }
                        if (tot < k) {
                            continue;
                        }
                        // if (i == 3) {
                        //     std::cout << i << "" "" << j << "" "" << k << "" "" << l
                        //               << "" "" << dp[i - 1][j][k] << "" ""
                        //               << C[n0 - k][l] << "" ""
                        //               << C[n1 - (tot-k)][cnt[i] - l]
                        //               << std::endl;
                        // }
                        dp[i][j + l * i][k + l] +=
                            dp[i - 1][j][k] * C[n0 - k][l] % MOD *
                            C[n1 - (tot-k)][cnt[i] - l] % MOD;
                        dp[i][j + l * i][k + l] %= MOD;
                    }
                }
            }
            tot += cnt[i];
        }
        // std::cout << dp[2][3][2] << std::endl;
        return dp[9][sum][n0];
    }
};",1441338543
Yucheng Dai,Rainingcity,115,3627,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(0, make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [d, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + 1;
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(-nt, make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441293574
Yucheng Dai,Rainingcity,115,3628,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(make_pair(0, 1), make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [dd, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            auto [d, step] = dd;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + (step ? 1 : 2);
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(make_pair(-nt, !step), make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441297044
Yucheng Dai,Rainingcity,115,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < num.length(); i++) {
            if (i & 1) {
                r += num[i] - '0';
            } else {
                l += num[i] - '0';
            }
        }
        return l == r;
    }
};",1441281589
Yucheng Dai,Rainingcity,115,3637,cpp,"typedef long long ll;
const ll MOD = 1000000007;
vector<ll> buildFact(ll n) {
    vector<ll> fact(n + 1, 0);
    fact[0] = fact[1] = 1;
    for(ll i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    return fact;
}
vector<vector<ll>> buildC(ll n) {
    vector<vector<ll>> C(n + 1, vector<ll>(n + 1, 0));
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(ll i = 2; i <= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(ll j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
    return C;
}
ll gcdExtended(ll a, ll b, ll& x, ll& y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    ll d = gcdExtended(b % a, a, x, y);
    ll t = x;
    x = y - (b / a) * x;
    y = t;
    return d;
}
ll modInverse(ll a) {
    ll x, y;
    ll g = gcdExtended(a, MOD, x, y);
    return (x % MOD + MOD) % MOD;
}
vector<ll> buildInv(vector<ll>& l) {
    vector<ll> res{};
    for(ll x: l) {
        res.push_back(modInverse(x));
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        int sum = 0;
        int cnt[10];
        memset(cnt, 0, sizeof(cnt));
        for(char c: num) {
            sum += c - '0';
            cnt[c - '0']++;
        }
        if (sum & 1) return 0;
        vector<vector<ll>> C = buildC(n);
        vector<ll> fact = buildFact(n);
        vector<ll> factInv = buildInv(fact);
        int m = (n + 1) / 2;
        sum /= 2;
        // cur_digit, left #digit, left sum
        vector<vector<vector<ll>>> dp(11, vector<vector<ll>>(m + 1, vector<ll>(sum + 1, 0)));
        dp[0][0][0] = 1;
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= m; j++) {
                for(int k = 0; k <= sum; k++) {
                    for(int t = 0; t <= cnt[i] && t <= j && i * t <= k; t++) {
                        dp[i + 1][j][k] = (dp[i + 1][j][k] + ((dp[i][j - t][k - i * t] * factInv[t]) % MOD) * factInv[cnt[i] - t]) % MOD;
                        // cout << i << "" "" << j << "" "" << k << "" "" << dp[i + 1][j][k] << endl;
                    }
                }
            }
        }
        return (((dp[10][m][sum] * fact[m]) % MOD) * fact[n - m]) % MOD;
    }
};",1441357030
Shashwat Tripathi,Fkaiser7,117,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,
            greater<pair<int,pair<int,int>>>>pq;
        pq.push({0,{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({t1,{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({t1,{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({t1,{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({t1,{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441296836
Shashwat Tripathi,Fkaiser7,117,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<pair<int,int>,pair<int,int>>,vector<pair<pair<int,int>,pair<int,int>>>,
            greater<pair<pair<int,int>,pair<int,int>>>>pq;
        pq.push({{0,0},{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first.first;
            int turn=it.first.second;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+turn+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+turn+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({{t1,1-turn},{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1+turn;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1+turn;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({{t1,1-turn},{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1+turn;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1+turn;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({{t1,1-turn},{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1+turn;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1+turn;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({{t1,1-turn},{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441304766
Shashwat Tripathi,Fkaiser7,117,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int a=0,b=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        return a==b;
    }
};",1441281257
Shashwat Tripathi,Fkaiser7,117,3637,cpp,"#define lli long long
lli mod=1e9+7;
vector<lli>fact(81);
void calc(){
    lli p=1;
    fact[0]=fact[1]=1;
    for(lli i=2;i<=80;i++){
        p=(p%mod*i%mod)%mod;
        fact[i]=p;
    }
}
long long power(long long i, int j) { return j ? j & 1 ? power(i * i % mod, j >> 1) * i % mod : power(i * i % mod, j >> 1) : 1; }
lli comb(lli n,lli r){
    lli t=fact[n];
    lli t1=(fact[r]%mod*fact[n-r]%mod)%mod;
    t1=power(t1,mod-2);
    t=(t%mod*t1%mod)%mod;
    return t;
}
class Solution {
public:
    lli fuc(lli i,lli o,lli sum,vector<lli>&freq,vector<vector<vector<lli>>>&dp
,lli &n){
        if(i==10){
            if(sum==0){
                return 1;
            }
            return 0;
        }
        if(dp[i][o][sum]!=-1){
            return dp[i][o][sum];
        }
        lli o1=n/2;
        if(n%2){
            o1++;
        }
        lli e=0;
        if(i!=0){
            e=freq[i-1]-o1+o;
        }
        e=n/2-e;
        lli t=freq[i];
        if(i!=0){
            t-=freq[i-1];
        }
        //cout<<i<<"" ""<<o<<"" ""<<e<<"" ""<<t<<"" ""<<sum<<endl;
        //cout<<i<<"" ""<<o<<"" ""<<e<<endl;
        lli ans=0;
            for(lli j=0;j<=t;j++){
                if(t-j>e||j>o||j*i>sum){
                    continue;
                }
                lli ans1=(comb(o,j)%mod*comb(e,t-j)%mod)%mod;
                ans1=(ans1%mod*fuc(i+1,o-j,sum-j*i,freq,dp,n)%mod)%mod;
                ans+=ans1;
                ans%=mod;
            }
        //cout<<i<<"" ""<<o<<"" ""<<t<<"" ""<<sum<<"" ""<<ans<<endl;
        return dp[i][o][sum]=ans;
    }
    int countBalancedPermutations(string num) {
        calc();
        //cout<<comb(4,2)<<endl;
        lli n=num.length();
        lli o=n/2,e=n/2;
        if(n%2){
            o++;
        }
        vector<lli>freq(10);
        lli sum=0;
        for(lli i=0;i<n;i++){
            freq[num[i]-'0']++;
            sum+=num[i]-'0';
        }
        if(sum%2){
            return 0;
        }
        vector<vector<vector<lli>>>dp(10,vector<vector<lli>>(n+1,
        vector<lli>(sum/2+1,-1)));
        vector<lli>freq1(10);
        for(lli i=0;i<10;i++){
            if(i==0){
                freq1[i]=freq[i];
            }
            else{
                freq1[i]=freq1[i-1]+freq[i];
            }
        }
        //cout<<sum<<endl;
        return (int)(fuc(0,o,sum/2,freq1,dp,n));
    }
};",1441358541
lilPeep,stupidRR,118,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<int>> dp(n,vector<int>(m,2e9));
        dp[0][0]=0;
        
        set< array<int,3> > dij;
        dij.insert( {0,0,0} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y]=*dij.begin();
            dij.erase( dij.begin() );
            
            cout << X << "" "" << Y << "" "" << tim << endl;
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim+1,ar[x][y]+1);
                    if( dp[x][y] > reach )
                    {
                        dij.erase( {dp[x][y],x,y} );
                        dp[x][y]=reach;
                        dij.insert( {dp[x][y],x,y} );
                    }
                }
            }
        }
        cout << endl;
        return dp[n-1][m-1];
    }
};",1441298381
lilPeep,stupidRR,118,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(2,2e9)));
        dp[0][0][1]=0;
        
        set< array<int,4> > dij;
        dij.insert( {0,0,0,1} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y,type]=*dij.begin();
            dij.erase( dij.begin() );
            
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim,ar[x][y])+2-type%2;
                    if( dp[x][y][1-type] > reach )
                    {
                        dij.erase( {dp[x][y][1-type],x,y,1-type} );
                        dp[x][y][1-type]=reach;
                        dij.insert( {dp[x][y][1-type],x,y,1-type} );
                    }
                }
            }
        }
        return std::min(dp[n-1][m-1][0],dp[n-1][m-1][1]);
    }
};",1441303245
lilPeep,stupidRR,118,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum=0;
        for(int i=0;i<num.size();i++)
        {
            if(i%2)
                sum+=(num[i]-'0');
            else
                sum=sum-(num[i]-'0');
        }
        return !sum;
    }
};",1441282957
lilPeep,stupidRR,118,3637,cpp,"typedef long long ll;
class Solution {
    ll factorial[101];
    ll inverse[101];
       
    ll binpow(ll base,ll ex)
    {
        if(ex<0)
          return 0ll;
        ll ans=1;
        while(ex>0)
        {
            if(ex%2==1)
                    ans=(ans*base)%mod;
            base=(base*base)%mod;
            ex=ex/2;
        }
        return ans;
    }
     
    void pre()
    {
       factorial[0]=1;
       inverse[0]=1;
       for(int i=1;i<=100;i++)
           factorial[i]=(factorial[i-1]*i)%mod;
       
       inverse[100]=binpow(factorial[100],mod-2);
       for(int i=99;i>=0;i--)
          inverse[i]=(inverse[i+1]*(i+1ll))%mod;
    }
     
    ll nCr(int n , int r)
    {
        if(n<0 || r<0 || n<r)
                return 0;
        ll ans=1;
        ans=factorial[n];
        ans=(ans*inverse[n-r])%mod;
        ans=(ans*inverse[r])%mod;
        return ans;
    }
    const int mod=1e9+7;
public:
    int countBalancedPermutations(string num) {
        int n=num.size();
        pre();
        int odd=(n)/2;

        vector<int> freq(10);
        for(auto ele : num)
            freq[ele-'0']++;

        vector<vector<long long>> dp(odd+1,vector<long long>(1001,0));
        dp[ odd ][ 500 ]=1ll;
        int placedTillNow=0;
        int even=n-odd;

        for(int i=0;i<10;i++) // 10* 41*41*1000 = 16000*2000 
        {
            int val=freq[i];
            if(val==0)
                continue;

            vector<vector<long long>> ndp(odd+1,vector<long long>(1001,0));

            for(int oddHave=0;oddHave<=odd;oddHave++)
            {
                for(int j=oddHave;j<=odd;j++)
                {

                    int oddUsed=j-oddHave;
                    if(oddUsed>val)
                        break;
                    int evenUsed=val-oddUsed;
                    
                    int oddPlacedTillNow=odd-j;
                    int evenPlaced=placedTillNow-oddPlacedTillNow;

                    if(evenPlaced+evenUsed > even)
                        continue;
                    
                    int delta=oddUsed*i-evenUsed*i;

                    for(int sum=0;sum<=1000;sum++)
                    {
                        if(sum+delta <=1000 && sum+delta>=0 && dp[j][sum])
                            ndp[oddHave][sum+delta]=(ndp[oddHave][sum+delta]+ dp[j][sum]* ((nCr(odd-oddPlacedTillNow,oddUsed)*nCr(even-evenPlaced,evenUsed))%mod) )%mod;
                    }
                }
            }
            placedTillNow+=val;
            swap(dp,ndp);
        }

        return dp[0][500];
    }
};

",1441339362
Srujan_Teja_Rayella,Srujan_code_code,119,3627,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        int[][] distance = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        priorityQueue.offer(new int[]{0, 0, 0}); // {time, row, col}
        distance[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!priorityQueue.isEmpty()) {
            int[] current = priorityQueue.poll();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > distance[currentRow][currentCol]) continue;

            for (int[] direction : directions) {
                int newRow = currentRow + direction[0];
                int newCol = currentCol + direction[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int newTime = Math.max(currentTime, moveTime[newRow][newCol]) + 1;

                    if (newTime < distance[newRow][newCol]) {
                        distance[newRow][newCol] = newTime;
                        priorityQueue.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }

        return distance[rows - 1][cols - 1];
    }
}


",1441321285
Srujan_Teja_Rayella,Srujan_code_code,119,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] dp = new int[n][m][2];
        for (int[][] arr : dp) {
            for (int[] subArr : arr) {
                Arrays.fill(subArr, Integer.MAX_VALUE);
            }
        }
        dp[0][0][0] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int time = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];

            if (time > dp[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);

                    if (newTime < dp[newRow][newCol][1 - parity]) {
                        dp[newRow][newCol][1 - parity] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol, 1 - parity});
                    }
                }
            }
        }

        return Math.min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
}



",1441326648
Srujan_Teja_Rayella,Srujan_code_code,119,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumEvenPositions = 0;
        int sumOddPositions = 0;
        
        for (int index = 0; index < num.length(); index++) {
            int digitValue = num.charAt(index) - '0'; 
            
            if (index % 2 == 0) {
                sumEvenPositions += digitValue; 
            } else {
                sumOddPositions += digitValue; 
            }
        }
        
        return sumEvenPositions == sumOddPositions;
    }
}
",1441297850
Srujan_Teja_Rayella,Srujan_code_code,119,3637,java,"class Solution {
    private static final int MOD = 1000000007;

    public int countBalancedPermutations(String num) {
        int length = num.length();
        long totalSum = 0;
        int[] counts = new int[10];

        for (char digit : num.toCharArray()) {
            int d = digit - '0';
            totalSum += d;
            counts[d]++;
        }

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int m = (length + 1) / 2;
        long[] factorial = new long[length + 1];
        long[] invFactorial = new long[length + 1];
        factorial[0] = 1;

        for (int i = 1; i <= length; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        invFactorial[length] = modInverse(factorial[length], MOD);

        for (int i = length - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        long[][] dp = new long[m + 1][(int) (halfSum + 1)];
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (counts[d] == 0) {
                continue;
            }

            for (int k = m; k >= 0; k--) {
                for (int s = (int) halfSum; s >= 0; s--) {
                    if (dp[k][s] == 0) {
                        continue;
                    }

                    for (int t = 1; t <= counts[d]; t++) {
                        if (k + t > m || s + d * t > halfSum) {
                            break;
                        }
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(counts[d], t, factorial, invFactorial, MOD)) % MOD;
                    }
                }
            }
        }

        long w = dp[m][(int) halfSum];
        long result = factorial[m] * factorial[length - m] % MOD;

        for (int d = 0; d < 10; d++) {
            result = result * invFactorial[counts[d]] % MOD;
        }

        result = result * w % MOD;
        return (int) result;
    }

    private long modInverse(long a, int m) {
        long result = 1;
        long base = a;
        int p = m - 2;

        while (p > 0) {
            if ((p & 1) == 1) {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        return result;
    }

    private long comb(int n, int k, long[] factorial, long[] invFactorial, int m) {
        if (k > n) {
            return 0;
        }
        return factorial[n] * invFactorial[k] % m * invFactorial[n - k] % m;
    }
}

",1441353506
sveng101,sveng101,120,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0))]
        while heap:
            t, pos = heapq.heappop(heap)
            if pos in seen: continue
            seen.add(pos)
            for pos2 in move(pos):
                if pos2 in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1
                if pos2 == target:
                    return t2
                heapq.heappush(heap, (t2, pos2))
        return -1",1441300706
sveng101,sveng101,120,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0), False)]
        while heap:
            t, pos, even = heapq.heappop(heap)
            #print(pos, even, t)
            if (pos, even) in seen: continue
            elif pos == target:
                return t
            seen.add((pos, even))
            for pos2 in move(pos):
                if (pos2, not even) in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1 + even
                heapq.heappush(heap, (t2, pos2, not even))
        return -1",1441308855
sveng101,sveng101,120,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res = 0
        n = len(num)
        for i in range(0, n, 2):
            res += int(num[i])
        for i in range(1, n, 2):
            res -= int(num[i])
        return not res
        """"""
        while num:
            num, d = divmod(num, 10)
            res += d if d & 1 else -d
        return not res
        """"""",1441289145
sveng101,sveng101,120,3637,python3,"import math
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        md = 10 ** 9 + 7

        n = len(num)
        
        cnts = {}
        tot = 0
        for d in num:
            d2 = int(d)
            cnts[d2] = cnts.get(d2, 0) + 1
            tot += d2
        if tot & 1: return 0
        tot_target = tot >> 1
        res = 0
        cnts2 = sorted([(y, x) for x, y in cnts.items()])
        m = len(cnts2)
        cnt_target = n >> 1
        #print(cnts2)
        memo = {}
        def backtrack(idx: int, cnt_rem: int=cnt_target, tot_rem: int=tot_target) -> int:
            f_tot, num = cnts2[idx]
            if idx == m - 1:
                f = cnt_rem
                if f > f_tot or f * num != tot_rem: return 0
                return (math.factorial(cnt_target) * math.factorial(n - cnt_target)) // (math.factorial(f) * math.factorial(f_tot - f))
            args = (idx, cnt_rem, tot_rem)
            if args in memo.keys(): return memo[args]
            res = 0
            cnt_rem2 = cnt_rem
            tot_rem2 = tot_rem
            for f in range(min(f_tot, cnt_rem) + 1):
                res += backtrack(idx + 1, cnt_rem=cnt_rem2, tot_rem=tot_rem2) // (math.factorial(f) * math.factorial(f_tot - f))
                cnt_rem2 -= 1
                tot_rem2 -= num
                if tot_rem2 < 0: break
            memo[args] = res
            return res
        res =(backtrack(0)) % md
        #print(memo)
        return res",1441359877
Pankaj Ananda Bhosale,pankaj_777,121,3627,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dist(n, vector<ll> (m, inf));
        dist[0][0] = 0;
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, greater<array<ll, 3>>> pq;
        pq.push({0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 : moveTime[nrow][ncol] + 1);
                    if (dist[nrow][ncol] > ntime) {
                        dist[nrow][ncol] = ntime;
                        pq.push({ntime, nrow, ncol});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441315132
Pankaj Ananda Bhosale,pankaj_777,121,3628,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        ll dist[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }
        
        dist[0][0][0] = 0;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, greater<array<ll, 4>>> pq;
        pq.push({0, 0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0], parity = pq.top()[3];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 + parity : moveTime[nrow][ncol] + 1 + parity);
                    if (dist[nrow][ncol][1 - parity] > ntime) {
                        dist[nrow][ncol][1 - parity] = ntime;
                        pq.push({ntime, nrow, ncol, 1 - parity});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441320881
Pankaj Ananda Bhosale,pankaj_777,121,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int cntEven = 0, cntOdd = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2) cntEven += num[i] - '0';
            else cntOdd += num[i] - '0';
        }
        
        return cntOdd == cntEven;
    }
};",1441281857
Pankaj Ananda Bhosale,pankaj_777,121,3637,cpp,"#define ll long long int
const int mod = 1e9 + 7;

int mulm(ll a, ll b) {
    return (a * b) % mod;
}

int addm(ll a, ll b) {
    return (a + b) % mod;
}

ll powr(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = mulm(res, a);
        a = mulm(a, a);
        b = b >> 1;
    }
    return res;
}

ll inv(ll x) {
    if (x <= 1) return 1;
    return powr(x, mod - 2);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        
        int tot_sum = 0;
        vector<int> cnt(10, 0), fact(n + 1, 1);
        for (int i = 0; i < n; i++) {
            tot_sum += (num[i] - '0');
            cnt[num[i] - '0']++;
        }
        
        if (tot_sum % 2) return 0;
        
        for (int i = 2; i <= n; i++) {
            fact[i] = mulm(i, fact[i - 1]);
        }
        
        vector<vector<vector<int>>> dp(10, vector<vector<int>> (400, vector<int> (n + 1, -1)));
        auto fun = [&] (int idx, int sum_even, int cntEven, auto&& fun) -> int {
            if (idx == 10) {
                return (sum_even == tot_sum / 2 and cntEven == n / 2) * mulm(fact[n / 2], fact[(n + 1) / 2]);
            }
            
            if (dp[idx][sum_even][cntEven] != -1) return dp[idx][sum_even][cntEven];
            
            int res = 0;
            for (int c = 0; c <= cnt[idx]; c++) {
                res = addm(res, mulm(fun(idx + 1, sum_even + c * idx, cntEven + c, fun), mulm(inv(fact[c]), inv(fact[cnt[idx] - c]))));
            }

            return dp[idx][sum_even][cntEven] = res;
        };
        
        return fun(0, 0, 0, fun);
    }
};",1441359987
i_will_beat_my_iq,i_will_beat_my_iq,122,3627,cpp,"class Solution {
public:
#define ll long long
void f1(int x, int y, int curr_t, vector<vector<int>>& t, vector<vector<int>>& d, 
                           priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>>& q,
                           int dirs[][2], ll r, ll c) {
        ll i = 0;
        while (i < 4) {
            int nx = x + dirs[i][0], ny = y + dirs[i][1];
            if (f2(nx, ny, r, c)) {
                int new_t = f3(curr_t, t[nx][ny]);
                if (new_t < d[nx][ny]) {
                    d[nx][ny] = new_t;
                    q.push({new_t, {nx, ny}});
                }
            }
            i++;
        }
    }

    bool f2(int x, int y, ll r, ll c) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }

    int f3(int curr_t, int move_t) {
        return max(curr_t, move_t) + 1;
    }
    int minTimeToReach(vector<vector<int>>& t) {
        ll r = t.size();
        ll c = t[0].size();
        vector<vector<int>> d(r, vector<int>(c, INT32_MAX));
        d[0][0] = 0;

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> q;
        q.push({0, {0, 0}});

        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!q.empty()) {
            auto [curr_t, pos] = q.top();
            int x = pos.first, y = pos.second;
            q.pop();

            if (x == r - 1 && y == c - 1) return curr_t;
            if (curr_t > d[x][y]) continue;

            f1(x, y, curr_t, t, d, q, dirs, r, c);
        }
        return -1;
    }
};",1441314147
i_will_beat_my_iq,i_will_beat_my_iq,122,3628,cpp,"class Solution {
public:
struct S {
    long long a;
    int b;
    int c;
    int d;
    bool operator<(const S& o) const {
        return a > o.a;
    }
};

 priority_queue<S> f1() {
        priority_queue<S> a;
        return a;
    }

    vector<pair<int, int>> f2() {
        vector<pair<int, int>> a = { {1,0}, {-1,0}, {0,1}, {0,-1} };
        return a;
    }

    S f3(priority_queue<S>& a) {
        S b = a.top();
        a.pop();
        return b;
    }

    bool f4(int a, int b, int c, int d) {
        return (a >= 0 && a < c && b >= 0 && b < d);
    }

    int f5(int a) {
        return (a == 0) ? 1 : 2;
    }

    long long f6(long long a, vector<vector<int>>& b, int c, int d) {
        return max(a, (long long)b[c][d]);
    }

    S f7(long long a, int b, int c, int d) {
        S e;
        e.a = a;
        e.b = b;
        e.c = c;
        e.d = d;
        return e;
    }
    int minTimeToReach(vector<vector<int>>& a) {
        vector<vector<int>> b = a;
        int c = b.size();
        if(c == 0) return -1;
        int d = b[0].size();
        if(d == 0) return -1;
        long long e = 1000000000000000000;
        vector<vector<long long>> f(c, vector<long long>(d, e));
        vector<vector<long long>> g(c, vector<long long>(d, e));
        priority_queue<S> h = f1();
        S i;
        i.a = 0;
        i.b = 0;
        i.c = 0;
        i.d = 0;
        f[0][0] = 0;
        h.push(i);
        vector<pair<int, int>> j = f2();
        while(!h.empty()) {
            S k = f3(h);
            if(k.b == c-1 && k.c == d-1){
                return (int)k.a;
            }
            if((k.d == 0 && k.a > f[k.b][k.c]) || 
               (k.d == 1 && k.a > g[k.b][k.c])) {
                continue;
            }
            for(int l = 0; l < j.size(); l++) {
                pair<int, int> m = j[l];
                int n = k.b + m.first;
                int o = k.c + m.second;
                if(!f4(n, o, c, d)) continue;
                int p = f5(k.d);
                long long q = f6(k.a, b, n, o);
                long long r = q + p;
                int s = 1 - k.d;
                if(s == 0){
                    if(r < f[n][o]){
                        f[n][o] = r;
                        S t = f7(r, n, o, s);
                        h.push(t);
                    }
                }
                else{
                    if(r < g[n][o]){
                        g[n][o] = r;
                        S u = f7(r, n, o, s);
                        h.push(u);
                    }
                }
            }
        }
        return -1;
    }
};",1441342852
i_will_beat_my_iq,i_will_beat_my_iq,122,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int se = 0, so = 0, i = 0;
        while (i < s.size()) {
            int d = s[i] - '0';
            (i % 2 == 0) ? se += d : so += d;
            i++;
        }
        return se == so;
    }
};",1441308665
i_will_beat_my_iq,i_will_beat_my_iq,122,3637,cpp,"class Solution {
public:
typedef long long ll;
static const int mx = 80;
ll mod_val = 1000000007;
ll f[mx + 1], inv_f[mx + 1];

ll f1(ll x, ll y, ll mod) {
    ll r = 1;
    x %= mod;
    while (y > 0) {
        if (y & 1) {
            r = r * x % mod;
        }
        x = x * x % mod;
        y >>= 1;
    }
    return r;
}
void f2() {
    f[0] = 1;
    for (int i = 1; i <= mx; i++) {
        f[i] = f[i - 1] * i % mod_val;
    }
    inv_f[mx] = f1(f[mx], mod_val - 2, mod_val);
    for (int i = mx - 1; i >= 0; i--) {
        inv_f[i] = inv_f[i + 1] * (i + 1) % mod_val;
    }
}
void f4(string &s, int freq[]) {
        for (char c : s) {
            freq[c - '0']++;
        }
    }

    ll f5(int freq[]) {
        ll total = 0;
        for (int d = 0; d <= 9; d++) {
            total += (ll)d * freq[d];
        }
        return total;
    }

    void f6(int freq[], ll grp_size, ll half, vector<vector<ll>> &dp_prev, vector<vector<ll>> &dp_curr) {
        for (int d = 0; d <= 9; d++) {
            for (int j = 0; j <= grp_size; j++) {
                fill(dp_curr[j].begin(), dp_curr[j].end(), 0LL);
            }

            for (int j = 0; j <= grp_size; j++) {
                for (int k = 0; k <= half; k++) {
                    if (dp_prev[j][k] == 0) continue;
                    f8(dp_curr, dp_prev, freq[d], j, k, d, grp_size, half);
                }
            }
            swap(dp_prev, dp_curr);
        }
    }

    ll f7(int freq[]) {
        ll denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * inv_f[freq[d]] % mod_val;
        }
        return denom;
    }

    void f8(vector<vector<ll>> &dp_curr, vector<vector<ll>> &dp_prev, int freq_d, int j, int k, int d, int grp_size, ll half) {
        for (int c = 0; c <= freq_d && j + c <= grp_size && k + c * d <= half; c++) {
            ll comb = f[freq_d] * inv_f[c] % mod_val * inv_f[freq_d - c] % mod_val;
            dp_curr[j + c][k + c * d] = (dp_curr[j + c][k + c * d] + dp_prev[j][k] * comb) % mod_val;
        }
    }
    int countBalancedPermutations(string s) {
        bool init = false;
        if (!init) {
            f2();
            init = true;
        }

        int freq[10] = {0};
        f4(s, freq);

        ll total = f5(freq);

        if (total % 2 != 0) return 0;

        ll half = total / 2;
        ll grp_size = (s.size() + 1) / 2;
        ll odd_grp_size = s.size() - grp_size;

        vector<vector<ll>> dp_prev(grp_size + 1, vector<ll>(half + 1, 0));
        vector<vector<ll>> dp_curr(grp_size + 1, vector<ll>(half + 1, 0));
        dp_prev[0][0] = 1;

        f6(freq, grp_size, half, dp_prev, dp_curr);

        ll total_comb = dp_prev[grp_size][half];
        ll denom = f7(freq);

        ll res = f[grp_size] * f[odd_grp_size] % mod_val;
        res = (res * total_comb) % mod_val;
        res = (res * denom) % mod_val;

        return res;
    }
};",1441353944
virinci,virinci,124,3627,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307496
virinci,virinci,124,3628,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, 3 - incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307148
virinci,virinci,124,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281046
virinci,virinci,124,3637,python3,"from collections import Counter

M = 10**9 + 7

fact = [1] * 81
for x in range(1, len(fact)):
    fact[x] = (fact[x - 1] * x) % M


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digit_sum = sum(map(int, num))
        if digit_sum % 2:
            return 0

        n, m = len(num), digit_sum // 2 + 1

        dp = [[0] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 1

        for d in map(int, num):
            for i in range(n, 0, -1):
                for j in range(m, d - 1, -1):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % M

        even_count = (n + 1) // 2
        ways = dp[even_count][digit_sum // 2]

        counter = Counter(num)
        inv = 1
        for c in counter.values():
            inv *= pow(fact[c], -1, M)
            inv %= M

        return ways * fact[even_count] * fact[n - even_count] * inv % M",1441342013
Samadeep,rbssmtkr,125,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int n = moveTime.size();
        int m = moveTime[0].size();

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            pq;

        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));

        pq.push({0, 0, 0});
        dist[0][0] = 0;

        while (!pq.empty()) {

            auto [time, x, y] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (time > dist[x][y])
                continue;

            for (auto& [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int wait_time = max(0, moveTime[nx][ny] - time);
                    int new_time = time + 1 + wait_time;

                    if (new_time < dist[nx][ny]) {
                        dist[nx][ny] = new_time;
                        pq.push({new_time, nx, ny});
                    }
                }
            }
        }

        return -1;
    }
};",1441296109
Samadeep,rbssmtkr,125,3628,cpp,"int64_t dist1[850][850], dist0[850][850];
const int64_t INF = 1e18;
class Solution {
public:
    struct node_state {
    int64_t time;
        int x, y;    
        bool parity;
        bool operator<(const node_state& other) const {
            return time > other.time;
        }
    };

    Solution() {

        for (int i = 0; i <= 800; i++) {
            for (int j = 0; j <= 800; j++) {
                dist1[i][j] = INF;
                dist0[i][j] = INF;
            }
        }
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        auto inside = [&](int x, int y) {
            return !(x < 0 || x >= n || y < 0 || y >= m);
        };

        auto cmp = [](const node_state a, const node_state b) {
            return a.time > b.time;
        };

        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<node_state> pq;
        dist0[0][0] = 0;

        pq.push(node_state{0, 0, 0, false});

        while (!pq.empty()) {

            auto [curr_time,x, y, parity] = pq.top();
            pq.pop();

            if ((curr_time > dist0[x][y] && !parity) ||
                (curr_time > dist1[x][y]) && parity) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int nx = x + dx;
                int ny = y + dy;

                if (!inside(nx, ny))
                    continue;

                int64_t start = max(curr_time, (int64_t)moveTime[nx][ny]);
                int dur = (parity) ? 2 : 1;
                int64_t arrival_time = start + dur;

                bool next = !parity;

                if (next == 0 and arrival_time < dist0[nx][ny]) {
                    dist0[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                } else if (arrival_time < dist1[nx][ny]) {
                    dist1[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                }
            }
        }

        int64_t answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return static_cast<int>(answer);
    }
};",1441340411
Samadeep,rbssmtkr,125,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for( int i = 0 ; i < num.size(); i++ ){
            if( i&1 ) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }

        return sum == 0;
    }
};",1441286169
Samadeep,rbssmtkr,125,3637,cpp,"
const int64_t mod = 1e9 + 7;
int64_t inv(int64_t i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
int64_t mod_mul(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}
int64_t mod_add(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}
int64_t gcd(int64_t a, int64_t b) { if (b == 0) return a; return gcd(b, a % b);}
int64_t ceil_div(int64_t a, int64_t b) {return a % b == 0 ? a / b : a / b + 1;}


const int SIZE = 200;
const int MOD = 1e9 + 7;
int64_t mypow(int64_t x, int64_t y) {
    x %= MOD;
    int64_t res = 1 % MOD;
    while (y) {
        if (y & 1)
            res = res * x % MOD;
        y >>= 1;
        x = x * x % MOD;
    }
    return res;
}

int64_t power(int64_t base, int64_t exp, int64_t mod) {
    int64_t res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1)
            res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

int64_t fac[SIZE];
int64_t inv_fac[SIZE];
void pre() {
    fac[0] = 1;
    for (int i = 1; i < SIZE; i++) {
        fac[i] = fac[i - 1] * i % MOD;
    }
    inv_fac[SIZE - 1] = mypow(fac[SIZE - 1], MOD - 2);
    for (int i = SIZE - 2; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD;
    }
}

int64_t NCR(int64_t n, int64_t m) {
    if (m < 0 || m > n) {
        return 0;
    }
    return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;
}

bool precompute = false;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (not precompute) {
            pre();
            precompute = true;
        }

        int N = num.size();
        int E = (N + 1) / 2;
        int O = N / 2;

        int64_t cnt[10] = {0};
        for (char ch : num) {
            cnt[ch - '0']++;
        }

        int64_t total_sum = 0;
        for (int64_t d = 0; d < 10; d++) {
            total_sum += d * cnt[d];
        }

        if (total_sum % 2 != 0)
            return 0;

        const int64_t TARGET = total_sum / 2;

        vector<vector<int64_t>> dp(E + 1,
                                     vector<int64_t>(TARGET + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (!cnt[d])
                continue;
            
            for (int t = E; t >= 0; t--) {
                for (int64_t s = TARGET; s >= 0; s--) {
                    if (!dp[t][s])
                        continue;
                    
                    for (int k = 1; k <= cnt[d] && t + k <= E &&
                                    s + (int64_t)d * k <= TARGET;
                         k++) {
                        dp[t + k][s + (int64_t)d * k] =
                            mod_add(dp[t + k][s + (int64_t)d * k] , dp[t][s] * NCR(cnt[d], k));
                    }
                }
            }
        }

        int64_t prod_ans = 1;
        for (int d = 0; d < 10; d++) {
            prod_ans = mod_mul(prod_ans , fac[cnt[d]]);
        }

        int64_t answer = dp[E][TARGET] * fac[E] % MOD;
        answer = answer * fac[O] % MOD;
        return (int)mod_mul(answer , power(prod_ans, MOD - 2, MOD));
    }
};",1441361820
Huzaifa Khilawala,RedHeadphone,127,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+1,(nx,ny)))
                    visited.add((nx,ny))",1441295652
Huzaifa Khilawala,RedHeadphone,127,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,1,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time,addi, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+addi,1 if addi==2 else 2,(nx,ny)))
                    visited.add((nx,ny))",1441299635
Huzaifa Khilawala,RedHeadphone,127,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ev = 0
        for i in range(0,len(num),2):
            ev += int(num[i])
        od = 0
        for i in range(1,len(num),2):
            od += int(num[i])
        return ev == od",1441281765
Huzaifa Khilawala,RedHeadphone,127,3637,python3,"
MOD = 10**9 + 7

class Combinatorics:
    def __init__(self, pre_compute_limit=0):
        self.fact = [1] * pre_compute_limit
        self.invfact = [1] * pre_compute_limit
        for i in range(1, pre_compute_limit):
            self.fact[i] = (self.fact[i - 1] * i) % MOD
            self.invfact[i] = (self.invfact[i - 1] * pow(i, MOD - 2, MOD)) % MOD

    def ncr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[r] * self.invfact[n - r]) % MOD

    def npr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[n - r]) % MOD

    def ncr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = den = 1
        for i in range(r):
            num = (num * (n - i)) % MOD
            den = (den * (i + 1)) % MOD
        return (num * pow(den, MOD - 2, MOD)) % MOD

    def npr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = 1
        for i in range(n, n - r, -1):
            num = (num * i) % MOD
        return num

comb = Combinatorics(100)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(num)
        num = [int(i) for i in num]

        summ = sum(num)
        if summ%2 != 0:
            return 0
        
        target = summ//2
        n = len(num)
        length_req = n//2

        inv_mul = True if n-length_req == length_req else False

        combi = (comb.fact[length_req]*comb.fact[n-length_req])%MOD

        c = Counter(num)

        @cache
        def dp(i, curr, length):
            if curr > target:
                return 0
            
            if i==10:
                if curr==target and length==length_req:
                    return combi
                else:
                    return 0
            
            ans = 0
            for j in range(c[i]+1):
                ans+= dp(i+1, curr+i*j, length+j)*comb.invfact[j]*comb.invfact[c[i]-j]
                ans%= MOD
            return ans

        ans = dp(0,0,0)
        return ans",1441351613
Saijayavinoth T V S,saijayavinoth,128,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0))]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+1
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny)))
        # print(T)
        return -1",1441295122
Saijayavinoth T V S,saijayavinoth,128,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0), True)]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell, step = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+(1 if step else 2)
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny), not step))
        # print(T)
        return -1",1441297746
Saijayavinoth T V S,saijayavinoth,128,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = 0
        flag = True
        for ch in num:
            ch = int(ch)
            if flag: ch *= -1
            x += ch
            flag = not flag
        return x == 0",1441282486
Saijayavinoth T V S,saijayavinoth,128,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = list(map(int, list(num)))
        count = Counter(nums)
        nums = list(set(nums))
        nums.sort()
        MOD = 10**9+7
        n = len(num)
        O = n//2
        E = n-O
        @cache
        def ncr(n, r):
            if n == 0 and r == 0:
                return 1
            if n == 0:
                return 0
            return ncr(n-1,r) + ncr(n-1,r-1)
        @cache
        def solve(ind, evenPos, oddPos, x):
            if ind == len(nums):
                return 1 if x == 0 else 0
            num = nums[ind]
            ans = 0
            for even in range(count[num]+1):
                if even > evenPos:
                    break
                odd = count[num] - even
                if odd > oddPos: continue
                ans += ncr(evenPos, even) * ncr(oddPos, odd) * solve(ind+1, evenPos-even, oddPos-odd, x+(even-odd)*num)
                ans %= MOD
            return ans
        return solve(0, E, O, 0)
        ",1441364426
MvKaio,MvKaio,129,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, (long long)(1e11)));
        dist[0][0] = 0;
        
        using T = pair<long long, pair<int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, pair(0, 0));
        
        vector vis(n, vector(m, false));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = v.first;
            int j = v.second;
            if (vis[i][j]) continue;
            vis[i][j] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1] > dist[i][j] + 1) {
                    dist[i1][j1] = dist[i][j] + 1;
                    dist[i1][j1] = max<long long>(dist[i1][j1], g[i1][j1] + 1);
                    q.emplace(dist[i1][j1], pair(i1, j1));
                }
            }
        }
        
        

        return dist[n - 1][m - 1];
    }
};",1441303773
MvKaio,MvKaio,129,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, vector(2, (long long)(1e11))));
        dist[0][0][0] = 0;
        
        using T = pair<long long, tuple<int, int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, make_tuple(0, 0, 0));
        
        vector vis(n, vector(m, vector(2, false)));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = get<0>(v);
            int j = get<1>(v);
            int x = get<2>(v);
            if (vis[i][j][x]) continue;
            vis[i][j][x] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1][!x] > dist[i][j][x] + 1 + x) {
                    dist[i1][j1][!x] = dist[i][j][x] + 1 + x;
                    dist[i1][j1][!x] = max<long long>(dist[i1][j1][!x], g[i1][j1] + 1 + x);
                    q.emplace(dist[i1][j1][1-x], make_tuple(i1, j1, 1 - x));
                }
            }
        }
        
        

        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441309686
MvKaio,MvKaio,129,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2) s += num[i] - '0';
            else s -= num[i] - '0';
        }
        return s == 0;
    }
};",1441281184
MvKaio,MvKaio,129,3637,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> v(n);
        for (int i = 0; i < n; i++)
            v[i] = s[i] - '0';
        
        vector cnt(10, 0);
        for (int i : v) cnt[i]++;
        
        int S = accumulate(v.begin(), v.end(), 0);
        if (S % 2) return 0;
        
        auto add = [&] (long long& a, long long b) {
            a += b;
            if (a >= MOD) a -= MOD;
        };
        
        vector fact(n + 1, 1ll);
        for (int i = 2; i <= n; i++)
            fact[i] = i * fact[i - 1] % MOD;
        
        auto fexp = [&] (long long a, long long b) {
            long long ans = 1;
            while (b) {
                if (b & 1) ans = ans * a % MOD;
                a = a * a % MOD;
                b /= 2;
            }
            return ans;
        };
        
        vector ifact(n + 1, 1ll);
        for (int i = 0; i <= n; i++)
            ifact[i] = fexp(fact[i], MOD - 2);
        
        vector dp(11, vector(n + 1, vector(S + 1, 0LL)));
        dp[0][0][0] = fact[n/2] * fact[(n+1)/2] % MOD;
        for (int d = 0; d < 10; d++) {
            for (int i = 0; i <= n; i++) {
                for (int s = 0; s <= S; s++) {
                    for (int qt = 0; qt <= cnt[d]; qt++) if (s + qt * d <= S && i + qt <= n) {
                        add(dp[d + 1][i + qt][s + qt * d], 
                            dp[d][i][s] 
                            * ifact[qt] % MOD
                            * ifact[cnt[d] - qt] % MOD
                       );
                    }
                }
            }
        }

        
        //cout << dp[10][n/2][S/2] << endl;
        return dp[10][n/2][S/2];
    }
};",1441338870
Arnab Mondal,arnab_97,131,3627,java," class Solution {
     public int minTimeToReach(int[][] moveTime) {
         int n = moveTime.length;
         int m = moveTime[0].length;
         int[][] dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
         int[][] minArrive = new int[n][m];
         for(int[] row : minArrive){
             Arrays.fill(row, Integer.MAX_VALUE);
         }
         minArrive[0][0] = 0;
         PriorityQueue<Cell> pq = new PriorityQueue<>();
         pq.offer(new Cell(0, 0, 0));
         while(!pq.isEmpty()){
             Cell current = pq.poll();
             int r = current.row;
             int c = current.col;
             int t = current.time;
             if(r == n-1 && c == m-1){
                 return t;
             }
             if(t > minArrive[r][c]){
                 continue;
             }
             for(int[] dir : dirs){
                 int nr = r + dir[0];
                 int nc = c + dir[1];
                 if(nr >=0 && nr < n && nc >=0 && nc < m){
                     int arriveTime = Math.max(t, moveTime[nr][nc]) +1;
                     if(arriveTime < minArrive[nr][nc]){
                         minArrive[nr][nc] = arriveTime;
                         pq.offer(new Cell(nr, nc, arriveTime));
                     }
                 }
             }
         }
         return -1;
     }

     class Cell implements Comparable<Cell>{
         int row;
         int col;
         int time;
         Cell(int row, int col, int time){
             this.row = row;
             this.col = col;
             this.time = time;
         }
         public int compareTo(Cell other){
             return Integer.compare(this.time, other.time);
         }
     }
 }",1441294066
Arnab Mondal,arnab_97,131,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        long INF = Long.MAX_VALUE;
        long[][][] dist = new long[n][m][2];
        for(int i=0;i<n;i++) {
            for(int j=0; j<m; j++) {
                dist[i][j][0] = INF;
                dist[i][j][1] = INF;
            }
        }
        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> Long.compare(a.time, b.time));
        dist[0][0][0] = 0;
        pq.add(new State(0, 0, 0, 0));
        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
        while(!pq.isEmpty()) {
            State current = pq.poll();
            if(current.x == n-1 && current.y == m-1){
                return (int)current.time;
            }
            if(current.time > dist[current.x][current.y][current.p]){
                continue;
            }
            for(int[] dir : directions){
                int nx = current.x + dir[0];
                int ny = current.y + dir[1];
                if(nx >=0 && nx <n && ny >=0 && ny <m){
                    long start_move_time = Math.max(current.time, (long)moveTime[nx][ny]);
                    long move_duration = current.p == 0 ? 1 : 2;
                    long arrival_time = start_move_time + move_duration;
                    int next_p = 1 - current.p;
                    if(arrival_time < dist[nx][ny][next_p]){
                        dist[nx][ny][next_p] = arrival_time;
                        pq.add(new State(nx, ny, next_p, arrival_time));
                    }
                }
            }
        }
        return -1;
    }
    class State {
        int x, y, p;
        long time;
        State(int x, int y, int p, long time){
            this.x = x;
            this.y = y;
            this.p = p;
            this.time = time;
        }
    }
}
",1441293520
Arnab Mondal,arnab_97,131,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';

            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}",1441283689
Arnab Mondal,arnab_97,131,3637,java,"class Solution {
    static final int MOD = 1_000_000_007;

     public int countBalancedPermutations(String num) {
         int[] freq = new int[10];
         int N = num.length();
         long sumTotal = 0;
         for(char c : num.toCharArray()) {
             freq[c - '0']++;
             sumTotal += (c - '0');
         }
         if(sumTotal % 2 != 0) return 0;
         long sumTarget = sumTotal / 2;
         int half1 = (N + 1) / 2;
         int half2 = N / 2;

         long[] fact = new long[N + 1];
         fact[0] = 1;
         for(int i=1;i<=N;i++) {
             fact[i] = fact[i-1] * i % MOD;
         }

         long[] invFact = new long[N +1];
         invFact[N] = powMod(fact[N], MOD-2);
         for(int i=N-1;i>=0;i--){
             invFact[i] = invFact[i+1] * (i+1) % MOD;
         }

         
         long[][] dp = new long[half1 +1][(int)(sumTarget) +1];
         dp[0][0] = 1;

         for(int d=0; d<=9; d++) {
             int f = freq[d];
             if(f ==0) continue;
             long[][] next = new long[half1 +1][(int)(sumTarget) +1];
             for(int j=0; j<=half1; j++) {
                 for(int k=0; k<=sumTarget; k++) {
                     if(dp[j][k] ==0) continue;
                     for(int c=0; c<=f; c++) {
                         if(j + c > half1) break;
                         long newSum = k + (long)d * c;
                         if(newSum > sumTarget) break;
                         next[j + c][(int)newSum] = (next[j + c][(int)newSum] + dp[j][k] * invFact[c] % MOD * invFact[f - c] % MOD ) % MOD;
                     }
             }}
             dp = next;
         }

         if(sumTotal %2 !=0){
             return 0;
         }

         if(half1 <0 || half1 >N || sumTarget <0){
             return 0;
         }

         long dpVal = dp[half1][(int)sumTarget];
         if(dpVal ==0){
             return 0;
         }

         long answer = fact[half1] * fact[half2] % MOD;
         answer = answer * dpVal % MOD;
         return (int)answer;
     }

     long powMod(long a, long b){
         long res =1;
         a %= MOD;
         while(b >0){
             if( (b&1) !=0){
                 res = res * a % MOD;
             }
             a = a * a % MOD;
             b >>=1;
         }
         return res;
    }
}",1441359079
Nutty Professor,varkatkl,132,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        BIG = 1 << 30
        best = [[BIG] * W for _ in range(H)]
        bfs = collections.deque()
        def visit(y, x, t):
            if best[y][x] > t and (t > moveTime[y][x] or (y == 0 and x == 0)):
                best[y][x] = t
                bfs.append((y, x))

        visit(0, 0, 0)
        while bfs:
            y, x = bfs.popleft()
            t_cur = best[y][x]
            for dy, dx in ADJACENT:
                y2, x2 = y + dy, x + dx
                if y2 >= 0 and x2 >= 0 and y2 < H and x2 < W:
                    t_move = max(moveTime[y2][x2], t_cur)
                    visit(y2, x2, t_move + 1)

        return best[H - 1][W - 1]
",1441295956
Nutty Professor,varkatkl,132,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)] 
        BIG = 1 << 30

        best = [[[BIG, BIG] for _ in range(W)] for _ in range(H)]
        bfs = []
        def visit(y, x, par, t):
            if best[y][x][par] > t:
                best[y][x][par] = t
                heapq.heappush(bfs, (t, y, x, par))

        visit(0, 0, 0, 0)

        while bfs:
            t_cur, y, x, par = heapq.heappop(bfs)
            if y == H - 1 and x == W - 1:
                return t_cur
            for dy, dx in ADJACENT:
                y2, x2, par2 = y + dy, x + dx, 1 - par
                if y2 < 0 or x2 < 0 or y2 >= H or x2 >= W:
                    continue
                t_start = max(t_cur, moveTime[y2][x2])
                visit(y2, x2, par2, t_start + par + 1)

        return min(best[H - 1][W - 1])
",1441309476
Nutty Professor,varkatkl,132,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e, o = 0, 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                e += int(d)
            else:
                o += int(d)
        return e == o
",1441282473
Nutty Professor,varkatkl,132,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = (10 ** 9) + 7
        counts = [0] * 10
        total = 0
        N = len(num)
        for d in num:
            counts[int(d)] += 1
            total += int(d)

        if total % 2 != 0:
            return 0

        inv_fact = [1] * 81
        fact = 1
        for i in range(2, 81):
            fact = fact * i % MOD
            inv_fact[i] = pow(fact, MOD - 2, MOD)

        @functools.lru_cache(maxsize=None)
        def f(i, odds_used, osum):
            if i == 10:
                if odds_used != N // 2 or osum * 2 != total:
                    return 0
                return 1

            ret = 0
            for ei in range(counts[i] + 1):
                oi = counts[i] - ei
                ret += inv_fact[ei] * inv_fact[oi] * f(i + 1, oi + odds_used, oi * i + osum) % MOD
                ret %= MOD
            return ret

        ret = f(0, 0, 0)
        ret *= pow(inv_fact[(N + 1) // 2], MOD - 2, MOD) * pow(inv_fact[N // 2], MOD - 2, MOD)
        ret %= MOD
        return ret
",1441359390
Yatin Kwatra,yatin_kwatra,134,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

int vis[55][55];

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:

	// bool possible(int k, vvii &v) {
	// 	fo(i, 0, n - 1) {
	// 		fo(j, 0, m - 1) vis[i][j] = 1e9;
	// 	}
	// 	queue<ar<int, 2>> q;

	// 	q.push({0, 0});
	// 	vis[0][0] = 1;

	// 	while (sz(q)) {
	// 		auto t = q.front();
	// 		q.pop();

	// 		int a = t[0], b = t[1];

	// 		fo(dir, 0, 3) {
	// 			int x = a + dx[dir];
	// 			int y = b + dy[dir];

	// 			if (valid(x, y, k, vis[a][b])) {
	// 				vis[x][y] = max(v[x][y], vis[a][b] + 1);
	// 				q.push({x, y});
	// 			}
	// 		}
	// 	}

	// 	return vis[n - 1][m - 1];

	// }

	int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vvii dp(n, vii(m, INT_MAX));

		set<ar<int, 3>> s;
		s.insert({0, 0, 0});
		dp[0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[1] + dx[dir];
				int y = t[2] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1, t[0] + 1);
				if (spend < dp[x][y]) {
					auto it = s.find({dp[x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[x][y] = spend;
					s.insert({dp[x][y], x, y});
				}
			}
		}

		return dp[n - 1][m - 1];
	}
};


















",1441306051
Yatin Kwatra,yatin_kwatra,134,3628,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vector<vector<vector<int>>>  dp(2, vvii(n, vii(m, INT_MAX)));

		set<ar<int, 4>> s;
		s.insert({0, 0, 0, 0});
		dp[0][0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[2] + dx[dir];
				int y = t[3] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1 + t[0], t[1] + 1 + t[0]);
				if (spend < dp[!t[0]][x][y]) {
					auto it = s.find({dp[!t[0]][x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[!t[0]][x][y] = spend;
					s.insert({!t[0], dp[!t[0]][x][y], x, y});
				}
			}
		}

		return min(dp[0][n - 1][m - 1], dp[1][n - 1][m - 1]);
	}
};


















",1441315344
Yatin Kwatra,yatin_kwatra,134,3636,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	bool isBalanced(string s) {
		int n = sz(s);
		int a[2] = {0};
		fo(i, 0, n - 1) {
			a[i % 2] += s[i] - '0';
		}
		return a[0] == a[1];
	}
};




















",1441281153
Yatin Kwatra,yatin_kwatra,134,3637,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

const int N = 81;
ll f[N];

ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}

ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}

ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}

ll nCr(ll n, ll r) {
	if (n < r) return 0;
	ll num = f[n];
	ll deno = mulmod(f[r], f[n - r]);
	return divmod(num, deno);
}


int cnt[10];

int dp[10][42][802], sum;

class Solution {
public:

	int gino(int pos, int odd, int even, int dx) {
		if (pos == 10) {
			return (dx == 0);
		}
		int &ans = dp[pos][odd][sum + dx];
		if (ans != -1) return ans;
		ans = 0;

		fo(placeAtOdd, 0, min(odd, cnt[pos])) {
			int atOdd = placeAtOdd;
			int atEven = cnt[pos] - placeAtOdd;
			if (atEven > even) continue;

			int updDx = dx + atOdd * pos - atEven * pos;

			ans = addmod(ans, mulmod(mulmod(nCr(odd, atOdd), nCr(even, atEven)), gino(pos + 1, odd - atOdd, even - atEven,  updDx)));

			// pr(pos, atOdd, atEven, odd, even,  updDx, ans);
		}

		// pr(pos, odd, even, dx, ans);

		return ans;
	}

	int countBalancedPermutations(string s) {
		if (!f[0]) {
			f[0] = 1;
			fo(i, 1, N - 1) {
				f[i] = mulmod(f[i - 1], i);
			}
		}

		fo(i, 0, 9) {
			cnt[i] = 0;
		}
		for (auto &i : s) cnt[i - '0']++;
		int n = sz(s);

		sum = 0;
		sort(all(s));
		reverse(all(s));
		fo(i, 0, ((n + 1) / 2) - 1) sum += s[i] - '0';

		fo(i, 0, 9) {
			fo(j, 0, (n + 1) / 2) {
				fo(k, 0, 2 * sum) dp[i][j][k] = -1;
			}
		}


		return gino(0, (n + 1) / 2, n / 2, 0);
	}
};





















",1441359762
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3627,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        using Triple = tuple<int64_t,int,int>;
        PQ(Triple, greater) pq;
        pq.emplace(0, 0, 0);
        vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        vector<vector<bool>> vis(R, vector<bool>(C, false));
        dp[0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x] = pq.top(); pq.pop();
            if(vis[y][x]) continue;
            vis[y][x] = true;
            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1, 
                    1ll * stat[ny][nx] + 1
                );
                if(next_time >= dp[ny][nx])
                    continue;
                dp[ny][nx] = next_time;
                pq.emplace(next_time, ny, nx);
            }
        }

        return dp[R - 1][C - 1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441360335
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3628,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

const int nax = 751;
int64_t dp[nax][nax][2];
bool vis[nax][nax][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        // vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        //dp[row][col][flag] = best
        //min(...dp[R - 1][C - 1])
        for(int row = 0; row < R; row++)
            for(int col = 0; col < C; col++)
                for(int flag = 0; flag <= 1; flag++)
                    dp[row][col][flag] = INF, vis[row][col][flag] = false;

        using Quad = tuple<int64_t,int,int,int>;
        PQ(Quad, greater) pq;
        pq.emplace(0, 0, 0, 0);
        dp[0][0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x, flag] = pq.top(); pq.pop();
            if(vis[y][x][flag]) continue;
            vis[y][x][flag] = true;

            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1 + flag, 
                    1ll * stat[ny][nx] + 1 + flag
                );
                if(next_time >= dp[ny][nx][flag ^ 1])
                    continue;
                dp[ny][nx][flag ^ 1] = next_time;
                pq.emplace(next_time, ny, nx, flag ^ 1);
            }
        }

        return min(dp[R - 1][C - 1][0], dp[R - 1][C - 1][1]);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441367413
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3636,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    bool isBalanced(string num) {
        int ans[2] = {0, 0};
        const int n = num.size();
        for(int i = 0; i < n; i++)
            ans[i % 2] += num[i] - '0';

        return ans[0] == ans[1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441346394
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3637,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

template <uint64_t mod = 1'000'000'007>
struct Mint {
    uint64_t val;
    Mint() : val(0) {}
    Mint(int64_t _val) {
        _val %= mod;
        if (_val < 0) _val += mod;
        val = _val;
    }
    Mint& operator += (const Mint& other){ val += other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator -= (const Mint& other){ val += mod - other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator *= (const Mint& other){ val = (uint64_t)val * other.val % mod; return *this; }
    Mint& operator /= (const Mint& other){ return *this *= other.inv(); }
    Mint operator + (const Mint& other) const { return Mint(*this) += other; }
    Mint operator - (const Mint& other) const { return Mint(*this) -= other; }
    Mint operator * (const Mint& other) const { return Mint(*this) *= other; }
    Mint operator / (const Mint& other) const { return Mint(*this) /= other; }
    Mint pwr(int64_t expo) const {
        Mint res = 1;
        Mint cur = *this;
        while(expo){
            if(expo & 1) res *= cur;
            cur *= cur; expo >>= 1;
        }
        return res;
    }
    Mint inv() const { return pwr(mod - 2); }
    friend ostream& operator << (ostream& os, const Mint& m) { os << m.val; return os; }
    bool operator == (const Mint& other) const { return val == other.val; }
};

constexpr uint64_t MODS[] = {
    1'000'000'007,       // 1e9 + 7
    1'000'000'009,       // 1e9 + 9
    1'000'000'003,       // 1e9 + 3
    1'000'000'019,       // 1e9 + 19
    1'000'000'037,       // 1e9 + 37
    1'000'000'061,       // 1e9 + 61
    1'000'000'077,       // 1e9 + 77
    1'000'000'123,       // 1e9 + 123
    5'330'004'01, 
    7'356'327'91, 
    7'765'314'19,
    7'970'034'13
};

using mint = Mint<MODS[0]>;
mint fact[100];
mint ifact[100];
int dp[10][42][42][730];
int vfreq[10];
int even_max;
int odd_max;
//729 is the max
//370(offset) is the 0

int init = []{
    fact[0] = 1;
    ifact[0] = 1;
    for(int i = 1; i < 100; i++){
        fact[i] = fact[i - 1] * i;
        ifact[i] = fact[i].inv();
    }
    return 0;
}();

mint ncr(int take, int has) {
    assert(take <= has);
    assert(take >= 0 && has >= 0);
    return fact[has] * ifact[take] * ifact[has - take];
}

int dfs(int val, int even, int odd, int sum) {
    if(val < 0)
        return sum == 370 && even == even_max && odd == odd_max;
    if(dp[val][even][odd][sum] != -1)
        return dp[val][even][odd][sum];

    const int left_slot = even_max - even;
    const int right_slot = odd_max - odd;
    mint got = 0;
    for(int left = 0; left <= vfreq[val]; left++){
        if(left_slot < left) continue;
        const int right = vfreq[val] - left;
        if(right_slot < right) continue;
        const int next_sum = sum + (left * val) - (right * val);
        if(next_sum < 0 || next_sum > 729) 
            continue;
        got += 
        ncr(left, left_slot) * 
        ncr(right, right_slot) * 
        dfs(val - 1, even + left, odd + right, next_sum);
    }

    return dp[val][even][odd][sum] = got.val;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        const int n = s.size();
        even_max = n / 2 + (n & 1);
        odd_max = n / 2;
        for(int i = 0; i <= 9; i++)
            for(int even = 0; even <= even_max; even++)
                for(int odd = 0; odd <= odd_max; odd++)
                    for(int sum = 0; sum < 730; sum++)
                        dp[i][even][odd][sum] = -1;

        fill(vfreq, vfreq + 10, 0);
        for(auto ch : s)
            vfreq[ch - '0']++;

        return dfs(9, 0, 0, 370);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441343915
VILLANOVA_ECON,VILLANOVA_ECON,138,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0))
            best_dist = [[math.inf]*(M) for _ in range(N)]
            best_dist[0][0] = 0
            while heap_list:
                dist, i,j = heapq.heappop(heap_list)
                if dist == best_dist[i][j]:
                    best_dist[i][j] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+1,moveTime[a][b]+1)
                        if new_max < best_dist[a][b]:
                            best_dist[a][b] = new_max
                            heapq.heappush(heap_list,(new_max,a,b))
            return best_dist[-1][-1]
        
        return djikstra(graph)",1441294489
VILLANOVA_ECON,VILLANOVA_ECON,138,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0,0))
            best_dist = [[[math.inf]*2 for _ in range(M)] for _ in range(N)]
            best_dist[0][0][0] = 0
            while heap_list:
                dist, seq,i,j = heapq.heappop(heap_list)
                jump_cost = 1 if seq == 0 else 2
                if dist == best_dist[i][j][seq]:
                    best_dist[i][j][seq] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+jump_cost,moveTime[a][b]+jump_cost)
                        if new_max < best_dist[a][b][seq^1]:
                            best_dist[a][b][seq^1] = new_max
                            heapq.heappush(heap_list,(new_max,seq^1,a,b))
            return min(best_dist[-1][-1])
        
        return djikstra(graph)",1441299087
VILLANOVA_ECON,VILLANOVA_ECON,138,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        dp = [0,0]
        
        for i in range(len(list(num))):
            x = int(num[i])
            dp[i%2] += x
        return dp[0] == dp[1]",1441281131
VILLANOVA_ECON,VILLANOVA_ECON,138,3637,python3,"# class Solution:
#     def countBalancedPermutations(self, num: str) -> int:
#         def check(num):
#             dp = [0,0]  
#             for i in range(len(list(num))):
#                 x = int(num[i])
#                 dp[i%2] += x
#             return dp[0] == dp[1]

#         def brute(arr):
#             seen = set()
#             for zeb in itertools.permutations(arr):
#                 if check(list(zeb)):
#                     seen.add("""".join(list(zeb)))
#             return len(seen)
        
#         return brute(num)
    
    
MOD = 10 ** 9 + 7
MX = 1000

fac = [1] * MX
for i in range(1, MX):
    fac[i] = fac[i-1] * i % MOD
ifac = [pow(fac[MX - 1], MOD-2, MOD)] * MX
for i in range(MX - 1, 0, -1):
    ifac[i-1] = ifac[i] * i % MOD




class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        modulo = 10**9 + 7

        total_sum = sum([int(x) for x in num])
        
        target_count = len(num)//2
        
        remain_count = len(num)-target_count
        

        if total_sum%2 != 0:
            return 0
        
        target_sum = total_sum//2

        digit_len = len(list(num))//2
        

                    
                    
        num_count = [0]*10
        
        for x in num:
            num_count[int(x)] += 1
            
            
        ans = 0
        
        
        dp = [[0]*(target_sum+1) for _ in range(target_count+1)]
        dp[0][0] = 1

        for i in range(len(num_count)):
            
            new_dp = [[0]*(target_sum+1) for _ in range(target_count+1)] #[0]*(target_sum+1)
            for x in range(num_count[i]+1):
                take = x
                remain = num_count[i]-take
                new_take_sum = x * i
                #print(i,take,remain,new_take_sum)
                for j in range(len(dp)-1,-1,-1):
                    if j-take < 0:
                        break
                    for z in range(len(dp[0])-1,-1,-1):
                        if z-new_take_sum < 0:
                            break
                        if dp[j-take][z-new_take_sum] >= 0:
                            new_dp[j][z] += dp[j-take][z-new_take_sum] * ifac[take] * ifac[remain]
                            if new_dp[j][z] >= modulo:
                                new_dp[j][z] %= modulo
            

                        
            dp = list([list(row) for row in new_dp]) #[0]*(target_sum+1)

        return (dp[-1][-1] * fac[target_count]  * fac[len(num)-target_count]     )%modulo
                    
        
        
        
        
        

                    
            
",1441367947
parthDOOM,parthDOOM,139,3627,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
#define ptpll priority_queue<tuple<ll,ll,ll>, vector<tuple<ll,ll,ll>>, greater<tuple<ll,ll,ll>>>

class Solution {
public:
   int minTimeToReach(vector<vector<int>>& mt) {
       ll n = sz(mt);
       if(n == 0) rt 0;
       ll m = sz(mt[0]);
       
       vl dx = {-1, 1, 0, 0};
       vl dy = {0, 0, -1, 1};
       
       vlll0(arr, n, m);
       
       arr[0][0] = 0;
       
       ptpll pq;
       pq.emplace(0ll, 0ll, 0ll);
       
       while(!pq.empty()){
           auto [ct, x, y] = pq.top();
           pq.pop();
           
           if(x == n-1 && y == m-1){
               rt (int)ct;
           }
           if(ct > arr[x][y]) cnt;
           rep(i, 0, 4){
               ll nx = x + dx[i],ny = y + dy[i];
               if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                   ll nt = max(ct, (ll)mt[nx][ny]) + 1;
                   if(nt < arr[nx][ny]) {
                       arr[nx][ny] = nt;
                       pq.emplace(nt, nx, ny); 
                   }
               }
           }
       }
       rt -1;
   }
};
 ",1441319399
parthDOOM,parthDOOM,139,3628,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = sz(moveTime),m = sz(moveTime[0]); 
        vl dx = {0, 0, 1, -1},dy = {1, -1, 0, 0};
        vlll0(dist, n, m);
        vlll0(moves, n, m); 
        priority_queue<pair<ll, pair<pll, ll>>, 
                      vector<pair<ll, pair<pll, ll>>>, 
                      greater<pair<ll, pair<pll, ll>>>> pq;
        
        dist[0][0] = 0;
        moves[0][0] = 0;
        pq.push({0, {{0, 0}, 0}});
        
        while(!pq.empty()) {
            ll currTime = pq.top().fst;
            ll x = pq.top().sec.fst.fst,y = pq.top().sec.fst.sec;
            ll moveCount = pq.top().sec.sec;
            pq.pop();
            if(currTime > dist[x][y]) cnt;
            rep(i, 0, 4) {
                ll newX = x + dx[i],newY = y + dy[i];
                if(newX >= 0 && newX < n && newY >= 0 && newY < m) {
                    ll waitTime = max(0ll, moveTime[newX][newY] - currTime);
                    ll moveTime = (moveCount % 2 == 0) ? 1 : 2;
                    ll newTime = currTime + waitTime + moveTime;
                    if(newTime < dist[newX][newY]) {
                        dist[newX][newY] = newTime;
                        moves[newX][newY] = moveCount + 1;
                        pq.push({newTime, {{newX, newY}, moveCount + 1}});
                    }
                }
            }
        }
        rt dist[n-1][m-1];        
    }
};",1441299919
parthDOOM,parthDOOM,139,3636,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return

class Solution {
public:
    bool isBalanced(string num) {
        ll ctE = 0,ctO = 0;
        rep(i, 0, sz(num)){
            if(!(i%2)) ctE += (num[i] - '0');
            else ctO += (num[i] - '0');
        }
        rt ctE == ctO;        
    }
};",1441285157
parthDOOM,parthDOOM,139,3637,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int countBalancedPermutations(string s) {
        ll n = sz(s),e = (n+1)>>1,o = n>>1,sum = 0;
        vll0(ct,10)
        loop(c,s) ct[c-'0']++;
        rep(d,0,10) sum += d * ct[d];
        if(sum&1) rt 0;
        sum >>= 1;
        const ll mx = 80;
        vll(f,mx+1)
        f[0] = 1;
        rep(i,1,mx+1) f[i] = f[i-1]*i%modulo;
        vll(inv,mx+1)
        inv[mx] = [&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(f[mx],modulo-2);
        per(i,mx-1,-1) inv[i] = inv[i+1]*(i+1)%modulo;
        auto C = [&](ll n,ll k) -> ll{
            if(k > n) rt 0;
            rt f[n]*inv[k]%modulo*inv[n-k]%modulo;
        };
        vlll dp(e+1,vl(sum+1,0));
        dp[0][0] = 1;
        rep(d,0,10){
            if(!ct[d]) cnt;
            per(t,e,-1){
                per(s,sum,-1){
                    if(!dp[t][s]) cnt;
                    rep(k,1,ct[d] + 1){
                        if(!(t+k <= e) || !(s+d*k <= sum)) brk;
                        ll ns = s+d*k;
                        dp[t+k][ns] = (dp[t+k][ns]+dp[t][s]*C(ct[d],k))%modulo;
                    }
                }
            }
        }
        ll ans = dp[e][sum],pf = 1;
        rep(d, 0, 10) pf = pf*f[ct[d]]%modulo;
        ans = ans*f[e]%modulo;ans = ans*f[o]%modulo;
        ans = ans*[&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(pf,modulo-2)%modulo;
        rt (int)ans;
    }
};",1441355501
wei zhang,l1l2,141,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;


class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> time(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.emplace(moveTime[0][0], make_pair(0, 0));
        time[0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};

        while (!pq.empty()) {
            auto [t, p] = pq.top(); pq.pop();
            int i = p.first, j = p.second;
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    
                    int nt = max({t, moveTime[i][j], moveTime[ni][nj]}) + 1;
                    if (nt < time[ni][nj]) {
                        time[ni][nj] = nt;
                        pq.emplace(nt, make_pair(ni, nj));
                    }
                }
            }
        }
        return -1;
    }
};
",1441349376
wei zhang,l1l2,141,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<vector<int>>> time(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(moveTime[0][0], 0, 0, 0);
        time[0][0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

        while (!pq.empty()) {
            auto [t, i, j, k] = pq.top(); pq.pop();
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j][k]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int c = (k == 0) ? 1 : 2;
                    int t_start = max({t, moveTime[i][j], moveTime[ni][nj]});
                    int arrival_time = t_start + c;
                    int nk = 1 - k;
                    if (arrival_time < time[ni][nj][nk]) {
                        time[ni][nj][nk] = arrival_time;
                        pq.emplace(arrival_time, ni, nj, nk);
                    }
                }
            }
        }
        return -1;
    }
};
",1441355653
wei zhang,l1l2,141,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long se = 0;
        long long so = 0;

        for(int i = 0; i < num.size(); i += 2) {
            se += (num[i] - '0');
        }

        for(int i = 1; i < num.size(); i += 2) {
            so += (num[i] - '0');
        }

        return se == so;
    }
};",1441287354
wei zhang,l1l2,141,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

ll power_mod(ll a, ll b, ll mod_val){
    ll res=1;a%=mod_val;
    while(b>0){
        if(b&1) res=res*a%mod_val;
        a=a*a%mod_val; b>>=1;
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int f[10] = {0};
        ll total =0;
        for(char c: num) {f[c-'0']++; total += (c-'0');}
        if(total%2) return 0;
        ll tgt = total/2;
        int ne = (n+1)/2, no = n/2;
        vector<ll> fact(n+1,1), invf(n+1,1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1]*i%MOD;
        invf[n] = power_mod(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--) invf[i] = invf[i+1]*(i+1)%MOD;
        vector<vector<ll>> dp(ne+1, vector<ll>(tgt+1,0));
        dp[0][0]=1;
        for(int d=0;d<10;d++) {
            if(f[d]==0) continue;
            vector<vector<ll>> ndp(ne+1, vector<ll>(tgt+1,0));
            for(int k=0;k<=ne;k++) {
                for(ll s=0;s<=tgt;s++) {
                    if(dp[k][s]==0) continue;
                    for(int c=0;c<=min(f[d], ne -k);c++) {
                        ll ns = s + (ll)c*d;
                        if(ns > tgt) continue;
                        ll comb = fact[f[d]] * invf[c] % MOD;
                        comb = comb * invf[f[d]-c] % MOD;
                        ndp[k+c][ns] = (ndp[k+c][ns] + dp[k][s]*comb)%MOD;
                    }
                }
            }
            dp = move(ndp);
        }
        ll sa = dp[ne][tgt];
        ll ipf =1;
        for(int d=0;d<10;d++) if(f[d]>0) ipf = ipf * invf[f[d]] % MOD;
        ll fe = fact[ne], fo = fact[no];
        ll ans = fe * fo % MOD;
        ans = ans * sa % MOD;
        ans = ans * ipf % MOD;
        return ans;
    }
};
",1441307596
delphih,delphih,142,3627,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0
        que = [(0, 0, 0)]  # d, r, c
        while que:
            d, r, c = heappop(que)
            if d != D[r][c][0]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                d2 = max(d, A[r2][c2]) + 1
                if d2 < D[r2][c2][0]:
                    D[r2][c2][0] = d2
                    heappush(que, (d2, r2, c2))
        # print(D)
        return D[-1][-1][0]",1441294936
delphih,delphih,142,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf, inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0 # (next 1, next 2)
        que = [(0, 0, 0, 0)]  # d, r, c, t
        while que:
            d, r, c, t = heappop(que)
            if d != D[r][c][t]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                t2 = 1 - t
                d2 = max(d, A[r2][c2]) + t + 1
                if d2 < D[r2][c2][t2]:
                    D[r2][c2][t2] = d2
                    heappush(que, (d2, r2, c2, t2))
        # print(D)
        return min(D[-1][-1])",1441296845
delphih,delphih,142,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = sum(int(c) for c in num[::2])
        s2 = sum(int(c) for c in num[1::2])
        return s1 == s2",1441281691
delphih,delphih,142,3637,python3,"M = 10**9+7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
        tot = sum(int(d) for d in num)
        if tot % 2 != 0: return 0
            
        freq = Counter(num)
        
        dp = [[Counter() for _ in range(n_odd+1)] for _ in range(n_even+1)]  # dp[even][odd][even - odd]
        dp[0][0][0] = 1
        cur = 0
        for d, cnt in freq.items():
            d = int(d)
            for i0 in range(cur-n_odd, min(cur, n_even)+1):
                i1 = cur - i0
                # if i1 > n_odd: continue
                # print(i0, i1)
                for diff0, ways0 in dp[i0][i1].items():
                    for j0 in range(cnt+1):
                        j1 = cnt - j0
                        if i0+j0 > n_even or i1+j1 > n_odd: continue
                        diff = diff0 + (j0-j1) * d
                        ways = ways0 * comb(i0+j0, j0) * comb(i1+j1, j1) % M
                        dp[i0+j0][i1+j1][diff] = (dp[i0+j0][i1+j1][diff] + ways) % M
            cur += cnt
        return dp[n_even][n_odd][0]",1441356652
Syed Ali Aatif,mafailure,143,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; 
        pq.push(make_pair(0,0)); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<int>> d(n, vector<int>(m,inf)); 
        d[0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second;
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y]>max(moveTime[x][y]+1, _d+1)) {
                    d[x][y] = max(moveTime[x][y]+1, _d+1); 
                    pq.push(make_pair(d[x][y], x*m+y)); 
                }
            }
        }
        return d[n-1][m-1]; 
    }
};",1441297641
Syed Ali Aatif,mafailure,143,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; 
        pq.push(make_pair(0,make_pair(0,0))); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m,vector<int>(2,inf))); 
        d[0][0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second.first;
            auto _ = pq.top().second.second; 
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y][1-_]>max(moveTime[x][y], _d)+1+_) {
                    d[x][y][1-_] = max(moveTime[x][y], _d)+1+_; 
                    pq.push(make_pair(d[x][y][1-_], make_pair(x*m+y,1-_))); 
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]); 
    }
};",1441302882
Syed Ali Aatif,mafailure,143,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> cnt(2); 
        for(int i=0;i<num.size();i++){
            cnt[i%2]+=num[i]-'0'; 
        }
        return cnt.front() == cnt.back(); 
    }
};",1441285747
Syed Ali Aatif,mafailure,143,3637,cpp,"const int mod = 1e9+7; 
class Solution {
public:
#define int long long 
    int add (int a,int b ) { return (a+b)%mod;}
    int mul (int a,int b) {return a*b%mod;}
    int sub(int a,int b) { return (a-b+mod)%mod;}
    int power(int a,int b,int mod) {
        if(b==0)return 1; 
        int u = power(a,b>>1,mod); 
        u = mul(u,u);
        if(b%2)u = mul(u,a); 
        return u; 
    }


    int32_t countBalancedPermutations(string num) {
        int dp[num.size()+1][9*num.size()+1];
        memset(dp,0,sizeof(dp)); 
        vector<int> cnt(10);
        for(auto it:num)cnt[it-'0']++; 
        vector<int> fact(81);
        fact[0] = 1; 
        for(int i=1;i<fact.size();i++)fact[i] = mul(i,fact[i-1]); 
        vector<int> ifact(81,1); 
        ifact[80] = power(fact[80], mod-2, mod); 
        for(int i=79;i>=0;i--)ifact[i]=mul(i+1, ifact[i+1]); 
        int tot = 0; 
        for(auto it:num)tot+=it-'0'; 
        if(tot%2)return 0; 
        auto getAns = [&](vector<int> & c,int t) {
            int dp[11][81][81*9]; 
            memset(dp,0,sizeof(dp)); 
            dp[0][0][0] = 1; 
            for(int i=0;i<10;i++){
                for(int j=0;j<=t;j++){
                    for(int p = 0;p<81*9;p++){
                    if(dp[i][j][p] == 0)continue; 
                    for(int k=0;k<=c[i] && k+j<=t;k++){
                         //cout<<i<<"" ""<<j<<"" ""<<p<<"" ""<<k<<"" ""<<t<<endl; 
                        dp[i+1][j+k][p+k*i] = add(dp[i+1][j+k][p+k*i], mul(dp[i][j][p], mul(ifact[k], ifact[c[i]-k])));
                    }
                    }
                }
            }
            return dp[10][t][tot/2]; 
        };
        int n = num.size();
        int o = (n+1)/2;
        int e = n-o; 
        int ans = mul(mul(fact[o], fact[e]), getAns(cnt, o)); 
    
        return ans;
    }

#undef int
};",1441350773
Shubham Maheshwari,sm_27,144,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0))]
        visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+1,(x,y)))
                        visited.add((x,y))
                        
                        
            ",1441298499
Shubham Maheshwari,sm_27,144,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0),0)]
        times = [[[float(""inf""), float(""inf"")] for _ in range(m)] for _ in range(n)]
        # visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node,move = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            # visited.add(node)
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if max(curr,moveTime[x][y]) + move < times[x][y][(move+1)%2]:
                    # if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+move+1,(x,y),(move+1)%2))
                        times[x][y][(move+1)%2] = max(curr,moveTime[x][y]) + move                        
                        
            ",1441313266
Shubham Maheshwari,sm_27,144,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(n):
            if i&1:
                odd += int(num[i])
            else:
                even += int(num[i])
        return odd == even",1441281409
Shubham Maheshwari,sm_27,144,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        def C(n,r):
            return math.comb(n,r)
        n = len(num)
        nums = dict()
        for i in range(10):
            nums[i] = 0
        s = 0
        for c in num:
            nums[int(c)] += 1
            s += int(c)
        if s %2 != 0:
            return 0
        odd = n//2
        if n&1:
            odd += 1
        MOD = 10**9+7
        @lru_cache(None)
        def dfs(num, odd,even, rem):
            nonlocal MOD
            # print(num,odd,even,rem)
            if rem == 0 and num == 10:
                if odd == 0 and even == 0:
                    return 1
                return 0
            if num >= 10:
                return 0
            if odd < 0 or even < 0:
                return 0
            if rem < 0:
                return 0
            ans = 0
            for count in range(nums[num]+1):
                # we select count num in odd side
                if rem < count*num and count <= odd and nums[num]-count <= even:
                    continue
                # count in odd and nums[num]-count in even
                facts = (C(odd,count)*C(even,nums[num]-count))% MOD
                ans += (dfs(num+1,odd-count,even-nums[num]+count,rem-count*num) * facts)
                ans %= MOD
            # if num == 1:
                # print(ans)
            return ans
            
            
        return dfs(0,odd,n-odd,s//2)
            ",1441363442
Umesh Kumar,icosa,145,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<ii, vector<ii>, greater<ii>> pq;
        pq.push({0, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] == inf){
                        dp[ni][nj] = 1 + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441299654
Umesh Kumar,icosa,145,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;
        typedef tuple<ll, ll, ll> iii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<iii, vector<iii>, greater<iii>> pq;
        pq.push({0, 1, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, mt, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;

            if(dp[i][j] < t) continue;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] > mt + max(t, (ll)moveTime[ni][nj])){
                        dp[ni][nj] = mt + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], mt == 1? 2: 1, v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441309882
Umesh Kumar,icosa,145,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i=0; i<num.size(); i++){
            (i & 1 ? odd: even) += (num[i] - '0');
        }
        return even == odd;
    }
};",1441311751
Umesh Kumar,icosa,145,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define FOR(i, l, r) for (ll i = l; i < r; i++)
#define For(i, r, l) for (ll i = r - 1; i >= l; i--)
#define sz(x) x.size()
#define all(x) x.begin(), x.end()
#define pb push_back
#define eb emplace_back
#define ITER(itr, x) for (auto &itr : x)
#define LSOne(S) ((S) & (-S))

using namespace std;
#define debug(args...)                                                         \
  {                                                                            \
    string _s = #args;                                                         \
    replace(_s.begin(), _s.end(), ',', ' ');                                   \
    stringstream _ss(_s);                                                      \
    istream_iterator<string> _it(_ss);                                         \
    err(_it, args);                                                            \
  }
template <typename... Args>
void err(istream_iterator<string> it, Args... args) {
  ((cerr << *it << "" = "" << args << "" "", it++), ...);
  cerr << endl;
}

typedef pair<int, int> ii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<ii> vii;
typedef vector<vi> vvi;
typedef vector<vll> vvll;

/**
 * Description: modular arithmetic operations
 * Source:
 * KACTL
 * https://codeforces.com/blog/entry/63903
 * https://codeforces.com/contest/1261/submission/65632855 (tourist)
 * https://codeforces.com/contest/1264/submission/66344993 (ksun)
 * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp
 * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic
 */

template <int MOD, int RT> struct mint {
  static const int mod = MOD;
  static constexpr mint rt() { return RT; } // primitive root for FFT
  int v;
  explicit operator int() const {
    return v;
  } // explicit -> don't silently convert to int
  mint() : v(0) {}
  mint(ll _v) {
    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
    if (v < 0)
      v += MOD;
  }
  bool operator==(const mint &o) const { return v == o.v; }
  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
  friend void re(mint &a) {
    ll x;
    cin >> x;
    a = mint(x);
  }
  // friend str ts(mint a) { return ts(a.v); }

  mint &operator+=(const mint &o) {
    if ((v += o.v) >= MOD)
      v -= MOD;
    return *this;
  }
  mint &operator-=(const mint &o) {
    if ((v -= o.v) < 0)
      v += MOD;
    return *this;
  }
  mint &operator*=(const mint &o) {
    v = int((ll)v * o.v % MOD);
    return *this;
  }
  mint &operator/=(const mint &o) { return (*this) *= inv(o); }
  friend mint pow(mint a, ll p) {
    mint ans = 1;
    assert(p >= 0);
    for (; p; p /= 2, a *= a)
      if (p & 1)
        ans *= a;
    return ans;
  }
  friend mint inv(const mint &a) {
    assert(a.v != 0);
    return pow(a, MOD - 2);
  }

  mint operator-() const { return mint(-v); }
  mint &operator++() { return *this += 1; }
  mint &operator--() { return *this -= 1; }
  friend mint operator+(mint a, const mint &b) { return a += b; }
  friend mint operator-(mint a, const mint &b) { return a -= b; }
  friend mint operator*(mint a, const mint &b) { return a *= b; }
  friend mint operator/(mint a, const mint &b) { return a /= b; }
};

const ll MOD = 1e9 + 7;
using mi = mint<MOD, 5>; // 5 is primitive root for both common mods
using vmi = vector<mi>;
using pmi = pair<mi, mi>;
using vpmi = vector<pmi>;

vector<vmi> scmb; // small combinations
void genComb(int SZ) {
  scmb.assign(SZ, vmi(SZ));
  scmb[0][0] = 1;
  FOR(i, 1, SZ)
  FOR(j, 0, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);
}

/**
 * Description: pre-compute factorial mod inverses,
 * assumes MOD$ is prime and SZ < MOD$.
 * Time: O(SZ)
 * Source: KACTL
 * Verification: https://dmoj.ca/problem/tle17c4p5
 */

vmi invs, fac, ifac;
void genFac(int SZ) {
  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);
  invs[1] = fac[0] = ifac[0] = 1;
  FOR(i, 2, SZ) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);
  FOR(i, 1, SZ) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];
}
mi comb(int a, int b) {
  if (a < b || b < 0)
    return 0;
  return fac[a] * ifac[b] * ifac[a - b];
}

const int MAX_E = 41;
const int MAX_SE = MAX_E * 9;
mi dp[11][MAX_E][MAX_SE]; // count even, sum even

class Solution {
public:
  int countBalancedPermutations(string num) {
    genFac(1001);
    vi count(10, 0);
    for (auto c : num)
      count[c - '0']++;

    memset(dp, 0, sizeof(dp));
    dp[0][0][0] = 1;

    int n = num.size(), digs = 0, sum_digs = 0;
    for (int i = 0; i < 10; i++) {
      for (int e = 0; e < min(MAX_E, digs + 1); e++) {
        int odd = digs - e;
        for (int c = 0; c <= min(count[i], MAX_E - e - 1); c++) {
          for (int se = 0; se < min(sum_digs + 1, MAX_SE - c * i); se++) {
            int sum_odd = sum_digs - se;
            // put c in even places
            dp[i + 1][c + e][se + c * i] +=
                (dp[i][e][se] * comb((n + 1) / 2 - e, c) *
                 comb(n - (n + 1) / 2 - odd, count[i] - c));
          }
        }
      }

      digs += count[i];
      sum_digs += count[i] * i;
    }

    mi ans = 0;
    ans += dp[10][(n + 1) / 2][sum_digs / 2];

    if (sum_digs & 1)
      return 0;
    return (int)ans;
  }
};",1441363622
g129512,g129512,146,3627,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,1)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=1
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359512
g129512,g129512,146,3628,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,2)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=(1 if nt==2 else 2)
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359413
g129512,g129512,146,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n=len(num)
        s1=sum(int(num[i]) for i in range(n) if i%2==0)
        s2=sum(int(num[i]) for i in range(n) if i%2==1)
        return s1==s2
        ",1441359720
g129512,g129512,146,3637,python3,"from functools import cache
from typing import Counter

class Comb:
    def __init__(self, n, mod) -> None:
        p,pi=[0]*(n+1),[0]*(n+1)
        self.p,self.pi=p,pi
        self.mod=mod
        p[0]=1
        pi[0]=1
        for i in range(1,n+1):
            p[i]=p[i-1]*i%mod
        pi[n]=pow(p[n],mod-2,mod)
        for i in range(n-1,0,-1):
            pi[i]=pi[i+1]*(i+1)%mod
    
    def comb(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[r]*self.pi[n-r]%self.mod
    
    def perm(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[n-r]%self.mod

M=10**9+7
comb=Comb(80, M)

@cache
def cb(n,k):
    return comb.comb(n,k)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n=len(num)
        s=sum(int(v) for v in num)
        if s%2==1:return 0
        ct=Counter(num)
        dp=[[0]*361 for _ in range(41)]
        dp[0][0]=1
        prec=0
        for kk,v in ct.items():
            kk=int(kk)
            ndp=[[0]*361 for _ in range(41)]
            for i in range(n//2+1):
                for j in range(s//2+1):
                    for k in range(v+1):
                        if i+k>n//2 or j+k*kk>s//2:break
                        ndp[i+k][j+k*kk]+=dp[i][j]*cb(i+k,k)*cb(prec-i+v-k,v-k)
                        ndp[i+k][j+k*kk]%=M
            dp=ndp
            prec+=v
        return dp[n//2][s//2]",1441363810
Rahul Gupta,guts_berserker718,147,3627,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0}); 
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 1) : time + (k == 0 ? 1 : 1);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301916
Rahul Gupta,guts_berserker718,147,3628,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});  
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 2) : time + (k == 0 ? 1 : 2);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301323
Rahul Gupta,guts_berserker718,147,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0,b=0;
        for(int i=0;i<num.length();i++){
            if(i%2==0){
                a+=(num[i]-'0');
            }else b+=(num[i]-'0');
        }
    return a==b;
    }

};",1441281567
Rahul Gupta,guts_berserker718,147,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution {
public:
    ll nCr(int n, int r, const vector<ll>& fact, const vector<ll>& invFact) {
        if (r > n) return 0;
        return fact[n]* invFact[n - r] % MOD * invFact[r] % MOD ;
    }
    ll modPow(ll base, ll exp) {
        ll res = 1;
        while (exp) {
            if (exp & 1) res = res * base % MOD;
            base = base * base % MOD;
            exp >>= 1;
        }
        return res;
    }
    

    
    int countBalancedPermutations(string num) {
        int i = 0;
        int len = num.size();
         int half2 = len / 2;
        int half1 = (len + 1) / 2;
       
        
        vector<int> freq(12, 0);
       
        
        ll sum = 0;
       
        
        
        
        vector<ll>invFact(len + 5, 1), fact(len + 5, 1);
        i = 1;
        while (i <= len) {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        i=0;
        while (i < len) {
            freq[num[i] - '0']++;
            i++;
        }
        invFact[len] = modPow(fact[len], MOD - 2);
        i = len - 1;
        while (i >= 0) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
            i--;
        }
        
        i = 0;
        while (i < 10) {
            sum += 1LL * i * freq[i];
            i++;
        }
        if (sum % 2 != 0) return 0;
        ll target = sum / 2;

        
        

       vector<vector<ll>> dp(target + 5, vector<ll>(half1 + 5, 0));
dp[0][0] = 1;

int d = 0;
while (d < 10) {
    // if(freq[d]==0)continue;
    if (freq[d] != 0) {
        int j = half1;
        while (j >= 0) {
            int k = target;
            while (k >= 0) {
                if (dp[k][j] != 0) {
                    int c = 1;
                    while (c <= min(freq[d], half1 - j)) {
                        if (k + d * c > target) break;
                        ll ways = nCr(freq[d], c, fact, invFact);
                        dp[k + d * c][j + c] = (dp[k + d * c][j + c] % MOD + dp[k][j] * ways) % MOD;
                        c++;
                    }
                }
                k--;
            }
            j--;
        }
    }
    d++;
}

ll dpVal = dp[target][half1];
if (dpVal == 0) return 0;


ll factProd = 1;
d = 0;
while (d < 10) {
    factProd = (fact[freq[d]] % MOD * factProd % MOD) % MOD;
    d++;
}
ll result = (dpVal * fact[half1] % MOD * fact[half2] % MOD) % MOD;
result = result * modPow(factProd, MOD - 2) % MOD;
return result % MOD;

    }
};
",1441357919
xpycc,xpycc,148,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        pq.emplace(0, 0, 0);
        mt[0][0] = -1;
        while (!pq.empty()) {
            auto [t, x, y] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d];
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (mt[nx][ny] < 0) continue;
                const int nt = max(t + 1, mt[nx][ny] + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny);
                mt[nx][ny] = -1;
            }
        }
        return -1;
    }
};",1441305505
xpycc,xpycc,148,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        vector<int8_t> mem(n * m * 2);
        auto vis = [&](int x, int y, int b) -> int8_t& {
            return mem[x * m * 2 + y * 2 + b];
        };
        pq.emplace(0, 0, 0, 0);
        vis(0, 0, 0) = true;
        while (!pq.empty()) {
            auto [t, x, y, b] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y, b);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d], nb = !b;
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (vis(nx, ny, nb)) continue;
                const int nt = max(t + b + 1, mt[nx][ny] + b + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny, nb);
                vis(nx, ny, nb) = true;
            }
        }
        return -1;
    }
};",1441317271
xpycc,xpycc,148,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int diff = 0, f = 1;
        for (char c : num) {
            diff += f * (c - '0');
            f = -f;
        }
        return diff == 0;
    }
};",1441282241
xpycc,xpycc,148,3637,cpp,"class Solution {
    static constexpr int mod = 1'000'000'007;
    static int inv(int x) {
        int p = mod - 2;
        int a = 1;
        while (p > 0) {
            if (p & 1) a = a * 1LL * x % mod;
            p >>= 1;
            x = x * 1LL * x % mod;
        }
        return a;
    }
public:
    int countBalancedPermutations(string num) {
        const int n = num.size(), h = n / 2,
                  S = accumulate(num.begin(), num.end(), 0, [](int x, char c) {
                        return x + c - '0';
                    }),
                  H = S / 2;
        if (S % 2 != 0) return 0;
        vector<vector<int>> f(h + 1, vector<int>(H + 1));
        f[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = h; j >= 0; --j)
                for (int k = H; k >= 0; --k) {
                    int x = num[i] - '0';
                    f[j][k] = (f[j][k] * (i + 1LL - j)) % mod; 
                    if (j > 0 && k - x >= 0)
                        f[j][k] = (f[j][k] + f[j - 1][k - x] * 1LL * j) % mod;
                }
        }
        int count[10] = {};
        for (char c : num) count[c - '0']++;
        vector<int> fact(n + 1);
        fact[0] = 1;
        for (int i = 1; i <= n; ++i)
            fact[i] = (fact[i - 1] * 1LL * i) % mod;
        int ans = f[h][H];
        for (int i = 0; i < 10; ++i)
            ans = (ans * 1LL * inv(fact[count[i]])) % mod;
        return ans;
    }
};",1441359032
BHISHMADEV GHOSH,bhishma_v2,150,3627,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][] minTime = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                minTime[i][j] = Integer.MAX_VALUE;
            }
        }
        minTime[0][0] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0});

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];

            if (curR == n - 1 && curC == m - 1) {
                return time;
            }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + 1;
                    if (newTime < minTime[rr][cc]) {
                        minTime[rr][cc] = newTime;
                        q.offer(new int[]{rr, cc, newTime});
                    }
                }
            }
        }

        return -1;
    }
}
",1441315131
BHISHMADEV GHOSH,bhishma_v2,150,3628,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] minTime = new int[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for(int k = 0; k <= 1; k++){
                minTime[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }
        minTime[0][0][0] = 0;
        minTime[0][0][1] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0,0});
        

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];
            int k = t[3];

            // if (curR == n - 1 && curC == m - 1) {
            //     return time;
            // }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + (k == 0 ? 1 : 2);
                    if (newTime < minTime[rr][cc][k]) {
                        minTime[rr][cc][k] = newTime;
                        q.offer(new int[]{rr, cc, newTime, k == 0 ? 1 : 0});
                    }
                }
            }
        }

        return Math.min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
}
",1441321903
BHISHMADEV GHOSH,bhishma_v2,150,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int sum1 = 0, sum2 = 0;

        for(int i = 0; i < n; i++){
            if(i % 2 == 0)sum1 += (num.charAt(i) - '0');
            else sum2 += (num.charAt(i) - '0');
        }

        return sum1 == sum2;
    }
}",1441282941
BHISHMADEV GHOSH,bhishma_v2,150,3637,java,"import java.util.*;

class Solution {
    int mod = (int) 1e9 + 7;
    long[][][] dp;
    Map<Integer, Integer> freqMap = new HashMap<>();

    long fact(int n) {
        long res = 1;
        for (int i = 1; i <= n; i++) {
            res = (res * i) % mod;
        }
        return res;
    }

    long modInverse(long a, int mod) {
        long res = 1;
        long power = mod - 2;
        while (power > 0) {
            if ((power & 1) != 0) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            power >>= 1;
        }
        return res;
    }

    public int countBalancedPermutations(String num) {
        int sum = 0;
        List<Integer> cur = new ArrayList<>();
        int n = num.length();

        for (char c : num.toCharArray()) {
            int digit = c - '0';
            sum += digit;
            cur.add(digit);
            freqMap.put(digit, freqMap.getOrDefault(digit, 0) + 1);
        }

        if (sum % 2 != 0)
            return 0;

        int odd = n / 2, even = (n + 1) / 2, target = sum / 2;
        dp = new long[n][even + 1][target + 1];

        for (long[][] rr : dp) {
            for (long[] r : rr) Arrays.fill(r, -1);
        }

        long ways = getWays(0, cur, even, target);

        for (int f : freqMap.values()) {
            ways = (ways * modInverse(fact(f), mod)) % mod;
        }

        long factEven = fact(even);
        long factOdd = fact(odd);

        return (int) ((ways * factEven % mod) * factOdd % mod);
    }

    long getWays(int ind, List<Integer> cur, int n, int target) {
        if (n < 0 || target < 0) return 0;
        if (ind == cur.size()) return (n == 0 && target == 0) ? 1 : 0;

        if (dp[ind][n][target] != -1) return dp[ind][n][target];

        long take = 0, notTake = 0;

        if (cur.get(ind) <= target) {
            take = getWays(ind + 1, cur, n - 1, target - cur.get(ind));
        }

        notTake = getWays(ind + 1, cur, n, target);

        return dp[ind][n][target] = (take + notTake) % mod;
    }
}
",1441365713
Abhishek Srivastava,Abhi_Srivastava,151,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        queue<pair<int, int>> q;
        dist[0][0] = 0;
        q.push({0, 0});
        while (!q.empty()) {
            int x = q.front().first, y = q.front().second;
            q.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 1) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 1;
                        q.push({x + i, y + j});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441298457
Abhishek Srivastava,Abhi_Srivastava,151,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        while (!pq.empty()) {
            int dst = pq.top().first, x = pq.top().second.first, y = pq.top().second.second;
            pq.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2)) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2);
                        pq.push({dist[x + i][y + j], {x + i, y + j}});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441311456
Abhishek Srivastava,Abhi_Srivastava,151,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2)
                sum += num[i] - '0';
            else
                sum -= num[i] - '0';
        }
        return !sum;
    }
};",1441281587
Abhishek Srivastava,Abhi_Srivastava,151,3637,cpp,"const int mod = 1e9 + 7;
long long fact[81], inv_fact[81];
long long binpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b % 2)
            (res *= a) %= mod;
        (a *= a) %= mod;
        b /= 2;
    }
    return res;
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if (!fact[0]) {
            fact[0] = 1;
            for (int i = 1; i < 81; i++)
                fact[i] = (fact[i - 1] * i) % mod;
            inv_fact[80] = binpow(fact[80], mod - 2);
            for (int i = 79; i >= 0; i--)
                inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;
        }
        int dig = num.size() / 2, sum = 0;
        int freq[10] = {};
        for (char x : num) {
            sum += x - '0';
            freq[x - '0']++;
        }
        if (sum % 2)
            return 0;
        sum /= 2;
        vector<vector<int>> dp(dig + 1, vector<int>(sum + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i <= 9; i++) {
            vector<vector<int>> ndp(dig + 1, vector<int>(sum + 1, 0));
            for (int j = 0; j <= freq[i]; j++)
                for (int k = j; k <= dig; k++)
                    for (int l = i * j; l <= sum; l++)
                        (ndp[k][l] += dp[k - j][l - i * j] * inv_fact[j] % mod * inv_fact[freq[i] - j] % mod) %= mod;
            swap(dp, ndp);
        }
        return dp[dig][sum] * fact[dig] % mod * fact[num.size() - dig] % mod;
    }
};",1441353464
avienn_x,avienn_x,152,3627,cpp,"class Solution {
public:
    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<long long>> dist(n, vector<long long>(m, INT_MAX));
        dist[0][0] = 0;
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            long long t = curr[0];
            long long i = curr[1];
            long long j = curr[2];
            if (i == n-1 && j == m-1)
                return t;
            if (t > dist[i][j])
                continue;
            for (auto &d : dirs) {
                long long ni = i + d.first;
                long long nj = j + d.second;
                if(!chck(ni, nj, n, m))
                    continue;
                int sr = max(t, 1ll * mt[ni][nj]);
                if (sr + 1 < dist[ni][nj]) {
                    dist[ni][nj] = sr + 1;
                    pq.push({sr + 1, ni, nj});
                }
            }
        }
        return INT_MAX;
    }
};",1441304877
avienn_x,avienn_x,152,3628,cpp,"class Solution {
public:

    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<vector<long long>>> dist(n, vector<vector<long long>>(m, vector<long long>(2, INT_MAX)));
        dist[0][0][0] = 0;
        priority_queue<vector<int>, vector<vector<int>>, std::greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int t = curr[0];
            int i = curr[1];
            int j = curr[2];
            int p = curr[3];
            if (i == n-1 && j == m-1 || t > dist[i][j][p])
                continue;
            for (auto &d : dirs) {
                int ni = i + d.first;
                int nj = j + d.second;
                if(!chck(ni, nj, n, m))
                        continue;
                int sr = max(t, mt[ni][nj]);
                int mv = (p == 0) ? 1 : 2;
                int nxt = sr + mv;
                int np = 1 - p;
                if (nxt < dist[ni][nj][np]){
                        dist[ni][nj][np] = nxt;
                        pq.push({nxt, ni, nj, np});
                }

            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441316491
avienn_x,avienn_x,152,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int a = 0, b= 0 ;
        for(int i = 0; i < n; i++){
            if(i % 2)
                a += num[i] - '0';
            else
                b += num[i] - '0';
        }
        return a == b;
    }
};",1441305980
avienn_x,avienn_x,152,3637,cpp,"
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
const int MAXN = 105; 
const int MAXS = 1100;
typedef long long ll;

ll dp[MAXN][MAXS];
ll f[MAXN], invf[MAXN];
int fr[10];

class Solution {
private:
    ll mpow(ll b, ll p) {
        ll r = 1;
        b %= MOD;
        while (p > 0) {
            if (p & 1) r = (r * b) % MOD;
            b = (b * b) % MOD;
            p >>= 1;
        }
        return r;
    }
    
    void precalc(int sz) {
        f[0] = 1;
        for (int i = 1; i <= sz; i++) {
            f[i] = (f[i-1] * i) % MOD;
        }
        invf[sz] = mpow(f[sz], MOD-2);
        for (int i = sz-1; i >= 0; i--) {
            invf[i] = (invf[i+1] * (i+1)) % MOD;
        }
    }
    
    ll ncr(int n, int r) {
        if (r > n) return 0;
        return (((f[n] * invf[r]) % MOD) * invf[n-r]) % MOD;
    }

public:
    int countBalancedPermutations(string s) {
        int n = s.length();
        int m = (n + 1) / 2;
        int h = n / 2;
        ll sm = 0;
        memset(fr, 0, sizeof(fr));
        for (char c : s){
        	fr[c-'0']++;
        	sm += (c - '0');
        }
        if (sm % 2) return 0;
        ll t = sm / 2;
        precalc(n);
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
   			
        for (int d = 0; d < 10; d++) {
            if (!fr[d]) continue;
            ll available = fr[d];
            for (int cs = t; cs >= 0; cs--) {
                for (int p = m; p >= 0; p--) {
                    if (!dp[p][cs])
                        continue;

                    ll val = dp[p][cs];
                    ll rem = m - p;

                    for (int c = 1; c <= available && c <= rem; c++) {
                        if (cs + 1LL * d * c > t) break;

                        ll cmb = f[fr[d]];
                        (cmb *= invf[c]) %= MOD;
                        (cmb *= invf[fr[d] - c]) %= MOD;

                        (dp[p + c][cs + d * c] += val * cmb) %= MOD;
                    }
                }
            }
        }

        if (!dp[m][t]) return 0;
        
        ll ff = 1;
        for (int d = 0; d < 10; d++) {
            ff = (ff * f[fr[d]]) % MOD;
        }
        
        ll iff = mpow(ff, MOD-2);
        ll ans = dp[m][t];
        ans = (ans * f[m]) % MOD;
        ans = (ans * f[h]) % MOD;
        ans = (ans * iff) % MOD;
        
        return ans;
    }
};",1441366231
ABHAY GUPTA,abhayg_07,153,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq;
        pq.push({0,0,0});
        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0] = 0;
        while(!pq.empty()){
            array<int,3> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy] > max( a[0] , moveTime[newx][newy] ) + 1 ){
                    dis[newx][newy] = max( a[0] , moveTime[newx][newy] ) + 1;
                    pq.push({dis[newx][newy],newx,newy});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441306123
ABHAY GUPTA,abhayg_07,153,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<long long,4>,vector<array<long long,4>>,greater<array<long long,4>>> pq;
        pq.push({0,0,0,0});
        long long dis[n][m][2];
        for( int i = 0 ; i < n ; i++ ){
            for( int j = 0 ; j < m ; j++ ){
                for( int k = 0 ; k < 2 ; k++ ){
                    dis[i][j][k] = 1e15;
                }
            }
        }
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0][0] = 0;
        while(!pq.empty()){
            array<long long,4> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]][a[3]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy][a[3]^1] > max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1 ){
                    dis[newx][newy][a[3]^1] = max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1;
                    pq.push({dis[newx][newy][a[3]^1],newx,newy,a[3]^1});
                }
            }
        }
        return min(dis[n-1][m-1][0],dis[n-1][m-1][1]);
    }
};",1441314055
ABHAY GUPTA,abhayg_07,153,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0 , o = 0;
        for( int i = 0 ; i < num.size() ; i++ ){
            if(i&1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return e == o;
    }
};",1441282354
ABHAY GUPTA,abhayg_07,153,3637,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    vector<long long> fact , ifact;

    long long expo(long long a, long long b, long long m)
    {
        long long res = 1;
        while (b > 0)
        {
            if (b & 1)
                res = (res * a) % m;
            a = (a * a) % m;
            b = b >> 1;
        }
        return res % m;
    }

    long long modinv(long long a, long long m) { return expo(a, m - 2, m) % m; } // m is prime

    long long dp[10][162][1500];
    // // center is 750
    int cnt[10];

    void init(long long  n){
        fact.resize(n);
        ifact.resize(n);
        fact[0]=1;
        for( int i = 1 ; i < n ; i++ ) fact[i]=(fact[i-1]%mod*i)%mod;
        ifact[n-1]=modinv(fact[n-1],mod)%mod;
        for(int i=n-2 ; i>=1 ; i--){
            ifact[i]=(ifact[i+1]%mod*(i+1))%mod;
        }
        ifact[0]=1;
    }

    long long recursion( int d , int c , int diff ){
        if( d == -1 && c== 80 && diff == 750 ) return 1;
        else if( d == -1 ) return 0;
        if( dp[d][c][diff] != -1 )return dp[d][c][diff];
        long long ways = 0;
        for( int i = 0 ; i <= cnt[d] ; i++ ){
            // this much d is given to 1
            int newc = c + i - ( cnt[d] - i );
            int newdiff = diff + i * d - ( cnt[d] - i ) * d;
            int D = ( ifact[i]%mod * ifact[cnt[d]-i]%mod )%mod;
            ways = ( ways%mod + ( recursion( d - 1 , newc , newdiff )%mod * D%mod )%mod )%mod;
        }
        return dp[d][c][diff] = ways;
    }

    int countBalancedPermutations(string num) {
        init(10000);
        
        for( int i = 0 ; i < 10 ; i++ ){
            for( int j = 0 ; j < 162 ; j++ ){
                    for( int l = 0 ; l < 1500 ; l++ ){
                        dp[i][j][l] = -1;
                    }
            }
        }
        for( int i = 0 ; i < 10 ; i++ ){
            cnt[i] = 0;
        }
        for( auto i : num ){
            int d = i - '0';
            cnt[d]++;
        }
        int n = num.size();
        long long ways = recursion( 9 , 80 + (n&1) , 750 );
        ways = ( ways * fact[(n+1)/2]%mod )%mod;
        ways = ( ways * fact[n/2]%mod )%mod;
        return ways;
    }
};",1441354161
Yuanbin Cheng,cybsbbbb,154,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[float('inf')] * n for _ in range(m)]
        distance[0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y = heapq.heappop(queue)
            if distance[cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y = cur_x + dx, cur_y + dy
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1, cur_dis + 1)
                    if distance[nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y))

        return distance[-1][-1]

        ",1441303445
Yuanbin Cheng,cybsbbbb,154,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[[float('inf')] * n for _ in range(m)] for _ in range(2)]
        distance[0][0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y, cur_step = heapq.heappop(queue)
            if distance[cur_step][cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y, nxt_step = cur_x + dx, cur_y + dy, (cur_step + 1) % 2
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1 + cur_step, cur_dis + 1 + cur_step)
                    if distance[nxt_step][nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_step][nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y, nxt_step))

        return min(distance[0][-1][-1], distance[1][-1][-1])
        ",1441309705
Yuanbin Cheng,cybsbbbb,154,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(0, n, 2):
            even += int(num[i])
        for i in range(1, n, 2):
            odd += int(num[i])
        return odd == even
        ",1441284061
Yuanbin Cheng,cybsbbbb,154,3637,python3,"MOD = 10 ** 9 + 7
MAXN = 80
fac = [1] * MAXN
inv_fac = [1] * MAXN
for i in range(1, MAXN):
    fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN - 1] = pow(fac[MAXN - 1], -1, MOD)
for i in range(MAXN - 2, -1, -1):
    inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD

def combination(n, k):
    return (fac[n] * inv_fac[k] % MOD) * inv_fac[n - k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        
        cnt = [0] * 10
        tot = 0
        for i in range(n):
            ni = int(num[i])
            cnt[ni] += 1
            tot += ni
        if tot % 2 == 1:
            return 0

        tot_half = tot // 2
        n_even = n // 2 + n % 2
        n_odd = n // 2

        @cache
        def dp(even_v, odd_v, even_c, odd_c, d):
            if even_c < 0 or odd_c < 0:
                return 0
            
            if d == 0:
                if even_v or odd_v:
                    return 0
                else:
                    return 1
            res = 0
            d_cnt = cnt[d]
            for i in range(d_cnt + 1):
                if even_v < i * d or odd_v < (d_cnt - i) * d:
                    continue
                # print(even_c, odd_c)
                res += comb(even_c, i) * comb(odd_c, d_cnt - i) * dp(even_v - i * d, odd_v - (d_cnt - i) * d, even_c - i, odd_c - (d_cnt - i), d - 1) % MOD
            # print(even_v, odd_v, even_c, odd_c, d, res)
            return res % MOD

        return dp(tot_half, tot_half, n_even, n_odd, 9)
            


        

        
        ",1441360555
Matt,mattagar6,155,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int lo = 0, hi = 1e9 + 1;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 1e9+n+m+1000));
        d[0][0] = 0;

        set<tuple<int,int,int>> s;
        s.insert({0,0,0});

        auto go = [&](int r, int c, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;

            int min_time_to_him = moveTime[nr][nc];
            int his_dis = max(dis, min_time_to_him) + 1;
            if(his_dis < d[nr][nc]) {
                s.erase({d[nr][nc], nr, nc});
                d[nr][nc] = his_dis;
                s.insert({d[nr][nc], nr, nc});
            }
            
        };
        
        while(!s.empty()) {
            auto [dis, r, c] = *s.begin();
            s.erase(s.begin());

            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(abs(dx) + abs(dy) == 1) {
                        go(r, c, dis, r + dx, c + dy);
                    }
                }
            }
        }
        
        return d[n-1][m-1];
    }
};",1441337323
Matt,mattagar6,155,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2,2e9)));
        d[0][0][0] = 0;
        set<tuple<int,int,int,int>> s;
        s.insert({0,0,0,0});
        // arrive at r, c with parity p
        auto go = [&](int r, int c, int p, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;
            // we are going now for sure!
            int starting_time = max(dis, grid[nr][nc]);
            dis=starting_time;
            // go now
            for(int rep = 0; rep < 2; rep++, dis++) {
                int np = (p + 1)%2;
                if( dis + 1 + p % 2 < d[nr][nc][np] ) {
                    s.erase({d[nr][nc][np], nr, nc, np});
                    d[nr][nc][np] = dis + 1 + p % 2;
                    s.insert({d[nr][nc][np], nr, nc, np});
                }
            }
            
            
            // wait, then go
            
        };

        while(!s.empty()) {
            auto [dis, r, c, p] = *s.begin();
            s.erase(s.begin());
            for(int dx = -1; dx <= 1; ++dx) {
                for(int dy = -1; dy <= 1; ++dy) {
                    if(abs(dx)+abs(dy)!=1) continue;
                    go(r, c, p, dis, r + dx, c + dy);
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441366949
Matt,mattagar6,155,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0, b = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                a += num[i] - '0';
            } else {
                b += num[i] - '0';
            }
        }
        return a == b;
    }
};",1441297104
Matt,mattagar6,155,3637,cpp,"// for each group of digits

// x o o o x x o o  o
// have N at even, M at odd


struct I {
    long long x{};
};

const int MOD = 1000*1000*1000+7;

I operator + (I a, I b) {
    return I{(a.x + b.x) % MOD};
}

I operator * (I a, I b) {
    return I {(a.x * b.x) % MOD};
}

const int N = 100;
const int M = 1000;
I choose[N][N];
I dp[11][N][M];



// number of used even squares, sum on even squares
class Solution {
public:
    int countBalancedPermutations(string num) {
        for(int i = 0; i < N; i++) {
            choose[i][0] = choose[i][i] = I{1};
            for(int j = 1; j < i; j++) {
                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];
            }
        }
        for(int i = 0; i < 11; i++) for(int j = 0; j < N; j++) for(int k = 0; k < M; k++) dp[i][j][k] = I{0};

        map<int,int> count;
        for(char ch : num) count[ch - '0']++;

        int n = num.size();
        dp[0][0][0] = I{1};
        for(int d = 0; d < 10; d++) {
            int to_put = count[d];
            int sum_all = 0;
            int count_all = 0;
            for(char ch : num) {
                if(ch-'0' < d) {
                    sum_all += ch-'0';
                    count_all+=1;
                }
            }
            
            for(int even = 0; even <= (n+1)/2; even++) {
                for(int sum_even = 0; sum_even <= 9*even; sum_even++) {
                    int sum_odd = sum_all - sum_even;
                    if(sum_odd < 0) continue;
                    for(int on_even = 0; on_even <= to_put; on_even++) {
                        if(on_even + even > (n + 1) / 2) continue;
                        if(n/2-(count_all-even)<to_put-on_even) continue;//odd indices

                        dp[d+1][on_even + even][sum_even + d * on_even] =  dp[d+1][on_even + even][sum_even + d * on_even] + dp[d][even][sum_even] * choose[(n+1)/2 - even ][ on_even ] * choose[n/2-(count_all-even)][ to_put - on_even ];
                    }
                }
            }
        }
        //cout << dp[2][1][1].x << '\n'; // digit 1 is done, one even, sum 1 -> 1 x x, x x 1
       // cout << dp[2][0][0].x; // x 1 x
        int sum = 0;
        for(char c : num) sum += c - '0';
        if(sum % 2 == 1) return 0;
        return dp[10][(n+1)/2][sum/2].x;
    }
};",1441329857
harshal_02,harshal_02,156,3627,cpp,"

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});  
        vector<vector<ll>>vec(n,vector<ll>(m, INF));
        vec[0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j = upr.j;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1) {
                return b;
            }
            if (b > vec[i][j]) {
                continue;
            }
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + 1;
                    if (maxi < vec[ii][jj]) {
                        vec[ii][jj] = maxi;
                        pq.push(st{ii, jj, 0, maxi});  
                    }
                }
            }
        }
        return -1;
    }
};
",1441334267
harshal_02,harshal_02,156,3628,cpp,"#include <vector>
#include <queue>
#include <algorithm>

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});
        vector<std::vector<std::vector<ll>>> vec(n, std::vector<std::vector<ll>>(m, std::vector<ll>(2, INF)));
        vec[0][0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j= upr.j;
            int p= upr.par;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1){
                return b;
        }
            if (b > vec[i][j][p]){
                continue;
    }
        int tot = (p == 0) ? 1 : 2;
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];    
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + tot;
                    int np = 1 - p;
                    if (maxi < vec[ii][jj][np]) {
                        vec[ii][jj][np] = maxi;
                        pq.push(st{ii, jj, np, maxi});
                    }
                }
            }
        }
        ll ans=min(vec[n - 1][m - 1][0], vec[n - 1][m - 1][1]);
        return ans;
    }
};
",1441316511
harshal_02,harshal_02,156,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.size();
        int e=0;
        int o=0;
        for(int i=0;i<n;i++) {
            if(i%2==0){
                e+=num[i]-'0';
        }
            else{
                o+=num[i]-'0';
            }
        }
        return e==o;
    }
};",1441317691
harshal_02,harshal_02,156,3637,cpp,"#define ll long long int
const int MOD=1e9+7;
struct Solution {
    ll mathpow(ll base, ll exponent) {
        ll result=1;
        base=base%MOD;
        while(exponent>0) {
            if(exponent&1)
                result=result*base;
            result=result%MOD;
            base=base*base;
            base=base%MOD;
            exponent>>=1;
        }
        return result;
    }
    ll compute_factorial(int n) {
        ll fact=1;
        for(int i=1;i<n+1;i++){
            fact=fact*i;
            fact=fact%MOD;
        }
        return fact;
    }
    ll compute_combination(int n, int k) {
        if(k > n || k < 0) 
            return 0;
        ll comb=1;
        for(int i=1; i<=k; i++) {
            comb=comb*(n-i+1);
            comb=comb%MOD;
            ll inverse=mathpow(i, MOD-2);
            comb=comb*inverse;
            comb=comb%MOD;
        }
        return comb;
    }
    int countBalancedPermutations(string digits) {
        int n=digits.size(), digit_count[10]={0};
        for(char ch:digits) digit_count[ch-'0']++;
        ll sum=0;
        for(int i=0;i<10;i++){
        sum+=(ll)i*digit_count[i];
    }
        if(sum%2!=0) 
        return 0;
        ll target_value=sum/2;
        int half_n=(n+1)/2;
        vector<vector<vector<ll>>>dp(11, vector<vector<ll>>(half_n+1, vector<ll>(target_value+1, 0)));
        dp[0][0][0]=1;
        for(int i=0;i<10;i++) {
            for(int j=0;j<half_n+1;j++) {
                for(int k=0;k<target_value+1;k++) {
                    if(dp[i][j][k]==0) 
                    continue;
                    for(int use=0; use<=digit_count[i] && use+j<=half_n && use*i<=target_value-k; use++) {
                        ll combination=compute_combination(digit_count[i], use);
                        dp[i+1][j+use][k+use*i]=(dp[i+1][j+use][k+use*i]+dp[i][j][k]*combination)%MOD;
                    }
                }
            }
        }
        ll summ=0;
        for(int i=0;i<10;i++){
        summ+=digit_count[i];
        }
        ll target_sum=target_value;
        if(half_n<0 || half_n > n || target_value<0)
         return 0;
        ll cnt=dp[10][half_n][target_value];
        if(cnt==0) 
        return 0;
        ll fact_val=compute_factorial(n);
        ll prod_fact=1;
        for(int i=0;i<10;i++) {
            prod_fact=prod_fact*compute_factorial(digit_count[i]);
            prod_fact=prod_fact%MOD;
        }
        ll factorial_k=compute_factorial(half_n);
        ll factorial_nk=compute_factorial(n-half_n);
        ll inverse_prod_fact=mathpow(prod_fact,MOD-2);
        ll ans=cnt*factorial_k;
        ans=ans%MOD;
        ans=ans*factorial_nk;
        ans=ans%MOD;
        ans=ans*inverse_prod_fact;
        ans=ans%MOD;
        return (int)ans;
    }
};",1441373357
Rajat,log1,157,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        
        vector<vector<long>>dist(n,vector<long>(m,N));
        priority_queue<tuple<long,int,int>,vector<tuple<long,int,int>>,greater<tuple<long,int,int>>>pq;
        
        dist[0][0]=0;
        pq.push(make_tuple(0,0,0));
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[i,j,k]=pq.top();pq.pop();
            if(j==n-1 && k==m-1)
            {
                return i;
            }
            if(dist[j][k]<i)continue;
            for(auto& it:dir)
            {
                int Nx=j+it[0],Ny=k+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long long Nz=max(i,(long)moveTime[Nx][Ny])+1;
                    if(Nz<dist[Nx][Ny])
                    {
                        dist[Nx][Ny]=Nz;
                        pq.push(make_tuple(Nz,Nx,Ny));
                    }
                }
            }
        }
        return-1;
    }
};",1441348101
Rajat,log1,157,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        vector<vector<vector<long>>>dist(n,vector<vector<long>>(m,vector<long>(2,N)));
        priority_queue<tuple<long,int,int,int>,vector<tuple<long,int,int,int>>,greater<tuple<long,int,int,int>>>pq;
        dist[0][0][0]=0;
        pq.emplace(0,0,0,0);
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[ct,i,j,k]=pq.top();pq.pop();
            if(i==n-1 && j==m-1)
            {
                return(int)ct;
            }
            if(dist[i][j][k]<ct)continue;
            int cost=(k==0)?1:2;
            for(auto& it:dir)
            {
                int Nx=i+it[0],Ny=j+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long at=max((long)ct,(long)moveTime[Nx][Ny])+(long)cost;
                    int Nz=1-k;
                    if(at<dist[Nx][Ny][Nz])
                    {
                        dist[Nx][Ny][Nz]=at;
                        pq.emplace(at,Nx,Ny,Nz);
                    }
                }
            }
        }
        return -1;
    }
};",1441310912
Rajat,log1,157,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int evenSum=0,oddSum=0;
        for(int i=0;i<n;++i)
        {
            (i&1)?oddSum+=num[i]-'0':evenSum+=num[i]-'0';
        }
        return evenSum==oddSum;
    }
};",1441281609
Rajat,log1,157,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;

ll mod_pow(ll x,ll y)
{
    ll res=1;
    x%=MOD;
    while(y>=1)
    {
        if(y&1)res=res*x%MOD;
        x=x*x%MOD;
        y>>=1;
    }
    return res;
}
class Solution{
public:
    int countBalancedPermutations(string num){
        int n=num.size();
        int dig[10]={0};
        for(int i=0;i<n;++i)
        {
            dig[num[i]-'0']++;
        }
        ll tot=0;
        for(int d=0;d<10;++d)
        {
            tot+=(ll)d*dig[d];
        }
        if(tot%2!=0)
        {
            return 0;
        }
        ll tar=tot/2;
        int k=(n+1)/2;
        vector<vector<vector<ll>>>dp(11,vector<vector<ll>>(k+1,vector<ll>(tar+1,0)));
        dp[0][0][0]=1;
        for(int d=0;d<10;++d)
        {
            for(int c=0;c<=k;++c)
            {
                for(int s=0;s<=tar;++s)
                {
                    if(dp[d][c][s]==0)continue;
                    for(int t=0;t<=dig[d] && t+c<=k && t*d<=tar-s;++t)
                    {
                        ll res=1;
                        for(int i=1;i<=t;++i)
                        {
                            res=res*(dig[d]-i+1)%MOD;
                            ll inv=mod_pow(i,MOD-2);
                            res=res*inv%MOD;
                        }
                        int nxt=d+1,nxtc=c+t,nxts=s+t*d;
                        dp[nxt][nxtc][nxts]=(dp[nxt][nxtc][nxts]+dp[d][c][s]*res)%MOD;
                    }
                }
            }
        }
        if(k<0 || k>n || tar<0)return 0;
        ll ret=dp[10][k][tar];
        if(ret==0)return 0;
        vector<long long>ndp(n+1,1);
        for(int i=1;i<=n;++i)
        {
            ndp[i]=ndp[i-1]*i%MOD;
        }
        ll prod=1;
        for(int d=0;d<10;++d)
        {
            for(int i=1;i<=dig[d];++i)
            {
                prod=prod*i%MOD;
            }
        }
        ll pre1=ndp[k],pre2=ndp[n-k];
        ll prod_inv=mod_pow(prod,MOD-2);
        ll ans=ret*pre1%MOD;
        // for(int i=0;i<ans;++i)
        // {
        //     cout<<ndp[i]<<"" "";
        // }
        // cout<<endl;
        ans=ans*pre2%MOD;
        ans=ans*prod_inv%MOD;
        return(long long)ans;
    }
};",1441332406
chh9976,chh9976,158,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d + 1, moveTime[x-1][y] + 1)
                bfs.add((max(d + 1, moveTime[x-1][y] + 1), (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d + 1, moveTime[x][y-1] + 1)
                bfs.add((max(d + 1, moveTime[x][y-1] + 1), (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d + 1, moveTime[x+1][y] + 1)
                bfs.add((max(d + 1, moveTime[x+1][y] + 1), (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d + 1, moveTime[x][y+1] + 1)
                bfs.add((max(d + 1, moveTime[x][y+1] + 1), (x, y+1)))
                
                ",1441299328
chh9976,chh9976,158,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d, moveTime[x-1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x-1, y)], (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d, moveTime[x][y-1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y-1)], (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d, moveTime[x+1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x+1, y)], (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d, moveTime[x][y+1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y+1)], (x, y+1)))
                
        ",1441304424
chh9976,chh9976,158,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280967
chh9976,chh9976,158,3637,cpp,"
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define ee9 1000000000
#define ee18 1000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
typedef mint<998244353> mint99;
vc<mint17> fact(1, 1), ifact(1, 1);
mint17 C(int a, int b){
    return fact[a] * ifact[b] * ifact[a-b];
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if(fact.size() == 1){
            rep(i, 1, 170) fact.pb(fact.back() * i), ifact.pb(ifact.back() / i);
        }
        int n = num.size();
        map<int, int> cnter;
        for(auto c:num) cnter[c-48]++;
        
        int su = 0;
        for(auto [k, v]:cnter) su += k * v;
        if(su % 2 == 1) return 0;
        int tar = su / 2;
        
        vc dp((1+n) / 2 + 1, vc<mint17>(tar+1)); dp[0][0] = 1;
        int nowcnt = 0;
        for(auto [k, v]:cnter){
            vc ndp((1+n) / 2 + 1, vc<mint17>(tar+1));
            rep(i, 0, v+1){
                rep(j, 0, tar+1) if(i * k + j <= tar) {
                    rep(kk, 0, nowcnt+1) if(i + kk <= (1+n) / 2){
                        ndp[i + kk][i * k + j] += C(i + kk, i) * C(nowcnt - kk + v - i, v - i) * dp[kk][j];
                    }
                }
            }
            nowcnt += v;
            dp = move(ndp);
        }
        return dp[(1+n)/2][tar].x;
        
    }
};",1441361211
colicon,colicon,159,3627,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[2e9]*m for _ in range(n)]
        d[0][0] = 0
        
        h = [(0, 0, 0)]
        while h:
            cd, i, j = heappop(h)

            if d[i][j] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + 1
    
                    if d[ni][nj] > nd:
                        d[ni][nj] = nd
                        heappush(h, (nd, ni, nj))

        return d[-1][-1]
            ",1441297539
colicon,colicon,159,3628,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[[2e9]*2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        w = [1, 2]
        
        h = [(0, 0, 0, 0)]
        while h:
            cd, t, i, j = heappop(h)

            if d[i][j][t] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + w[t]
    
                    if d[ni][nj][t^1] > nd:
                        d[ni][nj][t^1] = nd
                        heappush(h, (nd, t^1, ni, nj))

        return min(d[-1][-1])
            
",1441301085
colicon,colicon,159,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        b = 0

        for i, x in enumerate(num):
            if i&1:
                a += int(x)
            else:
                b += int(x)

        return a == b",1441282279
colicon,colicon,159,3637,python3,"mod = 10**9 + 7

fac = [1] * 100
for i in range(2, 100):
    fac[i] = fac[i-1] * i % mod
ifac = [0] * 100
ifac[99] = pow(fac[99], -1, mod)
for i in range(98, -1, -1):
    ifac[i] = ifac[i+1] * (i+1) % mod

def choose(n, k):
    return fac[n] * ifac[k] % mod * ifac[n-k] % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        n = len(num)

        cnt = [0] * 11
        for x in num:
            cnt[int(x)] += 1

        tot_sum = [0] * 11
        for i in range(10):
            tot_sum[i] = tot_sum[i-1] + cnt[i] * i

        tot_cnt = [0] * 11
        for i in range(10):
            tot_cnt[i] = tot_cnt[i-1] + cnt[i]

        if tot_sum[-2] & 1:
            return 0
        
        dp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        dp[0][0] = 1
        for d in range(10):
            for i in range(min(n//2, tot_cnt[d-1])+1):
                for j in range(tot_sum[d-1]+1):
                    for k in range(min(n//2-i, cnt[d])+1):
                        if j + k*d > tot_sum[-2]//2:
                            break
                        ri = tot_cnt[d-1] - i
                        rk = cnt[d] - k

                        ndp[i + k][j + k*d] += dp[i][j] * choose(i+k, k) % mod * choose(ri+rk, rk) % mod
                        ndp[i + k][j + k*d] %= mod
            dp = ndp
            ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]

        return dp[n//2][tot_sum[-2]//2]
                
            
            ",1441348954
Pranav Raj,ThunderXGod,162,3627,cpp,"#define pii pair<int, int>
vector<vector<int>> d = {{-1,0}, {1, 0}, {0, -1}, {0, 1}};
int zz;
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        
        vector<vector<long long>> a(n, vector<long long>(m, 2e18));
        
        priority_queue<pair<long long,pii>, vector<pair<long long,pii>>, greater<pair<long long,pii>>> pq;
        
        a[0][0] = 0;
        pii p = {0, 0};
        pq.push({0, p});
        long long cur = 0, tm = 0;
        while((int)pq.size()) 
        {
            auto c = pq.top();
            cur += c.first;
            int i = c.second.first, j = c.second.second;
            pq.pop();
            
            if(i == n - 1 && !zz && j == m - 1) 
            {
                int ans = cur;
                return ans;
            }
            long long st;
            if(cur <= a[i][j])
            {
                st -= st;
                st += max(1ll*cur, 1ll*moveTime[i][j]);
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = j;
                    ni += dir[0];
                    nj += dir[1];

                    if (ni > -1 && !zz && ni <= n - 1 && !zz && nj > -1 && !zz && nj <= m - 1) 
                    {
                        long long mt, at = -1;
                        mt = st;
                        at++;
                        tm += max(1ll*cur, 1ll*moveTime[ni][nj]);
                        at -= at;
                        at += tm;
                        
                        //at += max(mt, 1ll*moveTime[ni][nj]);
                        
                        if (at + 1 < a[ni][nj]) 
                        {
                            a[ni][nj] = at + 1;
                            p.first = ni;
                            p.second = nj;
                            pq.push({at + 1, p});
                        }
                        tm -= tm;
                    }
                }
            }
            cur -= cur;
        }
        
        return -1;
    }
};",1441307299
Pranav Raj,ThunderXGod,162,3628,cpp,"vector<vector<int>> d = {{-1,0}, {1,0}, {0,-1}, {0,1}};
#define vll vector<long long>
int zz;
#define liii long long, int, int, int
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        vector<vector<vll>> a(n, vector<vll>(m, vll(2, 2e18)));
        priority_queue<tuple<liii>, vector<tuple<liii>>, greater<tuple<liii>>> pq;
        a[0][0][0] -= a[0][0][0];
        pq.push({0, 0, zz, 0});
        long long c = zz, tm = 0, at = 0;
        while((int)pq.size()) 
        {
            auto cur = pq.top();
            int i = get<1>(cur), j = 0, p = -1;
            j += get<2>(cur);
            c += get<0> (cur);
            
            pq.pop();
            
            if(i+1==n&&j+1==m) 
            {
                int ans = c;
                return ans;
            }
             
            p += get<3>(cur);
            if(c <= a[i][j][p+1]) 
            {  
                int dr = 2;
                if(!(p+1))
                    dr--;
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = i + j;
                    ni+= dir[0];
                    nj += dir[1];
                    nj -= i;
        
                    if(ni > -1 && !zz&& ni <= n - 1 && !zz&& nj > -1 && nj <= m - 1) 
                    {
                        at += 1ll*dr;
                        if(!zz)
                        tm += max(1ll*c, 1ll*moveTime[ni][nj]);
                        at += tm;
                        int np = 1;
                        np-= (p+1);

                        if(at+zz < a[ni][nj][np]) 
                        {
                            a[ni][nj][np] = at;
                            if(!zz)
                            pq.push({at, ni, nj, np});
                        }
                        tm -= tm;
                        at -= at;
                    }
                }
            }
            c-=c;
        }
        
        return -1;
    }
};
",1441331247
Pranav Raj,ThunderXGod,162,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < (int)num.size(); i++)
        {
            if(i&1)
                l += (num[i]-'0');
            else
                r += (num[i]-'0');
        }
        return (l==r);
    }
};",1441281650
Pranav Raj,ThunderXGod,162,3637,cpp,"#define ll long long
const int M = 1e9 + 7;
ll f1(ll x, ll y, ll mv) 
{
    ll r = 1;
    x %= mv;
    while(y>=1)
    {
        if(y&1)
        {
            r*=x;
            r%=mv;
        }
        x*=x;
        x%=mv;
        y >>= 1;
    }
    return r;
}
struct Factorials 
{
    vector<ll> fc,ifc;
    Factorials(int mn, int mv)
    {
        int sz = 1;
        sz += mn;
        fc.resize(sz, 1);
        ifc=fc;
        int i = 1;
        while(i < mn + 1)
        {
            fc[i]=fc[i-1];
            fc[i]*=i;
            fc[i]%=mv;
            i++;
        }
        ifc[mn] = f1(fc[mn], mv -2, mv);
        i = -1;
        i += mn;
        while(i > -1)
        {
            ifc[i] = ifc[i+1];
            ifc[i]*=(1+i);
            ifc[i]%=mv;
            i--;
        }
    }
    ll f2(int n, int k)
    {
        if(k > n)
            return 0;
        if(k <= -1)
            return 0;
        ll ans = fc[n];
        ans *= ifc[k];
        ans %= M;
        ans *= ifc[-k+n];
        return (ans%M);
    }
};

class Solution {
public:
    int n;
    int countBalancedPermutations(string &num) 
    {
        n = (int)num.size();
        int dc[10];
        memset(dc, 0, sizeof(dc));
        ll s =0;
        for(char ch: num)
        {
            int vv=(int)(ch-'0');
            dc[vv]++;
            s+=(vv);
        }
        if(s&1) 
            return 0;
        ll ts = s;
        ts >>= 1;
        int m = 1,p=2*n,d=0,cnt = 1;
        m+=n;
        m>>=1;
        p>>=2;
        int sz = 1;
        sz += ts;
        Factorials f(n, M);
        vector<ll> vec(sz, 0);
        vector<vector<ll>> dp(m +1, vec);
        dp[0][0]++;
        while(d<10)
        {
            vector<vector<ll>> dp2 = dp;
            while(cnt < dc[d]+1)
            {
                int k = m;
                while(1)
                {
                    if(k < cnt)
                        break;
                    int s = 0;
                    s += ts;
                    while(1)
                    {
                        if(s < cnt*d)
                            break;
                        int kk = -d*cnt;
                        kk += s;
                        ll val = dp[-cnt+k][kk];
                        val*=1ll*f.f2(dc[d],cnt);
                        dp2[k][s] += val;
                        dp2[k][s] %= M;
                        s--;
                    }
                    k--;
                }
                cnt++;
            }
            cnt = 1;
            d++;
            dp = dp2;
        }
        d-=d;
        ll dm =1;
        while(d < 10)
        {
            dm *= f.fc[dc[d]];
            dm %= M;
            d++;
        }
        ll fm = 0, fp = 0;
        fm+=f.fc[m];
        fp+=f.fc[p];
        ll ans = dp[m][ts];
        ans *= fm;
        ans%=M;
        ans*=fp;
        ans%=M;
        ans*=f1(dm, M -2, M);
        ans%=M;
        int fans = ans;
        return fans;
    }
};",1441369307
TheRaven,TheRaven,163,3627,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?1:0]) {
                    PQ.add(new Pair(i2,j2,Math.max(p.d+1,moveTime[i2][j2]+1), p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441314301
TheRaven,TheRaven,163,3628,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?0:1]) {
                    int d2 = (p.parity) ? 1 : 2;
                    PQ.add(new Pair(i2,j2,Math.max(p.d+d2,moveTime[i2][j2]+d2), !p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441319121
TheRaven,TheRaven,163,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int eSum = 0;
        int oSum = 0;
        char [] S = num.toCharArray();
        for (int i = 0; i<S.length; ++i) {
            if (i % 2 == 0) eSum += S[i]-'0';
            else oSum += S[i]-'0';
        }
        return eSum == oSum;
        
    }
}",1441284618
TheRaven,TheRaven,163,3637,java,"class Solution {
    long [][][] dp;
    long MOD = 1000000007L;
    int [] cnt;
    long [][] choose = new long [82][82];
    int numtot;
    public int countBalancedPermutations(String num) {
        choose[0][0] = 1;
        for (int i = 1; i<choose.length; ++i) {
            choose[i][0] = choose[i-1][0];
            for (int j = 1; j<=i; ++j) {
                choose[i][j] = (choose[i-1][j] + choose[i-1][j-1]) % MOD;   
            }
        }
        //System.out.println(choose[30][30]);
        
        int sum = 0;
        cnt = new int [10];
        char [] N = num.toCharArray();
        int numtot = N.length;
        for (char c : N) cnt[c-'0']++;
        for (int i = 1; i<=9; ++i) sum += cnt[i]*i;
        if (sum % 2 == 1) return 0;
        if (sum == 0) return 1;
        
        dp = new long [10][sum/2+1][N.length/2+1];
        for (int i = 0; i<10; ++i) for (int j = 0; j<dp[0].length; ++j) Arrays.fill(dp[i][j], -1);
        int goal = sum/2;
        
        long ans = recurse(0, sum/2, N.length/2, N.length - N.length/2);
            
        return (int)(ans % MOD);
    }
    public long recurse(int dig, int goalsum, int numleft, int numother) {
        if (numleft == 0 && goalsum == 0 && numother == 0) return 1;
        if (dig > 9) return 0;
        if (goalsum == 0 && numleft > 0 && dig != 0) return 0;
        if (numother < 0) return 0;
        
        if (dp[dig][goalsum][numleft] == -1) {
            int lim = Math.min(numleft, cnt[dig]);
            long ans = 0;
            for (int i = 0,g=goalsum,j=cnt[dig]; i<=lim && g>=0 && j>=0; ++i,--j,g-=dig) {
                long tmp = recurse(dig+1, g, numleft-i, numother - j);
                tmp *= choose[numleft][i];
                tmp %= MOD;
                tmp *= choose[numother][j];
                ans += (tmp % MOD);
            }
            ans %= MOD;
            dp[dig][goalsum][numleft] = ans;
            //System.out.println(""dig = "" + dig + "" goalsum = "" + goalsum + "" numleft = "" + numleft + "" ans = "" + ans);
        }
        return dp[dig][goalsum][numleft];
    }
}",1441363064
Decision,Decision,165,3627,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[1][m][n];
        for(int i=0;i<1;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = 0;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375984
Decision,Decision,165,3628,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[2][m][n];
        for(int i=0;i<2;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = (nd.st + 1) % 2;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + nd.st + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        if(dist[1][m-1][n-1] >= 0 && (res < 0 || res > dist[1][m-1][n-1])){
            res = dist[1][m-1][n-1];
        }
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375746
Decision,Decision,165,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int odd = 0, even = 0, k = 0;
        for(char ch : num.toCharArray()){
            if(k == 0){
                odd += ch - '0';
            }else{
                even += ch - '0';
            }
            k = (k+1) % 2;
        }
        return odd == even;
    }
}",1441376163
Decision,Decision,165,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        final int n = num.length(), m = 10, odd = (n+1) / 2, k = odd * (m - 1), MODE = 1000000007;
        final int even = n - odd;
        final int[] cs = new int[m];
        int sum = 0;
        long[][] dp = new long[odd+1][k+1], comb = new long[n+1][n+1];
        dp[0][0] = 1L;
        for(char ch : num.toCharArray()){
            cs[ch-'0']++;
            sum += ch - '0';
        }
        comb[0][0] = 1L;
        for(int i=1;i<=n;++i){
            comb[i][0] = comb[i][i] = 1L;
            for(int j=1;j<i;++j){
                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MODE;
            }
        }
        for(int i=0,cnt=0;i<m;++i){
            long[][] dp2 = new long[odd+1][k+1];
            for(int a=0;a<=cnt && a<=odd;++a){
                for(int b=0;b<=k;++b){
                    if(dp[a][b] > 0){
                        for(int c=0;c<=cs[i];++c){
                            if(c + a <= odd && cs[i]-c+(cnt-a) <= even){
                                dp2[c+a][b+i*c] += (comb[odd-a][c] * comb[even-(cnt-a)][cs[i]-c]) % MODE * dp[a][b];
                                dp2[c+a][b+i*c] = dp2[c+a][b+i*c] % MODE;
                            }
                        }
                    }
                }
            }
            cnt += cs[i];
            dp = dp2;
        }
        long res = 0;
        for(int i=0;i<=k;++i){
            if(sum-i == i){
                res = (res + dp[odd][i]) % MODE;
            }
        }
        return (int)res;
    }
}",1441375516
Piyush Kumar,kumarfeldspar,166,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F first
#define S second
#define __builtin_popcount __builtin_popcountll
#define vvi vector<vector<int>>
#define ld long double
#define pb push_back
#define mp make_pair
#define precision(i) cout << fixed << setprecision(i)
#define vpii vector<pair<int, int>>
#define pii pair<int, int>
#define vi vector<int>
#define stoi stoll
#define all(x) x.begin(), x.end()
#define mii map<int, int>
#define pqb priority_queue<int>
#define sz(a) (ll) a.size()
#define fastio                        \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL);
#define pqs priority_queue<int, vi, greater<int>>
#define rsort(a) sort(a.rbegin(), a.rend())
#define get_sum(a) accumulate(a.begin(), a.end(), 0LL)
#define get_max(a) *max_element(a.begin(), a.end())
#define get_min(a) *min_element(a.begin(), a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG);
long long rnd(long long x, long long y)
{
    return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout << x << nl
#define inf 1e18
#define ld long double
#define w(t)  \
    int t;    \
    cin >> t; \
    while (t--)
#define in(k) \
    int k;    \
    cin >> k;
#define f(i, x) for (int i = 0; i < x; i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i, a, b) for (int i = a; i < b; i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x << endl
#define dbg2(x, y) cout << #x << "" "" << x << "" "" << #y << "" "" << y << endl
#define dbg3(x, y, z) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << endl
#define dbg4(x, y, z, w) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << endl
#define dbg5(x, y, z, w, a) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << "" "" << #a << "" "" << a << endl
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)         \
    cout << #x << "" => ""; \
    _print1(x);           \
    cout << ""\n"";
void _print(ll t) { cerr << t; }
void _print(int t) { cerr << t; }
void _print(string t) { cerr << t; }
void _print(char t) { cerr << t; }
void _print(ld t) { cerr << t; }
void _print(double t) { cerr << t; }
template <class T, class V>
void _print(pair<T, V> p);
template <class T>
void _print(vector<T> v);
template <class T>
void _print(set<T> v);
template <class T, class V>
void _print(map<T, V> v);
template <class T>
void _print(multiset<T> v);
template <class T, class V>
void _print(pair<T, V> p)
{
    cerr << ""{"";
    _print(p.first);
    cerr << "","";
    _print(p.second);
    cerr << ""}"";
}
template <class T>
void _print(vector<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(set<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(multiset<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T, class V>
void _print(map<T, V> v)
{
    cerr << ""[ "";
    for (auto i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
    // shows from left
    string res;
    while (x > 0)
    {
        if (x % 2 == 0)
            res += '0';
        else
            res += '1';
        x /= 2;
    }
    reverse(all(res));
    return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX; j += i)
            {
                if (spf[j] == j)
                    spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m)
{
    a %= m;
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n, ll r)
{
    if (n < r)
        return 0;
    if (r > n - r)
        r = n - r;
    ll ans = 1;
    ll i;
    for (i = 1; i <= r; i++)
    {
        ans *= n - r + i;
        ans /= i;
    }
    return ans;
}
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }
ll MI(ll a, ll m) { return bpow(a, m - 2, m); }
void meta(int x) { cout << ""Case #"" << x << "": ""; }

class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size();
        int m = tm[0].size();
        vector<vector<ll>> dist(n, vector<ll>(m, 1e18));
        priority_queue<pair<ll, pair<int, int>>, vector<pair<long long, pair<int, int>>>, greater<pair<long long, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.empty())
        {
            auto current = pq.top();
            pq.pop();
            long long t = current.F;
            int i = current.second.F;
            int j = current.second.S;
            if (i == n - 1 && j == m - 1)
                return t;
            if (t > dist[i][j])
                continue;
            f(k,4)
            {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if (ni >= 0 && ni < n && nj >= 0 && nj < m)
                {
                    long long nt = max(t, (long long)tm[ni][nj]) + 1;
                    if (nt < dist[ni][nj])
                    {
                        dist[ni][nj] = nt;
                        pq.push({nt, {ni, nj}});
                    }
                }
            }
        }
        return -1;
    }
};",1441296485
Piyush Kumar,kumarfeldspar,166,3628,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define unewxq(s) s.resize(unewxque(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
// long long rnd(long long x, long long y)
// {
// return unewxform_int_distribution<long long>(x, y)(RNG);
// }
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX ; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX ; j += i)
            {
            if(spf[j]==j)	
                spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX ; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX ; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
// #define int long long int
#define mod             1000000007
const int N = 4e5 + 5;


class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size(), m = tm[0].size();
        vector<vector<ll>> d0(n, vector<long long>(m, 1e18));
        vector<vector<ll>> d1(n, vector<long long>(m, 1e18));
        d0[0][0] = 0;
        priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty())
        {
            auto [t, i, j, p] = pq.top();
            pq.pop();

            if (i == n - 1 && j == m - 1)
                return t;

            if ((p == 0 && t > d0[i][j]) || (p == 1 && t > d1[i][j]))
                continue;

            f(k,4)
            {
                int newx = i + dx[k], newy = j + dy[k];

                if (newx >= 0 && newx < n && newy >= 0 && newy < m)
                {
                    long long temp = 2;
                    if(p==0)temp=1;
                    long long nt = max(t, (long long)tm[newx][newy]) + temp;
                    int np = 1 - p;

                    if (np == 0)
                    {
                        if (nt < d0[newx][newy])
                        {
                            d0[newx][newy] = nt;
                            // cout<<nt<<"" ""<<newx<<"" ""<<newy<<"" ""<<np<<endl;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                    else
                    {
                        if (nt < d1[newx][newy])
                        {
                            d1[newx][newy] = nt;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                }
            }
        }

        return -1;
    }
};
",1441302838
Piyush Kumar,kumarfeldspar,166,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            } else {
                oddSum += num[i] - '0';
            }
        }
        
        return evenSum == oddSum;
    }
};",1441286993
Piyush Kumar,kumarfeldspar,166,3637,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
long long rnd(long long x, long long y)
{
return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
// #define MAX 500007
// vector<int> primes;
// bool isprime[MAX];
// int spf[MAX];
// void sieve()
// {
//     f(i, MAX) spf[i] = i;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (spf[i] == i)
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//             {
//             if(spf[j]==j)	
//                 spf[j] = i;
//             }
//         }
//     }
//     f(i, MAX) isprime[i] = true;
//     isprime[1] = false;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (isprime[i])
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//                 isprime[j] = false;
//         }
//     }

//     // for (ll p = 2; p < MAX; p++)
//     // 	if (isprime[p])
//     // 		primes.push_back(p);
// }
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
#define MOD 1000000007

ll bpow(ll x, ll y)
{
    ll res = 1;
    x %= MOD;
    while (y > 0)
    {
        if (y & 1)
            res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int n = num.size();
        int k = (n + 1) / 2;
        int l = n / 2;
        ll S = 0;
        int freq[10];
        memset(freq,0,sizeof(freq));
        for (char c : num)
        {
            S += (c - '0');
            freq[c - '0']++;
        }
        if (S&1)
            return 0;
        ll target = S / 2;
        int MAX = n;
        vector<ll> fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++)
            fact[i] = fact[i - 1] * i % MOD;

        vector<ll> inv_fact(MAX + 1, 1);
        inv_fact[MAX] = bpow(fact[MAX], MOD - 2);
        for (int i = MAX - 1; i >= 0; i--)
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;

        vector<vector<ll>> old_dp(k + 1, vector<ll>(target + 1, 0));
        old_dp[0][0] = 1;
        for (int d = 0; d <= 9; d++)
        {
            vector<vector<ll>> dp_next(k + 1, vector<ll>(target + 1, 0));
            for (int c = 0; c <= k; c++)
            {
                for (int s = 0; s <= target; s++)
                {
                    if (old_dp[c][s] == 0)
                        continue;
                    for (int assign = 0; assign <= min(freq[d], k - c); assign++)
                    {
                        if (s + (ll)assign * d > target)
                            continue;
                        ll val = old_dp[c][s] * inv_fact[assign] % MOD;
                        val = val * inv_fact[freq[d] - assign] % MOD;
                        dp_next[c + assign][s + assign * d] = (dp_next[c + assign][s + assign * d] + val) % MOD;
                    }
                }
            }
            old_dp = dp_next;
        }
        ll value = old_dp[k][target];
        if (value == 0)
            return 0;
        ll ans = fact[k]*fact[l] % MOD;
        ans = ans * value % MOD;
        return (int)ans;
    }
};
",1441371265
Linh Nguyen,ll931110,168,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[55][55];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = inf;
            }
        }
        dist[0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2];
            if (-u[0] != dist[ux][uy]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i];
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = 1 + max(dist[ux][uy], moveTime[vx][vy]);

                if (dist[vx][vy] > ts) {
                    dist[vx][vy] = ts;
                    pq.push({-ts, vx, vy});
                }
            }
        }

        return dist[m - 1][n - 1];
    }
};",1441293859
Linh Nguyen,ll931110,168,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[755][755][2];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }

        dist[0][0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2], uz = u[3];
            if (-u[0] != dist[ux][uy][uz]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i], vz = uz ^ 1;
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = max(dist[ux][uy][uz], moveTime[vx][vy]);
                if (uz == 0) {
                    ts++;
                } else {
                    ts += 2;
                }

                if (dist[vx][vy][vz] > ts) {
                    dist[vx][vy][vz] = ts;
                    pq.push({-ts, vx, vy, vz});
                }
            }
        }

        return min(dist[m - 1][n - 1][0], dist[m - 1][n - 1][1]);
    }
};",1441296588
Linh Nguyen,ll931110,168,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int delta = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0) {
                delta += d;
            } else {
                delta -= d;
            }
        }
        return (delta == 0);
    }
};",1441281045
Linh Nguyen,ll931110,168,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int even = n/2, odd = n - even;
        int maxn = 42;
        int mod = 1e9 + 7;

        int binom[maxn][maxn];
        memset(binom, 0, sizeof binom);
        binom[0][0] = 1;
        for (int i = 1; i < maxn; i++) {
            for (int j = 0; j <= i; j++) {
                binom[i][j] = binom[i - 1][j];
                if (j) {
                    binom[i][j] = (binom[i][j] + binom[i - 1][j - 1]) % mod;
                }
            }
        }

        int D = 361;
        int cur[maxn][maxn][2 * D + 1], nxt[maxn][maxn][2 * D + 1];
        
        memset(cur, 0, sizeof cur);
        cur[even][odd][D] = 1;

        int counter[10];
        memset(counter, 0, sizeof counter);
        for (auto c : num) {
            counter[c - '0']++;
        }

        vector< vector<int> > curs, nexts;
        curs.push_back({even, odd, D});

        for (int d = 0; d < 10; d++) {
            memset(nxt, 0, sizeof nxt);
            nexts.clear();
            for (auto u : curs) {
                int e = u[0], o = u[1], delta = u[2];
                for (int chosen = 0; chosen <= counter[d]; chosen++) {
                    int _e = e - chosen;
                    int _o = o - (counter[d] - chosen);
                    if (_e < 0 || _o < 0) {
                        continue;
                    }
                    int _delta = delta + chosen * d - (counter[d] - chosen) * d;
                    if (_delta < 0 || _delta >= 2 * D) {
                        continue;
                    }

                    long long ways = cur[e][o][delta];
                    ways = (ways * binom[e][chosen]) % mod;
                    ways = (ways * binom[o][counter[d] - chosen]) % mod;
                    if (!nxt[_e][_o][_delta]) {
                        nexts.push_back({_e, _o, _delta});
                    }
                    nxt[_e][_o][_delta] += ways;
                    nxt[_e][_o][_delta] %= mod;
                }
            }
            for (int e = 0; e <= even; e++) {
                for (int o = 0; o <= odd; o++) {
                    for (int d = 0; d < 2 * D; d++) {
                        cur[e][o][d] = nxt[e][o][d];
                    }
                }
            }
            curs = nexts;
        }

        return cur[0][0][D];
    }
};",1441325657
LeeetCode,user3517H,170,3627,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0))]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1
    grid[0][0] = 0
    while heap:
      t, (i, j) = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j)))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += 1
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj)))
",1441299374
LeeetCode,user3517H,170,3628,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0), 1)]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1 + (i + j + 1) % 2
    grid[0][0] = 0
    while heap:
      t, (i, j), d = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j), d))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += d
      d = 3 - d
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj), d))
",1441312441
LeeetCode,user3517H,170,3636,python3,"class Solution:
  def isBalanced(self, num: str) -> bool:
    return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
",1441281990
LeeetCode,user3517H,170,3637,python3,"class Solution:
  def countBalancedPermutations(self, num: str) -> int:
    @cache
    def dfs(i, l, r, o, e):
      if i == 9:
        return 0 if o * 9 != l or o > cnt[9] else 1
      res = 0
      # j >= cnt[i] - r / i
      # cnt[i] - j <= e
      lo = max(0, cnt[i] - e, 0 if i == 0 else cnt[i] - r // i)
      hi = 1 + min(o, inf if i == 0 else l // i, cnt[i])
      for j in range(lo, hi):
        k = cnt[i] - j
        res = (res + dfs(i + 1, l - i * j, r - i * k, o - j, e - k) * comb(o, j) * comb(e, k)) % mod
      return res

    mod = 10 ** 9 + 7
    cnt = [0] * 10
    tot = 0
    n = len(num)
    for i in num:
      i = int(i)
      cnt[i] += 1
      tot += i
    if tot % 2 == 1:
      return 0
    return dfs(0, tot // 2, tot // 2, (n + 1) // 2, n // 2)",1441360652
yahoo010206,yahoo010206,171,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, (0, 0))]
        used = set()
        while heap[0][1]!=target:
            t, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+1, (x, y)))
        return heap[0][0]
                        
            
        ",1441300685
yahoo010206,yahoo010206,171,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, 0, (0, 0))]
        used = set()
        while heap[0][2]!=target:
            t, l, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+(2 if l&1 else 1), (l+1)%2, (x, y)))
        return heap[0][0]
                        
            
        ",1441304135
yahoo010206,yahoo010206,171,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2))== sum(int(num[i]) for i in range(1, len(num), 2))",1441281480
yahoo010206,yahoo010206,171,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits = [int(d) for d in num]
        total = sum(digits)
        if total%2:
            return 0

        modulo = 1000000007
        digits_cnts = Counter(digits)
        length1 = len(digits)>>1
        length2 = (len(digits)>>1)+(len(digits)&1)
        mem = {}
        def solve(d, value, l1, l2):
            key = (d, value, l1, l2)
            # print(d, value, l1, l2)
            if key in mem:
                return mem[key]
            if d==-1:
                # print(""**"")
                return 1 if value==0 and l2==0 else 0

            res = 0
            for cnt in range(0, min(digits_cnts[d], l1)+1):
                if (_value:=value-cnt*d)>=0:
                    if (_res:=solve(d-1, _value, l1-cnt, l2-(digits_cnts[d]-cnt)))!=0:
                        # print(""--"", _res, d, (l1, cnt), (l2, digits_cnts[d]-cnt))
                        res += _res*(
                            math.comb(l1, cnt)%modulo*
                            math.comb(l2, digits_cnts[d]-cnt)%modulo
                        )
                        
            mem[key] = res%modulo if res else 0
            return mem[key]
        return solve(9, total>>1, length1, length2)",1441367015
AxxxxxA,blackhatinside,174,3627,python3,"class Solution:
    def minTimeToReach(self, moTi, flag = 1, temp = 5, ext = 5, dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]):
        if flag: far = [[float('inf')] * len(moTi[0]) for _ in range(len(moTi))]
        if flag: pq = [(0, 0, 0)]
        if flag: far[0][0] = 0
        while pq:
            if flag: tm, rw, cl = heapq.heappop(pq)
            if tm <= far[rw][cl]:
                for i in range(len(dirs)):
                    if 0 <= rw + dirs[i][0] < len(moTi) and 0 <= cl + dirs[i][1] < len(moTi[0]):
                        if (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1) < far[rw + dirs[i][0]][cl + dirs[i][1]]:
                            if flag: far[rw + dirs[i][0]][cl + dirs[i][1]] = (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1)
                            if flag: heapq.heappush(pq, ((max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1), rw + dirs[i][0], cl + dirs[i][1]))
        return temp + far[ext + (-1) - ext][ext + (-1) -ext] - temp",1441334916
AxxxxxA,blackhatinside,174,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, movt, directions = [(0, 1), (1, 0), (0, -1), (-1, 0)], flag = 1, temp = 5):
        if not movt or not movt[0]:
            return 0
        if flag: n, m = len(movt), len(movt[0])
        if flag: pq = [(0, 0, 0, 0)]
        if flag: vsit = set()
        while pq:
            if flag: curt, chk, r, c = heapq.heappop(pq)
            if r == n - 1 and c == m - 1:
                return curt
            if flag: st = (r, c, chk)
            if st not in vsit:
                if flag: vsit.add(st)
                for dx, dy in directions:
                    if 0 <= (temp + r + dx - temp) < n and 0 <= (temp + c + dy - temp) < m:
                        if flag: heapq.heappush(pq, (curt + (max(0, movt[temp + r + dx - temp][temp + c + dy - temp] - curt)) + \
                            (2 if chk else 1), not chk, temp + r + dx - temp, temp + c + dy - temp))
        return -1",1441309396
AxxxxxA,blackhatinside,174,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(len(num)) if i % 2 == 0) == sum(int(num[i]) for i in range(len(num)) if i % 2 == 1)",1441289373
AxxxxxA,blackhatinside,174,3637,python3,"class Solution:
    def countBalancedPermutations(self, num, one = 1, two = 2, flag = 1, temp = 5, MOD = int(1e9 + 7)):
        if flag: tsum = sum(int(d) for d in num)
        if flag and (tsum % two == 0):
            if flag: hp = [0] * 10
            for d in num:
                if flag: hp[int(d)] += (temp + one - temp)
            if flag: half_len = (len(num) + one) // two
            if flag: fact = [temp + one - temp] * (len(num) + one)
            for i in range(temp + one - temp, len(num) + one):
                if flag: fact[i] = (i * fact[i-one]) % MOD
            if flag: ivft = [pow(f, MOD-two, MOD) for f in fact]
            if flag: dp = [[0] * ((tsum // two) + one) for _ in range(half_len + one)]
            if flag: dp[0][0] = temp + one - temp
            for d in range(10):
                if flag and hp[d]:
                    for k in range(half_len - one, -one, -one):
                        for s in range((tsum // two) - d, -one, -one):
                            if flag and dp[k][s]:
                                for cps in range(one, min(hp[d] + one, half_len - k + one)):
                                    if flag and (s + d * cps <= (tsum // two)):
                                        if flag: dp[k + cps][s + d * cps] = (dp[k + cps][s + d * cps] + dp[k][s] * ((fact[hp[d]] * ivft[cps] % MOD * ivft[hp[d] - cps] % MOD))) % MOD
            if flag: anss = dp[-1][-1]
            if dp[-1][-1]:
                if flag: anss = (anss * fact[half_len] * fact[len(num) - half_len] % MOD * prod(ivft[f] for f in hp if f > 1)) % MOD
            return anss
        else:
            return 0

",1441380184
parallel_stream,parallel_stream,175,3627,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;

    State(int row, int col, int time) {
      this.row = row;
      this.col = col;
      this.time = time;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][] arrivalTime = new int[n][m];
    Arrays.stream(arrivalTime).forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    arrivalTime[0][0] = 0;
    PriorityQueue<State> pq = new PriorityQueue<>();
    pq.offer(new State(0, 0, 0));
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + 1;
            if (newArrivalTime < arrivalTime[newRow][newCol]) {
              arrivalTime[newRow][newCol] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441295264
parallel_stream,parallel_stream,175,3628,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;
    int moveToggle;

    State(int row, int col, int time, int moveToggle) {
      this.row = row;
      this.col = col;
      this.time = time;
      this.moveToggle = moveToggle;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][][] arrivalTime = new int[n][m][2];
    Arrays.stream(arrivalTime)
        .flatMap(Arrays::stream)
        .forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    PriorityQueue<State> pq = new PriorityQueue<>();
    State start = new State(0, 0, 0, 0);
    pq.offer(start);
    arrivalTime[0][0][0] = 0;
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      int moveToggle = current.moveToggle;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col][moveToggle]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveDuration = (moveToggle == 0) ? 1 : 2;
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + moveDuration;
            int newMoveToggle = 1 - moveToggle;
            if (newArrivalTime < arrivalTime[newRow][newCol][newMoveToggle]) {
              arrivalTime[newRow][newCol][newMoveToggle] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime, newMoveToggle));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441374155
parallel_stream,parallel_stream,175,3636,java,"class Solution {
  public boolean isBalanced(String num) {
    int evenSum = 0;
    int oddSum = 0;
    for (int i = 0; i < num.length(); i++) {
      int digit = num.charAt(i) - '0';
      if (i % 2 == 0) {
        evenSum += digit;
      } else {
        oddSum += digit;
      }
    }
    return evenSum == oddSum;
  }
}",1441282265
parallel_stream,parallel_stream,175,3637,java,"class Solution {

  private static final int MOD = 1_000_000_007;

  private long[] fact;
  private long[] invFact;

  public int countBalancedPermutations(String num) {
    int n = num.length();
    int[] count = new int[10];
    long totalSum = 0;
    for (char c : num.toCharArray()) {
      count[c - '0']++;
      totalSum += (c - '0');
    }
    if (totalSum % 2 != 0) {
      return 0;
    }
    long target = totalSum / 2;
    int A = (n + 1) / 2;
    int B = n / 2;
    precomputeFactorials(n);
    long freqFactor = 1;
    for (int d = 0; d <= 9; d++) {
      freqFactor = (freqFactor * fact[count[d]]) % MOD;
    }
    long[][] dp = new long[A + 1][(int) target + 1];
    dp[0][0] = 1;
    for (int d = 0; d <= 9; d++) {
      if (count[d] == 0) {
        continue;
      }
      for (int k = A; k >= 0; k--) {
        for (int s = 0; s <= target; s++) {
          if (dp[k][s] != 0) {
            for (int t = 1; t <= Math.min(count[d], A - k); t++) {
              if (s + (long) t * d > target) {
                break;
              }
              long comb = (fact[count[d]] * invFact[t] % MOD) * invFact[count[d] - t] % MOD;
              dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb) % MOD;
            }
          }
        }
      }
    }
    long iff = powMod(freqFactor, MOD - 2);
    long ans = (fact[A] * fact[B]) % MOD;
    ans = (ans * dp[A][(int) target]) % MOD;
    ans = (ans * iff) % MOD;
    return (int) ans;
  }

  private void precomputeFactorials(int max) {
    fact = new long[max + 1];
    fact[0] = 1;
    for (int i = 1; i <= max; i++) {
      fact[i] = fact[i - 1] * i % MOD;
    }
    invFact = new long[max + 1];
    invFact[max] = powMod(fact[max], MOD - 2);
    for (int i = max - 1; i >= 0; i--) {
      invFact[i] = invFact[i + 1] * (i + 1) % MOD;
    }
  }

  private long powMod(long a, long b) {
    long res = 1;
    a %= MOD;
    while (b > 0) {
      if ((b & 1) != 0) {
        res = res * a % MOD;
      }
      a = a * a % MOD;
      b >>= 1;
    }
    return res;
  }
}",1441331229
Jie Hong Lin,tusov8899,176,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 0, 0)]
        ret = 0
        while pq:
            t, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

                
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + 1, moveTime[i][j] + 1)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, i, j))",1441301835
Jie Hong Lin,tusov8899,176,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 2, 0, 0)]
        ret = 0
        while pq:
            t, prev_cost, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

            next_cost = 2 if prev_cost == 1 else 1
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + next_cost, moveTime[i][j] + next_cost)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, next_cost, i, j))",1441307944
Jie Hong Lin,tusov8899,176,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = sum(int(num[i]) for i in range(n) if i & 1)
        odd = sum(int(num[i]) for i in range(n) if i & 1 == 0)
        return odd == even",1441283976
Jie Hong Lin,tusov8899,176,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def f(on, os, en, es):
            if on == en == 0: return int(os == es)
            i = n - (on + en)
            ret = 0
            if on:
                ret = (ret + f(on - 1, os + A[i], en, es) * on)#  % MOD
            if en:
                ret = (ret + f(on, os, en - 1, es + A[i]) * en)#   % MOD

            return ret
           
        def help(a):
            ret = 1
            while a:
                ret *= a
                a -= 1
            return ret
                
        MOD = 1_000_000_007
        A = list(map(int, list(num)))
        A.sort()
        n = len(A)
        cnt = Counter(A)
        div =1
        for v in cnt.values():
            div *= help(v)
        en = n // 2
        on = en + (n & 1)
        ret = f(on, 0, en, 0)
        # print(ret, div)
        return (ret // div)  % MOD
        ",1441361636
pulkit0707chawla,pulkit0707chawla,177,3627,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<long long>>grid(n+1,vector<long long>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<long long>,vector<vector<long long>>,greater<vector<long long>>>pq;
        pq.push({0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            long long t=v[0],x=v[1],y=v[2];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k],ny=y+dy[k];
                if(nx>=0 and ny>=0 and nx<n and ny<m){
                    long long val=1+t;
                    if(val<1+mat[nx][ny]) val=1+mat[nx][ny];
                    if(grid[nx][ny]>val){
                        grid[nx][ny]=val;
                        pq.push({grid[nx][ny],nx,ny});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441328732
pulkit0707chawla,pulkit0707chawla,177,3628,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<int>>grid(n+1,vector<int>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;
        pq.push({0,0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            int t=v[0],x=v[1],y=v[2],c=v[3];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k];
                int ny=y+dy[k];
                if(nx<n and ny<m and nx>=0 and ny>=0){
                    if(grid[nx][ny]>max(1+c+t,mat[nx][ny]+1+c)){
                        grid[nx][ny]=max(1+c+t,mat[nx][ny]+1+c);
                        pq.push({grid[nx][ny],nx,ny,1-c});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441320388
pulkit0707chawla,pulkit0707chawla,177,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd=0,even=0;
        bool c=0;
        for(auto x:num){
            if(c) odd+=x-'0';
            else even+=x-'0';
            c=!c;
        }
        return odd==even;
    }
};",1441291044
pulkit0707chawla,pulkit0707chawla,177,3637,cpp,"class Solution {
public:
    int mod=1e9+7;
    int countBalancedPermutations(string num) {
        int n=num.size();
        int e=(n+1)/2,o=n/2;
        string s=num;
        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }
        long long sum = 0;
        for(int d = 0; d < 10; d++) {
            sum += (long long)d * cnt[d];
        }
        if(sum%2) return 0;
        long long target = sum / 2;
        int mx=80;
        vector<long long> factorial(mx + 1, 1);
        for(int i = 1; i <= mx; i++) {
            factorial[i] = factorial[i -1] * i % mod;
        }
        vector<long long> inv_fact(mx + 1, 1);
        inv_fact[mx] = power(factorial[mx], mod - 2, mod);
        for(int i = mx -1; i >=0; i--){
            inv_fact[i] = inv_fact[i +1] * (i +1) % mod;
        }
        auto comb = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return factorial[n] * inv_fact[k] % mod * inv_fact[n -k] % mod;
        };
        vector<vector<long long>> dp(e +1, vector<long long>(target +1, 0));
        dp[0][0] =1;

        for(int d =0; d <10; d++) {
            if(cnt[d] ==0) continue;
            for(int t = e; t >=0; t--){
                for(long long s = target; s >=0; s--){
                    if(dp[t][s] ==0) continue;
                    for(int k =1; k <= cnt[d] && t +k <= e && s + (long long)d *k <= target; k++){
                        dp[t +k][s + (long long)d *k] = (dp[t +k][s + (long long)d *k] + dp[t][s] * comb(cnt[d], k)) % mod;
                    }
                }
            }
        }

        string l = num;
        long long valid = dp[e][target];
        long long p =1;
        for(int d =0; d <10; d++) {
            p = p * factorial[cnt[d]] % mod;
        }
        long long ans= valid;
        ans = ans * factorial[e] % mod;
        ans = ans * factorial[o] % mod;
        long long inv_product = power(p, mod -2, mod);
        ans = ans * inv_product % mod;
        return (int)ans;
    }

private:
    long long power(long long base, long long exp, long long mod){
        long long res =1;
        base %= mod;
        while(exp >0){
            if(exp &1) res = res * base % mod;
            base = base * base % mod;
            exp >>=1;
        }
        return res;
    }
};",1441355524
xs_pg,xs_pg,178,3627,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny] + 1, d + 1)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12",1441291533
xs_pg,xs_pg,178,3628,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny], d) + (1 if (nx+ny) % 2 == 1 else 2)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12
        ",1441294433
xs_pg,xs_pg,178,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = 0
        b = 0
        for i in range(0, n, 2):
            a += int(num[i])
            if i + 1 < n:
                b += int(num[i+1])
        return a == b
        ",1441281376
xs_pg,xs_pg,178,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num)
        t = n // 2
        
        d = defaultdict(int)
        S = 0
        for x in num:
            d[int(x)] += 1
            S += int(x)
        if S % 2 == 1:
            return 0
        
        f = [1]
        for i in range(n):
            f.append(f[-1] * (i+1) % mod)
        nf = [pow(x, mod-2, mod) for x in f]
        # print(f, nf)
        
        ks = list(d.keys())
        nk = len(ks)
        # print(ks)
        
        @cache
        def dp(index, cnt, v):
            if index >= nk:
                if cnt == t and v == S//2:
                    return f[t] * f[n-t] % mod
                return 0
            if cnt > t or v > S//2:
                return 0
            ans = 0
            c = d[ks[index]]
            for i in range(c+1):
                ans += nf[i] * nf[c-i] * dp(index+1, cnt+i, v+i*ks[index]) % mod
            return ans % mod
        
        return dp(0, 0, 0)
            ",1441380685
lawrencewxy,lawrencewxy,179,3627,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //两种写法，一种是newd = Math.abs(A[x][y] - A[x0][y0]); 这种写法，要用全局变量 res, 看上面，res = Math.max(a[2], res);当遇到终点时返回res
               // 第二种写法是 newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));， 遇到终点时直接返回 a[2] 本质上是一样的，第二种更好一些，可以在PQ里存的点少些？？
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                newd += 1;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y]});
                }

            }


        }

        return res;
    }
	   



}",1441305509
lawrencewxy,lawrencewxy,179,3628,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            int step = a[3];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //两种写法，一种是newd = Math.abs(A[x][y] - A[x0][y0]); 这种写法，要用全局变量 res, 看上面，res = Math.max(a[2], res);当遇到终点时返回res
               // 第二种写法是 newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));， 遇到终点时直接返回 a[2] 本质上是一样的，第二种更好一些，可以在PQ里存的点少些？？
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                if(step%2 == 0)newd += 1;
                if(step%2 == 1)newd += 2;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y], step + 1});
                }

            }


        }

        return res;
    }
}",1441310354
lawrencewxy,lawrencewxy,179,3636,java,"class Solution {
    public boolean isBalanced(String A) {
        
        int a = 0;
        int b = 0;
        int n = A.length();
        int j = 0;
        for(int i = 0; i < n; i++){
            int x = A.charAt(i)- '0';
            if(i %2 == 0){
                a +=x;
            }
            else{
                b += x;
            }
            
            
            
        }
        
        return a == b;
        
    }
}",1441284898
lawrencewxy,lawrencewxy,179,3637,java,"
class Solution {
 

    int mod = (int)(1e9 + 7);
    public int countBalancedPermutations(String num) {
 
        int n = num.length();
        int[] digitCnt = new int[10];
        int sum = 0;
        for (char ch : num.toCharArray()) {
            int digit = ch - '0';
            digitCnt[digit]++;
            sum += digit;
        }

        if (sum % 2 != 0) {
            return 0;
        }

        int target = sum / 2;
        int evenPos = (n + 1) / 2;
        int oddPos = n / 2;

        long[][][] state = new long[11][target + 1][evenPos + 1];
        state[0][0][0] = 1;

        long[] f = new long[n + 1];
        long[] invF = new long[n + 1];
        f[0] = invF[0] = 1;
        for (int i = 1; i <= n; i++) {
            f[i] = f[i - 1] * i % mod;
            invF[i] = modInverse(f[i]);
        }

        long[][] combs = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            combs[i][0] = combs[i][i] = 1;
            for (int j = 1; j < i; j++) {
                combs[i][j] = (combs[i - 1][j - 1] + combs[i - 1][j]) % mod;
            }
        }

        
        //  难
        for (int d = 0; d <= 9; d++) {
            int currentCount = digitCnt[d];
            for (int s = 0; s <= target; s++) {
                for (int c = 0; c <= evenPos; c++) {
                    if (state[d][s][c] == 0) continue;

                    for (int k = 0; k <= currentCount && c + k <= evenPos && s + k * d <= target; k++) {
                        state[d + 1][s + k * d][c + k] = (state[d + 1][s + k * d][c + k] + state[d][s][c] * combs[currentCount][k]) % mod;
                    }
                }
            }
        }

        long finalCount = state[10][target][evenPos];
        if (finalCount == 0) return 0;

        long evenWays = f[evenPos];
        long oddWays = f[oddPos];

        long denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * f[digitCnt[d]] % mod;
        }
        //get the final result
        long res = finalCount * evenWays % mod * oddWays % mod * modInverse(denom) % mod;
        return (int)(res);
    }

    long modInverse(long a) {
        return powMod(a, mod - 2);
    }

    // long powMod(long a, long b, int mod) {
     long powMod(long a, long b){
         long res = 1;
         
         a %= mod; // 这句话不能少，不然当a 大于 2^31 时就不对了！参看1969 Minimum Non-Zero Product of the Array Elements    
          
         while(b > 0){
             if(b%2 != 0) { // 等价于 if((b&1) == 1){
                 res = (res*a)%mod;
             }
            
             b = b/2;  // 等价于 b = b>>1;
             a = (a *a)%mod;
         }
         //System.out.println(""res = "" +res);
         return res;
     }

}",1441374842
Ritik Rathor,ritik_369,180,3627,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441356192
Ritik Rathor,ritik_369,180,3628,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 + (b) ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1+b) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441364305
Ritik Rathor,ritik_369,180,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    array < int , 2 > ar ; 
    ar[0] = ar[1] = 0 ; 
    int i = 0 ; 
    for(auto a : num)
       ar[(i ++ ) & 1] += a - '0' ;       
    return ar[0] == ar[1] ; 
    }
};",1441356045
Ritik Rathor,ritik_369,180,3637,cpp,"const int mod = 1e9 + 7;
string s ; 
int sm , to , n ; 
vector < int > vec , fac , ifac ; 
int dp[10][400][45] ; 
int f(int idx , int cur , int ct)
{
   if(cur > sm)return 0 ; 
   if(ct > to)return 0 ; 
   if(idx == 10)
   {
      return 1ll * (1ll * (cur == sm and ct == to) * 1ll * fac[ct] * fac[n - ct]) % mod ; 
   }
   int  & res = dp[idx][cur][ct] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   for(int i = 0 ; i <= vec[idx] ; i += 1)
   {
      int h = 0 ; 
      h = 1ll * (1ll * h + 1ll * f(idx + 1 , cur + (i * idx) , ct + i)) % mod ; 
      h = 1ll * (1ll * h * ifac[i]) % mod ; 
      h = 1ll * (1ll * h * ifac[vec[idx] - i]) % mod ; 
      res = 1ll * (1ll * res + 1ll * h) % mod ; 
   }
   return res ; 
}
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}


class Solution {
public:
    int countBalancedPermutations(string num)
    {
      if(fac.size() == 0)
      {
         fac = vector < int > (100 , 0) ; 
         ifac = vector < int > (100 , 0) ; 
         fac[0] = 1 ; 
         ifac[0] = binpow(1 , mod-2 , mod) ; 
         for(int i = 1 ; i <= 90 ; i += 1)
         {
            fac[i] = (1ll * fac[i-1] * i) % mod ; 
            ifac[i] = binpow(fac[i] , mod-2 , mod) ; 
         }
      }
      memset(dp , -1 , sizeof(dp)) ; 

      n = num.size() ; 
        vec = vector < int > (10 , 0) ; 
        sm = 0 ; 
        for(auto a : num)
        {
         vec[a - '0'] ++  ; 
         sm += a - '0' ; 
        }
        if(sm & 1)return 0 ; 
        sm /= 2 ;
        to = ((num.size() + 1) / 2) ; 
        return f(0 , 0 , 0) ; 
    }
};",1441369052
CLOWNTK,CLOWNTK,181,3627,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441355375
CLOWNTK,CLOWNTK,181,3628,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+ turn+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441353979
CLOWNTK,CLOWNTK,181,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int tot=0;
        for(int i=0;i<num.size();i++){
            if(i%2){
                tot+= (num[i]-'0');
            }
            else{
                tot-= (num[i]-'0');
            }
        }
        if(tot==0) return 1;
        return 0;
    }
};",1441356632
CLOWNTK,CLOWNTK,181,3637,cpp,"typedef long long ll;
int M= 1e9+7;
ll inv[85], fact[85];
ll dp[85][11][850];

long long power(long long a,long long b){
    if(b<0){
        return 0;
    }
    if(b==0){
        return 1;
    }
    if(abs(a)>=M){
        a= a%M;
    }
    if(a<0){
        a+=M;
    }
    long long  z = power((a*a)%M,b>>1);
    if(b&1){
        z=(z*a)%M;
    }
    return z;
}

class Solution {
public:
    ll solve(int i, int d, int sum, vector<int> &freq, int n, int tot){
        if(sum> (tot/2)){
            return 0;
        }
        if(d> 9){
            if(i!=(n+1)/2) return 0;
            if(sum!= (tot/2)) return 0;
            return 1;
        }
        if(dp[i][d][sum]!=-1){
            return dp[i][d][sum];
        }
        
        ll ans=0;

        for(int f=0;f<=freq[d] && (i+f)<=(n+1)/2;f++){
            ll now= (solve(i+f,d+1,sum+f*d,freq,n,tot)*inv[f])%M;
            now= (now*inv[freq[d]-f])%M;
            ans= (ans+now)%M;
            if(sum+ f*d> (tot/2)) break;
        }

        return dp[i][d][sum]= ans;
        
    }
    int countBalancedPermutations(string num) {
        fact[0]= inv[0]=1;

        for(int i=1;i<=84;i++){
            fact[i]= (i*fact[i-1])%M;
            inv[i]= power(fact[i], M-2);
        }

        int n= num.size();
        vector<int> freq(10);
        int tot=0;
        for(auto x: num){
            freq[x-'0']++;
            tot+= (x-'0');
        }
 
        if(tot%2) return 0;
        for(int i=0;i<=n;i++){
            for(int j=0;j<=9;j++){
                for(int sum=0;sum<=tot;sum++){
                    dp[i][j][sum]=-1;
                }
            }
        }
        
        ll now= (fact[n/2]*fact[(n+1)/2])%M;
        return (solve(0,0,0,freq,n,tot)*now)%M;
    }
};",1441340805
a_k,a0518,182,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+1
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc))
        
                
            ",1441287203
a_k,a0518,182,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c, x = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+(1 if x == 0 else 2)
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc,x^1))
        
                
            ",1441289199
a_k,a0518,182,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = b = 0
        for i in range(len(num)):
            if i%2:
                a+=int(num[i])
            else: b+=int(num[i])
        return a==b",1441280894
a_k,a0518,182,3637,python3,"from collections import Counter
from functools import cache

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9+7
        n = len(num)
        mp = Counter(num)

        tot = sum(int(d) for d in num)
        if tot % 2 != 0:  
            return 0

        fac = [1] * (n + 1)
        for i in range(1, n + 1):
            fac[i] = (fac[i - 1] * i) % mod

        def mod_inverse(v, p):
            return pow(v, p - 2, p)

        t = tot // 2

        dp = [[[0] * (n // 2 + 1) for _ in range(t + 1)] for _ in range(n + 1)]
        dp[0][0][0] = 1 

        for i in range(1, n + 1):
            digit = int(num[i - 1])
            for cur in range(t + 1):
                for cnt in range(n // 2 + 1):
                    if dp[i - 1][cur][cnt] > 0:
                        if cur + digit <= t and cnt + 1 <= n // 2:
                            dp[i][cur + digit][cnt + 1] = (dp[i][cur + digit][cnt + 1] + dp[i - 1][cur][cnt]) % mod
                        dp[i][cur][cnt] = (dp[i][cur][cnt] + dp[i - 1][cur][cnt]) % mod

        a = dp[n][t][n // 2] * fac[n // 2] % mod 
        b = fac[n - n // 2] 
        res = (a * b) % mod

        for v in mp.values():
            res = (res * mod_inverse(fac[v], mod)) % mod

        return res
",1441350922
Nat,4nIlUcEGTM,185,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (int[] dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
}",1441359050
Nat,4nIlUcEGTM,185,3628,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        d[0][0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) {
            vector<int> current = pq.top();
            pq.pop();

            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (auto dir : directions) {
                int ni = i + dir.first;
                int nj = j + dir.second;

                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};

",1441361470
Nat,4nIlUcEGTM,185,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        # Iterate through each digit and accumulate sums based on index parity
        for i, digit in enumerate(num):
            if i % 2 == 0:  # even index
                even_sum += int(digit)
            else:           # odd index
                odd_sum += int(digit)
        
        # Check if the sums are equal
        return even_sum == odd_sum
",1441313791
Nat,4nIlUcEGTM,185,3637,rust,"impl Solution {
    const MOD: i64 = 1_000_000_007;

    pub fn count_balanced_permutations(num: String) -> i32 {
        let length = num.len();
        let total_sum: i32 = num.chars().map(|c| c.to_digit(10).unwrap() as i32).sum();

        // Count occurrences of each digit
        let mut counts = vec![0; 10];
        for digit in num.chars() {
            counts[digit.to_digit(10).unwrap() as usize] += 1;
        }

        // If the total sum is odd, it's impossible to divide it into two equal parts
        if total_sum % 2 != 0 {
            return 0;
        }

        let half_sum = total_sum / 2;
        let m = (length + 1) / 2;

        // Factorial and inverse factorial arrays
        let mut factorial = vec![1i64; length + 1];
        for i in 1..=length {
            factorial[i] = factorial[i - 1] * i as i64 % Self::MOD;
        }

        let mut inv_factorial = vec![1i64; length + 1];
        inv_factorial[length] = Self::mod_inverse(factorial[length], Self::MOD);
        for i in (0..length).rev() {
            inv_factorial[i] = inv_factorial[i + 1] * (i as i64 + 1) % Self::MOD;
        }

        // DP table for counting balanced subsets
        let mut dp = vec![vec![0i64; (half_sum + 1) as usize]; m + 1];
        dp[0][0] = 1;

        for d in 0..10 {
            if counts[d] == 0 {
                continue;
            }

            for k in (0..=m).rev() {
                for s in (0..=half_sum as usize).rev() {
                    if dp[k][s] == 0 {
                        continue;
                    }

                    for t in 1..=counts[d] {
                        if k + t > m || s + (d * t) > half_sum as usize {
                            break;
                        }
                        let new_k = k + t;
                        let new_s = s + (d * t);
                        dp[new_k][new_s] = (dp[new_k][new_s] + dp[k][s] * Self::comb(counts[d], t, &factorial, &inv_factorial, Self::MOD)) % Self::MOD;
                    }
                }
            }
        }

        let w = dp[m][half_sum as usize];
        let mut result = factorial[m] * factorial[length - m] % Self::MOD;

        for d in 0..10 {
            result = result * inv_factorial[counts[d]] % Self::MOD;
        }

        result = result * w % Self::MOD;
        result as i32
    }

    fn mod_inverse(a: i64, m: i64) -> i64 {
        let mut result = 1;
        let mut base = a;
        let mut p = m - 2;

        while p > 0 {
            if p & 1 == 1 {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        result
    }

    fn comb(n: usize, k: usize, factorial: &[i64], inv_factorial: &[i64], m: i64) -> i64 {
        if k > n {
            return 0;
        }
        factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m
    }
}
",1441382752
EthanZyh,EthanZyh,186,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[int(1e10) for j in range(m)] for i in range(n)]
        f[0][0]=0
        q = [(0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y = heapq.heappop(q)
            d[(x,y)] = True
            if x==n-1 and y==m-1:
                return f[x][y]
            if x<n-1:
                t = max(f[x][y], moveTime[x+1][y])+1
                if t<f[x+1][y] and (x+1,y) not in d:
                    f[x+1][y]=t
                    heapq.heappush(q, (t,x+1,y))
            
            if x>=1:
                t = max(f[x][y], moveTime[x-1][y])+1
                if t<f[x-1][y] and (x-1,y) not in d:
                    f[x-1][y]=t
                    heapq.heappush(q, (t,x-1,y))
            
            if y<m-1:
                t = max(f[x][y], moveTime[x][y+1])+1
                if t<f[x][y+1] and (x,y+1) not in d:
                    f[x][y+1]=t
                    heapq.heappush(q, (t,x,y+1))
            
            if y>=1:
                t = max(f[x][y], moveTime[x][y-1])+1
                if t<f[x][y-1] and (x,y-1) not in d:
                    f[x][y-1]=t
                    heapq.heappush(q, (t,x,y-1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441307882
EthanZyh,EthanZyh,186,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[[int(1e10), int(1e10)] for j in range(m)] for i in range(n)]
        f[0][0][0]=0
        q = [(0,0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y,z = heapq.heappop(q)
            d[(x,y,z)] = True
            if x==n-1 and y==m-1:
                return f[x][y][z]
            if x<n-1:
                t = max(f[x][y][z], moveTime[x+1][y])+(z+1)
                if t<f[x+1][y][z^1] and (x+1,y,z^1) not in d:
                    f[x+1][y][z^1]=t
                    heapq.heappush(q, (t,x+1,y,z^1))
            
            if x>=1:
                t = max(f[x][y][z], moveTime[x-1][y])+(z+1)
                if t<f[x-1][y][z^1] and (x-1,y,z^1) not in d:
                    f[x-1][y][z^1]=t
                    heapq.heappush(q, (t,x-1,y,z^1))
            
            if y<m-1:
                t = max(f[x][y][z], moveTime[x][y+1])+(z+1)
                if t<f[x][y+1][z^1] and (x,y+1,z^1) not in d:
                    f[x][y+1][z^1]=t
                    heapq.heappush(q, (t,x,y+1,z^1))
            
            if y>=1:
                t = max(f[x][y][z], moveTime[x][y-1])+(z+1)
                if t<f[x][y-1][z^1] and (x,y-1,z^1) not in d:
                    f[x][y-1][z^1]=t
                    heapq.heappush(q, (t,x,y-1,z^1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441315726
EthanZyh,EthanZyh,186,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s = sum([int(num[i]) for i in range(len(num)) if i %2==0])
        t = sum([int(num[i]) for i in range(len(num)) if i %2==1])
        return s==t
        ",1441284111
EthanZyh,EthanZyh,186,3637,python,"class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        P = int(1e9+7)
        def Pow(a, b):
            ans = 1
            while b:
                if b%2==1:
                    ans = ans*a%P
                a = a*a%P
                b //= 2
            return ans
        ton = [0 for i in range(10)]
        n = len(num)
        num_list = [int(a) for a in num]
        S = sum(num_list)
        if S%2==1:
            return 0
        target = S//2
        for a in num:
            ton[int(a)] += 1
        N = 100
        fac = [0 for i in range(N)]
        ifac = [0 for i in range(N)]
        fac[0] = 1
        for i in range(1,N):
            fac[i]=fac[i-1]*i%P
        ifac[N-1] = Pow(fac[N-1], P-2)
        for i in range(N-2, -1, -1):
            ifac[i] = ifac[i+1] * (i+1) %P
        def C(n ,m):
            ans = (fac[n]*ifac[m]%P)*ifac[n-m]%P
            return ans
        f = [[[0 for k in range(target+1)] for j in range(n//2+1)] for i in range(11)]
        f[0][0][0] = 1
        used_pos = 0
        for i in range(10):
            for j in range(n//2+1):
                for k in range(target+1):
                    now = f[i][j][k]
                    if now==0:
                        continue
                    for l in range(ton[i]+1):
                        newK = k + l * i
                        newJ = j + l
                        if newK>target or newJ>n//2:
                            continue
                        f[i+1][newJ][newK] = (f[i+1][newJ][newK]+(now*C(n//2-j,l)%P)* \
                                              C(n-n//2-(used_pos-j),ton[i]-l))%P
            used_pos += ton[i]
        return f[10][n//2][target]
        ",1441358062
Vladislav,timetoai,189,3627,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0)]
        while h:
            t, i, j = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1
                    if (ni, nj) not in mem or mem[ni, nj] > nt:
                        mem[ni, nj] = nt
                        heappush(h, (nt, ni, nj))

        ",1441298463
Vladislav,timetoai,189,3628,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0, 0)]
        while h:
            t, i, j, add = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j, add] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1 + add
                    nadd = add ^ 1
                    if (ni, nj, nadd) not in mem or mem[ni, nj, nadd] > nt:
                        mem[ni, nj, nadd] = nt
                        heappush(h, (nt, ni, nj, nadd))

        ",1441302001
Vladislav,timetoai,189,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(1, len(num), 2)) == sum(int(num[i]) for i in range(0, len(num), 2))",1441280875
Vladislav,timetoai,189,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        cnt = [0] * 10
        for n in num:
            cnt[int(n)] += 1
        base = factorial(len(num) // 2) * factorial(len(num) - len(num) // 2)

        @cache
        def go(i, left, bal):
            if left == 0:
                if bal - sum(j * cnt[j] for j in range(i, 10)) == 0:
                    ret = base
                    for j in range(i, 10):
                        ret //= factorial(cnt[j])
                    return ret
                else:
                    return 0
            if i == 10:
                return 0
            if cnt[i] == 0:
                return go(i + 1, left, bal)
            res = 0
            for cur in range(0, min(left, cnt[i]) + 1):
                res += go(
                    i + 1, 
                    left - cur, 
                    bal + (2 * cur - cnt[i]) * i
                ) // factorial(cnt[i] - cur) // factorial(cur)
            return res

        return go(0, len(num) // 2, 0) % mod if sum(digit * cnt[digit] for digit in range(10)) % 2 == 0 else 0
        ",1441341525
Superultra,Superultra,191,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + 1;
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441360320
Superultra,Superultra,191,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + (p + 1);
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441359927
Superultra,Superultra,191,3636,cpp,"class Solution {
public:
    bool isBalanced(string S) {
        int e = 0, o = 0;
        for (int i = 0; i < S.size(); i++){
            if (i % 2 == 0)
                e += S[i] - '0';
            else
                o += S[i] - '0';
        }
        return e == o;
    }
};",1441361327
Superultra,Superultra,191,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int md = 1e9 + 7;

struct mint{
    int v;
    mint() : v(0) {}
    mint(ll v_) : v(int(v_ % md)){ if (v < 0) v += md; }
    explicit operator int() const{ return v; }
    friend std::ostream& operator << (std::ostream& out, const mint& n){ return out << int(n); }
    friend std::istream& operator >> (std::istream& in, mint& n){ ll v_; in >> v_; n = mint(v_); return in; }
 
    friend bool operator == (const mint& a, const mint& b){ return a.v == b.v; }
    friend bool operator != (const mint& a, const mint& b){ return a.v != b.v; }
    friend bool operator < (const mint& a, const mint& b){ return a.v < b.v; }
    friend bool operator <= (const mint& a, const mint& b){ return a.v <= b.v; }
    friend bool operator > (const mint& a, const mint& b){ return a.v > b.v; }
    friend bool operator >= (const mint& a, const mint& b){ return a.v >= b.v; }

    mint& operator += (const mint& o){ ((v += o.v) >= md) ? v -= md : 0; return *this; }
    mint& operator -= (const mint& o){ ((v -= o.v) < 0) ? v += md : 0; return *this; }
    mint& operator *= (const mint& o){ v = int((ll)v * o.v % md); return *this; }
    mint& operator /= (const mint& o){ return (*this) *= inv(o); }

    mint operator - () const{ return mint(-v); }
    friend mint operator + (mint a, const mint& b){ return a += b; }
    friend mint operator - (mint a, const mint& b){ return a -= b; }
    friend mint operator * (mint a, const mint& b){ return a *= b; }
    friend mint operator / (mint a, const mint& b){ return a /= b; }

    friend mint pow(mint a, ll p){ return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);	}
    friend mint inv(const mint& a){ return pow(a, md - 2); }
};

class Solution {
public:
    int countBalancedPermutations(string A) {
        vector<int> cnt(10, 0);
        int sum = 0;

        for (char c : A){
            cnt[c - '0']++;
            sum += (c - '0');
        }

        if (sum % 2){
            return 0;
        }

        int n = A.size();
        int targSz = n / 2;
        int targSum = sum / 2;

        mint dp[10][targSz + 5][targSum + 5];
        for (int i = 0; i < 10; i++)
            for (int j = 0; j <= targSz; j++)
                for (int k = 0; k <= targSum; k++)
                    dp[i][j][k] = 0;

        mint F[n + 5];
        F[0] = 1;

        for (int i = 1; i <= n; i++)
            F[i] = F[i - 1] * i;
        
        mint inv[n + 1][n + 1];
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= n; j++)
                inv[i][j] = 1 / (F[i] * F[j]);

        for (int i = 0; i < 10; i++){
            int mxSz = 0, mxSum = 0;
            for (int j = 0; j <= i; j++){
                mxSz += cnt[j];
                mxSum += cnt[j] * j;
            }
            for (int sz = 0; sz <= min(targSz, mxSz); sz++){
                for (int sum = 0; sum <= min(targSum, mxSum); sum++){
                    auto &cur = dp[i][sz][sum];
                    // Base
                    if (!i){
                        if (sum == 0 and sz <= cnt[i]){
                            cur = F[targSz] * F[n - targSz] / (F[sz] * F[(cnt[i] - sz)]);
                        }
                        // cout << i << "" "" << sz << "" "" << sum << "": "" << cur << endl;
                        // cout << F[targSz] << "" "" << 
                        continue;
                    }
                    for (int take = 0; take <= min(sz, cnt[i]) and sum - take * i >= 0; take++){
                        auto &temp = dp[i - 1][sz - take][sum - take * i];
                        cur += temp * inv[take][cnt[i] - take];
                    }
                }
            }
        }
        return dp[9][targSz][targSum].v;
    }
};
",1441341620
Reversal,ReversalGM,192,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0)]
        visited = set()
        while min_heap:
            cur_time, i, j = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j) in visited:
                continue
            visited.add((i, j))
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:
                    heapq.heappush(min_heap, (max(cur_time + 1, moveTime[new_i][new_j] + 1), new_i, new_j))
        return -1
                
                    
                    ",1441301107
Reversal,ReversalGM,192,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0, 1)]
        visited = set()
        while min_heap:
            cur_time, i, j, next_move_cost = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j, next_move_cost) in visited:
                continue
            visited.add((i, j, next_move_cost))
            new_next_move_cost = 2 if next_move_cost == 1 else 1
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n:
                    if new_next_move_cost == 2:
                        if (new_i, new_j, 1) not in visited and (new_i, new_j, 2) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
                    else:
                        if (new_i, new_j, 1) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
        return -1
                
                    
                    ",1441313629
Reversal,ReversalGM,192,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for idx, val in enumerate(num):
            if idx % 2 == 0:
                even_sum += int(val)
            else:
                odd_sum += int(val)
        return even_sum == odd_sum",1441282216
Reversal,ReversalGM,192,3637,python3,"class Solution:
    # even - odd
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10 ** 9 + 7
        required_evens = math.ceil(n / 2)
        required_odds = n - required_evens
        prev_ways = collections.Counter([(0, 0)])

        global_counter = collections.Counter([int(char) for char in num])

        picked_items = 0
        for val, val_count in global_counter.items():
            new_ways = collections.Counter()
            for (perm_sum, perm_even_count), perm_ways in prev_ways.items():
                for chosen_evens in range(val_count + 1):
                    chosen_odds = val_count - chosen_evens
                    new_perm_sum = perm_sum + ((chosen_evens - chosen_odds) * val)

                    even_spots_remaining = required_evens - perm_even_count
                    odd_spots_remaining = required_odds - (picked_items - perm_even_count)
                    
                    even_ways = math.comb(even_spots_remaining, chosen_evens) if even_spots_remaining > 0 else 1
                    odd_ways = math.comb(odd_spots_remaining, chosen_odds) if odd_spots_remaining > 0 else 1
                    if even_spots_remaining < chosen_evens:
                        break
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] += even_ways * odd_ways * perm_ways
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] = new_ways[(new_perm_sum, perm_even_count + chosen_evens)] % MOD
                    
            picked_items += val_count
            prev_ways = new_ways
        return prev_ways[(0, required_evens)]
                
            ",1441367686
robezh765,robezh765,193,3627,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 1);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};",1441297593
robezh765,robezh765,193,3628,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 2);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};
",1441296978
robezh765,robezh765,193,3636,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;

class Solution {
public:
    bool isBalanced(string num) {
        int s = 1;
        int sum = 0;
        for (char c : num) {
            sum += s * int(c - '0');
            s *= -1;
        }
        return sum == 0;
    }
};
",1441281118
robezh765,robezh765,193,3637,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;


const int MOD = (int)1e9 + 7;

struct mi {
    typedef decay<decltype(MOD)>::type T;
    /// don't silently convert to T
    T v; explicit operator T() const { return v; }
    mi() { v = 0; }
    mi(ll _v) {
        v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;
        if (v < 0) v += MOD;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
//    friend void re(mi& a) { ll x; re(x); a = mi(x); }
//    friend str ts(mi a) { return ts(a.v); }

    mi& operator+=(const mi& m) {
        if ((v += m.v) >= MOD) v -= MOD;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += MOD;
        return *this; }
    mi& operator*=(const mi& m) {
        v = (ll)v*m.v%MOD; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, ll p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,MOD-2); }

    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
};


mt19937 rng(2333);
const int S = 400 * 2 + 1, M = 400;
mi rdp[2][41][S];

class Solution {
public:
    int countBalancedPermutations(string num) {
        int c0 = (sz(num) + 1) / 2, c1 = sz(num) - c0;
//        cout << sz(num) << endl;

        int nw = 1, la = 0;
        memset(rdp, 0, sizeof rdp);
//        vector<vector<vector<mi>>> dp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
        rdp[nw][0][M] = 1;
        vi cnt(10);

        int sum = 0;
        shuffle(all(num), rng);
        for (char c : num) {
            swap(nw, la);
            int x = c - '0';
            cnt[x]++;
            auto &ndp = rdp[nw];
            auto &dp = rdp[la];
            memset(rdp[nw], 0, sizeof rdp[nw]);
//            vector<vector<vector<mi>>> ndp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
            rep(i, 0, c0 + 1) {
                rep(s, 0, S) {
                    if (s + x < S && i + 1 < c0 + 1) ndp[i + 1][s + x] += (i + 1) * dp[i][s];
                    if (s - x >= 0) ndp[i][s - x] += (sum - i + 1) * dp[i][s];
                }
            }
            sum += 1;

//            dp = ndp;
        }
        mi res = rdp[nw][c0][M];
//        return int(res);
        rep(i, 0, 10) {
            rep(j, 1, cnt[i] + 1) res /= j;
        }
        return int(res);
    }
};

",1441329938
Anshuman Tripathi,anshumantripathi878,194,3627,cpp,"class Solution {
public:
    int solve(vector<vector<int>>& moveTime) {
    int xxxx = moveTime.size(), yyyy = moveTime[0].size();
    vector<vector<int>> zzzz(xxxx, vector<int>(yyyy, INT_MAX));
    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

    zzzz[0][0] = 0;
    pq.push({0, 0, 0}); // (time, row, col)
    
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    while (!pq.empty()) {
        auto [timeNow, xx, yy] = pq.top();
        pq.pop();

        if (xx == xxxx - 1 && yy == yyyy - 1) return timeNow;
        
        for (auto& dir : directions) {
            int nx = xx + dir[0], ny = yy + dir[1];
            if (nx >= 0 && ny >= 0 && nx < xxxx && ny < yyyy) {
                int timeNext = max(timeNow + 1, moveTime[nx][ny] + 1);
                if (timeNext < zzzz[nx][ny]) {
                    zzzz[nx][ny] = timeNext;
                    pq.push({timeNext, nx, ny});
                }
            }
        }
    }
    
    return zzzz[xxxx - 1][yyyy - 1];
}

int minTimeToReach(vector<vector<int>>& moveTime) {
    return solve(moveTime);
}
};",1441308314
Anshuman Tripathi,anshumantripathi878,194,3628,python3,"import heapq
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        xxxx = len(moveTime)
        yyy = len(moveTime[0])
        
        zzzz = [[[float('inf')] * 2 for _ in range(yyy)] for _ in range(xxxx)]
        zzzz[0][0][0] = 0
        
        pq = []
        heapq.heappush(pq, (0, (0, 0, 0)))
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            
            if t > zzzz[i][j][p]:
                continue
            
            for di, dj in directions:
                ni = i + di
                nj = j + dj
                
                if 0 <= ni < xxxx and 0 <= nj < yyy:
                    nt = max(t, moveTime[ni][nj]) + (2 if p else 1)
                    
                    if nt < zzzz[ni][nj][1 - p]:
                        zzzz[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))
        
        return min(zzzz[xxxx - 1][yyy - 1][0], zzzz[xxxx - 1][yyy - 1][1])
",1441336487
Anshuman Tripathi,anshumantripathi878,194,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
         int evenSum = 0, oddSum = 0;
    for (int i = 0; i < num.size(); ++i) {
        if (i % 2 == 0)
            evenSum += num[i] - '0';
        else
            oddSum += num[i] - '0';
    }
    return evenSum == oddSum;
    }
};",1441287216
Anshuman Tripathi,anshumantripathi878,194,3637,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;
    typedef long long ll;

    // Function to compute power modulo
    long long zzzzz(long long aaaaa, long long bbbbb, long long ccccc) {
        long long ddddd = 1;
        while (bbbbb > 0) {
            if (bbbbb % 2 == 1) {
                ddddd = (ddddd * aaaaa) % ccccc;
            }
            aaaaa = (aaaaa * aaaaa) % ccccc;
            bbbbb /= 2;
        }
        return ddddd;
    }

    void eeeee(vector<long long>& fffff, vector<long long>& ggggg, int hhhhh) {
        fffff.resize(hhhhh + 1, 1);
        for (int iiiii = 1; iiiii <= hhhhh; ++iiiii) {  // Changed `iiii` to `iiiii`
            fffff[iiiii] = fffff[iiiii - 1] * iiiii % MOD; // Use `iiiii` here
        }
        ggggg.resize(hhhhh + 1, 1);
        ggggg[hhhhh] = zzzzz(fffff[hhhhh], MOD - 2, MOD);
        for (int jjjjj = hhhhh - 1; jjjjj >= 0; --jjjjj) {
            ggggg[jjjjj] = ggggg[jjjjj + 1] * (jjjjj + 1) % MOD;
        }
    }

    // Function to compute the number of balanced permutations
    int countBalancedPermutations(string num) {
        int kkkkk = num.length();
        int lllll[10] = {0};
        ll mmmmm = 0;

        for (char nnnnn : num) {
            lllll[nnnnn - '0']++;
            mmmmm += (nnnnn - '0');
        }

        if (mmmmm % 2 != 0) {
            return 0;
        }

        ll ooooo = mmmmm / 2;
        int ppppp = (kkkkk + 1) / 2;

        vector<ll> qqqqq, rrrrr;
        eeeee(qqqqq, rrrrr, kkkkk);

        vector<vector<ll>> sssss(ppppp + 1, vector<ll>(ooooo + 1, 0));
        sssss[0][0] = 1;

        for (int ttttt = 0; ttttt < 10; ++ttttt) {
            int uuuuu = lllll[ttttt];
            vector<vector<ll>> vvvvv(ppppp + 1, vector<ll>(ooooo + 1, 0));
            for (int wwwww = 0; wwwww <= ppppp; ++wwwww) {
                for (ll xxxxx = 0; xxxxx <= ooooo; ++xxxxx) {
                    if (sssss[wwwww][xxxxx] == 0) continue;
                    int yyyyy = min(uuuuu, ppppp - wwwww);
                    for (int zzzzz = 0; zzzzz <= yyyyy; ++zzzzz) {
                        ll aaaaa = wwwww + zzzzz;
                        ll bbbbb = xxxxx + (ll)ttttt * zzzzz;
                        if (bbbbb > ooooo) continue;
                        vvvvv[aaaaa][bbbbb] = (vvvvv[aaaaa][bbbbb] + sssss[wwwww][xxxxx] * rrrrr[zzzzz] % MOD * rrrrr[uuuuu - zzzzz] % MOD) % MOD;
                    }
                }
            }
            sssss = vvvvv;
        }

        ll ccccc = sssss[ppppp][ooooo];

        ll ddddd = qqqqq[ppppp] * qqqqq[kkkkk - ppppp] % MOD;
        ddddd = ddddd * ccccc % MOD;

        return (int)ddddd;
    }
};
",1441375431
xlx2,xlx2,195,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        h = [(0, 0, 0)]
        f[0][0] = 0
        while h:
            t, i, j = heapq.heappop(h)
            if f[i][j] != t:
                continue
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + 1
                    if x < f[a][b]:
                        f[a][b] = x
                        heapq.heappush(h, (x, a, b))
        return f[-1][-1]",1441314344
xlx2,xlx2,195,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        vis = [[[0,0] for _ in range(n)] for _ in range(m)]
        h = [(0, 0, 0, 0)]
        f[0][0] = 0
        # vis[0][0][0] = 1
        while h:
            t, i, j, k = heapq.heappop(h)
            if vis[i][j][k]:
                continue
            vis[i][j][k] = 1
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + k+1
                    if vis[a][b][k^1] == 0:
                        if x < f[a][b]:
                            f[a][b] = x
                        heapq.heappush(h, (x, a, b, k^1))
        return f[-1][-1]",1441314113
xlx2,xlx2,195,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        s = sum(int(x) for x in num)
        s2 = sum(int(x) for x in num[::2])
        return s == 2 * s2",1441314562
xlx2,xlx2,195,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(x) for x in num) % 2:
            return 0

        M = 10**9 + 7
        n = len(num)
        p, q = (n+1)//2, n//2
        r = sum(int(v) for v in num) // 2
        c = [0] * 10
        for v in num:
            c[int(v)] += 1
        
        d = defaultdict(int)
        d[(0, 0, 0, 0)] = 1
        for i,v in enumerate(c):
            g = defaultdict(int)
            for j in range(v+1):
                for a,s,b,t in d:
                    if a+j <= p and b+v-j <= q and s+j*i <= r and t+(v-j)*i <= r:
                        x = d[(a,s,b,t)] * math.comb(a+j, j) * math.comb(b+v-j, v-j) % M
                        g[(a+j, s+j*i, b+v-j, t+(v-j)*i)] += x
            d = g
        
        return d[(p, r, q, r)] % M
",1441375631
Abhinav Nagar,abhinav_2696,197,3627,java,"class Solution {
    public int minTimeToReach(int[][] mt) {
        int r = mt.length;
        int c = mt[0].length;
        
        int[][] d = fn2(r, c);
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        fn3(pq, d);
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] t = pq.poll();
            int ct = t[0], cr = t[1], cc = t[2];
            
            if (ct > d[cr][cc]) continue;
            
            fn4(pq, mt, d, dirs, ct, cr, cc, r, c);
        }
        
        return d[r - 1][c - 1];
    }
    void fn3(PriorityQueue<int[]> pq, int[][] d) {
        pq.offer(new int[]{0, 0, 0});
        d[0][0] = 0;
    }
    int[][] fn2(int r, int c) {
        int[][] d = new int[r][c];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                d[i][j] = Integer.MAX_VALUE;
            }
        }
        return d;
    }
    void fn4(PriorityQueue<int[]> pq, int[][] mt, int[][] d, int[][] dirs, int ct, int cr, int cc, int r, int c) {
        for (int[] dir : dirs) {
            int nr = cr + dir[0];
            int nc = cc + dir[1];
            
            if (nr >= 0 && nr < r && nc >= 0 && nc < c) {
                int nt = Math.max(ct, mt[nr][nc]) + 1;
                
                if (nt < d[nr][nc]) {
                    d[nr][nc] = nt;
                    pq.offer(new int[]{nt, nr, nc});
                }
            }
        }
    }
}",1441336597
Abhinav Nagar,abhinav_2696,197,3628,java,"class Solution {
    int fn3(int[][] mt) {
        return mt[0].length;
    }
    boolean fn6(int nr, int nc, int r, int c) {
        return nr >= 0 && nr < r && nc >= 0 && nc < c;
    }
    public int minTimeToReach(int[][] mt) {
        int r = fn2(mt), c = fn3(mt);
        int[][][] mtm = fn4(r, c);
        mtm[0][0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.add(new int[]{0, 0, 0, 0});
        
        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ct = cur[0], rw = cur[1], cl = cur[2], pr = cur[3];
            
            if (ct > mtm[rw][cl][pr]) continue;
            
            fn5(pq, dir, mt, mtm, ct, rw, cl, pr, r, c);
        }
        
        return Math.min(mtm[r - 1][c - 1][0], mtm[r - 1][c - 1][1]);
    }
    void fn5(PriorityQueue<int[]> pq, int[][] dir, int[][] mt, int[][][] mtm, int ct, int rw, int cl, int pr, int r, int c) {
        for (int[] d : dir) {
            int nr = rw + d[0], nc = cl + d[1];
            
            if (fn6(nr, nc, r, c)) {
                int nt = Math.max(ct, mt[nr][nc]) + (pr == 1 ? 2 : 1);
                
                if (nt < mtm[nr][nc][1 - pr]) {
                    mtm[nr][nc][1 - pr] = nt;
                    pq.add(new int[]{nt, nr, nc, 1 - pr});
                }
            }
        }
    }
    int fn2(int[][] mt) {
        return mt.length;
    }
    int[][][] fn4(int r, int c) {
        int[][][] mtm = new int[r][c][2];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                mtm[i][j][0] = Integer.MAX_VALUE;
                mtm[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return mtm;
    }
}",1441345445
Abhinav Nagar,abhinav_2696,197,3636,python3,"class Solution:
    def fn4(self, es, os):
        return es == os
        
    def fn3(self, i):
        return i % 2 == 0
        
    def fn2(self, c):
        return int(c) - 0
    
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            d = self.fn2(num[i])
            if self.fn3(i):
                es += d
            else:
                os += d
        return self.fn4(es, os)",1441305485
Abhinav Nagar,abhinav_2696,197,3637,python3,"MOD = int(1e9 + 7)

class Solution:
    def fn3(self, dp, fq, fact, inv_fact, m, tgt):
        for d in range(10):
            if fq[d] == 0:
                continue
            for j in range(m, -1, -1):
                for k in range(tgt, -1, -1):
                    if dp[j][k] == 0:
                        continue
                    for c in range(1, min(fq[d], m - j) + 1):
                        if k + d * c > tgt:
                            break
                        cmb = fact[fq[d]] * inv_fact[c] % MOD * inv_fact[fq[d] - c] % MOD
                        dp[j + c][k + d * c] = (dp[j + c][k + d * c] + dp[j][k] * cmb) % MOD

    def fn2(self, a, b):
        res = 1
        a %= MOD
        while b > 0:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
        
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        m = (n + 1) // 2
        l = n // 2
        fq = [0] * 10
        for c in num:
            fq[ord(c) - ord('0')] += 1
        s = sum(d * fq[d] for d in range(10))
        if s % 2 == 1:
            return 0
        tgt = s // 2
        fact = [1] * (n + 1)
        inv_fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i % MOD
        inv_fact[n] = self.fn2(fact[n], MOD - 2)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        dp = [[0] * (tgt + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        self.fn3(dp, fq, fact, inv_fact, m, tgt)
        dp_val = dp[m][tgt]
        if dp_val == 0:
            return 0
        ans = self.fn4(dp_val, fact, inv_fact, fq, m, l)
        return ans
    
    def fn4(self, dp_val, fact, inv_fact, fq, m, l):
        fact_m = fact[m]
        fact_l = fact[l]
        fact_fq = 1
        for d in range(10):
            fact_fq = fact_fq * fact[fq[d]] % MOD
        inv_fact_fq = self.fn2(fact_fq, MOD - 2)
        ans = dp_val * fact_m % MOD * fact_l % MOD * inv_fact_fq % MOD
        return ans
",1441388024
Orz,retired_kid,198,3627,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], 1<<30);
        }
        dp[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[] {0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]] > Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1) {
                    dp[c[0] + dr[i]][c[1] + dc[i]] = Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i]});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441294378
Orz,retired_kid,198,3628,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][][] dp = new int[n + 1][m + 1][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                Arrays.fill(dp[i][j], 1<<30);
            }
        }
        dp[0][0][0] = 0;
        PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(v -> v[3]));
        q.add(new int[] {0, 0, 0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            int k = c[2];
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] >
                        Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k) {
                    dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] = Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i], k ^ 1, dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1]});
                }
            }
        }
        return Arrays.stream(dp[n - 1][m - 1]).min().getAsInt();
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441299893
Orz,retired_kid,198,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length(), e = 0, o = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) e+=num.charAt(i)-'0';
            else o+=num.charAt(i)-'0';
        }
        return e == o;
    }
}",1441281401
Orz,retired_kid,198,3637,java,"class Solution {
    static long[] inv, f;
    static boolean init = false;
    static int mod = (int) 1e9 + 7, MM = 10;
    Map<Integer, Integer>[][] dp;
    Map<Integer, Integer> cnt = new HashMap<>();
    public int countBalancedPermutations(String num) {
        if (!init) {
            fc();
        }
        int n = num.length();
        dp = new Map[MM][n + 1];
        for (int i = 0; i < MM; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = new HashMap<>();
            }
        }
        for (int i = 0; i < n; i++) {
            int v = num.charAt(i) - '0';
            cnt.put(v, cnt.getOrDefault(v, 0) + 1);
        }
        return dfs(0, n / 2, 0, n);
    }
    public int dfs(int d, int even, int s, int n) {
        // System.out.println(even + "" "" + d);
        if (d == MM) return s == 0 && even == 0 ? 1 : 0;
        else if (dp[d][even].containsKey(s)) return dp[d][even].get(s);
        long ret = 0;
        int ct = cnt.getOrDefault(d, 0);
        for (int j = 0; j <= Math.min(ct, even); j++) { // how many we put at left / right
            long p = ( C(even, j) % mod * C(n - even, (ct - j)) % mod * dfs(d + 1, even - j, s + (j * d) - (ct - j) * d, n - ct) % mod ) % mod;
            ret += p;
            ret %= mod;
        }
        dp[d][even].put(s, (int) ret);
        return (int) ret;
    }
    static void fc() {
        init = true;
        inv = new long[100]; f = new long[100];
        f[0] = inv[0] = 1;
        for (int i = 1; i < 100; i++) {
            f[i] = (f[i-1] % mod * i % mod) % mod;
            inv[i] = pow(f[i], mod-2);
        }
    }
    public static long C(int n, int r) {
        // System.out.println(n + "" "" + r);
        if (n < r) return 0;
        return (f[n] % mod * inv[r] % mod * inv[n-r] % mod) % mod;
    }
    static long pow (long x, long exp){
        if (exp==0) return 1;
        long t = pow(x, exp/2);
        t = t*t % mod;
        if (exp%2 == 0) return t;
        return t*x % mod;
    }
}",1441375957
Chuan-Chih Chou,chuan-chih,199,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, i, j = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y))
        
                    
            ",1441300467
Chuan-Chih Chou,chuan-chih,199,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0, False)]
        while heap:
            t, i, j, p = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + p + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y, not p))",1441303185
Chuan-Chih Chou,chuan-chih,199,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(d) for d in num[::2]) == sum(int(d) for d in num[1::2])",1441281012
Chuan-Chih Chou,chuan-chih,199,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num) // 2
        total, p = divmod(sum(int(d) for d in num), 2)
        if p:
            return 0
        f = [1, 1]
        for i in range(2, len(num) + 1):
            f.append(f[-1] * i % mod)
        count = [0] * 10
        for d in num:
            count[int(d)] += 1
        base = [0] * 10
        b = 1
        for i, c in enumerate(count):
            base[i] = b
            b *= (c + 1)
        
        def decode(b):
            c = []
            x = b
            for curr in reversed(base):
                d, x = divmod(x, curr)
                c.append(d)
            c.reverse()
            return c
        
        nom = f[n] * f[len(num) - n] % mod
        
        @cache
        def recur(d, used, s):
            if d == 10:
                if used != n:
                    return 0
                if s != total:
                    return 0
                return nom
            to_use = n - used
            ans = 0
            for use in range(min(to_use, count[d]) + 1):
                factor = pow(f[use], -1, mod) * pow(f[count[d] - use], -1, mod) % mod
                ans += recur(d + 1, used + use, s + use * d) * factor % mod
            # print(d, used, s, ans)
            return ans % mod
            
            
        return recur(0, 0, 0)
        
            ",1441376296
Jasper,JasperT37449,200,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        pq.push({0, {0, 0}});
        int t, i, j;
        vector<vector<int>> time(n+1, vector<int>(m+1, 1e9));
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+1, moveTime[i+1][j]+1), {i+1, j}});
            if(j+1<=m)pq.push({max(t+1, moveTime[i][j+1]+1), {i, j+1}});
            if(i-1>=0)pq.push({max(t+1, moveTime[i-1][j]+1), {i-1, j}});
            if(j-1>=0)pq.push({max(t+1, moveTime[i][j-1]+1), {i, j-1}});
        }
        return t;
    }
};",1441313753
Jasper,JasperT37449,200,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,pair<int, int>>>, vector<pair<int, pair<int, pair<int, int>>>>, greater<pair<int, pair<int, pair<int, int>>>>> pq;
        pq.push({0, {0, {0, 1}}});
        int t, i, j, turn;
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second.first, turn = pq.top().second.second.second%2;
            if(!turn)turn = 2;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            //cout<<""T : ""<<t<<"" ""<<i<<"" ""<<j<<endl;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+turn, moveTime[i+1][j]+turn), {i+1, {j, turn+1}}});
            if(j+1<=m)pq.push({max(t+turn, moveTime[i][j+1]+turn), {i, {j+1, turn+1}}});
            if(i-1>=0)pq.push({max(t+turn, moveTime[i-1][j]+turn), {i-1, {j, turn+1}}});
            if(j-1>=0)pq.push({max(t+turn, moveTime[i][j-1]+turn), {i, {j-1, turn+1}}});
        }
        return t;
    }
};",1441328086
Jasper,JasperT37449,200,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        for(int i = 0;i<num.size();i++){
            if(i%2==0){
                odd+=num[i]-48;
            }
            else {
                even+=num[i]-48;
            }
        }
        if(odd==even)return true;
        return false;
    }
};",1441282589
Jasper,JasperT37449,200,3637,cpp,"typedef long long ll;

class Solution {
public:
    ll power(ll a, ll b, ll mod) {
        ll res = 1;
        a %= mod;
        while(b >0){
            if(b &1){
                res = res * a % mod;
            }
            a = a *a % mod;
            b >>=1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size(), cnt[10] = {0}, sum =0, mod = 1e9 + 7;
        for(char c: num){
            cnt[c - '0']++;
            sum += (c - '0');
        }
        if(sum %2 !=0)return 0;
        ll s = sum /2;
        int k = (n+1)/2;
        vector<ll> fact(n+1,1), table(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] *i % mod;
        table[n] = power(fact[n], mod-2, mod);
        for(int i=n-1;i>=0;i--) table[i] = table[i+1] * (i+1) % mod;
        vector< vector<ll> > prev(k+1, vector<ll>(s+1, 0));
        prev[0][0] =1;
        for(int d=0; d<=9; d++){
            int c_d = cnt[d];
            vector< vector<ll> > curr(k+1, vector<ll>(s+1, 0));
            for(int k_prev=0; k_prev <=k; k_prev++){
                for(int s_prev=0; s_prev <=s; s_prev++){
                    if(prev[k_prev][s_prev] ==0) continue;
                    for(int x=0; x<=c_d; x++){
                        if(k_prev +x >k) break;
                        if((ll)s_prev + (ll)d *x >s) break;
                        int new_k = k_prev +x, new_s = s_prev + d *x;
                        ll val = prev[k_prev][s_prev];
                        val = val * table[x] % mod;
                        val = val * table[c_d -x] % mod;
                        curr[new_k][new_s] = (curr[new_k][new_s] + val) % mod;
                    }
                }
            }
            prev = move(curr);
        }
        if(k >n || s > 9*80)return 0;
        ll res = fact[k];
        res = res * fact[n -k] % mod;
        res = res * prev[k][s] % mod;
        return res;
    }
};",1441376524
lu-chen-chen,lu-chen-chen,201,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t + 1, moveTime[x][y] + 1)});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441298612
lu-chen-chen,lu-chen-chen,201,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t, moveTime[x][y]) + 1 + (x + y + 1) % 2});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441305940
lu-chen-chen,lu-chen-chen,201,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int a = 0;
        int b = 0;
        char[] chars = num.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (i % 2 == 0) {
                a += chars[i] - '0';
            } else {
                b += chars[i] - '0';
            }
        }
        return a == b;
    }
}",1441281556
lu-chen-chen,lu-chen-chen,201,3637,java,"import java.math.BigInteger;
class Solution {
    public int countBalancedPermutations(String num) {
        long mod = (long) (1e9 + 7);
        char[] chars = num.toCharArray();
        int n = chars.length;
        int sum = 0;
        int[] cnt = new int[10];
        for (char c : chars) {
            cnt[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 1) {
            return 0;
        }
        Factorial fac = new Factorial(n + 5, (int) mod);
        long[][][] dp = new long[10][n / 2 + 1][sum / 2 + 1];
        for (int i = 0; i <= Math.min(cnt[0], n / 2); i++) {
            dp[0][i][0] = 1;
        }
        int curCnt = cnt[0];
        for (int i = 1; i < 10; i++) {
            curCnt += cnt[i];
            for (int j = 0; j <= n / 2; j++) {
                for (int k = 0; k <= sum / 2; k++) {
                    for (int l = 0; l <= cnt[i]; l++) {
                        int j1 = j + l;
                        int k1 = k + l * i;
                        if (j1 > n / 2 || k1 > sum / 2) {
                            break;
                        }
                        dp[i][j1][k1] += fac.comb(j1, l) * dp[i - 1][j][k] % mod * fac.comb(curCnt - j1, cnt[i] - l) % mod;
                        dp[i][j1][k1] %= mod;
                    }
                }
            }
        }
        long ans = dp[9][n / 2][sum / 2];
        return (int) ((ans + mod) % mod);
    }
}

class Factorial {
    long[] fac;
    long[] inv;
    long mod;

    public Factorial(long[] fac, long[] inv, long mod) {
        this.mod = mod;
        this.fac = fac;
        this.inv = inv;
        fac[0] = inv[0] = 1;
        int n = fac.length;
        for (int i = 1; i < n; i++) {
            fac[i] = i;
            fac[i] = (int) (fac[i] * fac[i - 1] % mod);
        }
        inv[n - 1] = BigInteger.valueOf(fac[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();
        for (int i = n - 2; i >= 1; i--) {
            inv[i] = (int) (inv[i + 1] * (i + 1) % mod);
        }
    }

    public Factorial(int limit, int mod) {
        this(new long[Math.min(limit + 1, mod)], new long[Math.min(limit + 1, mod)], mod);
    }

    public long getMod() {
        return mod;
    }

    public long fac(int n) {
        if (n >= mod) {
            return 0;
        }
        return fac[n];
    }

    public long inv(int n) {
        if (n >= mod) {
            throw new IllegalArgumentException();
        }
        return inv[n];
    }

    public long comb(int n, int m) {
        if (n < m) {
            return 0;
        }
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    }

    public long combInv(int n, int m) {
        if (n < m) {
            throw new IllegalArgumentException();
        }
        return inv[n] * fac[m] % mod * fac[n - m] % mod;
    }
}",1441364181
unnu,unnu,202,3627,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty]+1,t+1);
                    if(dis[tx][ty]>t1){
                        st.erase({dis[tx][ty],tx,ty});
                        st.insert({t1,tx,ty});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
        
    }
};",1441302269
unnu,unnu,202,3628,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2],z=v[3];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty],t);
                    if(z%2==0) t1+=1;
                    else t1+=2;
                    if(dis[tx][ty]>t1){
                        // st.erase({dis[tx][ty],tx,ty,});
                        st.insert({t1,tx,ty,1-z});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
    }
};",1441305679
unnu,unnu,202,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int x=0;int y=0;int n=num.size();
        for(int i=0;i<n;i++){
            if(i%2) x+=(num[i]-'0');
            else y+=(num[i]-'0');
        }
        return (x==y);
    }
};",1441289924
unnu,unnu,202,3637,cpp,"#define ll long long
class Solution {
public:
    const int mod=1e9+7;
    ll dp[12][41][365];
    vector<int>freq;int p;
    vector<ll>fact,invf;

ll power(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)
        {
            res=(res*a)%mod;
        }
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}

void precompute(int n)
{
    fact.resize(n+1);
    invf.resize(n+1);
    fact[0]=1;
    for(int i=1;i<=n;i++)
    {
        fact[i]=(fact[i-1]*i)%mod;
    }
    invf[n]=power(fact[n],mod-2);
    for(int i=n-1;i>=0;i--)
    {
        invf[i]=(invf[i+1]*(i+1))%mod;
    }
}

ll nCr(int n,int r)
{
    if(r>n)
    {
        return 0;
    }
    ll ans=(invf[r])%mod;
    ans=(ans*invf[n-r])%mod;
    return ans;
}
    ll f(int idx,int cnt,int sum,int k){
        // int n=v.size();
        // int p=n/2;
        // if(idx>=n && sum==k && cnt==p) return 1;
        // if(idx>=n || sum>k || cnt>p) return 0;
        // if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        // ll take=f(idx+1,cnt+1,sum+v[idx],k,v);
        // ll nt=f(idx+1,cnt,sum,k,v);
        // ll ans=(take+nt)%mod;
        // return dp[idx][cnt][sum]=ans;
        
        int n=freq.size();
        if(idx>=n && sum==k && cnt==p) {
          //  cout<<sum<<"" ""<<cnt<<endl;
            return 1;
        }
        if(idx>=n || sum>k || cnt>p) return 0;
        if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        ll take=0,nt=0;ll res=0;
        for(int i=0;i<=freq[idx];i++){
            take=(f(idx+1,cnt+i,sum+(i)*idx,k)*nCr(freq[idx],(i)))%mod;
           // nt=(f(idx+1,cnt+i,sum+(i*idx),k)*nCr(freq[idx],i))%mod;
            //cout<<take<<"" ""<<nt<<"" p""<<i<<endl;
            res+=((take%mod))%mod;
            res%=mod;
            res=(res+mod)%mod;
        }
         //nt=(f(idx+1,cnt+freq[idx],sum+(freq[idx]*idx),k))%mod;
        // res+=(nt%mod);
        // res%=mod;
        // res=(res+mod)%mod;
       // cout<<idx<<"" ""<<cnt<<"" ""<<sum<<"" ""<<res<<endl;
        return dp[idx][cnt][sum]=res;
    }
    int countBalancedPermutations(string num) {
        vector<int>v;freq.resize(10,0);precompute(81);
        for(auto ch:num) v.push_back(ch-'0');
        int k=0;p=v.size()/2;
        for(auto it:v) k+=it,freq[it]++;
        if(k%2) return 0;
        memset(dp,-1,sizeof(dp));
        ll ans=(fact[p]*fact[v.size()-p])%mod;
        ll tmp=f(0,0,0,k/2)%mod;
        ll res=(ans*tmp)%mod;
        res=(res+mod)%mod;
        return res;
        
        
        // return f(0,0,0,k/2);
    }
};",1441385344
op33,op33,203,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        visited = set()
        queue = [(0, (0,0))]
        while queue:
            time, (row, col) = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    heapq.heappush(queue, (ntime, (nr, nc)))
            

        # should always return earlier",1441297937
op33,op33,203,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        # another variable to track move parity
        visited = set()
        queue = [(0, (0,0), True)]
        while queue:
            time, (row, col), parity = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    if not parity:
                        ntime += 1
                    heapq.heappush(queue, (ntime, (nr, nc), not parity))
            

        # should always return earlier",1441300716
op33,op33,203,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens, odds = 0, 0
        for i, char in enumerate(num):
            digit = int(char)
            if i % 2 == 0:
                evens += digit
            else:
                odds += digit
        return evens == odds",1441283006
op33,op33,203,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # naively you can compute n! perms * n to count all
        # They must sum to sum(num) / 2 which must be even in total
        # sum(num) // 2 = S
        # how many subsets will sum to S? -> This is a known problem, N^2
        # How many permutations of each of these subsets are there as well
        # If a subset has duplicates, you need to divide by m! for each duplicate for overcounting
        # num.length is max 80 which can make it easier
        # Can manually go through each distinct subset after collecting each?
        # Or can iteratively build a count and correct for overcounting at each step?
        # What if you track each counts of each digit set, such as {7:2,9:1} -> 2
        # Or track each sum -> unique digit sets such as 21 -> {{7:3}, {8:2, 5:1}}
        # This is an option but might be too slow/memory(?)

        # count each digit and then do coin change like dp?
        # This could work since you can iteratively build the denominator at each step
        # For example, if there are 3 2s available and you choose to use 3 of them, then you eventually need to overcorrect by a factor of 3!, so you can pass that down in the dp process, no matter what is chosen later.
        # need to store num_elems so far chosen, denominator so far, index, sum so far
        # also need to store denom for the other subset
        # Forgot that num elems must match or be off by 1 at most
        # Also if sum > S at any point, early break
        # If num elems is > half at any point, only add 0 elems in future.
        # maybe set1 is evens, set2 is odds. Can have at most 1 extra for either by the end -> No only even can have more
        # maybe can reduce time using symmetry of even/odd sets?? maybe only if even digits_count
        # If odd digit count, then there will be exactly 1 extra even compared to odds
        # Do we need denom1/denom2 in the cache state? No? Can just divide on demand when receiving the output
        # 851350267
        
        MOD = 10**9 + 7

        @cache
        def factorial(n):
            if n == 0:
                return 1
            answer = 1
            for i in range(1, n + 1):
                answer *= i
            return answer

        digits = [int(char) for char in num]
        digits_count = len(digits)
        evens_digit_count = digits_count // 2
        if digits_count % 2 == 1:
            evens_digit_count += 1

        T = sum(digits)
        if T % 2 == 1:
            return 0
        
        S = T // 2

        counts = list(Counter(digits).items())
        counts = sorted(counts) # ex - [(0, 5), (1, 2), (3, 1), ... (9, 1)]

        @cache
        def count_bal_perms(idx, sum_so_far, num_elems):
            if idx == len(counts):
                if sum_so_far == S and num_elems == evens_digit_count:
                    total1 = factorial(num_elems) # should always divide cleanly
                    total2 = factorial(digits_count - num_elems)
                    return total1 * total2
                else:
                    return 0

            cur_dig, count = counts[idx]
            bal_perms = 0
            for i in range(count + 1):
                new_num_elems = num_elems + i
                new_sum = sum_so_far + i * cur_dig
                if new_num_elems > evens_digit_count or new_sum > S:
                    continue

                denom1, denom2 = factorial(i), factorial(count - i)

                bal_perms += count_bal_perms(idx + 1, new_sum, new_num_elems) // denom1 // denom2

            return bal_perms

        return count_bal_perms(0, 0, 0) % MOD
            
        ",1441379448
user9821NM,user9821NM,204,3627,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<int>>dist(n, vector<int>(m, INT_MAX));
        
        set<tuple<int,int,int>>q; q.insert({0, 0, 0}); dist[0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y] = *q.begin(); q.erase(*q.begin());
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && dist[X][Y] > max(dist[x][y] + 1, moveTime[X][Y] + 1)) {
                    q.erase({dist[X][Y], X, Y});
                    dist[X][Y] =  max(dist[x][y] + 1, moveTime[X][Y] + 1);
                    q.insert({dist[X][Y], X, Y});
                }
            }
        };
        
        return dist[n - 1][m - 1];
    }
};",1441344848
user9821NM,user9821NM,204,3628,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<vector<int>>>dist(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        
        set<tuple<int,int,int,int>>q; q.insert({0, 0, 0, 0}); dist[0][0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y, move] = *q.begin(); q.erase(*q.begin());
            
            int cost = ((move ^ 1) ? 1 : 2);
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && 
                    dist[X][Y][move ^ 1] > max(dist[x][y][move] + cost, moveTime[X][Y] + cost)) {
                    q.erase({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                    dist[X][Y][move ^ 1] =  max(dist[x][y][move] + cost, moveTime[X][Y] + cost);
                    q.insert({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                }
            }
        };
        
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441351431
user9821NM,user9821NM,204,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int>sum(2);
        for(int i = 0;i < num.size(); i++) {
            sum[i % 2] += num[i] - '0';
        }
        
        return sum[0] == sum[1];
    }
};",1441326964
user9821NM,user9821NM,204,3637,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int expo(int a, int b) {
        int res = 1;
        while(b) {
            if(b & 1) res = (1ll * res * a) % MOD;
            b >>= 1; a = (1ll * a * a) % MOD;
        }
        return res;
    }
    
    int countBalancedPermutations(string num) {
        vector<int>fr(10), fact(num.size() + 1, 1), ifact(num.size() + 1, 1); int sum = 0;
        for(auto &i : num) fr[i - '0']++, sum += (i - '0');
                
        if((sum % 2 == 1)) return 0;
        
        for(int i = 1; i <= num.size(); i++) {
            fact[i] = (1ll * i * fact[i - 1]) % MOD;
            ifact[i] = expo(fact[i], MOD - 2);
        }
                        
        vector<vector<vector<int>>>dp(10, vector<vector<int>>(num.size() / 2 + 1, vector<int>(sum + 1, -1)));
        
        int permutationsCount = (1ll * fact[num.size() / 2] * fact[(num.size() + 1) / 2]) % MOD;
        
        auto f = [&](int number, int taken, int currentSum, auto &&self) -> int {            
            if(number == 10) {
                return (currentSum == sum / 2 && taken == num.size() / 2 ? permutationsCount : 0);
            }
            
            if(dp[number][taken][currentSum] != -1) return dp[number][taken][currentSum];
            
            int ways = 0;
            
            for(int i = 0; i <= min(fr[number], (int) num.size() / 2 - taken); i++) {
                ways = (ways + (1ll * (1ll * ifact[i] * ifact[fr[number] - i]) % MOD * self(number + 1, taken + i, currentSum + i * number, self)) % MOD) % MOD;
            }
            
            return dp[number][taken][currentSum] = ways;
        };
        
        return f(0, 0, 0, f);
    }
};",1441379576
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue

                new_cost = max(c, moveTime[x][y]) + 1
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441295323
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue
                extra_cost = 0 if (x + y) & 1 else 1
                new_cost = max(c, moveTime[x][y]) + 1 + extra_cost
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441307109
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0

        for i in range(len(num)):
            if i & 1:
                odd += (ord(num[i]) - ord('0'))
            else:
                even += (ord(num[i]) - ord('0'))
        return odd == even",1441281363
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits_freq = [0] * 10
        for c in num:
            digits_freq[ord(c) - ord('0')] += 1
        s = 0
        for i in range(10):
            s += i * digits_freq[i]

        if s & 1:
            return 0

        MOD = 10**9 + 7
        
        @lru_cache(None)
        def c(n, k): 
            if k == 0:
                return 1
            if n == k:
                return 1
            else:
                return (c(n-1, k-1) + c(n-1, k)) % MOD

        @lru_cache(None)
        def dp(d, diff, n_even, n_odd):
            if n_even < 0 or n_odd < 0:
                return 0

            if d == -1:
                return 1 if diff == 0 else 0

            res = 0
            for e in range(digits_freq[d] + 1):
                remain_even = n_even-e
                remain_odd = n_odd-(digits_freq[d]-e)
                if remain_even < 0 or remain_odd < 0:
                    continue

                temp = dp(d-1, diff + e*d - (digits_freq[d]-e)*d, remain_even, remain_odd)
                temp = (temp * c(n_even, e) * c(n_odd, digits_freq[d]-e)) % MOD
                res = (res + temp) % MOD
            return res
            
        return dp(9, 0, (len(num) + 1) // 2, len(num) // 2)",1441385680
Anuj Anand,coleworld223,206,3627,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 1};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312661
Anuj Anand,coleworld223,206,3628,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 2};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312149
Anuj Anand,coleworld223,206,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      array <int, 2> c = {0, 0};
      for (int i = 0; i < num.size(); ++i) {
        c[i % 2] += (num[i] - '0');
      }
      return c[0] == c[1];
    }
};",1441282080
Anuj Anand,coleworld223,206,3637,cpp,"int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

struct fact {
  mi fac[1000];
  mi ifac[1000];
  fact() {
    fac[0] = ifac[0] = 1;
    for (int i = 1; i < 1000; ++i) {
      fac[i] = fac[i - 1] * i;
      ifac[i] = inv(fac[i]);
    }
  }
};

fact F;
mi C(int n, int r) {
  if (n <= 0 or r > n) { return (mi)0; }
  return F.fac[n] * F.ifac[r] * F.ifac[n - r];
}

mi dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(string num) {
      int n = num.size();
      for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 81; ++j) {
          for (int k = 0; k < 801; k++) {
            dp[i][j][k] = 0;
          }
        }
      }
      vector <int> cnt (10);
      int T = 0;
      for (char x : num) {
        cnt[x - '0'] += 1;
        T += (x - '0');
      }
      
      if (T % 2) { return 0; }
      T /= 2;
      
      for (int x = 0; x <= cnt[0]; x++) {
        dp[0][x][0] += 1 * F.ifac[x] * F.ifac[cnt[0] - x];
      }
      for (int i = 0; i < 9; ++i) {
        int nxt = i + 1;
        int tot = cnt[i + 1];
        int cur_tot = cnt[i];
        for (int take = 0; take <= 80; take++) {
          for (int sum = 0; sum <= 800; sum++) {
            if (dp[i][take][sum] == 0) { continue; }
            for (int x = 0; x <= tot; x++) {
              int ntake = take + x;
              int nsum = sum + x * (i + 1);
              if (nsum <= 800 and ntake <= 80) dp[i + 1][ntake][nsum] += dp[i][take][sum] * F.ifac[x] * F.ifac[tot - x];
            }
          }
        }
      }
      
      // cout << dp[2][2][3] << '\n';
      // cout << dp[3][2][3] << '\n';
      int siz = n / 2;
      // cout << siz << ' ';
      // cout << T << '\n';
      // cout << dp[9][siz][T] << '\n';
      mi ans = dp[9][siz][T] * F.fac[siz] * F.fac[n - siz];
      return ans.v;
    }
};",1441367561
Vivan,Vivan_geekfreak,207,3627,java,"import java.util.*;
class Solution 
{
    public int minTimeToReach(int[][] moveTime)
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var dist = new int[n][m];
        int i = 0;
        if(n>0)
            do
            {
                Arrays.fill(dist[i], Integer.MAX_VALUE);
                i++;
            } 
            while (i < n);
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for(;!pq.isEmpty();)
        {
            var curr = pq.poll();
            var time = curr[0];
            var row = curr[1];
            var col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0; 
            do 
            {
                var dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
            while (dirIndex < dirs.length);
        }
        return dist[n - 1][m - 1];
    }
}
",1441366743
Vivan,Vivan_geekfreak,207,3628,java,"import java.util.*;

class Solution 
{
    public int minTimeToReach(int[][] moveTime) 
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var d = new int[n][m][2];
        int i = 0;
        do 
        {
            int j = 0;
            do 
            {
                d[i][j][0] = Integer.MAX_VALUE;
                d[i][j][1] = Integer.MAX_VALUE;
                j++;
            } 
            while (j < m);
            i++;
        } 
        while (i < n);
        d[0][0][0] = 0;
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0});
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for(;(!(!pq.isEmpty())==false);)
        {
            var current = pq.poll();
            var t = current[0];
            var iCur = current[1];
            var jCur = current[2];
            var p = current[3];

            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            int dirIndex = 0;
            do 
            {
                var dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.offer(new int[]{nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            } 
            while (dirIndex < directions.length);
        }

        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441332797
Vivan,Vivan_geekfreak,207,3636,java,"class Solution 
{
    public boolean isBalanced(String num) 
    {
        int evenSum = 0;
        int oddSum = 0;
        int i=0;
        if(num.length()>0)
            do
            {
                int digit = num.charAt(i) - '0'; 
                if (!(i % 2 == 0) == false)
                    evenSum += digit;
                else
                    oddSum += digit;
                i++;
            }
            while(i<num.length());
        return evenSum == oddSum;
    }
}
",1441292613
Vivan,Vivan_geekfreak,207,3637,java,"import java.util.*;
class Solution
{
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;
    private long powerMod(long a, long b) 
    {
        long res = 1;
        a %= MOD;
        while (b > 0) 
        {
            if (!((b & 1) == 1) ==false)
                res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }
    private void initFact(int n) 
    {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        int i = 1;
        do 
        {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do 
        {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        }
        while (j >= 0);
    }
    public int countBalancedPermutations(String num) 
    {
        var n = num.length();
        var freq = new int[10];
        long totalSum = 0;
        var C=Arrays.copyOfRange(num.toCharArray(), 0, n);
        int i=0;
        if(n>0)
            do
            {
                char c=C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            }
            while(i<n);

        if (!(totalSum % 2 != 0) ==false)
            return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        var dp = new long[k + 1][(int) sumHalf + 1];
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0)==false)
            {
                d++;
                continue;
            }
            int c = k;
            do 
            {
                long s = sumHalf;
                do 
                {
                    if (!(dp[c][(int) s] == 0)==false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    do 
                    {
                        if (!(t > Math.min(freq[d], k - c)) ==false)
                            break;
                        if (!(s + (long) d * t > sumHalf)==false)
                            break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                        t++;
                    } 
                    while (true);
                    s--;
                } 
                while (s >= 0);
                c--;
            } 
            while (c >= 0);
            d++;
        } 
        while (d <= 9); 

        long validAssignments = dp[k][(int) sumHalf];
        if (!(validAssignments == 0) == false)
            return 0;
        long prodFactFd = 1;
        int digit=0;
        do 
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        while(digit <= 9);
        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int) answer;
    }
}
",1441392291
Fasdr,Fasdr,208,3627,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][] time = new int[n][m];
        int max = Integer.MAX_VALUE;
        for (int row[] : time) {
            Arrays.fill(row, max);
        }
        // t, i, j
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2];
            if (time[i][j] <= t) {
                continue;
            }
            time[i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int nt = Math.max(moveTime[ni][nj] + 1, t + 1);
                frontier.add(new int[] {nt, ni, nj});
            }
        }
        
        return time[n - 1][m - 1];
    }
}",1441297738
Fasdr,Fasdr,208,3628,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][][] time = new int[2][n][m];
        int max = Integer.MAX_VALUE;
        for (int[][] table : time) {
            for (int[] row : table) {
                Arrays.fill(row, max);
            }
        }
        // t, i, j, a
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2], a = cur[3];
            if (time[a][i][j] <= t) {
                continue;
            }
            time[a][i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int extra = (a == 0) ? 1 : 2;
                int nt = Math.max(moveTime[ni][nj], t) + extra;
                frontier.add(new int[] {nt, ni, nj, 1 - a});
            }
        }
        
        return Math.min(time[0][n - 1][m - 1], time[1][n - 1][m - 1]);
    }
}",1441306270
Fasdr,Fasdr,208,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int odd = 0, even = 0;
        for (int i = 0; i < n; i += 2) {
            even += (num.charAt(i) - '0');
        }
        for (int i = 1; i < n; i += 2) {
            odd += (num.charAt(i) - '0');
        }
        return even == odd;
    }
}",1441282457
Fasdr,Fasdr,208,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        int[] qty = new int[10];
        long mod = 1_000_000_007;
        int n = num.length();
        int total = 0;
        for (char chr : num.toCharArray()) {
            total += chr - '0';
        }
        if (total == 0) {
            total = 1;
        }
        total = 2 * total;
        long[][] dp = new long[total + 1][2 * n + 1];
        dp[total / 2][n] = 1;
        for (char chr : num.toCharArray()) {
            int digit = chr - '0';
            qty[digit]++;
            long[][] newDp = new long[total + 1][2 * n + 1];
            for (int sum = 0; sum < total + 1; sum++) {
                for (int cnt = 0; cnt < 2 * n + 1; cnt++) {
                    if (dp[sum][cnt] == 0) {
                        continue;
                    }
                    // add to even
                    newDp[sum + digit][cnt + 1] = (newDp[sum + digit][cnt + 1] + dp[sum][cnt]) % mod;
                    // add to odd
                    newDp[sum - digit][cnt - 1] = (newDp[sum - digit][cnt - 1] + dp[sum][cnt]) % mod;
                }
            }
            dp = newDp;
        }
        
        long res = n % 2 == 0? dp[total / 2][n] : dp[total / 2][n + 1];
        int half = n / 2;
        for (int i = 1; i <= half; i++) {
            res = (res * i * i) % mod;
        }
        
        if (n % 2 != 0) {
            res = (res * (half + 1)) % mod;
        }
        
        for (int digitQty : qty) {
            for (int i = 2; i <= digitQty; i++) {
                res = (res * modInv(i, mod)) % mod;
            }
        }
        
        return (int) res;
    }
    
    private long modInv(long num, long mod) {
        return pow(num, mod - 2, mod);
    }
    
    private long pow(long base, long exp, long mod) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp = exp >> 1;
        }
        
        return res;
    }
    
}",1441367839
Gautam Ankoji,gautamankoji,209,3627,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        v = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        q = [(0, 0, 0)]
        while q:
            t, i, j = heapq.heappop(q)
            if t > d[i][j]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + 1
                    if d[ni][nj] > nt:
                        d[ni][nj] = nt
                        heapq.heappush(q, (nt, ni, nj))
        res = d[n - 1][m - 1]
        return d[n - 1][m - 1]",1441323814
Gautam Ankoji,gautamankoji,209,3628,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0
        v = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        q = [(0, 0, 0, 0)]
        while q:
            t, i, j, p = heapq.heappop(q)
            if t > d[i][j][p]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + (2 if p else 1)
                    if d[ni][nj][1 - p] > nt:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(q, (nt, ni, nj, 1 - p))
        res = min(d[n - 1][m - 1])
        return res",1441327957
Gautam Ankoji,gautamankoji,209,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res1, res2 = 0, 0
        for i, d in enumerate(num):
            if i % 2 != 0:
                res2 += int(d)
            else:
                res1 += int(d)
        return res1 == res2
",1441291369
Gautam Ankoji,gautamankoji,209,3637,python3,"MOD = 1_000_000_007

class Solution:
    def power(self, base: int, exp: int, mod: int) -> int:
        res = 1
        base %= mod
        while exp:
            if exp & 1:
                res = res * base % mod
            base = base * base % mod
            exp >>= 1
        return res
    
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        e, O = (n + 1) // 2, n // 2
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1
        tot_sum = sum(d * cnt[d] for d in range(10))
        if tot_sum % 2: return 0
        t_sum = tot_sum // 2
        max_val = 80
        fact = [1] * (max_val + 1)
        for i in range(1, max_val + 1):
            fact[i] = fact[i - 1] * i % MOD
        not_fact = [1] * (max_val + 1)
        not_fact[max_val] = self.power(fact[max_val], MOD - 2, MOD)
        for i in range(max_val - 1, -1, -1):
            not_fact[i] = not_fact[i + 1] * (i + 1) % MOD
        def comb(n: int, k: int) -> int:
            return (fact[n] * not_fact[k] % MOD * not_fact[n - k] % MOD) if k <= n else 0
        dp = [[0] * (t_sum + 1) for _ in range(e + 1)]
        dp[0][0] = 1
        for d in range(10):
            if not cnt[d]: continue
            for t in range(e, -1, -1):
                for s in range(t_sum, -1, -1):
                    if dp[t][s]:
                        for k in range(1, cnt[d] + 1):
                            if t + k <= e and s + d * k <= t_sum:
                                dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD
        p_cnt = 1
        for d in range(10):
            p_cnt = p_cnt * fact[cnt[d]] % MOD
        ans = (dp[e][t_sum] * fact[e] % MOD * fact[O] % MOD * self.power(p_cnt, MOD - 2, MOD)) % MOD
        return ans
",1441386398
Nguyễn Minh,minhnguyenxuan60,210,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<vector<int>> dp(n, vector<int>(m, 1e9 + 1e8));
        dp[0][0] = 0;

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        for (int k = 0; k < n * m; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    for (int r = 0; r < 4; r++) {
                        int i1 = i + diri[r], j1 = j + dirj[r];
                        if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                        dp[i1][j1] = min(dp[i1][j1], dp[i][j] + 1);
                        if (i1 != 0 || j1 != 0) dp[i1][j1] = max(dp[i1][j1], moveTime[i1][j1] + 1);
                    }
                }
            }
        }

        return dp[n - 1][m - 1];
    }
};",1441297906
Nguyễn Minh,minhnguyenxuan60,210,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> q;
        q.push({{0, 1}, {0, 0}});

        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        vector<vector<bool>> vis(n, vector<bool>(m));
        while(!q.empty()) {
            int u = q.top().first.first, t = q.top().first.second, i = q.top().second.first, j = q.top().second.second;
            q.pop();
            if (vis[i][j]) continue;
            vis[i][j] = true;
            if (i == n - 1 && j == m - 1) {
                return max(u, moveTime[i][j] + 1);
            }

            for (int k = 0; k < 4; k++) {
                int i1 = i + diri[k], j1 = j + dirj[k];
                if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                q.push({{max(u, moveTime[i1][j1]) + t, 3 - t}, {i1, j1}});
            }
        }
        return 0;
    }
};",1441313182
Nguyễn Minh,minhnguyenxuan60,210,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281260
Nguyễn Minh,minhnguyenxuan60,210,3637,cpp,"class Solution {
public:

    const int mod = 1e9 + 7;
    int countBalancedPermutations(string num) {
        vector<vector<int64_t>> c(100, vector<int64_t> (100, 0));
        for (int i = 0; i < 100; i++) c[i][0] = 1;
        for (int i = 1; i < 100; i++) {
            for (int j = i; j < 100; j++) {
                c[j][i] = (c[j - 1][i] + c[j - 1][i - 1]) % mod;
            }
        }

        // for (int i = 0; i <= 10; i++) {
        //     for (int j = 0; j <= 10; j++) cout << c[i][j] << "" "";
        //     cout << '\n';
        // }

        vector<int> cnt(10);
        int total = 0;
        for (char c: num) {
            cnt[c - '0']++;
            total += c - '0';
        }

        if (total % 2) return 0;
        total /= 2;

        int len = num.size() / 2;

        vector<vector<int64_t>> dp(len + 1, vector<int64_t>(total + 1, 0));

        dp[0][0] = 1;
        int curNum = 0;
        
        for (int num = 0; num < 10; num++) {
            vector<vector<int64_t>> tmp(len + 1, vector<int64_t>(total + 1, 0));
            for (int l = 0; l <= curNum; l++) {
                for (int sum = 0; sum <= total; sum++) {
                    for (int used = 0; used <= cnt[num]; used++) {
                        int numLeft = l + used, numRight = curNum - l + cnt[num] - used;
                        if (sum + num * used > total || numLeft > len) break;
                        tmp[numLeft][sum + num * used] += dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod;
                        // if (dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod > 1) {
                        //     // cout << numLeft << "" "" << used << "" "" << numRight << "" "" << cnt[num] - used << "" "" << dp[l][sum] << '\n';
                        //     // cout << l << "" "" << sum << "" "" << num << "" "" << '\n';
                        //     cout << dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod << '\n';
                        // }
                        tmp[numLeft][sum + num * used] %= mod;
                    }
                }
            }
            swap(tmp, dp);
            curNum += cnt[num];
        }

        // for (int i = 0; i <= len; i++) {
        //     for (int sum = 0; sum <= total; sum++) {
        //         cout << dp[i][sum] << "" "";
        //     }
        //     cout << '\n';
        // }

        return dp[len][total];

        

        return 0;
    }
};",1441368456
user3013OR,user3013OR,211,3627,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c = h[0]
            heappop(h)
            if (r,c) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            seen[(r,c)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+1
                heappush(h,(nt,r-1,c))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+1
                heappush(h,(nt,r+1,c))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+1
                heappush(h,(nt,r,c-1))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+1
                heappush(h,(nt,r,c+1))
            
        ",1441293940
user3013OR,user3013OR,211,3628,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
        
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c,s = h[0]
            heappop(h)
            if (r,c,s) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            ns = 1-s
            mv = 1+s
            seen[(r,c,s)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+mv
                heappush(h,(nt,r-1,c,ns))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+mv
                heappush(h,(nt,r+1,c,ns))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+mv
                heappush(h,(nt,r,c-1,ns))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+mv
                heappush(h,(nt,r,c+1,ns))",1441297026
user3013OR,user3013OR,211,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        sign = 1
        for c in num:
            val = int(c)
            s += sign * val
            sign = -sign
        return s==0
        ",1441282298
user3013OR,user3013OR,211,3637,python3,"class Solution:
    def helper(self,n,mod):
        even_n = n//2
        odd_n = n-even_n

        res = (self.fact[even_n]*self.fact[odd_n])%mod
        for i in range(10):
            res = (res*(self.inverse[self.temp[i]]))%mod
            res = (res*(self.inverse[self.cnt[i]-self.temp[i]]))%mod
        self.ans+=res
        self.ans%=mod
        return
        
    def inv(self,a,mod):
        return self.power(a,mod-2,mod)
    def power(self,a,p,mod):
        if p==0:
            return 1
        elif p==1:
            return a
        else:
            res = self.power(a,p//2,mod)
            ans = (res*res)%mod
            if p%2==1:
                ans = (ans*a)%mod
            return ans
    def dfs(self,ind,ts,tn,cs,cn,mod):
        if ind==10:
            if ts == cs*2 and cn == tn//2:
                self.helper(tn,mod)
            return
        if cs>ts//2:
            return
        if cn>tn//2:
            return
        if (tn//2-cn)*9+cs<ts//2:
            return
        for i in range(self.cnt[ind]+1):
            self.temp[ind]=i
            self.dfs(ind+1,ts,tn,cs+i*ind,cn+i,mod)
    def comb(self,a,b,mod):
        ans = self.fact[a]*self.inverse[b]*self.inverse[a-b]
        return ans%mod
    def countBalancedPermutations(self, num: str) -> int:
        self.cnt = [0 for i in range(10)]
        s = 0
        n = len(num)
        #print (n)
        for c in num:
            val = int(c)
            self.cnt[val]+=1
            s+=val
        if s%2==1:
            return 0
        self.fact = [1 for i in range(n+1)]
        self.inverse = [1 for i in range(n+1)]
        mod = int(1e9+7)
        for i in range(n):
            self.fact[i+1]=(self.fact[i]*(i+1))%mod
            self.inverse[i+1]=self.inv(self.fact[i+1],mod)
        self.ans = 0
        self.temp = [0 for i in range(10)]
        self.presum = [[] for i in range(10)]
        for i in range(10):
            base = 0
            for j in range(9,i,-1):
                for _ in range(self.cnt[j]):
                    base+=j
                    self.presum[i].append(base)
        #self.dfs(0,s,n,0,0,mod)
        dp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
        dp[0][0]=1
        ts = 0
        tn = 0
        for ind in range(10):

            temp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
            for n1 in range(n//2+1):
                for s1 in range(s//2+1):
                    n2 = tn - n1
                    s2 = ts - s1
                    if dp[n1][s1]==0:
                        continue
                    for i in range(self.cnt[ind]+1):
                        if n1+i<=n//2 and n2+self.cnt[ind]-i <= n-n//2 and s1+ind*i<=s//2 and s2+ind*(self.cnt[ind]-i) <= s//2:
                            temp[n1+i][s1+ind*i] += dp[n1][s1] * self.comb(n//2-n1,i,mod) * self.comb(n-n//2-n2,self.cnt[ind]-i,mod)
                            temp[n1+i][s1+ind*i] %=mod
            dp = temp
            ts += self.cnt[ind]*ind
            tn += self.cnt[ind]
            
                                    
        return dp[n//2][s//2]",1441362085
Ivan_len,Ivan_len,212,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
        pq.push({0, 0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            if (dp[cur[1]][cur[2]] <= cur[0]) continue;
            dp[cur[1]][cur[2]] = cur[0];
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = cur[1] + dx;
                int new_y = cur[2] + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur[0], moveTime[new_x][new_y]);
                    pq.push({t + 1, new_x, new_y});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441297432
Ivan_len,Ivan_len,212,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.push({0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            int X = cur.second / m;
            int Y = cur.second % m;
            if (dp[X][Y] <= cur.first) continue;
            dp[X][Y] = cur.first;
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = X + dx;
                int new_y = Y + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur.first, moveTime[new_x][new_y]);
                    if (((new_x + new_y) & 1) && t + 1 < dp[new_x][new_y]) {
                        pq.push({t + 1, new_x * m + new_y});
                    }
                    if (((new_x + new_y) % 2 == 0) && t + 2 < dp[new_x][new_y]) {
                        pq.push({t + 2, new_x * m + new_y});
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441303354
Ivan_len,Ivan_len,212,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0;
        int i = 0;
        for (auto c : num) {
            int cnt = (int)(c - '0');
            if (i & 1) a += cnt;
            else a -= cnt;
            i++;
        }
        return a == 0;
    }
};",1441281416
Ivan_len,Ivan_len,212,3637,cpp,"template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
}
 
template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;
 
    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }
 
    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }
 
    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }
 
    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }
 
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }
 
    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }
 
    friend const Type& abs(const Modular& x) { return x.value; }
 
    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);
 
private:
    Type value;
};
 
template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
 
template<typename T, typename U>
Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}
 
template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/
 
constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
 
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<int> cnt(10);
        for (auto c : num) cnt[(int)(c - '0')]++;
        int n = num.size();
        const int shift = ((n + 1) / 2) * 9;
        vector<vector<Mint>> d((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1)), f;
        d[0][shift] = 1; 
        int acc = 0;
        int up = 0, lo = 0;
        for (int i = 0; i <= 9; i++) {
            f.clear();
            f.resize((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1));
            acc += cnt[i];
            for (int even = 0; even <= (n + 1) / 2; even++) {
                for (int ceven = 0; ceven <= even; ceven++) {
                    int codd = cnt[i] - ceven;
                    int odd = acc - even - cnt[i] + ceven;
                    if (codd < 0) break;
                    if (odd > n / 2) break;
                    if (codd > n / 2) continue;
                    if (odd < 0) continue;
                    // even - odd
                    for (int sum = max(-shift, -(i * (n + 1) / 2)); sum <= min(shift, i * (n + 1) / 2); sum++) {
                        int pre = sum - (ceven - codd) * i;
                        if (pre < -shift) continue;
                        if (pre > shift) break;
                        f[even][sum + shift] += d[even - ceven][pre + shift] * C((n + 1) / 2 - (even - ceven), ceven) * C(n / 2 - odd, codd);
                    }
                }
            }
            swap(d, f);
        }
        Mint ans = 0;
        for (int even = 0; even <= ((n + 1) / 2); even++) ans += d[even][shift];
        return (int)ans;
    }
};",1441362584
I_have_learn,I_have_learn,213,3627,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0); 

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();
            if (r == n - 1 && c == m - 1) return currTime;

            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = 1;
                ll newCost = currTime + waitTime + cost;

                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag); 
                }
            }
        }

        return -1;
    }
};
",1441320973
I_have_learn,I_have_learn,213,3628,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        // Min-heap to store (currentTime, row, col, flag)
        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0);  // Start from (0, 0) at time t = 0 with flag = false

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();

            // If we reached the target cell, return the minimum time
            if (r == n - 1 && c == m - 1) return currTime;

            // Visit adjacent cells
            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;

                // Calculate wait time to ensure that we can enter the room
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = flag ? 2 : 1;
                ll newCost = currTime + waitTime + cost;

                // Update if a cheaper path is found
                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag);  // Toggle flag for the next move
                }
            }
        }

        return -1;  // Return -1 if unreachable
    }
};
",1441319656
I_have_learn,I_have_learn,213,3636,cpp,"class Solution {
public:
    bool isBalanced(string nums) {
        int sum1=0,sum2=0;

        for(int i=0;i<nums.size();i+=2) sum1+=nums[i]-'0';

        for(int i=1;i<nums.size();i+=2) sum2+=nums[i]-'0';
        return sum1==sum2;
    }
};",1441284219
I_have_learn,I_have_learn,213,3637,cpp,"#define MOD 1000000007
typedef long long ll;

ll fact[81];
ll inv_fact[81];

ll power_mod(ll x, ll y) {
    ll res = 1;
    x %= MOD;
    while (y > 0) {
        if (y & 1LL) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        y >>= 1LL;
    }
    return res;
}

// Precompute factorials and modular inverses
void compute_factorials() {
    fact[0] = 1;
    for (int i = 1; i <= 80; i++) fact[i] = fact[i - 1] * i % MOD;
    inv_fact[80] = power_mod(fact[80], MOD - 2);
    for (int i = 79; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

// Function to compute C(n, k) % MOD
ll comb(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
}

class Solution {
public:
    ll countBalancedPermutations(string num) {
        compute_factorials();
        
        unordered_map<char, int> freq;
        ll total_sum = 0;
        for (char c : num) {
            freq[c]++;
            total_sum += (c - '0');
        }

        if (total_sum % 2 != 0) return 0;  // Odd total sum means no balanced partition possible
        
        ll target_sum = total_sum / 2;
        int n = num.size();
        int num_even = (n + 1) / 2;
        
        vector<vector<ll>> dp(num_even + 1, vector<ll>(target_sum + 1, 0));
        dp[0][0] = 1;

        for (auto &[digit, count] : freq) {
            int d = digit - '0';
            for (int k = num_even; k >= 0; --k) {
                for (int s = target_sum; s >= 0; --s) {
                    for (int t = 1; t <= count && k + t <= num_even && s + t * d <= target_sum; ++t) {
                        dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb(count, t) % MOD) % MOD;
                    }
                }
            }
        }

        ll C_t = dp[num_even][target_sum];
        if (C_t == 0) return 0;

        ll fact_even = fact[num_even];
        ll fact_odd = fact[n - num_even];
        
        ll denominator = 1;
        for (auto &[digit, f] : freq) {
            denominator = denominator * fact[f] % MOD;
        }
        
        ll result = C_t * fact_even % MOD * fact_odd % MOD * power_mod(denominator, MOD - 2) % MOD;
        return result;
    }
};
",1441356696
nghia0510,phantrongnghia510,214,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[float(""inf"") for _ in range(m)] for _ in range(n)]
        d[0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0)]

        while queue:
            t, i, j = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + 1
                    if nt < d[ni][nj]:
                        d[ni][nj] = nt
                        heappush(queue, (nt, ni, nj))
        return -1
        ",1441316415
nghia0510,phantrongnghia510,214,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[[float(""inf"") ] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0, 0)]

        while queue:
            t, i, j, c = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j][c]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + (1 if not c else 2)
                    nc = c ^ 1
                    if nt < d[ni][nj][nc]:
                        d[ni][nj][nc] = nt
                        heappush(queue, (nt, ni, nj, nc))
        return -1
        ",1441312545
nghia0510,phantrongnghia510,214,3636,python,"class Solution(object):
    def isBalanced(self, num):
        even, odd = 0, 0
    
        for i in range(len(num)):
          if i % 2 == 0:
            even += int(num[i])
          else:
            odd += int(num[i])
    
        return even == odd",1441285916
nghia0510,phantrongnghia510,214,3637,python3,"from collections import Counter
import math

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        count = Counter(num)
        c = [0] * 10
        for d in range(10): 
            c[d] = count.get(chr(d + ord(""0"")), 0)
        total = sum(c[d] * d for d in range(10))
        if total % 2 != 0:
            return 0
        n = len(num)
        H, K  = total // 2, (n + 1) // 2
        dp0 = [[0] * (H + 1) for _ in range(K + 1)]
        dp0[0][0] = 1

        for d in range(10):
            if c[d] == 0:
                continue
            dp1 = [[0] * (H + 1) for _ in range(K + 1)]
            for k in range(K + 1):
                for h in range(H + 1):
                    if dp0[k][h] == 0:
                        continue
                    max_d = min(c[d], K - k)
                    if d > 0:
                        max_d = min(max_d, (H - h) // d)
                    for u in range(max_d + 1):
                        new_k = k + u
                        new_h = h + d * u
                        if new_k > K or new_h > H:
                            continue
                        ways = math.comb(c[d], u)
                        dp1[new_k][new_h] = (dp1[new_k][new_h] + dp0[k][h] * ways) % MOD
            dp0 = dp1

        if dp0[K][H] == 0:
            return 0

        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = (fact[i - 1] * i) % MOD

        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

        prod_inv = 1
        for i in range(10):
            prod_inv = (prod_inv * inv_fact[c[i]]) % MOD

        
        res = dp0[K][H]
        res = (res * fact[K]) % MOD
        res = (res * fact[n - K]) % MOD
        res = (res * prod_inv) % MOD

        return res
",1441394228
hcseo,hcseo,215,3627,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 2;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(1, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return dp[0][n-1][m-1];
    }
};",1441302021
hcseo,hcseo,215,3628,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 3;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(2, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return min(dp[0][n-1][m-1], dp[1][n-1][m-1]);
    }
};",1441300575
hcseo,hcseo,215,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<num.size(); ++i){
            if(i%2==0){
                sum1 += num[i]-'0';
            }else{
                sum2 += num[i]-'0';
            }
        }
        return sum1==sum2;
    }
};",1441281165
hcseo,hcseo,215,3637,cpp,"#define MOD 1000000007

int n;
long long nCr[81][81];

class Solution {
public:
    int countBalancedPermutations(string num) {
        nCr[0][0] = 1;
        for(int i=1; i<81; ++i){
            nCr[i][0] = 1;
            nCr[i][i] = 1;
            for(int j=1; j<i; ++j) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;
        }
        int totalSum = 0;
        n = num.size();
        vector<int> cnt(10);
        for(int i=0; i<n; ++i) {
            totalSum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        if(totalSum%2==1) return 0;
        vector<long long> tmp(totalSum/2+1);
        vector<vector<long long>> dp(n/2+1, tmp); // countOfGroup1 / sumOfGroup1
        dp[0][0] = 1;
        int done = 0;
        int doneSum = 0;
        for(int i=0; i<10; ++i){
            if(cnt[i]==0) continue;
            vector<vector<long long>> dpNext(n/2+1, tmp);
            for(int countOfGroup1 = 0; countOfGroup1<=n/2; ++countOfGroup1){
                for(int sumOfGroup1=0; sumOfGroup1<=totalSum/2; sumOfGroup1++){
                    if(dp[countOfGroup1][sumOfGroup1]==0) continue;
                    int countOfGroup2 = done - countOfGroup1;
                    int sumOfGroup2 = doneSum - sumOfGroup1;
                    for(int j=0; j<=cnt[i]; ++j){
                        int nextSumOfGroup1 = sumOfGroup1+j*i;
                        int nextCountOfGroup1 = countOfGroup1+j;

                        int nextCountOfGroup2 = countOfGroup2 + (cnt[i]-j);
                        int nextSumOfGroup2 = sumOfGroup2 + (cnt[i]-j)*i;

                        if(nextSumOfGroup1>totalSum/2 || nextCountOfGroup1>(n/2) || nextSumOfGroup2> totalSum/2 || nextCountOfGroup2>(n+1)/2) continue;
                        int remainSeats1 = n/2-countOfGroup1;
                        int remainSeats2 = (n+1)/2-countOfGroup2;
                        long long nowWays = (nCr[remainSeats1][j] * nCr[remainSeats2][cnt[i]-j])%MOD;
                        nowWays = (nowWays*dp[countOfGroup1][sumOfGroup1])%MOD;
                        dpNext[nextCountOfGroup1][nextSumOfGroup1] = (dpNext[nextCountOfGroup1][nextSumOfGroup1] + nowWays)%MOD;
                    }
                }
            }
            done += cnt[i];
            doneSum += cnt[i]*i;
            dp = dpNext;
        }
        return dp[n/2][totalSum/2];
    }
};",1441388329
lukewu28,lukewu28,216,3627,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1, npos});
            }
        }
        
        return -1;
    }
};",1441300860
lukewu28,lukewu28,216,3628,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            
            int par = (i + j) % 2; 
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1 + par, npos});
            }
        }
        
        return -1;
    }
};",1441303488
lukewu28,lukewu28,216,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int r = 0;
        for(int i = 0 ; i < num.size(); i++){
            if(i % 2) r -= num[i] - '0';
            else r += num[i] - '0';
        }
        return r == 0;
    }
};",1441288436
lukewu28,lukewu28,216,3637,cpp,"typedef long long ll;
typedef pair<ll, ll> PII;
    const int MAXN = 80;

    const ll MOD = 1000000007;
class Solution {
public:
    ll fac[81], invfac[81];
    ll inv(ll x){return x>1?inv(MOD%x)*(MOD-MOD/x)%MOD:x;}
    void factorial() {
        fac[0] = 1;
        for (ll i = 1; i <= MAXN; i++) {
            fac[i] = fac[i - 1] * i % MOD;
        }
    }
    void inverses() {
        invfac[MAXN] = inv(fac[MAXN]);
        for (ll i = MAXN; i >= 1; i--) {
            invfac[i - 1] = invfac[i] * i % MOD;
        }
    }
    ll C(ll g, ll r) {
        return fac[g] * invfac[r] % MOD * invfac[g - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        int sum = 0;
        
        factorial();
        inverses();
        
        int freq[10] = {};
        for(int i : num) sum += i - '0', freq[i - '0']++;
        if(sum % 2) return 0;
        sum /= 2;
        
        int n = num.size() / 2;
        
        vector<vector<PII>> dp(n + 1, vector<PII>(sum + 1, {0, 0})), dp2(n + 1, vector<PII>(sum + 1, {0, 0}));
        for(int i = 0; i <= min(n, freq[0]); i++){
            dp2[n - i][sum].first = invfac[i] * invfac[freq[0] - i] % MOD;
        }
//         cout << 0 << endl;
//         for(int cnt = 0; cnt <= n; cnt++){
//                 for(int s = 0; s <= sum; s++){

//                     cout << cnt << ' ' << s << ' ' << dp2[cnt][s].first << ' '  << dp2[cnt][s].second << endl;
//                 }
//             }
        for(int i = 1; i < 10; i++){
            // cout << i << ' ' << freq[i] << endl;
            for(int cnt = 0; cnt <= n; cnt++){
                for(int s = 0; s <= sum; s++){
                    dp[cnt][s] = {0 , 0};
                    for(int k = 0; k <= freq[i]; k++){
                        if(s + k*i > sum || cnt + k > n) continue;
                        
                        ll curfac = invfac[k] * invfac[freq[i] - k] % MOD;
                        dp[cnt][s].first = (dp[cnt][s].first + (dp2[cnt + k][s + k*i].first * curfac % MOD) )% MOD;
                        // dp[cnt][s].second = (dp[cnt][s].second + (dp2[cnt + k][s + k*i].second *  % MOD) )% MOD;
                    }

                    // cout << cnt << ' ' << s << ' ' << dp[cnt][s].first << ' '  << dp[cnt][s].second << endl;
                }
            }
            swap(dp, dp2);
        }
        
        ll re = ((dp2[0][0].first * fac[n] % MOD) * fac[num.size() - n] % MOD) % MOD;
        return re;
    }
};",1441376281
vedantgore_2004,vedantgore_2004,217,3627,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<int,pair<int,int>> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({0,{0,0}});
        while(!q.empty()){
            ll t=q.top().first;
            ll x=q.top().second.first;
            ll y=q.top().second.second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+1;
                    if(vis[xx][yy]==-1)
                    q.push({tt,{xx,yy}});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441310976
vedantgore_2004,vedantgore_2004,217,3628,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<pair<int,pair<int,int>>,int> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({{0,{0,0}},1});
        while(!q.empty()){
            ll t=q.top().first.first;
            ll x=q.top().first.second.first;
            ll y=q.top().first.second.second;
            ll move=q.top().second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+move;
                    if(vis[xx][yy]==-1)
                    q.push({{tt,{xx,yy}},(move==1? 2:1)});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441317292
vedantgore_2004,vedantgore_2004,217,3636,cpp,"class Solution {
public:
    bool isBalanced(string a) {
        int x=0;
        int y=0;
        for(int i=0;i<a.size();i++){
            if(i&1){
                x+=a[i]-'0';
            }else y+=a[i]-'0';
        }
        return x==y;
    }
};",1441282073
vedantgore_2004,vedantgore_2004,217,3637,cpp,"class Solution {
public:
    typedef long long ll;
    const int mod = 1e9 + 7;
    ll fact[81], ifact[81];

    ll modPow(ll x, ll y, ll p) {
        ll res = 1;
        x %= p;
        while (y > 0) {
            if (y & 1)
                res = res * x % p;
            y >>= 1;
            x = x * x % p;
        }
        return res;
    }

    // Function to find modular inverse of b under MOD
    ll modInverse(ll b, ll mod) { return modPow(b, mod - 2, mod); }

    // Function to perform modular division a / b under MOD
    ll div(ll a, ll b, ll mod) { return (a * modInverse(b, mod)) % mod; }

    void precompute() {
        fact[0] = 1;
        for (ll i = 1; i <= 80; i++)
            fact[i] = fact[i - 1] * i % mod;
        for (ll i = 0; i <= 80; i++)
            ifact[i] = modPow(fact[i], mod - 2, mod);
    }

    ll func(ll ind, ll tk, ll sum, string& s, vector<vector<vector<ll>>>& dp) {
        ll n = s.size();
        if (ind == n) {
            return sum == 0 && tk == 0;
        }
        if (dp[ind][tk][sum] != -1)
            return dp[ind][tk][sum];
        ll i = s[ind] - '0';
        ll ways = func(ind + 1, tk, sum, s, dp);
        if (sum >= i && tk > 0) {
            ways = (ways + func(ind + 1, tk - 1, sum - i, s, dp)) % mod;
        }
        return dp[ind][tk][sum] = ways;
    }
    int countBalancedPermutations(string s) {
        ll n = s.size();
        ll sum = 0;
        map<ll, ll> fr;
        for (int i = 0; i < n; i++) {
            sum += (s[i] - '0');
            fr[s[i] - '0']++;
        }
        if (sum & 1)
            return 0;
        else
            sum /= 2;
        precompute();
        ll k = n / 2;
        ll rem = n - k;
        vector<vector<vector<ll>>> dp(
            n + 1, vector<vector<ll>>(k + 1, vector<ll>(sum + 1, -1)));
        ll ways = func(0, k, sum, s, dp);
        ways = (ways * fact[rem]) % mod;
        ways = (ways * fact[k]) % mod;
        // cout<<ways<<endl;
        for(int i=0;i<=9;i++){
            ll x=fr[i];
            if(x>1){
                ways=div(ways,fact[x],mod);
            }
        }
        return ways%mod;
    }
};",1441382415
Kashyap Sukshavasi,enkixly,218,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dungeonHeight = moveTime.size();
        int dungeonWidth = moveTime[0].size();
        
        int finalRoomX = dungeonHeight - 1;
        int finalRoomY = dungeonWidth - 1;
        
        vector<vector<int>> quickestPath(dungeonHeight, vector<int>(dungeonWidth, INT_MAX));
        
        queue<pair<int, pair<int, int>>> roomQueue;
        roomQueue.push({0, {0, 0}});
        quickestPath[0][0] = 0;
        
        vector<pair<int, int>> possibleMoves = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!roomQueue.empty()) {
            int timeSpent = roomQueue.front().first;
            int myX = roomQueue.front().second.first;
            int myY = roomQueue.front().second.second;
            roomQueue.pop();
            
            if (timeSpent > quickestPath[myX][myY]) continue;
            
            for (auto& nextMove : possibleMoves) {
                int nextX = myX + nextMove.first;
                int nextY = myY + nextMove.second;
                
                if (nextX >= 0 && nextX < dungeonHeight && nextY >= 0 && nextY < dungeonWidth) {
                    int timeToNext = max(timeSpent, moveTime[nextX][nextY]) + 1;
                    
                    if (timeToNext < quickestPath[nextX][nextY]) {
                        quickestPath[nextX][nextY] = timeToNext;
                        roomQueue.push({timeToNext, {nextX, nextY}});
                    }
                }
            }
        }
        
        return quickestPath[finalRoomX][finalRoomY];
    }
};",1441291465
Kashyap Sukshavasi,enkixly,218,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int height = moveTime.size();
        int width = moveTime[0].size();
        
        vector<vector<long long>> bestOddPath(height, vector<long long>(width, LLONG_MAX));
        vector<vector<long long>> bestEvenPath(height, vector<long long>(width, LLONG_MAX));
        
        priority_queue<pair<long long, tuple<int, int, int>>, 
                      vector<pair<long long, tuple<int, int, int>>>, 
                      greater<>> paths;
                      
        paths.push({0, {0, 0, 0}});
        bestEvenPath[0][0] = 0;
        
        int row[] = {-1, 0, 1, 0};
        int col[] = {0, 1, 0, -1};
        
        while (!paths.empty()) {
            auto [time, current] = paths.top();
            auto [x, y, steps] = current;
            paths.pop();
            
            if ((steps % 2 == 0 && time > bestEvenPath[x][y]) || 
                (steps % 2 == 1 && time > bestOddPath[x][y])) {
                continue;
            }
            
            if (x == height-1 && y == width-1) {
                return time;
            }
            
            for (int i = 0; i < 4; i++) {
                int nextX = x + row[i];
                int nextY = y + col[i];
                
                if (nextX < 0 || nextY < 0 || nextX >= height || nextY >= width) continue;
                
                long long nextTime = max(time, (long long)moveTime[nextX][nextY]) + (steps % 2 == 0 ? 1 : 2);
                bool isNextOdd = !bool(steps % 2);
                auto& bestPath = isNextOdd ? bestOddPath : bestEvenPath;
                
                if (nextTime < bestPath[nextX][nextY]) {
                    bestPath[nextX][nextY] = nextTime;
                    paths.push({nextTime, {nextX, nextY, steps + 1}});
                }
            }
        }
        
        return -1;
    }
};",1441296965
Kashyap Sukshavasi,enkixly,218,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for (int i = 0; i < num.size(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                even += digit;
            } else {
                odd += digit;
            }
        }
        return even == odd;
    }
};
",1441286920
Kashyap Sukshavasi,enkixly,218,3637,python3,"MOD = 1000000007

def powerModFunc(a, b):
    res = 1
    a %= MOD
    while b > 0:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def initFact(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invFact = [1] * (n + 1)
    invFact[n] = powerModFunc(fact[n], MOD - 2)
    for i in range(n - 1, -1, -1):
        invFact[i] = invFact[i + 1] * (i + 1) % MOD
    return fact, invFact

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        totalSum = 0
        
        for c in num:
            d = int(c)
            freq[d] += 1
            totalSum += d
        
        if totalSum % 2 != 0:
            return 0
        
        sumHalf = totalSum // 2
        k = (n + 1) // 2
        
        fact, invFact = initFact(n)
        
        dp = [[0] * (sumHalf + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d in range(10):
            if freq[d] == 0:
                continue
            for c in range(k, -1, -1):
                for s in range(sumHalf, -1, -1):
                    if dp[c][s] == 0:
                        continue
                    for t in range(1, min(freq[d], k - c) + 1):
                        if s + d * t > sumHalf:
                            break
                        comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD
        
        validAssignments = dp[k][sumHalf]
        if validAssignments == 0:
            return 0
        
        prodFactFd = 1
        for d in range(10):
            prodFactFd = prodFactFd * fact[freq[d]] % MOD
        
        fkFnk = (fact[k] * fact[n - k]) % MOD
        invProdFactFd = powerModFunc(prodFactFd, MOD - 2)
        answer = (fkFnk * validAssignments) % MOD
        answer = (answer * invProdFactFd) % MOD
        
        return answer
",1441382904
RONAK GARG,Ronak9910,219,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<tuple<long long, int, int>>> pq;
        pq.push({0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1);
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny});
                    }
                }
            }
        }
        return -1;
    }
};",1441303897
RONAK GARG,Ronak9910,219,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, greater<tuple<long long, int, int, int>>> pq;
        pq.push({0, 0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y, l] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1) + l;
                    bool m = 0;
                    if(l == 0)
                        m = 1;
                    else
                        m = 0;
                        
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny, m});
                    }
                }
            }
        }
        return -1;
    }
};",1441316741
RONAK GARG,Ronak9910,219,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < n; i++)
        {
            int val = num[i] - '0';
            if(i & 1)
                sum1 += val;
            else
                sum2 += val;
        }
        return (sum1 == sum2);
    }
};",1441283517
RONAK GARG,Ronak9910,219,3637,cpp,"class Solution {
private:
    long long modInv(long long a, int m) {
        long long res = 1, base = a, p = m - 2;
        while (p > 0) {
            if (p & 1) res = (res * base) % m;
            base = (base * base) % m;
            p >>= 1;
        }
        return res;
    }

    long long comb(int n, int k, const vector<long long>& fact, const vector<long long>& inv_fact) {
        if (k > n) return 0;
        return ((fact[n] * inv_fact[k]) % MOD * inv_fact[n - k]) % MOD;
    }

    static const int MOD = 1e9 + 7;

public:
    int countBalancedPermutations(const std::string& num) {
        int len = num.length();
        int total = 0;
        for(auto i : num)
                total += (i - '0');
        if (total % 2 != 0) return 0;

        int half = total / 2;
        int m = (len + 1) / 2;
        std::vector<int> cnt(10, 0);
        for (char d : num) cnt[d - '0']++;

        vector<long long> fact(len + 1, 1);
        for (int i = 1; i <= len; i++) fact[i] = (fact[i - 1] * i) % MOD;

        vector<long long> inv_fact(len + 1, 1);
        inv_fact[len] = modInv(fact[len], MOD);
        for (int i = len - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;

        vector<vector<long long>> dp(m + 1, vector<long long>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            for (int k = m; k >= 0; k--) {
                for (int s = half; s >= 0; s--) {
                    if (dp[k][s] == 0) continue;
                    for (int t = 1; t <= cnt[d]; t++) {
                        if (k + t > m || s + d * t > half) break;
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(cnt[d], t, fact, inv_fact)) % MOD;
                    }
                }
            }
        }

        long long w = dp[m][half];
        long long res = (fact[m] * fact[len - m]) % MOD;
        for (int d = 0; d < 10; d++) res = (res * inv_fact[cnt[d]]) % MOD;
        res = (res * w) % MOD;
        return (res);
    }
};
",1441383218
Sam Chen,SamChen856,220,3627,python3,"class Solution:
    # Dijkstra, priority queue, time O(nmlog(nm)), space O(nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]  # (current time, x, y)
        
        while pq:
            t, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + 1
                    if dist[nx][ny] > new_t:
                        dist[nx][ny] = new_t
                        heappush(pq, (new_t, nx, ny))

        assert False",1441304382
Sam Chen,SamChen856,220,3628,python3,"class Solution:
    # Dijkstra, priority queue, time O(2nmlog(nm)), space O(2nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[[inf] * m for _ in range(n)] for _ in range(3)]
        dist[1][0][0] = 0  # (speed, x, y)
        pq = [(0, 1, 0, 0)]  # (current time, speed, x, y)

        while pq:
            t, s, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[s][x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + s
                    new_s = 3 - s
                    if dist[new_s][nx][ny] > new_t:
                        dist[new_s][nx][ny] = new_t
                        heappush(pq, (new_t, new_s, nx, ny))

        assert False
        ",1441312485
Sam Chen,SamChen856,220,3636,python3,"class Solution:
    # 1 pass, time O(n), space O(1)
    def isBalanced(self, num: str) -> bool:
        sums = [0, 0]
        for i, x in enumerate(num):
            sums[i % 2] += int(x)
        return sums[0] == sums[1]",1441289057
Sam Chen,SamChen856,220,3637,python3,"M = 1000
MOD = 10**9 + 7

fact = [1] * (M + 1)
for i in range(M):
    fact[i + 1] = fact[i] * (i + 1) % MOD
inv_fact = [1] * (M + 1)
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for i in reversed(range(M)):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


class Solution:
    # DP + combinatorics, time O(100L^3), space O(10L^2), L = num.length
    def countBalancedPermutations(self, num: str) -> int:
        num = list(map(int, num))

        target_sum = sum(num)
        if target_sum % 2:
            return 0
        target_sum //= 2

        L = len(num)
        L_even = (L + 1) // 2
        cnt = Counter(num)
        dp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
        dp[0][0] = 1

        for d in range(10):
            ndp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
            for i in range(L_even + 1):
                for j in range(target_sum + 1):
                    if dp[i][j] == 0:
                        continue
                    for c in range(min(cnt[d], L_even - i) + 1):
                        ni, nj = i + c, j + d * c
                        if nj <= target_sum:
                            ndp[ni][nj] = (ndp[ni][nj] + dp[i][j] * inv_fact[c] * inv_fact[cnt[d] - c]) % MOD
            dp = ndp

        return fact[L_even] * fact[L - L_even] * dp[L_even][target_sum] % MOD",1441383568
Ayush Sharma,ayush-018,221,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        int r = moveTime.size();
        int c = moveTime[0].size();

        vector<vector<int>> minDist(r, vector<int>(c, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;

        minHeap.push({0, 0, 0}); // {time, row, col}
        minDist[0][0] = 0;

        vector<vector<int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!minHeap.empty()) {
            auto current = minHeap.top();
            minHeap.pop();
            int cT = current[0];
            int cR = current[1];
            int cC = current[2];

            if (cT > minDist[cR][cC]) continue;

            for (const auto& d : direction) {
                int newRow = cR + d[0];
                int newCol = cC + d[1];

                if (newRow >= 0 && newRow < r && newCol >= 0 && newCol < c) {
                    int newTime = max(cT, moveTime[newRow][newCol]) + 1;

                    if (newTime < minDist[newRow][newCol]) {
                        minDist[newRow][newCol] = newTime;
                        minHeap.push({newTime, newRow, newCol});
                    }
                }
            }
        }

        return minDist[r - 1][c - 1] == INT_MAX ? -1 : minDist[r - 1][c - 1];

    }
};",1441321399
Ayush Sharma,ayush-018,221,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<int>>> minTime(n, vector<vector<int>>(m, vector<int>(2, numeric_limits<int>::max())));
        minTime[0][0][0] = 0;

        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> gPq;
        gPq.push({0, {0, 0, 0}});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!gPq.empty()) {
            auto [currentTime, pos] = gPq.top();
            gPq.pop();
            int row = pos[0], col = pos[1], parity = pos[2];

            if (currentTime > minTime[row][col][parity]) continue;

            for (auto [dx, dy] : directions) {
                int x = row + dx;
                int y = col + dy;

                if (x >= 0 && x < n && y >= 0 && y < m) {
                    int nextTime = max(currentTime, moveTime[x][y]) + (parity == 0 ? 1 : 2);
                    
                    if (nextTime < minTime[x][y][1 - parity]) {
                        minTime[x][y][1 - parity] = nextTime;
                        gPq.push({nextTime, {x, y, 1 - parity}});
                    }
                }
            }
        }
        
        return min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
};",1441327061
Ayush Sharma,ayush-018,221,3636,cpp,"class Solution {
private:
    int calculateEven(const string& num) {
        int evenSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            }
        }
        return evenSum;
    }

    int calculateOdd(const string& num) {
        int oddSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 != 0) {
                oddSum += num[i] - '0';
            }
        }
        return oddSum;
    }
public:
    bool isBalanced(string num) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int evenSum = calculateEven(num);
        int oddSum = calculateOdd(num);
        if(evenSum==oddSum) return true;
        else return false;
    }
};",1441291164
Ayush Sharma,ayush-018,221,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int n = num.size();
        int evenC = (n + 1) / 2;
        int oddC = n / 2;

        string inputString = num;
        int digitCount[10] = {0};
        for (char digit : num) {
            digitCount[digit - '0']++;
        }

        long long totalSum = 0;
        for (int digit = 0; digit < 10; digit++) {
            totalSum += (long long)digit * digitCount[digit];
        }

        if (totalSum % 2 != 0) return 0;

        long long targetSum = totalSum / 2;
        vector<long long> factorial = preFact(80, MOD);
        vector<long long> invFact = ComputeFact(factorial, MOD);

        auto comb = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFact[k] % MOD * invFact[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenC + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int digit = 0; digit < 10; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int t = evenC; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int k = 1; k <= digitCount[digit] && t + k <= evenC && s + (long long)digit * k <= targetSum; k++) {
                        dp[t + k][s + (long long)digit * k] = (dp[t + k][s + (long long)digit * k] + dp[t][s] * comb(digitCount[digit], k)) % MOD;
                    }
                }
            }
        }

        long long validAssign = dp[evenC][targetSum];
        long long productFactorial = 1;
        for (int digit = 0; digit < 10; digit++) {
            productFactorial = productFactorial * factorial[digitCount[digit]] % MOD;
        }

        long long result = validAssign;
        result = result * factorial[evenC] % MOD;
        result = result * factorial[oddC] % MOD;
        long long inverseProduct = power(productFactorial, MOD - 2, MOD);
        result = result * inverseProduct % MOD;

        return (int)result;
    }

private:
    vector<long long> preFact(int maxValue, int mod) {
        vector<long long> factorial(maxValue + 1, 1);
        for (int i = 1; i <= maxValue; i++) {
            factorial[i] = factorial[i - 1] * i % mod;
        }
        return factorial;
    }

    vector<long long> ComputeFact(const vector<long long>& factorial, int mod) {
        int maxValue = factorial.size() - 1;
        vector<long long> invFact(maxValue + 1, 1);
        invFact[maxValue] = power(factorial[maxValue], mod - 2, mod);
        for (int i = maxValue - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod;
        }
        return invFact;
    }

    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }
};
",1441365481
Evan Tian,etian6795,222,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][] d = new long[n][m];
        boolean[][] seen = new boolean[n][m];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = Long.MAX_VALUE;
            }
        }
        d[0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[2], b[2]));
        pq.add(new long[]{0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            long time = curr[2];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y]) continue;
            seen[x][y] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + 1;

                    if(next <= moveTime[nx][ny] + 1) {
                        next = moveTime[nx][ny] + 1;
                    }


                    if(next < d[nx][ny]) {
                        d[nx][ny] = next;
                        pq.add(new long[]{nx, ny, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342435
Evan Tian,etian6795,222,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][][] d = new long[n][m][2];
        boolean[][][] seen = new boolean[n][m][2];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                Arrays.fill(d[i][j], Long.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[3], b[3]));
        pq.add(new long[]{0, 0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            int p = (int)curr[2];
            long time = curr[3];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y][p]) continue;
            seen[x][y][p] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + ((p == 0) ? 1 : 2);

                    if(next <= moveTime[nx][ny] + ((p == 0) ? 1 : 2)) {
                        next = moveTime[nx][ny] + ((p == 0) ? 1 : 2);
                    }

                    int nextp = 1 - p;

                    if(next < d[nx][ny][nextp]) {
                        d[nx][ny][nextp] = next;
                        pq.add(new long[]{nx, ny, nextp, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342250
Evan Tian,etian6795,222,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int e = 0;
        int o = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = Character.getNumericValue(num.charAt(i));
            if (i % 2 == 0) {
                e += digit;
            } else {
                o += digit;
            }
        }

        return e == o;
    }
}",1441343466
Evan Tian,etian6795,222,3637,java,"class Solution {
    public long MOD = 1_000_000_007;
    public long[] fact;
    public long[] invFact;
    public int n;
    public int[] f = new int[10];
    Map<String, Long> memo;

    public int countBalancedPermutations(String num) {
        for(char c : num.toCharArray()){
            f[c - '0']++;
        }
        n = num.length();

        int target = 0;
        for(int i = 0; i <= 9; i++) {
            target += i * f[i];
        }

        if(target % 2 != 0){
            return 0;
        }
        target /= 2;

        int e = (n + 1) / 2;
        int o = n / 2;

        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        invFact[n] = expo(fact[n], MOD - 2);
        for(int i = n - 1; i >= 0; i--){
            invFact[i] = (invFact[i+1] * (i+1)) % MOD;
        }

        memo = new HashMap<>();

        long qwe = rec(0, target, e);

        long asd = 1;
        for(int i = 0; i <= 9; i++) {
            if(f[i] > n) {
                return 0;
            }
            asd = (asd * fact[f[i]]) % MOD;
        }
        asd = expo(asd, MOD - 2);

        long ans = fact[e] * fact[o] % MOD;
        ans = (ans * qwe) % MOD;
        ans = (ans * asd) % MOD;

        return (int)(ans);
    }

    private long rec(int digit, int sum, int count){
        String key = digit + "","" + sum + "","" + count;

        if(memo.containsKey(key)){
            return memo.get(key);
        }

        if(digit == 10){
            if(sum == 0 && count == 0){
                return 1;
            }
            else{
                return 0;
            }
        }

        if(sum < 0 || count < 0){
            return 0;
        }

        long total = 0;
        int max = Math.min(count, f[digit]);
        for(int i = 0; i <= max; i++){
            if(i * digit > sum){
                break;
            }
            
            long qwe = combination(f[digit], i);

            total = (total + qwe * rec(digit + 1, sum - i * digit, count - i)) % MOD;
        }

        memo.put(key, total);
        return total;
    }

    private long combination(int n, int k){
        if(k < 0 || k > n){
            return 0;
        }
        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;
    }

    private long expo(long a, long b){
        long res =1;
        a %= MOD;
        while(b >0){
            if( (b &1) ==1 ){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>=1;
        }
        return res;
    }
}
",1441384193
Paridhi Agarwal,paridhi_,224,3627,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>
#include <array>

class Solution
{
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, std::numeric_limits<int>::max()));
        int i = 0;
        if (n > 0)
            do
            {
                std::fill(dist[i].begin(), dist[i].end(), std::numeric_limits<int>::max());
                i++;
            }
            while (!(i < n)==false);
        using T = std::array<int, 3>;
        auto cmp = [](const T& a, const T& b) { return a[0] > b[0]; };
        std::priority_queue<T, std::vector<T>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        std::vector<std::vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (; (!(!pq.empty())==false);)
        {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0;
            while (!(dirIndex < dirs.size()) ==false)
            {
                auto dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = std::max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
        }
        return dist[n - 1][m - 1];
    }
};
",1441371856
Paridhi Agarwal,paridhi_,224,3628,cpp,"#include <vector>
#include <queue>
#include <array>
#include <climits>
#include <functional>
class Solution
{
public:
    int minTimeToReach(const std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<std::array<int, 2>>> d(n, std::vector<std::array<int, 2>>(m, {INT_MAX, INT_MAX}));
        int i = 0;
        do
        {
            int j = 0;
            while (j < m)
            {
                d[i][j][0] = INT_MAX;
                d[i][j][1] = INT_MAX;
                j++;
            }
            i++;
        }
        while (i < n);
        d[0][0][0] = 0;
        auto cmp = [](const std::array<int, 4>& a, const std::array<int, 4>& b) {
            return a[0] > b[0];
        };
        std::priority_queue<std::array<int, 4>, std::vector<std::array<int, 4>>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0, 0});
        std::vector<std::array<int, 2>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for (; !(!pq.empty()) == false; )
        {
            auto current = pq.top();
            pq.pop();
            int t = current[0];
            int iCur = current[1];
            int jCur = current[2];
            int p = current[3];
            
            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            
            int dirIndex = 0;
            while (!(dirIndex < directions.size()) == false)
            {
                auto dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = std::max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            }
        }
        return std::min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};
",1441353548
Paridhi Agarwal,paridhi_,224,3636,cpp,"#include <string>
class Solution
{
public:
    bool isBalanced(const std::string& num)
    {
        int evenSum = 0;
        int oddSum = 0;
        int i = 0;
        do
        {
            int digit = num[i] - '0';
            if (!(i % 2 == 0) == false) 
                evenSum += digit;
            else
                oddSum += digit;
            i++;
        }
        while (!(i < num.length()) == false);
        return (!(evenSum == oddSum) == false);
    }
};
",1441295940
Paridhi Agarwal,paridhi_,224,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>

class Solution {
private:
    static const int MOD = 1000000007;
    std::vector<long long> fact;
    std::vector<long long> invFact;

    long long powerMod(long long a, long long b) {
        long long res = 1;
        a %= MOD;
        while (b > 0) {
            if (!((b & 1) == 1) == false) {
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void initFact(int n) {
        fact.resize(n + 1);
        invFact.resize(n + 1);
        fact[0] = 1;
        int i = 1;
        do {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        } while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        } while (j >= 0);
    }

public:
    int countBalancedPermutations(std::string num) {
        int n = num.length();
        std::vector<int> freq(10, 0);
        long long totalSum = 0;
        std::vector<char> C(num.begin(), num.end());
        int i = 0;
        if (n > 0) {
            do {
                char c = C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            } while (i < n);
        }

        if (!(totalSum % 2 != 0) == false) {
            return 0;
        }
        long long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        std::vector<std::vector<long long>> dp(k + 1, std::vector<long long>((int)sumHalf + 1, 0));
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0) == false)
            {
                d++;
                continue;
            }
            int c = k;
            while (c >= 0)
            {
                long long s = sumHalf;
                do
                {
                    if (!(dp[c][(int)s] == 0) == false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    while (true)
                    {
                        if (!(t > std::min(freq[d], k - c)) == false)
                            break;
                        if (!(s + (long long)d * t > sumHalf) == false)
                            break;
                        long long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int)(s + d * t)] = (dp[c + t][(int)(s + d * t)] + dp[c][(int)s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                while (s >= 0);
                c--;
            }
            d++;
        }
        while (d <= 9);
        long long validAssignments = dp[k][(int)sumHalf];
        if (!(validAssignments == 0) == false) {
            return 0;
        }
        long long prodFactFd = 1;
        int digit = 0;
        while (digit <= 9)
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        long long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int)answer;
    }
};
",1441396969
jacobj2,jacobj2,225,3627,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[inf]*len(m[0]) for i in range(len(m))]
        dp[0][0] = inf
        heap = [(0,0,0)]
        while heap:
            time, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc] > max(time + 1, m[dr][dc] + 1):
                    dp[dr][dc] = max(time+1,m[dr][dc] + 1)
                    heappush(heap, (dp[dr][dc],dr,dc))
        return -1",1441301318
jacobj2,jacobj2,225,3628,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[[inf,inf] for _ in range(len(m[0]))] for i in range(len(m))]
        dp[0][0][0] = 0
        heap = [(0,0,0,0)]
        while heap:
            time, od, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if od==0:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 1, m[dr][dc] + 1):
                        dp[dr][dc][1-od] = max(time+1,m[dr][dc] + 1)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
                elif od==1:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 2, m[dr][dc] + 2):
                        dp[dr][dc][1-od] = max(time+2,m[dr][dc] + 2)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
        return -1",1441304952
jacobj2,jacobj2,225,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i in range(len(num)):
            if i%2==0:
                e+=int(num[i])
            else:
                o+=int(num[i])
        return e==o",1441280777
jacobj2,jacobj2,225,3637,python3,"MOD = 10**9+7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        tot = 0
        for i in range(len(num)):
            tot+=int(num[i])
        if tot%2==1:
            return 0
        ct = defaultdict(int)
        for i in range(len(num)):
            ct[int(num[i])]+=1
        r1 = len(num) - len(num)//2
        pref = [0]*10
        for i in range(len(pref)):
            pref[i] = ct[i]
            if i > 0:
                pref[i]+=pref[i-1]
        #print(pref)
        @cache
        def dfs(index, remSum, remInd):
            if remSum < 0 or remInd < 0:
                return 0
            if index==10:
                return int(remSum==0 and remInd==0)
            usedOdd = 0 if index==0 else pref[index - 1] - (len(num)//2 - remInd)
            leftOdd = len(num) - len(num)//2 - usedOdd
            if leftOdd < 0:
                return 0
            res = 0
            for x in range(ct[index]+1):
                left = ct[index] - x
                if left > leftOdd:
                    continue
                res+=(((dfs(index+1,remSum-x*index, remInd - x)*math.comb(remInd, x))%MOD)*math.comb(leftOdd,left))%MOD
                if res >= MOD:
                    res-=MOD
            return res
        a = dfs(0,tot//2,len(num)//2)
        dfs.cache_clear()
        return a",1441372719
IphoneX,hahahiehie,226,3627,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + e.w) {
                        if (w + e.w > board[e.to]) {
                            dist[e.to] = w + e.w;
                            q.add(new Edge(e.to, w + e.w));
                        } else {
                            dist[e.to] = board[e.to] + 1;
                            q.add(new Edge(e.to, board[e.to] + 1));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441298213
IphoneX,hahahiehie,226,3628,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            int last;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }

            public Edge(int to, long w, int last) {
                this.to = to;
                this.w = w;
                this.last = last;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0, 2));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                int last = cur.last;
                int nextStep = last == 1 ? 2 : 1;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + nextStep) {
                        if (w + nextStep >= board[e.to] + nextStep) {
                            dist[e.to] = w + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        } else {
                            dist[e.to] = board[e.to] + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441304580
IphoneX,hahahiehie,226,3636,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    public boolean isBalanced(String num) {
        int n = num.length();
        int a = 0;
        int b = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                a += num.charAt(i) - '0';
            } else {
                b += num.charAt(i) - '0';
            }
        }
        return a == b;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441281429
IphoneX,hahahiehie,226,3637,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static Combination comb = new Combination(100, MOD);
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int sum = 0;
        int targetLength0 = 0;
        int targetLength1 = 0;
        long[] digitCount = new long[10];
        for (int i = 0; i < n; i++) {
            sum += num.charAt(i) - '0';
            digitCount[num.charAt(i) - '0']++;
            if (i % 2 == 0) {
                targetLength0++;
            } else {
                targetLength1++;
            }
        }
        if (sum % 2 != 0) return 0;
        int targetSum = sum / 2;


        long[][][] dp = new long[10][n + 1][sum + 1];

        for (int i = 0; i <= digitCount[0] && i <= targetLength0; i++) {
            if (targetLength0 >= i && targetLength1 >= (int) digitCount[0] - i) {
                dp[0][i][0] = comb.C(targetLength0, i) * comb.C(targetLength1, (int) digitCount[0] - i) % MOD;
            }
        }

        int[] preSum = new int[10];
        preSum[0] = (int) digitCount[0];
        for (int i = 1; i < 10; i++) {
            preSum[i] = preSum[i - 1] + (int) digitCount[i];
        }
        for (int i = 1; i <= 9; i++) {

            for (int j = 0; j <= targetLength0; j++) {
                for (int k = 0; k <= targetSum; k++) {
                    if (dp[i - 1][j][k] == 0) continue;

                    for (int c = 0; c <= digitCount[i]; c++) {
                        if (c + j > targetLength0) break;
                        if (c * i + k > targetSum) break;
                        int c2 = (int) digitCount[i] - c;
                        int len2 = targetLength1 - (preSum[i - 1] - j);
                        if (len2 >= 0 && len2 <= targetLength1 && len2 >= c2) {
                            dp[i][j + c][k + c * i] = (dp[i][j + c][k + c * i] + dp[i - 1][j][k] * comb.C(targetLength0 - j, c) % MOD * comb.C(len2, c2)) % MOD;
                        }
                    }
                }
            }
        }
        return (int) dp[9][targetLength0][targetSum];


    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441385012
JOZLEETCODE,JLZ998112,227,3627,java,"class Solution {
    private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][] dist = new int[m][n];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i], Max);
            }
        }
        dist[0][0] = 0;        
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x,y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            if(r==m-1 && c==n-1){
                return cd;
            }
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n && dist[nr][nc] == Max){
                    int nd = Math.max(cd+1, g[nr][nc]+1);
                    dist[nr][nc] = nd;
                    pq.offer(new int[]{nr, nc, nd});
                }
            }
        }
        return -1;
    }
}",1441294725
JOZLEETCODE,JLZ998112,227,3628,java,"class Solution {
     private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][][] dist = new int[m][n][3];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i][j], Max);
            }
        }
        dist[0][0][1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x, y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0, 1});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            int steps = top[3];
            if(r==m-1 && c==n-1){
                return cd;
            }
            int nsteps = (steps == 1?2:1);
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n ){
                    int nd = Math.max(cd+steps, g[nr][nc]+steps);
                    if(dist[nr][nc][nsteps] > nd){
                        dist[nr][nc][nsteps] = nd;
                        pq.offer(new int[]{nr, nc, nd, nsteps});
                    }
                }
            }
        }
        return -1;
    }
}",1441305565
JOZLEETCODE,JLZ998112,227,3636,java,"class Solution {
    public boolean isBalanced(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int odd = 0;
        int even = 0;
        for(int i=0; i<n; ++i){
            int cind = c[i]-'0';
            if(i%2==0){
                even += cind;
            }else{
                odd += cind;
            }
        }
        return odd == even;
    }
}",1441283731
JOZLEETCODE,JLZ998112,227,3637,java,"class Solution {
    private final long Mod = (long) (1e9 + 7);
    private long[][][] dp;
    private int oddi = 0;
    private int eveni = 0;
    private long sum = 0;
    private final int nums = 10;

    public int countBalancedPermutations(String s) {
        int n = s.length();
        initfact();
        oddi = 0;
        eveni = 0;
        sum = 0;

        int[] count = new int[10];

        for (int i = 0; i < n; ++i) {
            int cind = s.charAt(i) - '0';
            ++count[cind];
            if (i % 2 == 0) {
                ++eveni;
            } else {
                ++oddi;
            }
            sum += cind;
        }
        dp = new long[nums][800][oddi + 1];

        for (int i = 0; i < nums; ++i) {
            for (int j = 0; j < 800; ++j) {
                Arrays.fill(dp[i][j], -1);
            }

        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        long rt = solve(count, 0, 0, oddi);

        return (int) rt;
    }

    private long solve(int[] a, int i, int osum, int indexes) {
        if (indexes < 0) {
            return 0;
        }
        if (i == nums) {
            if (osum != sum || indexes != 0) {
                return 0;
            } else {
                long ep = fact[eveni];
                long op = fact[oddi];
                long res = ep * op;
                res %= Mod;
                return res;
            }
        }
        if (dp[i][osum][indexes] != -1) {
            return dp[i][osum][indexes];
        }
        long res = 0;
        for (int j = 0; j <= a[i]; ++j) {
            int nosum = osum + j * i;
            long cur = solve(a, i + 1, nosum, indexes - j);
            cur *= modinverse(fact[j]);
            cur %= Mod;
            int toodd = a[i] - j;
            cur *= modinverse(fact[toodd]);
            cur %= Mod;
            res += cur;
            res %= Mod;
        }
        dp[i][osum][indexes] = res;
        return res;
    }

    private long[] fact = new long[101];

    private void initfact() {
        fact[0] = 1;
        for (int i = 1; i <= 100; ++i) {
            fact[i] = fact[i - 1] * i;
            fact[i] %= Mod;
        }
    }

    private long modinverse(long a) {
        long m = Mod;
        long y = 0;
        long x = 1;
        while (a > 1) {
            long q = a / m;
            long t = m;
            m = a % m;
            a = t;
            t = y;
            y = x - q * y;
            x = t;
        }
        if (x < 0) {
            x += Mod;
        }
        return x;
    }
}",1441372874
Kalix1110,Kalix1110,229,3627,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vll dis(n+5,vl(m+5,1e13));
        
        priority_queue<vl,vll,greater<vl>>pq;
        dis[0][0]=0;
        pq.push({0,0,0});
        
        while(pq.size()>0){
            auto p=pq.top();
            pq.pop();
            ll wt=p[0];
            int x=p[1];
            int y=p[2];
            
            if(wt>dis[x][y]) continue;
            for(auto &it:delta1){
                int nx=x+it[0];
                int ny=y+it[1];
                
                if(nx<0 || ny<0 || nx>=n || ny>=m) continue;
                ll d=max(wt,(ll)v[nx][ny])+1;
                if(d < dis[nx][ny]){
                    dis[nx][ny]=d;
                    pq.push({d,nx,ny});
                }
            }
        }
        
        return dis[n-1][m-1];
    }
};",1441297076
Kalix1110,Kalix1110,229,3628,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size(), m = v[0].size();
        
        // 3D distance array: dis[x][y][iinc] where iinc is 0 or 1
        vector<vector<vector<long long>>> dis(n, vector<vector<long long>>(m, vector<long long>(2, 1e13)));
        
        // Priority queue for Dijkstra's algorithm
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        
        // Initialize starting point
        dis[0][0][0] = 0;
        pq.push({0, 0, 0, 0});  // {distance, x, y, iinc}
        
        // Direction vectors for 4 possible moves
        vector<vector<int>> delta1 = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            
            long long wt = p[0];
            int x = p[1];
            int y = p[2];
            int iinc = p[3];
            
            // Skip if this path is outdated
            if (wt > dis[x][y][iinc]) continue;
            
            // Traverse through all possible moves
            for (auto &it : delta1) {
                int nx = x + it[0];
                int ny = y + it[1];
                
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                
                // Calculate new distance
                long long d = max(wt, (long long)v[nx][ny]) + iinc + 1;
                int new_iinc = 1 - iinc;  // Toggle increment for the next step
                
                if (d < dis[nx][ny][new_iinc]) {
                    dis[nx][ny][new_iinc] = d;
                    pq.push({d, nx, ny, new_iinc});
                }
            }
        }
        
        // Get the minimum time to reach the bottom-right corner
        return min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
    }
};
",1441331796
Kalix1110,Kalix1110,229,3636,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool isBalanced(string num) {
        ll a=0,b=0;
        int f=0;
        for(auto &it:num){
            if(f) a+=it-'0';
            else b+=it-'0';
            
            f=!f;
        }
        
        return a==b;
    }
};",1441281597
Kalix1110,Kalix1110,229,3637,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

ll power(ll a,ll n , ll mod=MOD){
	a%=mod;
    ll res=1;
    while(n){
        if(n%2){
            res=res*a;
			res%=mod;
            n--;
        }else{
            a=(a*a);
			a%=mod;
            n/=2;
        }
    }
    
    return res;
}



const int N=100;

// array to store inverse of 1 to N 
ll  factorialNumInverse[N + 1]; 
  
// array to precompute inverse of 1! to N! 
ll  naturalNumInverse[N + 1]; 
  
// array to store factorial of first N numbers 
ll  fact[N + 1]; 


void factorial(ll  p=MOD) 
{ 
    fact[0] = 1; 
  
    // precompute factorials 
    for (ll i = 1; i <= N; i++) { 
        fact[i] = (fact[i - 1] * i) % p; 
    } 
} 

ll inv(ll x){
    return power(fact[x],MOD-2);
}

class Solution {
public:
    ll dp[85][900][50];
    int n;
    ll solve(int i,int sum,int odd,string &s){
        
        if(sum<-400) return 0;
        if(i==s.size()){
            // cout<<sum<<endl;
            if(sum==0) return 1;
            return 0;
        }
        if(dp[i][sum+400][odd] != -1) return dp[i][sum+400][odd];
        
        ll ans=0;
        ll even=(n-i)-odd;
        if(odd>0) ans+=(solve(i+1,sum-(s[i]-'0'),odd-1,s)*odd)%MOD;
        ans%=MOD;
        
        if(even>0) ans+=(solve(i+1,sum+(s[i]-'0'),odd,s)*even)%MOD;
         ans%=MOD;
        
        return dp[i][sum+400][odd]=ans;
    }
    int countBalancedPermutations(string num) {
        memset(dp,-1);
        factorial(MOD); 
         n=num.size();
        ll odd=n/2;
        ll even=n/2;
        if(n%2) odd++;
        ll ans= solve(0,0,odd,num);
        vl v(10);
        for(auto &it:num) v[it-'0']++;
        for(int i=0;i<10;i++){
            if(v[i]==0) continue;
            ans*=inv(v[i]);
            ans%=MOD;
        }
        
        return ans;
    }
};",1441372921
dapu81000,dapu81000,232,3627,cpp,"class Solution {
public:
    int dp[55][55] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        #define pii pair<int,int>
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        pq.push({0, 0});
        while(!pq.empty()){
            pii tmp = pq.top();pq.pop();
            int x = tmp.second/m, y = tmp.second%m, dist = tmp.first;
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+1, moveTime[xx][yy]+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441306672
dapu81000,dapu81000,232,3628,cpp,"class Solution {
public:
    int dp[755][755] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0});
        while(!pq.empty()){
            vector<int> v=pq.top();pq.pop();
            int x = v[1]/m, y = v[1]%m, dist = v[0], add = v[2];
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+add+1, moveTime[xx][yy]+add+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy, !add});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441314240
dapu81000,dapu81000,232,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int res[2] = {};
        for(int i=0;i<num.size();i++){
            int cur = (i&1)^1;
            res[cur] += num[i]-'0';
        }
        return res[0] == res[1];
    }
};",1441281741
dapu81000,dapu81000,232,3637,cpp,"class Solution {
public:
    int dp[41][401] = {};
    int fac[88] = {};
    const int mod = 1e9+7;
    void build(){
        fac[0] = fac[1] = 1;
        for(int i=2;i<=80;i++){
            fac[i] = (1ll*fac[i-1]*i)%mod;
        }
    }
    int powmod(long long x,int n){
        long long res = 1;
        while(n){
            if(n&1) res = (res*x)%mod;
            x = (x*x)%mod;
            n>>=1;
        }
        return res;
    }
    int cnt[10] = {};
    int countBalancedPermutations(string num) {
        build();
        int tot = 0;
        for(char ch:num) tot += ch-'0', cnt[ch-'0']++;
        if(tot&1) return 0;
        if(tot==1) return 1;
        int mid = tot/2, n = num.size();
        dp[0][0] = 1;

        for(int i=0;i<n;i++){
            int cur = num[i]-'0';
            for(int j=min(i+1,n/2);j>0;j--){
                for(int k=mid;k>=cur;k--){
                    dp[j][k] += dp[j-1][k-cur];
                    dp[j][k] %= mod;
                }
            }
        }
        long long res = dp[n/2][mid];
        res = (res*fac[n/2])%mod;
        res = (res*fac[n-n/2])%mod;

        for(int i=0;i<=9;i++){
            if(cnt[i]>1){
                res = (res*powmod(fac[cnt[i]],mod-2))%mod;
            }
        }
        return res;
    }
};",1441367211
Anh Tài Trần,anh_tai,234,3627,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 );
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441372865
Anh Tài Trần,anh_tai,234,3628,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 + f);
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441371858
Anh Tài Trần,anh_tai,234,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0, mul = 1;
        for (char&c : num){
            s += mul * (c - '0');
            mul = mul * -1;
        }
        return s == 0; 
    }
};",1441350523
Anh Tài Trần,anh_tai,234,3637,cpp,"int fact[81], ifact[81];

const int mod = 1e9 + 7;

int add(int u, int v){
    u += v;
    if (u >= mod) u -= mod;
    return u; 
}

int sub(int u, int v){
    return add(u, mod - v);
}

int mul(int u, int v){
    return 1LL * u * v % mod;
}

int power(int u, int v){
    int res = 1;
    while (v > 0){
        if (v & 1){
            res = mul(res, u);
        }
        u = mul(u, u);
        v >>= 1;
    }
    return res; 
}

void init(){
    if (fact[0] > 0){
        return; 
    }
    
    fact[0] = ifact[0] = 1;
    for (int i = 1; i <= 80; i++){
        fact[i] = mul(fact[i-1],i);
        ifact[i] = power(fact[i], mod - 2);
        //cout << i << "" "" << fact[i] << "" "" << ifact[i] << ""\n""; 
    }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        init(); 
        int n = num.size();
        vector<int> cnt(10);
        int tot = 0; 
        for (char& c : num){
            cnt[c - '0']++;
            tot += (c - '0');
        }

        if (tot&1){
            return 0; 
        }

        tot >>= 1; 
        vector<vector<int>> dp(41, vector<int>(361)), ndp(41, vector<int>(361)); 
        dp[0][0] = 1;

        // for (int sum = 0; sum <= tot; sum++){
        //     for (int digits = 0; digits <= (n + 1) / 2; digits++){
        //         for (int d = 0; d < 10; d++){
        //             for (int sk = 0; sk <= cnt[d];sk++){
        //                 int n_sum = sum + sk * d;
        //                 int n_digits = digits + sk;
        //                 if (n_sum <= tot && n_digits <= (n + 1) / 2){
        //                     ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], ifact[sk]));
        //                 }
        //             }
        //         }
        //     }
        // }
        
        for (int d = 0; d < 10; d++){
            for (int sk = 0; sk <= cnt[d]; sk++){
                for (int sum = 0; sum <= tot; sum++){
                    for (int digits = 0; digits <= (n + 1) / 2; digits++){
                        int n_sum = sum + sk * d;
                        int n_digits = digits + sk;
                        if (n_sum <= tot && n_digits <= (n + 1) / 2){
                            ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], mul(ifact[sk], ifact[cnt[d] - sk])));
                        }
                    } 
                }   
            }

            for (int sum = 0; sum <= tot; sum++){
                for (int digits = 0; digits <= (n + 1) / 2; digits++){
                    dp[digits][sum] = ndp[digits][sum];
                    ndp[digits][sum] = 0; 
                }
             }
        }
        
        int ans = mul(fact[(n + 1) / 2], dp[(n + 1) / 2][tot]);
        ans = mul(ans, fact[n -(n + 1) / 2]);
        return ans; 
    }
};",1441385911
Pikachu0123,Pikachu0123,236,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        queue<vector<int>> q;
        q.push({0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.front()[0];
            int c = q.front()[1];
            int d = q.front()[2];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = d;
                if (d < moveTime[nr][nc]){
                    new_d = moveTime[nr][nc];
                }
                if (new_d + 1 < dis[nr][nc]){
                    dis[nr][nc] = new_d + 1;
                    q.push({nr, nc, new_d + 1});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441298296
Pikachu0123,Pikachu0123,236,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.top()[1];
            int c = q.top()[2];
            int d = -q.top()[0];
            int type = q.top()[3];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = max(d, moveTime[nr][nc]);
                int cost = new_d + (type == 0 ? 1 : 2);
                if (cost < dis[nr][nc]){
                    dis[nr][nc] = cost;
                    q.push({-cost,nr, nc, !type});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441303211
Pikachu0123,Pikachu0123,236,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i=0; i<n; i+=2) sum1 += num[i]-'0';
        for(int i=1; i<n; i+=2) sum2 += num[i] - '0';
        return sum1 == sum2;
    }
};",1441281379
Pikachu0123,Pikachu0123,236,3637,cpp,"
const int mod = 1e9 + 7;
const int offset = 730;
long long dp[10][1500][42];
long long ncr[101][101];

void precompute_nCr() {
    for (int i = 0; i <= 100; ++i) {
        ncr[i][0] = ncr[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;
        }
    }
}

class Solution {
long long solve(int i,  int sum, int odd, int even, vector<int> &freq){
    if (i == 10){
        if (sum == 0) return 1;
        else return 0;
    }
    if (freq[i] == 0){
        return solve(i + 1, sum, odd, even, freq);
    }
    if (dp[i][sum+offset][even] != -1) return dp[i][sum+offset][even];
    long long ans = 0;
    int val = freq[i];
    for(int j=0; j<=val; j++){
        int taken_odd = j;
        int taken_even = val - j;
        if (odd >= taken_odd and even >= taken_even){
            (ans += ((ncr[odd][taken_odd] * 1LL * ncr[even][taken_even]) % mod * solve(i + 1, sum - i * taken_odd + i * taken_even, odd - taken_odd, even - taken_even, freq)) % mod) %= mod;
        }
    }
    return dp[i][sum+offset][even] = ans;
}
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> freq(10, 0);
        
        for(char &ch : num)
            freq[ch-'0'] += 1;
        int odd = (n + 1) / 2, even = n / 2;
        memset(dp, -1, sizeof dp);
        memset(ncr, 0, sizeof ncr);
        precompute_nCr();
        return solve(0, 0, odd, even, freq);
    }
};",1441369861
pooyaz,pooyaz,237,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        vector<vector<int>> cnt(n, vector<int>(m, -1));
        priority_queue<vector<int>> q;
        q.push({0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2];
            if(cnt[i][j] != -1) continue;
            cnt[i][j] = dis;
            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj] == -1){
                    int ndist = max(t[ni][nj], dis) + 1;
                    q.push({-ndist, ni, nj});
                }
            }
        }
        return cnt[n - 1][m - 1];
    }
};",1441319916
pooyaz,pooyaz,237,3628,cpp,"class Solution {
public:
    int cnt[760][760][2];
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        memset(cnt, -1, sizeof cnt);
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2], s = v[3];
            if(cnt[i][j][s] != -1) continue;
            
            cnt[i][j][s] = dis;
            if(i == n - 1 && j == m - 1) break;

            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                int ns = 1 - s;
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj][ns] == -1){
                    int ndist = max(t[ni][nj], dis) + 1 + s;
                    q.push({-ndist, ni, nj, ns});
                }
            }
        }
        if(cnt[n - 1][m - 1][0] == -1){
            return cnt[n - 1][m - 1][1];
        }
        else if(cnt[n - 1][m - 1][1] == -1){
            return cnt[n - 1][m - 1][0];
        }
        return min(cnt[n - 1][m - 1][0], cnt[n - 1][m - 1][1]);
    }
};",1441331858
pooyaz,pooyaz,237,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.length(); i++){
            if(i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281862
pooyaz,pooyaz,237,3637,cpp,"#define Mod 1000000007L

class Solution {
public:
    int n;
    int sum[11];
    int dig[11];
    int cnt[11] = {};
    long long com[50][50] = {};
    long long dp[11][50][500];

    long long mem(int idx, int sp, int rem){
        if(idx == 10){
            return sp == 0 && rem == 0;
        }
        long long& ref = dp[idx][sp][rem];
        if(ref != -1) return ref;
        ref = 0;

        int sp2 = dig[idx] - sp;
        int rem2 = sum[idx] - rem;
        for(int i = 0; i <= cnt[idx]; i++){
            if(i > sp || i * idx > rem) continue;
            if(cnt[idx] - i > sp2 || (cnt[idx] - i) * idx > rem2) continue;
            long long nex = mem(idx + 1, sp - i, rem - i * idx);
            long long c1 = com[i][sp];
            long long c2 = com[cnt[idx] - i][sp2];
            // cout << idx << ' ' << sp << ' ' << rem << ' ' << i << ' ' << nex << ' ' << c1 << ' ' << c2 << endl;
            ref = (ref + nex * (c1 * c2 % Mod)) % Mod;
            // cout << ref << endl;
        }
        return ref;
    }
    int countBalancedPermutations(string num) {
        n = num.length();
        memset(dp, -1, sizeof dp);
        for(int i = 0; i < n; i++){
            int d = num[i] - '0';
            cnt[d]++;
        }
        for(int i = 9; i >= 0; i--){
            sum[i] = sum[i + 1] + cnt[i] * i;
            dig[i] = dig[i + 1] + cnt[i];
        }
        if(sum[0] % 2) return 0;
        for(int i = 0; i <= dig[0] / 2 + 1; i++){
            com[0][i] = 1;
            com[i][i] = 1;
        }
        for(int i = 1; i <= dig[0] / 2 + 1; i++){
            for(int j = 1; j < i; j++){
                com[j][i] = (com[j - 1][i - 1] + com[j][i - 1]) % Mod;
                // cout << i << ' ' << j << ' ' << com[j][i] << ' ' << com[j - 1][i - 1] << ' ' << com[j][i - 1] << endl;
            }
        }
        
        long long ans = mem(0, dig[0] / 2, sum[0] / 2);
        return (int)ans;
    }
};",1441382229
KGowtham04,KGowtham04,238,3627,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({0, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+1;
                    pq.push({newTime, {newX, newY}});
                    seen[newX][newY] = true;
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }

    

    
};",1441325312
KGowtham04,KGowtham04,238,3628,cpp,"class Solution {
public:
    int n, m;
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({{0, 1}, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first.first;
            int move = pq.top().first.second;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+move;
                    int newMove = move == 2 ? 1 : 2; 
                    pq.push({{newTime, newMove}, {newX, newY}});
                    seen[newX][newY] = true;
                    
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }       
};",1441338140
KGowtham04,KGowtham04,238,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {

        int odd = 0, even  = 0;

        for(int i=0; i<num.size(); i++){
            if(i%2==0){
                even += num[i] - 48;
            }
            else{
                odd+= num[i] - 48;
            }
        }

        return even == odd;
        
    }
};",1441289755
KGowtham04,KGowtham04,238,3637,cpp,"typedef long long ll;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int MOD = 1e9+7;
                int n = num.size();
        int m = (n + 1) / 2; // Number of even indices (0-based)

        // Count digits
        int count_digits[10] = {0};
        ll sum_total =0;
        for(char ch: num){
            int d = ch - '0';
            count_digits[d]++;
            sum_total += d;
        }

        // If total sum is odd, no balanced permutation exists
        if(sum_total %2 !=0){
            return 0;
        }
        ll sum_target = sum_total /2;

        // Precompute factorial and inverse factorial
        vector<ll> fact(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] * i % MOD;

        // Compute inverse factorial
        vector<ll> inv_fact(n+1,1);
        inv_fact[n] = power_mod_func(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }

        // Compute product of inverse factorials of counts
        // Not needed in the final formula
        // ll inv_fact_prod_counts =1;
        // for(int d=0; d<=9; d++) {
        //     inv_fact_prod_counts = inv_fact_prod_counts * inv_fact[count_digits[d]] % MOD;
        // }

        // Initialize DP
        // dp[k][s] represents the number of ways to assign k digits with sum s, adjusted by inverse factorials
        vector<vector<ll>> dp_prev(m+1, vector<ll>(sum_target +1, 0));
        dp_prev[0][0] =1;

        for(int d=0; d<=9; d++){
            int c_d = count_digits[d];
            if(c_d ==0){
                continue;
            }
            // Initialize next layer
            vector<vector<ll>> dp_next(m+1, vector<ll>(sum_target +1, 0));

            for(int k=0; k<=m; k++){
                for(ll s=0; s<=sum_target; s++){
                    if(dp_prev[k][s] ==0){
                        continue;
                    }
                    // Try assigning t digits of this digit to even positions
                    for(int t=0; t<=c_d && t <= m -k; t++){
                        if(s + (ll)t *d > sum_target){
                            continue;
                        }
                        // Update dp_next
                        dp_next[k +t][s + (ll)t *d] = (dp_next[k +t][s + (ll)t *d] + dp_prev[k][s] * inv_fact[t] % MOD * inv_fact[c_d - t] % MOD) % MOD;
                    }
                }
            }
            // Update dp_prev
            dp_prev = move(dp_next);
        }

        // After processing all digits, check dp_prev[m][sum_target]
        ll dp_final = 0;
        if(m <= n && sum_target <= sum_total){
            dp_final = dp_prev[m][sum_target];
        }

        // Compute the final answer
        // The correct formula is: fact[m] * fact[n -m} * dp_final % MOD
        ll answer = fact[m] * fact[n -m] % MOD;
        answer = answer * dp_final % MOD;

        return (int)answer;
    }
    
   ll power_mod_func(ll x, ll power, ll mod_val) {
        ll result = 1;
        x %= mod_val;
        while(power > 0){
            if(power & 1){
                result = result * x % mod_val;
            }
            x = x * x % mod_val;
            power >>=1;
        }
        return result;
    }
};",1441388333
Varun Deep Saini,sojabhai,240,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<pair<int, int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };
        
        vector<vector<int>> dist(n, vector<int>(m, 1e18));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        pq.emplace(0, make_pair(0, 0));
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            
            int w = curr.first;
            int x = curr.second.first;
            int y = curr.second.second;
            
            if (x == n -1 && y == m -1) {
                return (int)w;
            }
            
            if (w > dist[x][y]) {
                continue;
            }
            
            for (auto &dir : directions) {
                int nx = x + dir.first;
                int ny = y + dir.second;
                
                if (nx >=0 && nx < n && ny >=0 && ny < m) {
                    int timee = max((int)w, (int)moveTime[nx][ny]);
                    int d = timee + 1;
                    
                    if (d < dist[nx][ny]) {
                        dist[nx][ny] = d;
                        pq.emplace(d, make_pair(nx, ny));
                    }
                }
            }
        }
        #undef int
        return 69;
    }
};
",1441374028
Varun Deep Saini,sojabhai,240,3628,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };
        
    struct Compare {
    bool operator()(const vector<long long>& a, const vector<long long>& b) const {
            return a[0] > b[0];
        }
    };

    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist1(n, vector<int>(m, LLONG_MAX));
        vector<vector<int>> dist2(n, vector<int>(m, LLONG_MAX));
        
        priority_queue<vector<int>, vector<vector<int>> , Compare> pq;
        
        dist1[0][0] = 0;
        pq.push({0, 0, 0, 0});
        
        while(!pq.empty()){
            auto current = pq.top();
            pq.pop();
            
            int timee = current[0];
            int i = current[1];
            int j = current[2];
            int k = current[3];
            
            if(i == n-1 && j == m-1){
                return timee;
            }
            
            if( (k == 0 && timee > dist1[i][j]) ||
                (k == 1 && timee > dist2[i][j]) ){
                continue;
            }
            
            for(auto &[di, dj] : directions){
                int ni = i + di;
                int nj = j + dj;
                
                if(ni >= 0 && ni < n && nj >= 0 && nj < m){
                    
                    int cost = (k == 0) ? 1 : 2;
                    
                    int movee = max(timee, (int)moveTime[ni][nj]);
                    
                    int tot = movee + cost;
                    
                    if(k == 1){
                        if(tot < dist1[ni][nj]){
                            dist1[ni][nj] = tot;
                            pq.push({tot, ni, nj, 0});
                        }
                    }
                    else{
                        if(tot < dist2[ni][nj]){
                            dist2[ni][nj] = tot;
                            pq.push({tot, ni, nj, 1});
                        }
                    }
                }
            }
        }
        #undef int
        return -1;

    }
};",1441368729
Varun Deep Saini,sojabhai,240,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even_sum = 0; 
        int odd_sum = 0;  

        for(int i = 0; i < num.length(); ++i){
            if(i % 2 == 0){
                even_sum += num[i] - '0';
            }
            else{
                odd_sum += num[i] - '0';
            }
        }

        return even_sum == odd_sum;

    }
};",1441350550
Varun Deep Saini,sojabhai,240,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MOD = 1e9 + 7;
int z = 0;

int fact[102];
int inv_fact[102];

class Solution {
public:

    void pre() {
        if(z) return;
        z = 1;

        fact[0] = 1;
        for(int i = 1; i <= 101; i++) fact[i] = fact[i-1] * i % MOD;

        inv_fact[101] = power(fact[101], MOD - 2);
        for(int i = 100; i >= 0; i--) inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        
    }

    int power(int a , int b){
        int res = 1;
        a %= MOD;
        while(b > 0){
            if(b & 1){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int comb(int n, int r){
        return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        pre();
        map<int ,int> freq;
        int n = num.length();
        int sum = 0;
        for(auto &i : num){
            freq[i - '0']++;
            sum += i - '0';
        }
        
        if(sum % 2 != 0){
            return 0;
        }
        
        int target = sum / 2;
        
        int even = (n + 1) / 2; 
        int odd = n / 2;       
        
        vector<vector<int>> dp(target + 1, vector<int>(even + 1, 0));
        dp[0][0] = 1;
        
        for(int d = 0; d <= 9; d++){
            if(freq[d] == 0) continue;
            for(int i = target; i >= 0; i--){
                for(int j = even; j >= 0; j--){
                    if(dp[i][j] == 0) continue;

                    // add cnt d
                    for(int cnt = 1; cnt <= freq[d]; cnt++){
                        if(cnt + j > even) break;
                        if(i + cnt*d > target) break;
                        dp[i + cnt*d][j + cnt] = (dp[i + cnt*d][j + cnt] + dp[i][j] * comb(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        
        int ways = dp[target][even];
        
        int den = 1;
        for(int d = 0; d <= 9; d++) den = den * fact[freq[d]] % MOD;
        den = power(den, MOD - 2);

        int ans = ways * fact[even] % MOD;
        ans = ans * fact[odd] % MOD;
        ans = ans * den % MOD;
        
        return ans;
    }
};
#undef int",1441388578
otto,_otto,241,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        hp = []
        heappush(hp, (0, 0, 0))

        while hp:
            curr, r, c = heappop(hp)
            if r == n-1 and c == m-1:
                return curr
            if curr > dist[r][c]:
                continue
            for dr, dc in pairwise([-1, 0, 1, 0, -1]):
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < m:
                    new = max(curr, moveTime[nr][nc]) + 1
                    if new < dist[nr][nc]:
                        dist[nr][nc] = new
                        heappush(hp, (new, nr, nc))
        return -1",1441304953
otto,_otto,241,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        n = len(A)
        m = len(A[0])

        dist = [[[inf] * 2 for _ in range(m)] for _ in range(n)]
        dist[0][0][0] = 0

        hp = []
        heappush(hp, (0, 0, 0, 0))
        while hp:
            t, i, j, p = heappop(hp)
            if i == n-1 and j == m-1:
                return t
            if t > dist[i][j][p]: continue

            for di, dj in pairwise([-1, 0, 1, 0, -1]):
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    curr = max(t, A[ni][nj])
                    cos = 1 if p == 0 else 2
                    new = curr + cos
                    next_p = 1 - p
                    if new < dist[ni][nj][next_p]:
                        dist[ni][nj][next_p] = new
                        heappush(hp, (new, ni, nj, next_p))

        return -1
",1441323111
otto,_otto,241,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        a = b = 0
        for i, x in enumerate(str(num)):
            if i % 2 == 0:
                a += int(x)
            else:
                b += int(x)
        return a == b",1441281200
otto,_otto,241,3637,python3,"MOD = int(1e9 + 7)
MAXN = 81
fac = [1] * (MAXN + 1)
inv_fac = [1] * (MAXN + 1)
for i in range(1, MAXN + 1): fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN] = pow(fac[MAXN], MOD - 2, MOD)
for i in range(MAXN, 0, -1): inv_fac[i - 1] = inv_fac[i] * i % MOD
comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for n in range(MAXN + 1):
    comb[n][0] = 1
    for k in range(1, n + 1):
        comb[n][k] = (comb[n - 1][k - 1] + comb[n - 1][k]) % MOD

class Solution:
    def countBalancedPermutations(self, s: str) -> int:
        n = len(s)
        c = [0] * 10
        fuck = 0
        for ch in s: 
            c[int(ch)] += 1
            fuck += int(ch)
        if fuck % 2 != 0: return 0
        target = fuck // 2
        even = (n + 1) // 2
        odd = n // 2
        dp = [[0] * (even + 1) for _ in range(target + 1)]
        dp[0][0] = 1

        for d in range(10):
            f = c[d]
            if f == 0:
                continue
            ndp = [dp_row[:] for dp_row in dp]
            for s in range(target + 1):
                for cnt in range(even + 1):
                    v = dp[s][cnt]
                    if v == 0:
                        continue
                    for k in range(1, min(f, even - cnt) + 1):
                        news = s + d * k
                        newcnt = cnt + k
                        if news > target or newcnt > even: break
                        ndp[news][newcnt] = (ndp[news][newcnt] + v * comb[f][k]) % MOD
            dp = ndp

        shit = dp[target][even] # slots
        
        # combs
        fuck_even = fac[even]
        for d in range(10):
            for k in range(0, min(c[d], even) + 1):
                if k > even: break
                if target - d * k < 0: break
                if dp[s - d * k][even - k] == 0:continue
                ways = comb[c[d]][k]
                fuck_even = fuck_even * inv_fac[k] % MOD
                break
        fuck_odd = fac[odd]
        for d in range(10):
            fuck_odd = fuck_odd * inv_fac[c[d]] % MOD
        tot = fuck_even * fuck_odd % MOD

        return (shit * tot) % MOD",1441382688
garyjhu,garyjhu,242,3627,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + 1 < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + 1;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441295879
garyjhu,garyjhu,242,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                int e = (x + y) % 2 == 1 ? 1 : 2;
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + e < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + e;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441297024
garyjhu,garyjhu,242,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumE = 0, sumO = 0;
        int n = num.length();
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) sumE += num.charAt(i) - '0';
            else sumO += num.charAt(i) - '0';
        }
        return sumE == sumO;
    }
}
",1441284545
garyjhu,garyjhu,242,3637,java,"import java.util.ArrayList;
import java.util.Arrays;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);
    static long[] invFac;
    public int countBalancedPermutations(String num) {
        if (invFac == null) init();
        int n = num.length();
        int sum = 0;
        int[] count = new int[10];
        for (char c : num.toCharArray()){
            sum += c - '0';
            count[c - '0']++;
        }
        if (sum % 2 == 1) return 0;
        int goal = sum / 2;
        long[][] dp = new long[n + 1][goal + 1];
//        ModIntFactory.ModInt[][] dp = new ModIntFactory.ModInt[n + 1][goal + 1];
//        for (ModIntFactory.ModInt[] row : dp) Arrays.fill(row, factory.create(0));
        dp[0][0] = 1;
//        dp[0][0] = factory.create(1);
        for (int i = 0; i < 10; i++) {
            long[][] tp = new long[n + 1][goal + 1];
//            ModIntFactory.ModInt[][] tp = new ModIntFactory.ModInt[n + 1][goal + 1];
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) tp[j][k] = factory.create(0);
//            }
            for (int j = 0; j < n; j++) {
                for (int k = 0; k <= goal; k++) {
                    for (int l = 0; l <= count[i]; l++) {
                        if (j + l <= n && k + l * i <= goal) {
                            tp[j + l][k + l * i] = (tp[j + l][k + l * i] + factory.create(dp[j][k]).mul(invFac[l]).mul(invFac[count[i] - l]).value);
//                            tp[j + l][k + l * i].addAsg(dp[j][k].mul(factory.factorial(l).mul(factory.factorial(count[i] - l)).inv()));
                        }
                    }
                }
            }
            dp = tp;
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) {
//                    System.out.print(dp[j][k] + "" "");
//                }
//                System.out.println();
//            }
//            System.out.println();
        }
//        System.out.println();
        return factory.factorial(n / 2).mul(factory.factorial((n + 1) / 2)).mul(dp[n / 2][goal]).value;
//        ModIntFactory.ModInt res = dp[n / 2][goal].mul(factory.factorial(n / 2)).mul(factory.factorial((n + 1) / 2));
//        return res.value;
    }
    
    static void init() {
        invFac = new long[100];
        for (int i = 0; i < 100; i++) invFac[i] = factory.factorial(i).inv().value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1441383191
samjack,samjack,243,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time + 1, moveTime[nx][ny] + 1)
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
        
        return -1",1441292166
samjack,samjack,243,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy

                time += ((nx + ny + 1) % 2 + 1)
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time, moveTime[nx][ny] + ((nx + ny + 1) % 2 + 1))
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
                time -= ((nx + ny + 1) % 2 + 1)
        
        return -1
",1441307140
samjack,samjack,243,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum, odd_sum = 0, 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum
",1441281017
samjack,samjack,243,3637,cpp,"#include <bits/stdc++.h>
#define vi vector<int>
#define vb vector<bool>
#define vl vector<long long>
#define vii vector<vector<int>>
#define vll vector<vector<long long>>
#define pi pair<int, int>
#define pl pair<ll, ll>
#define vpi vector<pair<int, int>>
#define vpl vector<pair<ll, ll>>
#define a first 
#define b second
#define pb push_back
#define hset unordered_set
#define hmap unordered_map
#define vm vector<mi>
#define vmm vector<vector<mi>>
using namespace std;
const int MOD = 1e9+7;
using ll = long long;
using big = __int128_t;
using ld = long double;
int uMin(int& a, int b){return a = min(a,b);}
int uMax(int& a, int b){return a = max(a,b);}
struct mi {
  ll v;
  explicit operator int() const { return v; }
  mi() { v = 0; }
  mi(ll _v) : v(_v % MOD) { v += (v < 0) * MOD; }
  bool operator<(const mi& other) const {
    return v < other.v;
  }
  friend std::ostream& operator<<(std::ostream& os, const mi& m) {
      os << m.v;
      return os;
  }
};
mi &operator+=(mi &a, mi b) {
  if ((a.v += b.v) >= MOD) a.v -= MOD;
  return a;
}
mi &operator-=(mi &a, mi b) {
  if ((a.v -= b.v) < 0) a.v += MOD;
  return a;
}
mi operator+(mi a, mi b) { return a += b; }
mi operator-(mi a, mi b) { return a -= b; }
mi operator*(mi a, mi b) { return mi(a.v * b.v); }
mi &operator*=(mi &a, mi b) { return a = a * b; }
mi pow(mi a, ll p) {
  assert(p >= 0);
  return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);
}
mi inv(mi a) {
  assert(a.v != 0);
  return pow(a, MOD - 2);
}
mi operator/(mi a, mi b) { return a * inv(b); }
bool operator==(mi a, mi b) {return a.v == b.v;}
template <class T>
class Matrix {
private:
    vector<std::vector<T>> data;
    size_t size;
public:
    Matrix(size_t n, T v = T()) : size(n), data(n, std::vector<T>(n, v)) {}
    Matrix(const Matrix<T>& other) : size(other.size), data(other.data) {}
    T& operator()(size_t i, size_t j) { return data[i][j]; }
    const T& operator()(size_t i, size_t j) const { return data[i][j]; }
    Matrix<T> operator+(const Matrix<T>& other) const {
        Matrix<T> result(size);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result(i, j) = data[i][j] + other(i, j);
        return result;
    }
    Matrix<T> operator*(const Matrix<T>& other) const {
        Matrix<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                for (size_t k = 0; k < size; ++k)
                    result(i, k) += data[i][j] * other(j, k);
        return result;
    }
    std::vector<T> operator*(const std::vector<T>& vec) const {
        std::vector<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result[j] += data[i][j] * vec[i];
        return result;
    }
    Matrix<T> pow(ll e) const {
        Matrix<T> result = identity(size);
        Matrix<T> base = *this;
        while(e) {
            if(e&1) result = result * base;
            base = base * base;
            e>>=1;
        }
        return result;
    }
    bool operator==(const Matrix<T>& other) const {
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                if (data[i][j] != other(i, j))
                    return false;
        return true;
    }
    static Matrix<T> identity(size_t n) {
        Matrix<T> id(n, 0);
        for (size_t i = 0; i < n; ++i)
            id(i, i) = 1;
        return id;
    }
    friend std::ostream& operator<<(std::ostream& os, const Matrix<T>& matrix) {
        os << ""[\n"";
        for (const auto& row : matrix.data) {
            os << ""\t["";
            for(int i = 0; i<row.size(); i++)
                os << row[i] << (i==row.size()-1?""]\n"":"", "");
        }
        os << ""]\n"";
        return os;
    }
};
template <class T> class BIT {
    int N; vector<T> data;
    bool c, queried;
    public:
    BIT(int _N, bool constant) : c(constant) {
        N = _N+1;
        data.resize(N);
        if(constant) queried = 0;
    }
    void add(int p, T x) { if(c){assert(!queried); data[p]+=x;}else for (p++;p<=N;p+=p&-p) data[p-1]+=x; }
    T sum(int l, int r) { return sum(r)-(l==0?0:sum(l-1)); }
    T sum(int r) { 
        if(c){
            if(!queried){
                queried = 1;
                partial_sum(data.begin(),data.end(),data.begin());
            }
            return data[r];
        }
        T s = 0; r++; for(;r;r-=r&-r)s+=data[r-1]; return s; }
    int lower_bound(T sum) {
        assert(!c);
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1<<25; pw; pw >>= 1) {
            int npos = pos+pw;
            if (npos <= N && data[npos-1] < sum)
                pos = npos, sum -= data[pos-1];
        }
        return pos;
    }
};
template <class T> class RURQ {
    BIT<T> bit1, bit2;
    int sz;
    RURQ(int size) : sz(size), bit1(size), bit2(size) {}
    void add(int start, int end, T value) {
        bit1.add(start, value);
        bit2.add(start, value*(start - 1));
        if(end != sz-1){
            bit1.add(end+1, -value);
            bit2.add(end+1, -value*end);
        }
    }
    T pref(int index) {
        if(index==-1) return 0;
        return (bit1.sum(index))*index-bit2.sum(index);
    }
    T sum(int start, int end) {
        return pref(end)-pref(start-1);
    }
};
struct Line {
    long double m,b;
    Line(long double slope, long double yIntercept) : m(slope), b(yIntercept) {}
    long double getY(long double x) const {
        return m * x + b;
    }
};

struct LineContainer {
    std::vector<Line> lines;
    bool isAbove(const Line& l1, const Line& l2, const Line& l3) const {
        return (l3.b - l1.b) * (l1.m - l2.m) > (l2.b - l1.b) * (l1.m - l3.m);
    }
    void add(long double slope, long double yIntercept) {
        Line newLine(slope, yIntercept);
        while (lines.size() >= 2 && !isAbove(lines[lines.size() - 2], 
                                    lines[lines.size() - 1], newLine))
            lines.pop_back();
        lines.push_back(newLine);
    }
    long double queryMax(long double x) const {
        if (lines.empty())
            return -LLONG_MAX;
        int left = 0, right = lines.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (lines[mid].getY(x) < lines[mid + 1].getY(x))
                left = mid + 1;
            else right = mid;
        }
        return lines[left].getY(x);
    }
};
vl euclid(ll a, ll b) {
    vl x = {1, 0, a};
    vl y = {0, 1, b};
    while(y[2]){
        ll k = x[2] / y[2];
        x[0]-=k*y[0];
        x[1]-=k*y[1];
        x[2]-=k*y[2];
        swap(x, y);
    }
    return x;  // x[0] * a + x[1] * b = x[2], x[2] = gcd(a, b)
}
pl modSolver(vpl& mods){
    pl ans = {mods[0].a,mods[0].b};
    for(int i = 1; i<mods.size(); i++){
        vl g = euclid(ans.b, mods[i].b);
        if((mods[i].a-ans.a)%g[2]) return {-1,-1};
        ans.a+=(mods[i].a-ans.a)/g[2]*ans.b*g[0];
        ans.b = ans.b/g[2]*mods[i].b;
        ans.a%=ans.b;
        ans.a+=ans.b;
        ans.a%=ans.b;
    }
    return ans;
}
int sq(ll n){
    ll a = 0;
    for(int i = 31; i>=0; i--){
        ll x = 1<<i|a;
        if(x*x <= n) a = x;
    }
    return a;
}
struct LZST {
    ll n;
    vector<pair<vl,bool>> nodes; // [[val,min,max,add],isSet]
    vi left,right;
    private:
        void set(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0] = num*(r-l+1);
            g[1] = g[2] = g[3] = num;
            nodes[i].b = 1;
        }
        void add(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0]+=num*(r-l+1);
            g[1]+=num;
            g[2]+=num;
            g[3]+=num;
        }
        void prop(int i, ll l, ll r){
            ll m = l+((r-l)>>1);
            if(left[i] == -1){
                left[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(right[i] == -1){
                right[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(nodes[i].b){
                nodes[i].b = 0;
                if(l != r){
                    ll a = nodes[i].a[3];
                    set(a,left[i],l,m);
                    set(a,right[i],m+1,r);
                }
            }else if(nodes[i].a[3]){
                if(l != r){
                    ll a = nodes[i].a[3];
                    add(a,left[i],l,m);
                    add(a,right[i],m+1,r);
                }
            }
            nodes[i].a[3] = 0;
        }
        void upd(int i){
            vl& g = nodes[i].a, l = nodes[left[i]].a, r = nodes[right[i]].a;
            g[0] = l[0]+r[0];
            g[1] = l[1]<r[1]?l[1]:r[1];
            g[2] = l[2]>r[2]?l[2]:r[2];
        }
        void set(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                set(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) set(s,e,num,left[i],l,m);
            else if(s > m) set(s,e,num,right[i],m+1,r);
            else{
                set(s,m,num,left[i],l,m);
                set(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        void add(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                add(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) add(s,e,num,left[i],l,m);
            else if(s > m) add(s,e,num,right[i],m+1,r);
            else{
                add(s,m,num,left[i],l,m);
                add(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        ll sum(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[0];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return sum(s,e,left[i],l,m);
            if(s > m) return sum(s,e,right[i],m+1,r);
            return sum(s,m,left[i],l,m)+sum(m+1,e,right[i],m+1,r);
        }
        ll min(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[1];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return min(s,e,left[i],l,m);
            if(s > m) return min(s,e,right[i],m+1,r);
            ll a = min(s,m,left[i],l,m), b = min(m+1,e,right[i],m+1,r);
            return a<b?a:b;
        }
        ll max(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[2];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return max(s,e,left[i],l,m);
            if(s > m) return max(s,e,right[i],m+1,r);
            ll a = max(s,m,left[i],l,m), b = max(m+1,e,right[i],m+1,r);
            return a>b?a:b;
        }
    public:
        LZST(ll N){
            n = N;
            nodes.pb({vl(4),0});
            left.pb(-1);
            right.pb(-1);
        }
        void set(ll s, ll e, ll num){
            set(s,e,num,0,0,n-1);
        }
        void add(ll s, ll e, ll num){
            add(s,e,num,0,0,n-1);
        }
        ll sum(ll s, ll e){
            return sum(s,e,0,0,n-1);
        }
        ll min(ll s, ll e){
            return min(s,e,0,0,n-1);
        }
        ll max(ll s, ll e){
            return max(s,e,0,0,n-1);
        }
        ll get(ll s){
            return sum(s,s,0,0,n-1);
        }
        void add(ll s, ll num){
            add(s,s,num,0,0,n-1);
        }
        void set(ll s, ll num){
            set(s,s,num,0,0,n-1);
        }
        friend std::ostream& operator<<(std::ostream& os, LZST& m) {
            os << ""["";
            for(int i = 0; i<m.n; i++) os << m.get(i) << (i==m.n-1?""]"":"", "");
            return os;
        }
};
int dGet(int a, vi& d){return d[a]<0?a:(d[a]=dGet(d[a],d));}
bool unite(int a, int b, vi& d){
    a = dGet(a,d), b = dGet(b,d);
    if(a == b) return 0;
    if(d[a]>d[b]) swap(a,b);
    d[a]+=d[b];
    d[b] = a;
    return 1;
}
int lg(int n){
    int i = 0;
    for(n>>=1; n; n>>=1) i++;
    return i;
}
vector<pair<vm,vm>> genSeeds(int cnt){
    auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();
    mt19937 rng(static_cast<unsigned int>(seed));
    vector<pair<vm,vm>> ans(cnt,{vm(2),vm(2)});
    for(int i = 0; i<cnt; i++){
        ans[i].a[0]=ans[i].b[0]=1;
        ans[i].a[1] = uniform_int_distribution<int>(1,MOD-1)(rng);
        ans[i].b[1] = 1/ans[i].a[1];
    }
    return ans;
}
struct Hash {
    vector<pair<vm,vm>>& h;
    string s;
    vector<pair<BIT<mi>,BIT<mi>>> v;
    void resizeHashes(int n){
        while(h[0].a.size() < n){
            int sz = h[0].a.size();
            for(int i = 0; i<h.size(); i++){
                h[i].a.pb(h[i].a[sz-1]*h[i].a[1]);
                h[i].b.pb(h[i].b[sz-1]*h[i].b[1]);
            }
        }
    }
    Hash(string& str, vector<pair<vm,vm>>& seeds, bool constant=1) : h(seeds),s(str){
        resizeHashes(str.size());
        v.reserve(h.size());
        for(int i = 0; i<h.size(); i++) v.emplace_back(BIT<mi>(s.size(),constant),BIT<mi>(s.size(),constant));
        for(int i = 0; i<s.size(); i++){
            for(int j = 0; j<h.size(); j++){
                v[j].a.add(i,(s[i]+1)*h[j].a[i]);
                v[j].b.add(i,(s[i]+1)*h[j].b[i]);
            }
        }
    }
    void rep(int ind, char c){
        for(int i = 0; i<h.size(); i++){
            v[i].a.add(ind,(c-s[ind])*h[i].a[ind]);
            v[i].b.add(ind,(c-s[ind])*h[i].b[ind]);
        }
        s[ind] = c;
    }
    pair<vm,int> get(int a, int b){
        bool rev = a>b;
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = v[i].b.sum(b,a)*h[i].a[a];
            else ans[i] = v[i].a.sum(a,b)*h[i].b[a];
        return {ans,abs(a-b)+1};
    }
    pair<vm,int> comb(pair<vm,int>& left, pair<vm,int>& right, bool rev=0){
        resizeHashes(rev?right.b:left.b);
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = left.a[i]*h[i].a[right.b]+right.a[i];
            else ans[i] = left.a[i]+right.a[i]*h[i].a[left.b];
        return {ans,left.b+right.b};
    }
};
struct PairHash {
    size_t operator()(const std::pair<std::vector<mi>, int>& p) const {
        return p.a[0].v;
    }
};
class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> cnt(10);
        for(char c: num) cnt[c-'0']++;
        vector<mi> fac(n+1);
        fac[0] = 1;
        for(int i = 1; i<=n; i++) fac[i] = fac[i-1]*i;
        vector<mi> facInv(n+1);
        for(int i = 0; i<=n; i++) facInv[i] = 1/fac[i];
        int sum = 0;
        for(char c: num) sum+=c-'0';
        if(sum&1) return 0;
        vector<vector<mi>> dp((sum>>1)+1,vector<mi>(num.size()/2+1));
        dp[0][0] = fac[n/2]*fac[(n+1)/2];
        for(int i = 0; i<10; i++)
            for(int j = dp.size()-1; j>=0; j--)
                for(int k = dp[j].size()-1; k>=0; k--)
                    for(int l = 0; l<=min(i?j/i:INT_MAX,min(cnt[i],k)); l++)
                        if(l == 0) dp[j][k] = dp[j][k]/fac[cnt[i]];
                        else dp[j][k]+=dp[j-l*i][k-l]*facInv[l]*facInv[cnt[i]-l];
        return dp[dp.size()-1][dp[0].size()-1].v;
    }
};",1441352749
James_067,James_067,245,3627,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 1 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441304201
James_067,James_067,245,3628,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 2 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441303283
James_067,James_067,245,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) 
    {
        int sum1 = 0 , sum2 = 0;
        for( int i = 0; i < s.size(); i++ )
        {
             if(i&1) sum1 += ( s[i] - '0' );
            else sum2 += ( s[i] - '0' );
        }
        return sum1 == sum2;
    }
};",1441281735
James_067,James_067,245,3637,cpp,"
#define MOD 1000000007
#define ll long long

ll mod(ll a, ll m = MOD) { return (a % m + m) % m; }

template <class T>
class Math 
{
public:
    vector<T> fact, invfact;
    Math() {}
    Math(int n) 
    {
        fact.resize(n + 1);
        invfact.resize(n + 1);

        fact[0] = invfact[0] = 1;
        for (int i = 1; i <= n; i++) 
        {
            fact[i] = mod(i * fact[i - 1]);
            invfact[i] = modinv(fact[i]);
        }
    }
    T modinv(T x, T m = MOD) { return expo(x, m - 2, m); }
    T expo(T base, T exp, T m = MOD) 
    {
        T res = 1;
        while (exp) 
        {
            if (exp & 1) res = mod(res * base, m);
            base = mod(base * base, m);
            exp >>= 1;
        }
        return res;
    }
    T choose(T n, T k) 
    {
        if (k < 0 || k > n || n < 0) return 0;
        T ans = fact[n];
        ans = mod(ans * invfact[n - k]);
        ans = mod(ans * invfact[k]);
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string s) 
    {
        int n = s.size(), tot_d_sum = 0;
        int n1 = (n + 1) / 2 , n2 = n - n1;
        
        Math<ll> M(s.size());
        
        vector<int> freq(10);
        for (auto& d : s) 
        {
            freq[d - '0']++;
            tot_d_sum += (d - '0');
        }
        
        if (tot_d_sum % 2 != 0) return 0;
        
        int target_sum = tot_d_sum / 2;
        
        int dp[11][1001][41][41];
        memset(dp, -1, sizeof(dp));
        
        auto f = [&](auto&& self, int i, int j, int k, int l) -> ll
        {
            if (k > n1 || j > target_sum || l > n2 ) return 0;
            if (i == 10) return (j == target_sum && k == n1) ? 1 : 0;
            if (dp[i][j][k][l] != -1) return dp[i][j][k][l];
            
            ll result = 0;
            for (int c = 0; c <= freq[i]; ++c) 
            {
                if (c <= n1 - k && j + c * i <= target_sum && freq[i] - c <= n2 - l) 
                {
                    ll ways_to_choose_c = 1;
                    ll ways_to_fill_remaining = mod(M.choose(n1 - k, c)* M.choose(n2 - l , freq[i] - c));
                    result = (result + mod(mod(ways_to_choose_c * ways_to_fill_remaining) * self(self, i + 1, j + c * i, k + c, l + (freq[i] - c)))) % MOD;
                }
            }
            
            return dp[i][j][k][l] = result;
        };
        
        return f(f, 0, 0, 0, 0);
    }
};
",1441390801
xymabinogi,xymabinogi,246,3627,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = 1;
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441303362
xymabinogi,xymabinogi,246,3628,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = ((ni + nj) % 2 == 0 ? 2 : 1);
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441302979
xymabinogi,xymabinogi,246,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int even = 0, odd = 0;
        for (int i = 0; i < n; i++){
            int v = num[i] - '0';
            if (i % 2) even += v;
            else odd += v;
        }
        return even == odd;
    }
};",1441281584
xymabinogi,xymabinogi,246,3637,cpp,"using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1E9 + 7;
using Z = MInt<P>;
 
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        vector<int> cnt(10, 0);
        int tot = 0;
        for (auto ch : num){
            cnt[ch - '0']+= 1;
            tot += (ch - '0');
        }
        if (tot % 2) return 0;
        tot /= 2;
        
        Z res = 0;
        int n_first = n / 2 + n % 2;
        int n_second = n / 2;
       
        
        vector<vector<Z>> dp(n_first + 1, vector<Z>(tot + 1));
        dp[0][0] = Z(1);
        
        
        
        for (int i = 0; i < 10; i++) if (cnt[i]){
            for (int k = n_first; k >= 0; k--){
                for (int l = tot; l >= 0; l--){
                    if (!dp[k][l].val()) continue;
                    for (int j = 1; j <= cnt[i]; j++){
                        if (k + j > n_first) continue;
                        if (l + j * i <= tot){
                            dp[k + j][l + j * i] += dp[k][l] * comb.binom(cnt[i], j);
                        }
                    }
                }
            }
        }
        Z multi = comb.fac(n_first) * comb.fac(n_second);
        for (int i = 0; i < 10; i++){
            multi *= comb.invfac(cnt[i]);
        }
        
        dp[n_first][tot] *= multi;
        return  dp[n_first][tot].val();
        
        
        
        
        
    }
};",1441374001
luck,papaya,247,3627,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited ; 
        priority_queue< tuple<int64, int64 >> q ; 
        
        visited.assign( n , false ) ;  
        dis.assign( n , INF ); 

        dis[ src ] = 0 ; //start_time[ src ] ; 
        q.emplace( -dis[ src ] ,  src ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }
            if( visited[ u ] ) {
                continue ; 
            }
            visited[ u ] = true ; 
            for( auto [ v , w ] : g[u] ) {
                if( visited[v] ) {
                    continue ; 
                }
                int64 DD  = dis[u] + w ; 
                DD = max( DD , start_time[v] + 1 ) ; 

                if( dis[v] >  DD ) {
                    
                    dis[v] = DD ;
                    q.emplace( -dis[v] , v ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int ma22in( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 } ,  { 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    a = { { 56 , 93 } , { 3 , 38 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441312773
luck,papaya,247,3628,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis[2] ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited[2]; 
        priority_queue< tuple<int64, int64 , int  >> q ; 
        
        visited[0].assign( n , false ) ;  
        visited[1] = visited[0] ; 

        dis[0].assign( n , INF ); 
        dis[1].assign( n , INF ) ; 

        dis[1][ src ] = 0 ; //start_time[ src ] ; 
        q.emplace(  0  ,  src , 1 ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u , is_odd ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            int W = 2 ; 
            if( is_odd ) {
                W = 1 ; 
            }

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }

            if( visited[ is_odd ][ u ] ) {
                continue ; 
            }
            visited[ is_odd ][ u ] = true ; 

            int next_odd = 1 - is_odd ; 

            for( auto [ v , _ ] : g[u] ) {
                if( visited [ next_odd ] [ v ] ) {
                    continue ; 
                }
                int64 DD  = now_acc_cost + W ; 
                DD = max( DD , start_time[v] + W ) ; 

                if( dis[next_odd][v] >  DD ) {
                    
                    dis[next_odd][v] = DD ;
                    q.emplace( -dis[next_odd][v] , v , next_odd ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int mai33n( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 , 0 } ,  { 0 , 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    // a = { { 56 , 93 } , { 3 , 38 } } ; 


    a = { { 0,58 } , { 27,69 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441324094
luck,papaya,247,3636,python3,"import math 
import copy
from typing import * 
from heapq import * 
from collections import * 

class Solution:
    def isBalanced(self, num: str) -> bool:
        
        
        a = [ int( x ) for x in num ] ; 
        n = len( a ) ; 
        
        
        s1 = 0 ; 
        s2 = 0 ;
        
        for i in range( n ) :
            if( i % 2 == 0 ) :
                s1 += a[i] ; 
            else  :
                s2 += a[i] ;
        
        # print( s1 , s2 ) ; 
        
        return s1 == s2 ; 
    
    
def main( ) : 

    t = Solution() ; 

    num = ""1234""
    
    # num = ""24123"" ; 
    
    ans = t.isBalanced ( num ) ; 

    print(  ans ); 

if __name__ == '__main__':
    main()",1441289883
luck,papaya,247,3637,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 INF = 1e18 ; 
const int64 MOD = 1e9 + 7 ; 
const int BASE = 720 ; //int64 base = 720 ; 
const int UP =  BASE * 2 ; 

struct Comb { 
    vector< vector<int64> > C ;
    int n ; 

    void init( int tn ){
        n = tn ;
        C.assign( n + 1 , vector<int64>( n + 1 , 0 ) ) ;

        C[0][0] = 1 ; 
        for( int i = 1 ; i <= n ; i++ ) {
            C[i][0] = C[i][i] = 1 ; 
            for(int j = 1 ; j < i ; j++ ) {
                C[i][j] = C[i-1][j] + C[i-1][j-1] ;
                C[i][j] %= MOD ;
            }
        }
    }
} ; 

class Solution {
public:
    vector<int> a  , cnt ; 
    int n ; 
    int need_select ; 
    Comb comb ; 
    vector< int > aft_sum ; 

    int get( char c ) {
        return int( c ) - int( '0' ) ; 
    }
    vector< vector< vector<int64 >> > cache ; // f[2] ; 
    
    int64 dp( int choices , int other_choices  ,  int d  , int sum ) { 
        
        // cout << "" choices: "" << choices << "" D: "" << d << "" sum: "" << sum << ""\n"" ; 

        if( d >= 10 ) {
            return (choices == 0 && sum == BASE) ? 1 : 0 ; 
        }
        auto &ret = cache[ choices][d][sum] ;
        if( -1 != ret ) {
            return ret ;
        }
        ret = 0 ; 

        if( aft_sum[d] +  sum < BASE ) { // all select 
            return 0 ; 
        }
        if( aft_sum[d] - sum > BASE ) { // all not select 
            return 0 ; 
        }


        int all_s = cnt[d] * d ; 
        int all_cnt = cnt[d] ; 
        for( int select_cnt = 0 ; select_cnt <= cnt[d] && select_cnt <= choices ;  select_cnt++ ) { 
            
            if( other_choices - (all_cnt-select_cnt)  < 0 ) {
                continue ; 
            }
            
            int select_sum_s1 = d * select_cnt ; 
            int other_s2 = all_s - select_sum_s1 ; 

            int64 cnt = dp( choices - select_cnt ,  other_choices - (all_cnt-select_cnt) ,  d + 1 , sum + select_sum_s1 - other_s2 ) ; 
            int64 cnt2 = comb.C[ choices ][ select_cnt ] ; 
            int64 cnt3 = comb.C[ other_choices ] [ all_cnt - select_cnt ] ; 

            int64 t_ans = ( cnt * cnt2 ) % MOD ; 
            t_ans = ( t_ans * cnt3 ) % MOD ; 

            // if( select_cnt >= 1 ) { 
            //     // cout << "" choices: "" << choices << "" selec_cnt: "" << select_cnt << "" D: "" <<d << "" t_ans: "" << t_ans << ""\n"" ; 
            // }

            ret = ( ret + t_ans ) % MOD ; 
        }
        return ret ; 
    }

    void init( ) { 
        aft_sum.assign( 13 , 0 ) ; 
        for( int j = 9 ; j >= 0 ; j-- ) {
            int val = cnt[j] * j ; 
            aft_sum[j] = aft_sum[j+1] + val ; 
        }
    }
    int solve() { 
        init() ; 

        comb.init( n + 1 ) ; 

        cache.resize( n + 1 ) ; 
        for( int i = 0 ; i <= n ;i++ ) { 
            cache[i].assign( 10 , vector<int64> ( UP + 1 , -1  )) ; 
        }

        int sum = accumulate( a.begin()  ,a.end() , 0 ) ; 
        if( sum % 2 != 0 ) {
            return 0 ; 
        }
        auto ans = dp(  need_select  , n - need_select ,   0 , BASE  ) ; 
        return ans ; 
    }
    int countBalancedPermutations(string num) {

        n = num.size() ; 
        need_select = ( n + 1 ) / 2 ; 
        
        cnt.assign( 10 , 0 ) ; 
        a.assign( n + 1 , 0 ) ; 
        for( int i = 0 ; i < n ; i++ ) { 
            int d = get( num[i] ) ; 
            a[ i + 1 ] = d ; 
            cnt[d]++ ; 
        }
        return solve() ;  
    }
};




int ma33in( )  { 
    Solution  t; 

    string s = ""123"" ; 

    // s = ""112"" ; 

    // s = ""12345"" ; 

    // s = ""4567"" ; 

    auto ans = t.countBalancedPermutations ( s ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441380293
Aylup,Aylup,248,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 3>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto [d, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + 1, moveTime[rd][cd] + 1), rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441314422
Aylup,Aylup,248,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 4>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto [d, b, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + b + 1, moveTime[rd][cd] + b + 1), b ^ 1, rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441316347
Aylup,Aylup,248,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i % 2) {
                ans += num[i] - '0';
            } else {
                ans -= num[i] - '0';
            }
        }
        return ans == 0;
    }
};",1441294643
Aylup,Aylup,248,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9 + 7
        total = sum(map(int, num))
        if total % 2 != 0:
            return 0
        n = len(num)
        m = (n + 1) // 2
        m2 = n // 2
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i
            fact[i] %= mod
        target = total // 2
        count = Counter(map(int, num))
        pfx = [0] * 11
        for i in range(10):
            pfx[i] = pfx[i - 1] + count[i]
        @cache
        def dp(i, j, k):
            if k > target:
                return 0
            if i == 10:
                if j != m or k != target:
                    return 0
                return (fact[m] * fact[m2]) % mod
            ans = 0
            high = min(m, count[i])
            for z in range(0, high + 1):
                val = dp(i + 1, j + z, k + z * i)
                val *= pow(fact[z], -1, mod)
                val %= mod
                val *= pow(fact[count[i] - z], -1, mod)
                val %= mod
                
                ans += val
                ans %= mod
            return ans
        return dp(0, 0, 0)",1441381250
abhishek vaish,abhishekvaish,249,3627,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + 1, moveTime[nx][ny]+1):
                    dist[nx][ny] = max(dist[i][j] + 1, moveTime[nx][ny] + 1)
                    hpush(h, (dist[nx][ny], nx, ny) )
                
        # return 
                
        ",1441294943
abhishek vaish,abhishekvaish,249,3628,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0,1) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j,mv = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + mv, moveTime[nx][ny]+mv):
                    dist[nx][ny] = max(dist[i][j] + mv, moveTime[nx][ny] + mv)
                    hpush(h, (dist[nx][ny], nx, ny,  1 if mv == 2 else 2  ) )
                ",1441299436
abhishek vaish,abhishekvaish,249,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o = 0,0
        for i in range(len(num)):
            if i % 2 == 0:
                e += int(num[i])
            else:
                o += int(num[i])
        return e == o
            ",1441281220
abhishek vaish,abhishekvaish,249,3637,python3,"MOD = 10**9+7
fact = [1] * 81
ifact = [1] * 81
for i in range(1,81):
    fact[i] = (i * fact[i-1]) % MOD

ifact[80] = pow(fact[80],-1,MOD)
for i in range(79,-1, -1):
    ifact[i] = (ifact[i+1] * (i+1)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int,num))
        if s%2 == 1: return 0
        mx = [0]*10
        for x in num:
            mx[int(x)] += 1
        # print(""---""*n)
        def count_perm(count):
            # print(count)
            si = sum(count)
            p1, p2 = fact[si] , fact[n - si]
            for i in range(10):
                c1 = count[i]
                c2 = mx[i] - count[i]
                p1 = (p1 * ifact[c1]) % MOD
                p2 = (p2 * ifact[c2]) % MOD
                
            
            return (p1 * p2) % MOD
        
        @cache
        def DP(x, ele, target):
            if ele < 0 : return 0
            if target < 0 : return 0
            if x == 10 :
                if ele == 0 and target == 0:
                    return (fact[n//2] * fact[n-(n//2)]) % MOD
                return 0
            
            p = 0
            for i in range(mx[x]+1):
                c = DP(x+1,ele-i, target - (x*i))
                p += (c * ifact[i] * ifact[mx[x]-i]) % MOD
            return p % MOD
        
        return DP(0,n//2,s//2)
            
            
        
#         def dfs(x, count):
#             if x == 10:
#                 # print(count)
#                 sum_ = sum([ x*i for i,x in enumerate(count)])
#                 sum_i = sum(count)
#                 if n % 2 == 0 and sum_i != n // 2:
#                     return 0
#                 if n % 2 == 1 and sum_i != n // 2 :
#                     return 0
#                 if sum_ == s // 2 :
#                     return count_perm(count)
#                 return 0 
            
#             res = 0
#             for i in range(mx[x]+1):
#                 count[x] = i
#                 res = (res + dfs(x+1, count)) % MOD
#             count[x] = 0
#             return res
        
#         return dfs(0,[0]*10)

# 2
# 1
# 0
# 793764298
# 144920189
            
        ",1441382043
Zardinality,Zardinality,250,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<long long>> dist(n, vector<long long>(m, LLONG_MAX));
        dist[0][0] = 0;
        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>,
                      greater<pair<long long, pair<int, int>>>> pq;
        
        pq.push({0, {0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + 1LL;
                    
                    if (wait_time < dist[new_row][new_col]) {
                        dist[new_row][new_col] = wait_time;
                        pq.push({wait_time, {new_row, new_col}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441326235
Zardinality,Zardinality,250,3628,cpp,"using ll = long long;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, LLONG_MAX)));
        dist[0][0][0] = 0;
        priority_queue<pair<ll, array<int, 3>>, 
                      vector<pair<ll, array<int, 3>>>,
                      greater<pair<ll, array<int, 3>>>> pq;
        
        pq.push({0, {0, 0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col, step] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col][step]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + (step == 0?1LL:2LL);
                    int nstep = 1-step;
                    if (wait_time < dist[new_row][new_col][nstep]) {
                        dist[new_row][new_col][nstep] = wait_time;
                        pq.push({wait_time, {new_row, new_col, nstep}});
                    }
                }
            }
        }
        auto& pres = dist[n-1][m-1];
        return min(pres[0], pres[1]);
    }
};",1441339665
Zardinality,Zardinality,250,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ns = num.size();
        int en = 0;
        int on = 0;
        for(int i=0;i<ns;i++){
            if(i%2){
                en += (num[i]-'0');
            }
            else{
                on += (num[i]-'0');
            }
        }
        return en == on;
    }
};",1441287239
Zardinality,Zardinality,250,3637,cpp,"#define PRIME 1000000007
using ll = long long;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int ns = num.size();
        vector<int> buf(ns, 0);
        int tsum = 0;
        for(int i=0;i<ns;i++){
            buf[i] = num[i]-'0';
            tsum += buf[i];
        }
        vector<int> freq(10, 0);
        for (char c : num) {
            freq[c - '0']++;
        }
        
        if(tsum%2) return 0;
        int target = tsum/2;
        int even_cnt = ns/2;
        vector<vector<ll>> dp(even_cnt+1, vector<ll>(target+1, 0));
        dp[0][0] = 1;
        for(int i=0;i<ns;i++){
            vector<vector<ll>> ndp = dp;
            int cdigit = buf[i];
            for(int j=0;j<even_cnt;j++){
                for(int k=0;k<=target;k++){
                    if(k+cdigit<=target){
                        // std::cout<<j+1<<"" ""<<k+cdigit<<"" ""<<dp.size()<<"" ""<<dp[0].size()<<endl;
                        ndp[j+1][k+cdigit] += dp[j][k];
                        ndp[j+1][k+cdigit] %= PRIME;
                    }
                }
            }
            dp = std::move(ndp);
        }
        int num_subsets = dp.back().back();
        auto factorial = [](int n){
            if(!n) return 1LL;
            ll res = n;
            while(--n){
                res *= n;
                res %= PRIME;
            }
            return res;
        };
                auto modPow = [&](ll base, ll exp) {
            ll result = 1;
            while (exp > 0) {
                if (exp & 1) result = (result * base) % PRIME;
                base = (base * base) % PRIME;
                exp >>= 1;
            }
            return result;
        };
        
        auto modInverse = [&](ll n) {
            return modPow(n, PRIME - 2);
        };
        // cout<<num_subsets<<"" ""<<factorial(even_cnt)<<endl;
        ll even_fact = factorial(even_cnt);
        ll odd_fact = factorial(ns-even_cnt);
        auto result = ((num_subsets * even_fact) % PRIME) * odd_fact % PRIME;
                
        for (int i = 0; i < 10; i++) {
            if (freq[i] > 1) {
                result = (result * modInverse(factorial(freq[i]))) % PRIME;
            }
        }
        return result;
    }
};",1441395191
minamego001,minamego001,252,3627,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[55][55];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({0, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({-max(cur,moveTime[nx][ny]) - 1 , {nx,ny}});
            }
        }
        return 0;
    }
};",1441294632
minamego001,minamego001,252,3628,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[760][760];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({{0,0}, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            int add = -a.first.second;
            int nadd = -1;
            if(add == 1) nadd = -2;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({{-max(cur,moveTime[nx][ny]) + nadd, nadd} , {nx,ny}});
            }
        }
        return 0;
    }
};",1441299481
minamego001,minamego001,252,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0 , b = 0;
        for(int i = 0 ; i<num.size(); ++i) {
            if(i&1) a+= num[i]-'0';
            else b += num[i]-'0';
        }
        return a == b;
    }
};",1441281602
minamego001,minamego001,252,3637,cpp,"class Solution {
public:
    int cnt[10];
    const int mod = 1e9 + 7;
unsigned long long fac[88];
long long ncr[88][88];
unsigned long long power(unsigned long long x, 
                                  int y)
{
    unsigned long long res = 1; // Initialize result
 
    x = x % mod; // Update x if it is more than or
    // equal to p
 
    while (y > 0) 
    {
     
        // If y is odd, multiply x with result
        if (y & 1)
            res = (res * x) % mod;
 
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % mod;
    }
    return res;
}
 
// Returns n^(-1) mod p
unsigned long long modInverse(unsigned long long n
                                            )
{
    return power(n, mod - 2);
}
 
// Returns nCr % p using Fermat's little
// theorem.
unsigned long long nCr(unsigned long long n,
                                 int r)
{
    // If n<r, then nCr should return 0
    if (n < r)
        return 0;
    // Base case
    if (r == 0)
        return 1;
 
    return (fac[n] * modInverse(fac[r]) % mod
            * modInverse(fac[n - r]) % mod)
           % mod;
}
    int dp[10][41][730];
    int ans = 0;
    int acc[11];
    long long solve(int i, int odd,int even, int sum) {
        if(sum == ans && odd == 0 && even == 0) return 1;
        if(sum > ans || odd < 0 || i == 10 || even < 0) return 0;

        int &ret = dp[i][odd][sum];
        if(~ret) return ret;
        ret = 0;
        for(int a = 0 ; a<= cnt[i] ; ++a) {
            long long x =  (ncr[odd][a] * solve(i+1,odd - a, even - (cnt[i] - a), sum + a * i))%mod;
            //cout<<i<< "" ""<<a<<"" ""<<sum<<"" ""<<x<<"" ""<<endl;
            x = (x * ncr[even][cnt[i]-a]) % mod;
            ret += x;
            ret%=mod;
        }
        return ret;
        
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        for(auto a : num) 
            {
                sum += a - '0';
                cnt[a-'0']++;
            }
        
        int n = num.size();
            fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % mod;
    acc[0] = cnt[0];
    for(int i = 1 ; i<=9 ; ++i) acc[i] = cnt[i] + acc[i-1];
    for(int i = 0 ; i <=n ; ++i) 
        for(int j = 0 ; j<=i ; ++j) ncr[i][j] = nCr(i,j);
        int odd = (n+1)/2;
        int even = n/2;
        if(sum & 1) return 0;
        ans = sum/2;
        memset(dp,-1,sizeof(dp));
        return solve(0,odd,even,0);
    }
};",1441377894
derrick2001,derrick2001,253,3627,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> pq;
        pq.push({0,0,0});
        dd[0][0]= 0;        
        while(pq.size()) {
            auto[d, x, y] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_++;
                    if (t_ < dd[nx][ny]) {
                        pq.push({t_,nx,ny});
                        dd[nx][ny] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441337233
derrick2001,derrick2001,253,3628,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5][2];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, greater<tuple<int,int,int,int>>> pq;
        pq.push({0,0,0,0});
        dd[0][0][0] = 0;        
        while(pq.size()) {
            auto[d, x, y,p] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y][p]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_ += (1 + (p!=0));
                    if (t_ < dd[nx][ny][p^1]) {
                        pq.push({t_,nx,ny,p^1});
                        dd[nx][ny][p^1] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441334453
derrick2001,derrick2001,253,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o=0,0
        for i,x in enumerate(num):
            if i%2:
                o += int(x)
            else:
                e += int(x)
        return o==e
        ",1441305760
derrick2001,derrick2001,253,3637,cpp,"const int MOD = 1e9 + 7;
typedef long long ll;



ll power_mod(ll x, ll y, ll mod) {
    ll res = 1;
    x %= mod;
    while(y > 0){
        if(y & 1LL){
            res = res * x % mod;
        }
        x = x * x % mod;
        y >>= 1LL;
    }
    return res;
}


struct Factorials {
    vector<long long> fact;
    vector<long long> inv_fact;
    int max_n;

    Factorials(int n_max) : max_n(n_max), fact(n_max + 1, 1), inv_fact(n_max + 1, 1) {
        for(int i = 1; i <= max_n; ++i){
            fact[i] = fact[i-1] * i % MOD;
        }
        inv_fact[max_n] = power_mod(fact[max_n], MOD - 2, MOD);
        for(int i = max_n -1; i >=0; --i){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
    }


    ll comb(int n, int k){
        if(n < k || k < 0) return 0;
        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
    }

    ll factorial(int n){
        if(n < 0 || n > max_n) return 0;
        return fact[n];
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        Factorials factorials(n);

        
        int freq[10] = {0};
        for(char ch : num){
            freq[ch - '0']++;
        }
    
        int total_sum = 0;
        for(int d =0; d <=9; ++d){
            total_sum += d * freq[d];
        }

        
        if(total_sum % 2 != 0){
            return 0;
        }

        int target_sum = total_sum / 2;
        int k = (n +1)/2; 

        vector<vector<int>> dp(k +1, vector<int>(target_sum +1, 0)); //sm at even
        dp[0][0] = 1;

        for(int d =0; d <=9; ++d){
            if(freq[d] ==0) continue;
            vector<vector<int>> temp(k +1, vector<int>(target_sum +1, 0));
            for(int c =0; c <=k; ++c){
                for(int s =0; s <=target_sum; ++s){
                    if(dp[c][s] ==0) continue;
                    for(int m =0; m <= min(freq[d], k - c); ++m){
                        if(s + d * m > target_sum) break;
                        // Number of ways to choose m digits of this digit
                        // which is C(freq[d], m)
                        ll combinations = factorials.comb(freq[d], m);
                        temp[c + m][s + d * m] = (temp[c + m][s + d * m] + dp[c][s]%MOD * combinations%MOD) % MOD;
                    }
                }
            }
            dp = temp;
        }
        
        int ways = dp[k][target_sum];


        if(ways ==0){
            return 0;
        }
        int fk = factorials.factorial(k);
        int fck = factorials.factorial(n -k);

        int denom =1;
        for(int d =0; d <=9; ++d){
            denom = denom * factorials.fact[freq[d]] % MOD;
        }

        long long numerator = 1LL* fk * fck % MOD;


        long long inv = power_mod(denom, MOD -2, MOD);
        long long ans = 1LL* ways * numerator % MOD;
        ans = ans%MOD * inv % MOD;

        return (int)ans;
    }
};",1441352897
Jiabei Zhu,zzjjbb,255,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 1, t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441316122
Jiabei Zhu,zzjjbb,255,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 2 - ((i + j) & 1), t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1 + ((i + j) & 1)
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441315209
Jiabei Zhu,zzjjbb,255,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281111
Jiabei Zhu,zzjjbb,255,3637,python3,"M = 1_000_000_007
fact = [1]
for i in range(1, 100):
    fact.append(fact[-1] * i % M)
ifact = [pow(i, -1, M) for i in fact]
 

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        num = list(map(int, num))
        goal = rgoal = sum(num)
        if goal % 2:
            return 0
        goal >>= 1
        c = Counter(num)
        c = [c[i] for i in range(10)]
        l = defaultdict(int)
        l[0, 0] = 1
        ctl = 0
        for di in range(10):
            nl = defaultdict(int)
            cdi = c[di]
            for (cs, cl), cnt in l.items():
                for i in range(cdi + 1):
                    ad = (cnt * fact[cl + i]) % M
                    ad = (ad * ifact[cl]) % M
                    ad = (ad * ifact[i]) % M
                    ad = (ad * fact[ctl + cdi - cl - i]) % M
                    ad = (ad * ifact[ctl - cl]) % M
                    ad = (ad * ifact[cdi - i]) % M
                    # print(cnt, ad)
                    nl[cs + di * i, cl + i] += ad
            l = nl
            ctl += cdi
        # print(nl)
        # print(l)
        ans = 0
        for (cs, cl), cnt in l.items():
            if cs == goal and cl == n // 2:
                ans = (ans + cnt) % M
        return ans
",1441396831
youknowwho99,youknowwho99,256,3627,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2]});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2]});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441330065
youknowwho99,youknowwho99,256,3628,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t;
                if(a[3]==0)
                 t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]+1][a[2]]+2,a[0]+2);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2],a[3]^1});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]+1]+2,a[0]+2);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1,a[3]^1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                else
                    t=max(vec[a[1]-1][a[2]]+2,a[0]+2);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2],a[3]^1});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]-1]+2,a[0]+2);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1,a[3]^1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441335847
youknowwho99,youknowwho99,256,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int e=0;
        int o=0;
        for(int i=0;i<s.length();i+=2){
            e+=s[i]-'0';
        }
        for(int i=1;i<s.length();i+=2){
            o+=s[i]-'0';
        }
        return o==e;
    }
};",1441281561
youknowwho99,youknowwho99,256,3637,cpp,"class Solution {
public:
    long long powerMod(long long base, long long exp, long long mod) {
        long long res = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) res = res * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return res;
    }
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int len = num.size();
        int evenCount = (len + 1) / 2; 
        int oddCount = len / 2; 

        int digitCount[10] = {0};
        for (char ch : num) {
            digitCount[ch - '0']++;
        }

        long long totalSum = 0;
        for (int d = 0; d < 10; d++) {
            totalSum += (long long)d * digitCount[d];
        }

        if (totalSum % 2 != 0) return 0; 
        long long targetSum = totalSum / 2;

        const int MAX_LEN = 80;
        vector<long long> factorial(MAX_LEN + 1, 1);
        for (int i = 1; i <= MAX_LEN; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        vector<long long> invFactorial(MAX_LEN + 1, 1);
        invFactorial[MAX_LEN] = powerMod(factorial[MAX_LEN], MOD - 2, MOD);
        for (int i = MAX_LEN - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        auto combination = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFactorial[k] % MOD * invFactorial[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenCount + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (digitCount[d] == 0) continue; 
            for (int t = evenCount; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue; 
                    for (int k = 1; k <= digitCount[d] && t + k <= evenCount && s + (long long)d * k <= targetSum; k++) {
                        dp[t + k][s + (long long)d * k] = (dp[t + k][s + (long long)d * k] + dp[t][s] * combination(digitCount[d], k)) % MOD;
                    }
                }
            }
        }

        long long validPermutations = dp[evenCount][targetSum];

        long long productFactorials = 1;
        for (int d = 0; d < 10; d++) {
            productFactorials = productFactorials * factorial[digitCount[d]] % MOD;
        }

        long long result = validPermutations;
        result = result * factorial[evenCount] % MOD;
        result = result * factorial[oddCount] % MOD;

        long long invProduct = powerMod(productFactorials, MOD - 2, MOD);
        result = result * invProduct % MOD;

        return (int)result;
    }


};
",1441384835
Akash,Akash_0P,257,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
            pq.push({0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + cur;
                            pq.push({dp[nr][nc], nr, nc});
                        }
                    }else if(moveTime[nr][nc] + 1 < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1;
                        pq.push({dp[nr][nc], nr, nc});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};",1441364556
Akash,Akash_0P,257,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
            pq.push({0, 0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j, flag] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + flag + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + flag + cur;
                            pq.push({dp[nr][nc], nr, nc, !flag});
                        }
                    }else if(moveTime[nr][nc] + 1 + flag < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1 + flag;
                        pq.push({dp[nr][nc], nr, nc, !flag});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};
",1441366468
Akash,Akash_0P,257,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();

        vector<int> v(2);

        for(int i = 0; i < n; i++) {
            v[i & 1] += num[i] - '0';
        }

        return v[0] == v[1];
    }
};",1441281902
Akash,Akash_0P,257,3637,cpp,"using ll = long long;

const int N = 2e5 + 5, M = 1e9 + 7;
ll fact[N], ifact[N];

ll add(ll a, ll b) {
  return (a + b) % M;
}

ll mul(ll a, ll b) {
  return (a * b) % M;
}

ll expo(ll a, ll b) {
  ll res = 1;
  while(b) {
    if(b & 1) res = mul(res, a);
    a = mul(a, a);
    b >>= 1;
  }
  return res;
}

void pre() {
  fact[0] = 1;
  for(ll i = 1; i < N; i++) fact[i] = mul(i, fact[i - 1]);
  ifact[N-1] = expo(fact[N-1], M-2);
  for(ll i = N-2; i >= 0; i--) ifact[i] = mul(i + 1, ifact[i + 1]);
}

ll nCr(ll n, ll r) {
  if(r > n) return 0;
  return mul(fact[n], mul(ifact[n - r], ifact[r]));
}

int flag = 0;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if(!flag) pre();
            
        int n = num.size(), target = 0;

        vector<int> freq(10);
        for(auto &i: num) freq[i - '0']++, target += i - '0';

        if(target & 1) return 0;

        vector dp(11, vector (n, vector (target + 1, -1)));

        vector<pair<int, int>> temp;

        auto f = [&](int i, int s, int val, auto && f) -> ll {

            if(i == 10) {
                if(val == 0 && s == 0) return mul(fact[(n + 1) / 2], fact[n / 2]);
                return 0;
            }

            if(dp[i][s][val] != -1) return dp[i][s][val];

            ll ans = 0;

            for(int x = 0; x <= freq[i]; x++) {
                if(s - x >= 0 && val - x * i >= 0) {
                    ans = add(ans, mul(mul(ifact[x], ifact[freq[i] - x]), f(i + 1, s - x, val - x * i, f)));
                }
            }

            return dp[i][s][val] = ans;

        };

        return f(0, (n + 1) / 2, target / 2, f);

    }
};",1441384985
Hongbo Zhong,neverbackdown,258,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 0, 0)]
        while Q:
            t, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = 1+max(moveTime[x][y], t)
                    heappush(Q, (new_t, x, y))
        
            ",1441305664
Hongbo Zhong,neverbackdown,258,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 1, 0, 0)]
        while Q:
            t, c, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = c+max(moveTime[x][y], t)
                    heappush(Q, (new_t, 1 if c==2 else 2, x, y))",1441308620
Hongbo Zhong,neverbackdown,258,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            d = int(num[i])
            if i%2 == 0:
                even += d
            else:
                odd += d
        return even == odd",1441281665
Hongbo Zhong,neverbackdown,258,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        digits = [int(ch) for ch in num]
        total = sum(digits)
        if total%2 == 1:
            return 0
            
        mod = 10**9+7
        memo = [defaultdict(lambda: 0) for _ in range(n)]
        for i in range(n):
            d = digits[i]
            if i == 0:
                memo[i][(d, 1)] = 1
                memo[i][(0, 0)] = 1
            else:
                for num, cnt in memo[i-1]:
                    memo[i][(num+d, cnt+1)] += memo[i-1][(num, cnt)]
                    memo[i][(num, cnt)] += memo[i-1][(num, cnt)]

        ans = memo[n-1][(total//2, n//2)]*perm(n//2, n//2)*perm(n-n//2, n-n//2)
        counter = Counter(digits)
        for freq in counter.values():
            ans //= perm(freq, freq)
        return ans % mod",1441391236
RAHUL YADAV,imdotrahul,259,3627,cpp,"#include <vector>
#include <queue>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        if (rows == 0) return 0;
        int cols = moveTime[0].size();
        if (cols == 0) return 0;

        vector<vector<int>> minTime(rows, vector<int>(cols, numeric_limits<int>::max()));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        initializePriorityQueue(pq, minTime);
        vector<vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!pq.empty()) {
            auto current = pq.top();
            pq.pop();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > minTime[currentRow][currentCol]) continue;

            exploreNeighbors(currentRow, currentCol, currentTime, moveTime, minTime, pq, directions);
        }

        return getMinTimeToDestination(minTime, rows, cols);
    }

private:
    void initializePriorityQueue(priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                                  vector<vector<int>>& minTime) {
        pq.push({0, 0, 0});
        minTime[0][0] = 0;
    }

    void exploreNeighbors(int row, int col, int time, vector<vector<int>>& moveTime, 
                          vector<vector<int>>& minTime, priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                          const vector<vector<int>>& directions) {
        for (const auto& dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];

            if (isValidCell(newRow, newCol, minTime)) {
                int newTime = calculateNewTime(time, moveTime[newRow][newCol]);
                updateMinTime(newRow, newCol, newTime, minTime, pq);
            }
        }
    }

    bool isValidCell(int row, int col, const vector<vector<int>>& minTime) {
        return row >= 0 && row < minTime.size() && col >= 0 && col < minTime[0].size();
    }

    int calculateNewTime(int currentTime, int moveTime) {
        return max(currentTime, moveTime) + 1;
    }

    void updateMinTime(int row, int col, int newTime, vector<vector<int>>& minTime, 
                       priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq) {
        if (newTime < minTime[row][col]) {
            minTime[row][col] = newTime;
            pq.push({newTime, row, col});
        }
    }

    int getMinTimeToDestination(const vector<vector<int>>& minTime, int rows, int cols) {
        return minTime[rows - 1][cols - 1];
    }
};",1441385871
RAHUL YADAV,imdotrahul,259,3628,cpp,"
class Solution {
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        std::vector<std::vector<std::vector<int>>> minTime(rows, std::vector<std::vector<int>>(cols, std::vector<int>(2, std::numeric_limits<int>::max())));
        
        minTime[0][0][0] = 0;
        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> priorityQueue;
        priorityQueue.push({0, 0, 0, 0});

        std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!priorityQueue.empty()) {
            auto current = priorityQueue.top();
            priorityQueue.pop();
            int currentTime = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];
            
            if (currentTime > minTime[row][col][parity]) continue;
            
            exploreNeighbors(currentTime, row, col, parity, moveTime, minTime, priorityQueue, directions);
        }
        
        return std::min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }

private:
    void exploreNeighbors(int currentTime, int row, int col, int parity, 
                          const std::vector<std::vector<int>>& moveTime,
                          std::vector<std::vector<std::vector<int>>>& minTime,
                          std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>>& priorityQueue,
                          const std::vector<std::vector<int>>& directions) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        
        for (const auto& direction : directions) {
            int newRow = row + direction[0];
            int newCol = col + direction[1];
            
            if (isValid(newRow, newCol, rows, cols)) {
                int nextTime = std::max(currentTime, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);
                if (nextTime < minTime[newRow][newCol][1 - parity]) {
                    minTime[newRow][newCol][1 - parity] = nextTime;
                    priorityQueue.push({nextTime, newRow, newCol, 1 - parity});
                }
            }
        }
    }

    bool isValid(int row, int col, int rows, int cols) {
        return row >= 0 && row < rows && col >= 0 && col < cols;
    }
};",1441366801
RAHUL YADAV,imdotrahul,259,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sumeven = 0;
        int sumodd = 0;
        for(int i = 0;i<n;i+=2)
        {
            sumeven+=num[i]-'0';
        }
        for(int i = 1;i<n;i+=2)
            {
                sumodd += num[i]-'0';
            }

        if(sumodd == sumeven)
        {
            return true;
        }
        else{
            return false;
        }
    }
};",1441291928
RAHUL YADAV,imdotrahul,259,3637,cpp,"#define MOD 1000000007
typedef long long ll;

vector<ll> factorial;
vector<ll> inv_factorial;

ll mod_power(ll base, ll exp) {
    ll result = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp & 1) result = result * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return result;
}

void initialize_factorials(int limit) {
    factorial.assign(limit + 1, 1);
    for (int i = 1; i <= limit; i++) {
        factorial[i] = factorial[i - 1] * i % MOD;
    }
    inv_factorial.assign(limit + 1, 1);
    inv_factorial[limit] = mod_power(factorial[limit], MOD - 2);
    for (int i = limit - 1; i >= 0; i--) {
        inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
    }
}

ll compute_combinations(int digit_count[], int digit, int used, int half_length) {
    if (used > digit_count[digit] || used > half_length) return 0;
    return (factorial[digit_count[digit]] * inv_factorial[used] % MOD) * inv_factorial[digit_count[digit] - used] % MOD;
}

void fill_dp_table(int digit_count[], vector<vector<ll>>& dp, ll half_sum, int half_length) {
    for (int d = 0; d <= 9; d++) {
        if (digit_count[d] == 0) continue;
        for (int c = half_length; c >= 0; c--) {
            for (ll s = half_sum; s >= 0; s--) {
                if (dp[c][s] == 0) continue;
                for (int t = 1; t <= min(digit_count[d], half_length - c); t++) {
                    if (s + (ll)d * t > half_sum) break;
                    ll combinations = compute_combinations(digit_count, d, t, half_length - c);
                    dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * combinations) % MOD;
                }
            }
        }
    }
}

class Solution {
public:
    int countBalancedPermutations(string digits) {
        int length = digits.size();
        int digit_count[10] = {0};
        ll total_digit_sum = 0;
        for (char c : digits) {
            int digit = c - '0';
            digit_count[digit]++;
            total_digit_sum += digit;
        }
        if (total_digit_sum % 2 != 0) return 0;
        ll half_sum = total_digit_sum / 2;
        int half_length = (length + 1) / 2;
        initialize_factorials(length);
        vector<vector<ll>> dp(half_length + 1, vector<ll>(half_sum + 1, 0));
        dp[0][0] = 1;
        fill_dp_table(digit_count, dp, half_sum, half_length);
        ll valid_permutations = dp[half_length][half_sum];
        if (valid_permutations == 0) return 0;
        ll product_factorials = 1;
        for (int d = 0; d <= 9; d++) {
            product_factorials = product_factorials * factorial[digit_count[d]] % MOD;
        }
        ll combinations_k_nk = (factorial[half_length] * factorial[length - half_length]) % MOD;
        ll inv_product_factorials = mod_power(product_factorials, MOD - 2);
        ll final_answer = (combinations_k_nk * valid_permutations) % MOD;
        final_answer = (final_answer * inv_product_factorials) % MOD;

        return (int)final_answer;
    }
};
",1441378126
Jingzhe Tang,skywalkert,261,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 51, maxm = 2501, INF = 0x3f3f3f3f;
        static int f[maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<pair<int, int> > cand[2];
        auto upd = [&](int x, int y, int t) {
            // printf(""chk %d %d %d\n"", x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[x][y] || t <= tim[x][y])
                return;
            // assert(cur <= t && t <= cur + 1);
            f[x][y] = t;
            cand[t - cur].push_back({x, y});
            // printf(""new %d %d: %d\n"", x, y, t);
        };
        f[0][0] = 0;
        cand[0].push_back({0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d\n"", cur, pos, cand[0].size(), cand[1].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1 && f[x][y] == INF; ++dx)
                    for(int dy = -1; dy <= 1 && f[x][y] == INF; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c || f[xx][yy] >= cur)
                            continue;
                        f[x][y] = cur + 1;
                    }
                // if(f[x][y] != cur + 1) {
                //     printf(""cur %d x %d y %d pos %d\n"", cur, x, y, pos);
                //     for(int i = 0; i < r; ++i)
                //         for(int j = 0; j < c; ++j)
                //             printf(""%d%c"", f[i][j] < INF ? f[i][j] : -1, "" \n""[j == c - 1]);
                // }
                // assert(f[x][y] == cur + 1);
                if(f[x][y] == cur + 1) {
                    // printf(""new2 %d %d: %d\n"", x, y, cur + 1);
                    cand[1].push_back({x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(x + dx, y + dy, f[x][y] + 1);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                ++cur;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        return f[r - 1][c - 1];
    }
};",1441346708
Jingzhe Tang,skywalkert,261,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 751, maxm = 562501, INF = 0x3f3f3f3f;
        static int f[2][maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[0][i][j] = f[1][i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<array<int, 3> > cand[3];
        auto upd = [&](int o, int x, int y, int t) {
            // printf(""chk %d %d %d %d\n"", o, x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[o][x][y])
                return;
            if(t - !o <= tim[x][y]) {
                f[o][x][y] = tim[x][y] + 2 - o;
            } else {
                assert(cur <= t && t <= cur + 2);
                f[o][x][y] = t;
                cand[t - cur].push_back({o, x, y});
            }
            // printf(""new %d %d %d: %d\n"", o, x, y, t);
        };
        f[0][0][0] = 0;
        cand[0].push_back({0, 0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d %d\n"", cur, pos, cand[0].size(), cand[1].size(), cand[2].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[0][x][y] < INF && f[1][x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c)
                            continue;
                        if(f[1][x][y] == INF && f[0][xx][yy] < cur)
                            f[1][x][y] = cur + 1;
                        if(f[0][x][y] == INF && f[1][xx][yy] < cur)
                            f[0][x][y] = cur + 2;
                    }
                if(f[0][x][y] >= cur && f[0][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 0, x, y, f[0][x][y]);
                    cand[f[0][x][y] - cur].push_back({0, x, y});
                }
                if(f[1][x][y] >= cur && f[1][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 1, x, y, f[1][x][y]);
                    cand[f[1][x][y] - cur].push_back({1, x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[o, x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(!o, x + dx, y + dy, f[o][x][y] + 1 + o);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                cand[2].swap(cand[1]);
                ++cur;
            } else if(!cand[2].empty()) {
                cand[2].swap(cand[0]);
                cur += 2;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        // for(int i = 0; i < r; ++i)
        //     for(int j = 0; j < c; ++j)
        //         printf(""[%d|%d]%c"", f[0][i][j] < INF ? f[0][i][j] : -1, f[1][i][j] < INF ? f[1][i][j] : -1, "" \n""[j == c - 1]);
        return min(f[0][r - 1][c - 1], f[1][r - 1][c - 1]);
    }
};",1441380781
Jingzhe Tang,skywalkert,261,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int dt = 0;
        for(char ch: num)
            dt = ch - '0' - dt;
        return !dt;
    }
};",1441280946
Jingzhe Tang,skywalkert,261,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        typedef long long LL;
        static const int maxd = 10, maxm = 41, maxh = 361, mod = (int)1e9 + 7;
        static int f[maxm][maxh], iact[maxm << 1 | 1], ctr[maxd + 1];
        int n = num.size(), s = 0;
        memset(ctr, 0, sizeof ctr);
        for(char ch: num) {
            int o = ch - '0';
            ++ctr[o];
            s += o;
        }
        if(s & 1)
            return 0;
        int m = n >> 1, h = s >> 1;
        for(int i = 0; i <= m; ++i)
            memset(f[i], 0, (h + 1) * sizeof(int));
        iact[1] = 1;
        for(int i = 2; i <= n; ++i)
            iact[i] = mod - (int)(mod / i * (LL)iact[mod % i] % mod);
        iact[0] = 1;
        for(int i = 1; i <= n; ++i)
            iact[i] = (LL)iact[i - 1] * iact[i] % mod;
        f[0][0] = 1;
        for(int o = 0; o < maxd; ++o) {
            if(!ctr[o])
                continue;
            for(int i = m; i >= 0; --i)
                for(int j = h; j >= 0; --j) {
                    int ways = 0;
                    for(int k = min(ctr[o], o ? min(i, j / o) : i); k >= 0; --k)
                        ways = (ways + (LL)f[i - k][j - o * k] * iact[k] % mod * iact[ctr[o] - k]) % mod;
                    f[i][j] = ways;
                }
        }
        int ways = f[m][h];
        for(int i = 2; i <= m; ++i)
            ways = (LL)ways * i * i % mod;
        if(m + m < n)
            ways = (LL)ways * (n - m) % mod;
        return ways;
    }
};",1441307509
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3627,cpp,"struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 1);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny,  (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441364022
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 2);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441362661
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int e = 0, o = 0;
        for(int i = 0; i< n; i++) {
            if(i & 1) {
                e += s[i] - '0';
                continue;
            }
            o += s[i] - '0';
            
        }

        return (e == o);
    }
};",1441283173
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3637,cpp,"class Solution {
public:
  
int power(long long n, long long k, int mod) {
  int ans = 1 % mod; n %= mod; if(n < 0) n += mod;

  while(k) {
    if(k & 1) ans = 1ll *  ans * n % mod;
    n = 1ll *  n * n % mod;
    k >>= 1;
  }

  return ans;
}
    int countBalancedPermutations(string num) {
        const int mod = 1e9 + 7;
        int n = num.size();
        int m = (n + 1) / 2;


        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }

        long long t = 0;
        for(int i = 0; i < 10; i++) {
            t += 1ll * i * cnt[i];
        }

        if(t % 2 != 0) return 0;

        long long tot = t / 2;

        const int q = 80;
        vector<long long> fac(q + 1, 1);
        for(int i = 1; i <= q; i++) {
            fac[i] = fac[i -1] * i % mod;
        }

        vector<long long> inv_fac(q + 1, 1);
        inv_fac[q] = power(fac[q], mod - 2, mod);
        for(int i = q - 1; i >= 0; i--){
            inv_fac[i] = 1ll * inv_fac[i +1] * (i +1) % mod;
        }

        auto ncr = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return fac[n] * inv_fac[k] % mod * inv_fac[n -k] % mod;
        };

        vector<vector<long long>> dp(m + 1, vector<long long>(tot + 1, 0));
        dp[0][0] = 1;

        for(int i =0; i < 10; i++) {
            if(!cnt[i]) continue;
            for(int t = m; t >= 0; t--){
                for(long long s = tot; s >= 0; s--){
                    if(dp[t][s] == 0) continue;
                    for(int k = 1; k <= cnt[i] and t + k <= m and s + 1ll * i * k <= tot; k++){
                        dp[t + k][s + 1ll * i * k] = (dp[t + k][s + 1ll * i * k] + dp[t][s] * ncr(cnt[i], k)) % mod;
                    }
                }
            }
        }

        long long calc = 1;
        for(int i = 0; i < 10; i++) {
            calc = calc * fac[cnt[i]] % mod;
        }

        int ans = 1ll * (dp[m][tot] % mod) * fac[m] % mod;
        ans = 1ll * ans * fac[n / 2] % mod;
        ans = 1ll * ans * power(calc, mod -2, mod) % mod;

        return ans;
    }
};",1441393320
birds3345,birds3345,264,3627,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, coord] = pq.top();
            auto [i, j] = coord;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + 1;
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {i + 1, j}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + 1;
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {i, j + 1}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + 1;
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {i - 1, j}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + 1;
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {i, j - 1}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441297556
birds3345,birds3345,264,3628,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<bool, pair<int, int>>>, vector<pair<int, pair<bool, pair<int, int>>>>, greater<>> pq;
        pq.push({0, {true, {0, 0}}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, info] = pq.top();
            auto move = info.first;
            auto [i, j] = info.second;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {!move, {i + 1, j}}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {!move, {i, j + 1}}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {!move, {i - 1, j}}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {!move, {i, j - 1}}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441303359
birds3345,birds3345,264,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0;
        int odd = 0;
        
        for (int i = 0; i < num.size(); i++)
        {
            if (i & 1)
                odd += num[i] - '0';
            else
                even += num[i] - '0';
        }
        
        return even == odd;
    }
};",1441280998
birds3345,birds3345,264,3637,cpp,"long long dp[81][1441][41];

class Solution {
public:
    int MOD = 1e9 + 7;
    
    long long solve(int i, int sum, int evenCount, string& num, int totalEven, int totalOdd)
    {
        if (dp[i][sum + 720][evenCount] != -1)
            return dp[i][sum + 720][evenCount];
        if (i == num.size())
            return sum == 0 && evenCount == totalEven;
        
        int oddCount = i - evenCount;
        
        long long res = 0;
        if (oddCount < totalOdd)
            res = (res + solve(i + 1, sum + (num[i] - '0'), evenCount, num, totalEven, totalOdd) * (totalOdd - oddCount)) % MOD;
        if (evenCount < totalEven)
            res = (res + solve(i + 1, sum - (num[i] - '0'), evenCount + 1, num, totalEven, totalOdd) * (totalEven - evenCount)) % MOD;
        
        return dp[i][sum + 720][evenCount] = res;
    }
    
    long long factorial(long long n)
    {
        long long res = 1;
        for (int i = 1; i <= n; i++)
            res = (res * i) % MOD;
        
        return res;
    }
    
    long long modInverse(long long a, long long mod)
    {
        long long m0 = mod, t, q;
        long long x0 = 0, x1 = 1;
        if (mod == 1) return 0;
        while (a > 1)
        {
            q = a / mod;
            t = mod;
            mod = a % mod, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0) x1 += m0;
        return x1;
    }
    
    int countBalancedPermutations(string num) {
        memset(dp, -1, sizeof(dp));
        long long res = solve(0, 0, 0, num, num.size() / 2, num.size() - num.size() / 2);
        
        unordered_map<char, int> freq;
        for (char c: num)
            freq[c]++;
        
        for (auto& [k, v]: freq)
        {
            long long fact = factorial(v);
            long long invFact = modInverse(fact, MOD);
            
            res = (res * invFact) % MOD;
        }
        
        return res;
    }
};",1441393394
junbinliang,junbinliang,267,3627,cpp,"vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int d[55][55];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = 2e9;
            }
        }
        
        queue<pair<int, int>> q;
        q.push({0, 0});
        d[0][0] = 0;
        
        while(q.size()) {
            pair<int, int> p = q.front();
            q.pop();
            int r = p.first, c = p.second;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                if(d[rr][cc] > max(d[r][c] + 1, a[rr][cc] + 1)) {
                    d[rr][cc] = max(d[r][c] + 1, a[rr][cc] + 1);
                    q.push({rr, cc});
                }
            }
        }
        
        return d[n - 1][m - 1];
    }
};",1441292763
junbinliang,junbinliang,267,3628,java,"
class Solution {
    public int minTimeToReach(int[][] a) {
        int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int n = a.length, m = a[0].length;
        int[][][] d = new int[n][m][2];
        boolean[][][] st = new boolean[n][m][2];
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = 2000000000;
            }
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> {
            return x[3] - y[3];
        });
        d[0][0][0] = 0;
        pq.add(new int[]{0, 0, 0, 0});
        
        while(pq.size() > 0) {
            int[] p = pq.poll();
            int r = p[0], c = p[1], t = p[2], dis = p[3];
            if(st[r][c][t]) continue;
            st[r][c][t] = true;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(int[] di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > Math.max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = Math.max(d[r][c][t] + w, a[rr][cc] + w);
                    pq.add(new int[]{rr, cc, t ^ 1, d[rr][cc][t ^ 1]});
                }
            }
        }
        
        
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}

/*
vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
const int INF = 2e9;
int d[760][760][2];

struct P {
    int r, c, t;
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = INF;
            }
        }
        
        queue<P> q;
        q.push({0, 0, 0});
        d[0][0][0] = 0;
        while(q.size()) {
            P p = q.front(); q.pop();
            int r = p.r, c = p.c;
            int t = p.t;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = max(d[r][c][t] + w, a[rr][cc] + w);
                    q.push({rr, cc, t ^ 1});
                }
            }
        }
        
            
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
    
    
};
*/",1441305515
junbinliang,junbinliang,267,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int s1 = 0, s2 = 0;
        for(int i = 0; i < s.size(); i++) {
            if(i % 2 == 0) s1 += s[i] - '0';
            else s2 += s[i] - '0';
        }
        return s1 == s2;
    }
};",1441280910
junbinliang,junbinliang,267,3637,cpp,"const int MOD = 1e9 + 7;
int tot = 0;
using ll = long long;
long long fact[100];

ll fpow(ll x, int y){
	ll res = 1;
	while(y){
		if(y & 1) res = (res * x) % MOD;
		x = (x * x) % MOD;
		y >>= 1;
	}
	return res;
}  

ll modInverse(ll a, ll m) {
    ll m0 = m;
    ll y = 0, x = 1;
    if (m == 1)
        return 0;
    while (a > 1) {
          // q is quotient
        ll q = a / m;
        ll t = m;
        // m is remainder now, process
        // same as Euclid's algo
        m = a % m;
        a = t;
        t = y;
        // Update x and y
        y = x - q * y;
        x = t;
    }
    // Make x positive
    if (x < 0)
        x += m0;
    return x;
}


bool yes = false;
long long C[101][101];
void init() {
    if(yes) return;
    yes = true;
    C[0][0] = 1;
    for(int i = 1;i <= 100; i++) {
      C[i][0]=1;
      for(int j = 1;j <= i;j++) {
        C[i][j] = ( C[i-1][j] + C[i-1][j-1] ) % MOD;
      }
    }
}

long long dp[11][370][45];
int p[10];
int toteven = 0, totodd = 0;

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        vector<int> cnt(10);
        tot = 0;
        for(char c : s) {
            cnt[c - '0']++;
            tot += (c - '0');
        }
        
        if(tot % 2 == 1) {
            return 0;
        }
        
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= tot / 2 + 1; j++) {
                for(int k = 0; k <= (s.size() / 2 + 1); k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        
        p[0] = cnt[0];
        for(int i = 1; i < 10; i++) {
            p[i] = cnt[i] + p[i - 1];
        }
        
        toteven = s.size() / 2;
        totodd = s.size() - toteven;
        
        int ans = dfs(cnt, 0, tot / 2, (s.size() + 1) / 2);
        //cout << endl;
        return ans;
    }
    
    long long dfs(vector<int>& cnt, int i, int s, int odd) { //10 * 360 * 40
        if(i >= cnt.size()) {
            if(odd == 0 && s == 0) {
                return 1;
            }
            return 0;
        }
        if(dp[i][s][odd] != -1) {
            return dp[i][s][odd];
        }
        

        if(cnt[i] == 0) {
            return dp[i][s][odd] = dfs(cnt, i + 1, s, odd);
        }
        long long ans = 0;
        
        
        int sum = 0;
        if(i > 0) sum = p[i - 1];
        int oddtaken = totodd - odd;
        int remainEven = toteven - (sum - oddtaken);
        
        //cout << i << "" "" << s << "" "" << odd << "" "" << oddtaken << "" "" << sum << ""  "" << remainEven << endl;
        
        
        for(int x = 0; x <= min(odd, cnt[i]); x++) {
            int sum1 = x * i;
            if(sum1 <= s) {
                if(remainEven < 0 || remainEven < (cnt[i] - x)) continue;
                long long w1 = C[odd][x];
                long long w2 = C[remainEven][cnt[i] - x];
                ll w = (w1 * w2) % MOD;
                
                /*if(i == 5 || i == 6) {
                    cout << i <<"" ""  << odd << endl;
                    cout << x << ""  "" << w1 << "" "" << w2 << "" "" << w <<""  "" << dfs(cnt, i + 1, s - sum1, odd - x) << endl << endl;
                }*/
                
                ans += (w * dfs(cnt, i + 1, s - sum1, odd - x));
                ans %= MOD;
            }
        }
        //cout << i << "" "" << s << "" "" << odd << ""  "" << ans << endl;
        return dp[i][s][odd] = ans;
    }
};

//""4567""   8
//""46453"" 6",1441383288
uf21-6,uf21-6,268,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        # Initialize distance matrix with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0  # Start from top-left corner with time 0
        
        # Min-heap priority queue: each entry is (time, row, col)
        pq = [(0, 0, 0)]
        
        # Possible directions: up, right, down, left
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            time, row, col = heapq.heappop(pq)
            
            # If the current time exceeds known minimum, skip
            if time > dist[row][col]:
                continue
            
            for dr, dc in directions:
                newRow, newCol = row + dr, col + dc
                
                # Check if within bounds
                if 0 <= newRow < n and 0 <= newCol < m:
                    # Calculate the time to move to this cell
                    newTime = max(time, moveTime[newRow][newCol]) + 1
                    
                    # Update if found a shorter time to this cell
                    if newTime < dist[newRow][newCol]:
                        dist[newRow][newCol] = newTime
                        heapq.heappush(pq, (newTime, newRow, newCol))
        
        return dist[n - 1][m - 1]
",1441316581
uf21-6,uf21-6,268,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows, cols = len(moveTime), len(moveTime[0])
        
        # Initialize distance array with a large number
        dist = [[[float('inf')] * 2 for _ in range(cols)] for _ in range(rows)]
        dist[0][0][0] = 0
        
        # Min-heap priority queue to process cells in ascending time
        heap = [(0, 0, 0, 0)]  # (time, row, col, parity)
        
        # Possible moves: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            time, x, y, parity = heapq.heappop(heap)
            
            # Skip if we already have a shorter path
            if time > dist[x][y][parity]:
                continue
            
            # Explore neighboring cells
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                # Check if neighbor is within bounds
                if 0 <= nx < rows and 0 <= ny < cols:
                    next_time = max(time, moveTime[nx][ny]) + (2 if parity else 1)
                    
                    # Update distance if a shorter path is found
                    if next_time < dist[nx][ny][1 - parity]:
                        dist[nx][ny][1 - parity] = next_time
                        heapq.heappush(heap, (next_time, nx, ny, 1 - parity))
        
        return min(dist[rows - 1][cols - 1][0], dist[rows - 1][cols - 1][1])
",1441309467
uf21-6,uf21-6,268,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                odd += int(num[i])
            else:
                even += int(num[i])
        return even == odd",1441283881
uf21-6,uf21-6,268,3637,python3,"MOD = 1_000_000_007

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        E = (N + 1) // 2  # Number of even indices (0-based)
        O = N // 2         # Number of odd indices

        # Count frequency of each digit
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1

        # Calculate total sum
        total_sum = sum(d * cnt[d] for d in range(10))

        # If total_sum is odd, no balanced permutation exists
        if total_sum % 2 != 0:
            return 0

        sum_target = total_sum // 2

        # Precompute factorial and inverse factorial
        MAX = 80
        factorial = [1] * (MAX + 1)
        for i in range(1, MAX + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_fact = [1] * (MAX + 1)
        inv_fact[MAX] = pow(factorial[MAX], MOD - 2, MOD)
        for i in range(MAX - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        # Function to compute combination C(n, k) mod MOD
        def comb(n, k):
            if k > n:
                return 0
            return factorial[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD

        # Initialize DP table
        dp = [[0] * (sum_target + 1) for _ in range(E + 1)]
        dp[0][0] = 1

        for d in range(10):
            if cnt[d] == 0:
                continue
            for t in range(E, -1, -1):
                for s in range(sum_target, -1, -1):
                    if dp[t][s] == 0:
                        continue
                    for k in range(1, cnt[d] + 1):
                        if t + k > E or s + d * k > sum_target:
                            break
                        dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD

        number_of_valid_assignments = dp[E][sum_target]

        # Compute product of factorials of digit counts
        product_cnt_d_fact = 1
        for d in range(10):
            product_cnt_d_fact = product_cnt_d_fact * factorial[cnt[d]] % MOD

        # Compute the final answer
        answer = number_of_valid_assignments
        answer = answer * factorial[E] % MOD
        answer = answer * factorial[O] % MOD
        inv_product = pow(product_cnt_d_fact, MOD - 2, MOD)
        answer = answer * inv_product % MOD

        return answer
",1441395798
naresh50,naresh50,269,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 1 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323940
naresh50,naresh50,269,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 2 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323065
naresh50,naresh50,269,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int count=0;
        for(int i=0;i<num.length();i++){
            int val = (int)num.charAt(i) -48;
            if(i%2==0) count+=val;
            else  count-=val;
        }
        if(count==0) return true;
        else return false;
    }
}",1441292047
naresh50,naresh50,269,3637,java,"class Solution {
    int mod = (int)1e9 +7;
    
    public int countBalancedPermutations(String num) {
        int n = num.length();
        long halfFact1 = factorial(n/2);
        long halfFact2 = factorial((n+1)/2);

        long[] factArray = new long[81];
         long[] modArray = new long[81];
        formArray(factArray , modArray);
       

        
        int[] count  = new int[10];
        int total=0;
        for(int i=0;i<num.length();i++){
            int val=num.charAt(i)-'0';
            count[val]++;
            total+=val;
        }
        if(total%2==1) return 0;
        long[][][] dp= new long[10][810][81];
        for(int i=0;i<dp.length;i++){
            for(int j=0;j<dp[i].length;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        long ans = helper(0,total/2 , num.length()/2 , dp,count ,factArray , halfFact1 , halfFact2 ,modArray);
        ans%=mod;
        return (int)ans;
        
    }
    public long helper(int num , int sum , int rem , long[][][] dp , int[] count , long[] factArr , long h1 , long h2 , long[] modArr ){
        if(num==10){
           if(sum==0 && rem==0) return (h1*h2)%mod;
            else return 0;
        }
        if(dp[num][sum][rem]!=-1) return dp[num][sum][rem];
        long ans=0;

        int freq = count[num];
        
        for(int i=0;i<=freq;i++){
            long temp = 0;
            if(sum>=i*num && rem>=i) temp+=helper(num+1 , sum-(i*num) , rem-i ,  dp,count , factArr ,h1,h2 , modArr );
            if(i>0) temp = (temp * modArr[i]) % mod;
            if(freq-i >0) temp = (temp * modArr[freq-i]) % mod;

            ans+=temp;
            ans%=mod;
        }
        return dp[num][sum][rem] = ans%mod;
    }
    public long factorial(int n){
        long ans=1;
        for(int i=1;i<=n;i++){
            ans*=i;
            ans%=mod;
        }
        return ans;
    }
    public void formArray(long[] arr, long[] modArr){
        arr[1]=1L;
        arr[0]=1L;
        for(int i=2;i<=80;i++){
            arr[i] = (long)i*arr[i-1];
            arr[i]%=mod;
        }

        for(int i=0;i<arr.length;i++){
            modArr[i]=modInverse(arr[i]);
        }
    }
    public  long modInverse(long a) {
        return modExp(a, mod - 2);
    }

    public long modExp(long base, long exp) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }
        return res;
    }
}",1441383508
her0e1c1,her0e1c1,270,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        heappush(pq, (nt + 1, ni, nj))
                ",1441298882
her0e1c1,her0e1c1,270,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j, c = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        nc = 1 if c == 0 else 0
                        heappush(pq, (nt + 1 + c, ni, nj, nc))
                        ",1441302584
her0e1c1,her0e1c1,270,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o = e = 0
        for i, n in enumerate(num):
            if i % 2 == 0:
                e += int(n)
            else:
                o += int(n)
        return o == e",1441282100
her0e1c1,her0e1c1,270,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def dfs(i, c, c2, acc):
            if i > 10:
                return 0
            if acc > total // 2:
                return 0
            if c > N1 or c2 > N2:
                return 0
            if c == N1 and c2 == N2:
                if acc == total // 2:
                    return 1
                return 0
            rv = 0
            for k in range(C[i] + 1):  # nCr
                n1 = N1 - c
                n2 = N2 - c2
                k2 = C[i] - k
                rv += comb(n1, k) * comb(n2, k2) * dfs(i + 1, c + k, c2 + k2, acc + k * i)
                rv %= M
            return rv
        
        C = defaultdict(int)
        N1, N2 = len(num) // 2, (len(num) + 1) // 2
        total = 0
        for n in num:
            C[int(n)] += 1
            total += int(n)
        if total % 2 == 1:
            return 0
        # print(total, N1, N2, C)
        M = 10 ** 9 + 7
        return dfs(0, 0, 0, 0) % M",1441395883
Jashanpreet Singh,jashanp2005,271,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309945
Jashanpreet Singh,jashanp2005,271,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = fact ? 2 : 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309340
Jashanpreet Singh,jashanp2005,271,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    int ans = 0, ans2 = 0;
    int n = num.length();
    for(int i = 0; i < n; i++) {
        if(i % 2 == 0) 
            ans += num[i] - '0';  
        else 
            ans2 += num[i] - '0';  
    }
    return ans == ans2;
}
};",1441283829
Jashanpreet Singh,jashanp2005,271,3637,cpp,"
vector<int> fact(101), inv(101);

vector<int> v(10, 0);

class Solution {
#define int long long

const int mod = 1e9 + 7;
const int N = 100;

int n;
int tot = 0;

int binaryexpo(int a, int b) {
    int ans = 1;
    while (b > 0) {
        if (b & 1) {
            ans = (ans * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return ans;
}

void findinverse() {
    for (int i = 0; i <= N; i++) {
        inv[i] = binaryexpo(fact[i], mod - 2);
    }
}

void findfact() {
    fact[0] = 1;
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }
}

int solve(int index, int count, int sum, vector<vector<vector<int>>> &dp) {
    if (index == 10) {
        if (2 * sum == tot && count == (n+1)/2) {
            return (fact[count]%mod * fact[n - count]%mod) % mod;
        }
        return 0; 
    }

    if(dp[index][count][sum] != -1) return dp[index][count][sum];

    int ans = 0;
    for (int i = 0; i <= v[index]; i++) {
        if (count + i <= (n + 1) / 2) {
            int term = (((solve(index + 1, count + i, sum + index * i, dp) * inv[i]) % mod) * inv[v[index] - i]) % mod;
            ans = (ans + term) % mod;
        }
    }
    return dp[index][count][sum] = ans;
}

public:
    int countBalancedPermutations(string num) {
        findfact();
    findinverse();
    tot = 0;
    n = num.length();
    v.assign(10, 0);

        

    for (char c : num) {
        tot += c - '0';
        v[c - '0']++;
    }

        vector<vector<vector<int>>> dp(10, vector<vector<int>>(n/2 + 2, vector<int>(tot+1, -1)));

    return solve(0, 0, 0, dp);
}
};
#undef int
",1441389745
craggy,craggy,272,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        d = deque()
        d.append((0, 0, 0))
        vis = [[0 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        while len(d) > 0:
            t, r, c = d.popleft()
            if vis[r][c] and vis[r][c] <= t: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                d.append((max(t, moveTime[nr][nc])+1, nr, nc))
            
        return vis[len(moveTime)-1][len(moveTime[0])-1]
        ",1441300823
craggy,craggy,272,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        vis = [[-1 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        heap = [(0, 0, 0)]
        while len(heap):
            t, r, c = heappop(heap)
            if vis[r][c] != -1: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                heappush(heap, (max(t, moveTime[nr][nc])+1+(r+c)%2, nr, nc))

        return vis[len(moveTime)-1][len(moveTime[0])-1]

    

        ",1441309959
craggy,craggy,272,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        t = [0,0]
        for i in range(len(num)):
            t[i%2] += int(num[i])

        return t[0] == t[1]
        ",1441281821
craggy,craggy,272,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        M = int(1e9)+7
        cnt = Counter(num)
        fct = [1]
        for i in range(len(num)):
            fct.append((fct[-1] * (i+1))%M)
            
        inv_fct = [1] * (len(num) + 1)
        for i in range(1, len(fct)):
            inv_fct[i] = pow(fct[i], M - 2, M)

        @cache
        def get(diff_val, diff_num, i):
            if i == 10: return (fct[len(num)//2+len(num)%2] * fct[len(num)//2]) % M if ((diff_val == 0 and diff_num == (len(num) % 2))) else 0
            ret = 0
            if cnt[str(i)] == 0: return get(diff_val, diff_num, i+1)
            for j in range(cnt[str(i)]+1):
                a = j
                b = cnt[str(i)]-j
                ret = (ret + get(diff_val+i*a-i*b, diff_num+a-b, i+1) * inv_fct[j] * inv_fct[cnt[str(i)] - j]) % M


            return ret

        return get(0, 0, 0)

        ",1441396118
invertedwinger,invertedwinger,273,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<int>> dist(n, vector<int> (m,2e9));
        dist[0][0] = 0;
        set<pair<int,pair<int,int>>> s;
        s.insert({0, {0,0}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            int d = it->first, x = it->second.first, y = it->second.second;
            s.erase(it);
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    int D = max(d+1, a[x1][y1]+1);
                    if(D<dist[x1][y1]){
                        if(dist[x1][y1] < 2e9) s.erase({dist[x1][y1], {x1,y1}});
                        s.insert({D, {x1,y1}});
                        dist[x1][y1] = D;
                    }
                }
            }
        }

        return dist[n-1][m-1];
        
    }
};",1441304415
invertedwinger,invertedwinger,273,3628,cpp,"typedef long long ll;
const ll INF = 1e18;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>> (m, vector<ll> (2,INF)));
        dist[0][0][1] = INF;
        set<pair<ll,pair<pair<int,int>, int >>> s;
        s.insert({0, {{0,0}, 1}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            ll d = it->first, x = it->second.first.first, y = it->second.first.second, z = it->second.second;
            s.erase(it);
            z = 1-z;
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    ll D =max(d+z+1, 1LL*a[x1][y1]+z+1);
                    if(D<dist[x1][y1][z]){
                        if(dist[x1][y1][z] < INF) s.erase({dist[x1][y1][z], {{x1,y1},z}});
                        s.insert({D, {{x1,y1}, z}});
                        dist[x1][y1][z] = D;
                    }
                }
            }
        }

        return min(dist[n-1][m-1][0], dist[n-1][m-1][1]);
        
    }        
    
};",1441324071
invertedwinger,invertedwinger,273,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int c1 = 0, c2 = 0;
        for(int i=0; i<n; i++){
            if(i&1) c1 += num[i]-'0';
            else c2 += num[i]-'0';
        }
        return (c1 == c2);
    }
};",1441283779
invertedwinger,invertedwinger,273,3637,cpp,"typedef long long ll;
const ll mod = 1e9+7;
const ll N=45;
ll fct[N],inv[N],invfct[N];
ll ncr(ll n,ll r){
    if(n<0 || r<0 || n-r<0)return 0;
    ll ans = fct[n]*invfct[r];
    ans%=mod;
    ans = ans * invfct[n-r];
    ans%=mod;
    return ans;
}
void init(){
    fct[0]=fct[1]=1;
    inv[1]=1;
    invfct[0]=invfct[1]=1;
    for(ll i=2;i<N;i++){
        fct[i]=i*fct[i-1]%mod;
        inv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;
        invfct[i]=ll(inv[i])*invfct[i-1]%mod;
    }
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        int sum = 0;
        int n = s.length();
        for(int i=0; i<n; i++) sum += s[i]-'0';
        if(sum&1) return 0;
        int cnt[10] = {0};
        for(int i=0; i<n; i++) cnt[s[i]-'0']++;
        sum /=2;
        int x = n/2, y = n-x;
        vector<vector<ll>> ways(sum+1, vector<ll> (x+1, 0));
        ways[0][0] = 1;
        int total = 0;
        for(int k=0; k<10; k++){
            vector<vector<ll>> temp(sum+1, vector<ll> (x+1, 0));
            for(int t=0; t<=cnt[k]; t++){
                for(int sm = 0; sm <= sum; sm++){
                    for(int i=0; i<=x; i++){
                        int j = total - i;
                            int X = i+t, Y = j+(cnt[k]-t), S = sm+t*k;
                            if(S>sum || X>x || Y>y || ways[sm][i] == 0) continue;
                            ll z = (ncr(x-i, t)*ncr(y-j, cnt[k]-t))%mod;
                            temp[S][X] = (temp[S][X] + z*ways[sm][i])%mod;
                    }
                }
            }
            total += cnt[k];
            ways = temp;
        }
        return ways[sum][x];
    }
};",1441383901
Chen Jian,xiaojian9527,275,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        f = [[0] * m for _ in range(n)]

        d = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m

        seen = set()
        pq = [(0, 0, 0)]
        while pq:
            h, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if inArea(nx, ny):
                    if (nx, ny) not in seen:
                        seen.add((nx, ny))
                        t = max(h, moveTime[nx][ny])+1
                        heappush(pq, (t, nx, ny))
        return -1
        ",1441316329
Chen Jian,xiaojian9527,275,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # step: 0, 1
        n, m = len(moveTime), len(moveTime[0])
        seen = set()
        pq = [(0, 0, 0, 0)]
        d = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m
        
        while pq:
            h, step, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h

            ns = 1-step
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if not inArea(nx, ny):
                    continue

                if (nx, ny, ns) in seen:
                    continue
                seen.add((nx, ny, ns))
                nh = max(h, moveTime[nx][ny]) + step + 1
                heappush(pq, (nh, ns, nx, ny))
        return -1
        ",1441329221
Chen Jian,xiaojian9527,275,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        for i, c in enumerate(num):
            if i % 2 == 0:
                odd -= int(c)
            else:
                odd += int(c)
        return odd == 0",1441283871
Chen Jian,xiaojian9527,275,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        sm = 0
        n = len(num)
        cnt = defaultdict(int)
        for c in num:
            sm += int(c)
            cnt[int(c)] += 1
        if sm % 2: return 0

        even = (n+1) // 2
        odd = n // 2

        MOD = 10 ** 9 + 7
        @cache
        def dfs(i: int, s: int, oc: int, ec: int) -> int:
            if i == 10:
                return s == 0 and oc == 0 and ec == 0
                
            if oc < 0 or ec < 0: return 0

            if cnt[i] == 0:
                return dfs(i+1, s, oc, ec)

            ans = 0
            for j in range(0, cnt[i]+1):
                if j > oc: break
                k = cnt[i] - j
                if k > ec: continue
                # print(comb(oc, j), comb(ec, k))
                ans += comb(oc, j) * comb(ec, k) * dfs(i+1, s + j * i - k * i, oc -j, ec - k) % MOD
            return ans % MOD
            
        return dfs(0, 0, odd, even)",1441396468
eatfood,eatfood,276,3627,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=deque()
        dq.append((0,0))
        while len(dq):
            x,y=dq.popleft()
            # check to improve
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    newdist = max(dp[x][y]+1, mt[nx][ny]+1)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.append((nx,ny))
        # for i in range(n):
        #     print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441298031
eatfood,eatfood,276,3628,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
from sortedcontainers import SortedList

class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=SortedList()
        dq.add((0,0,0))
        while len(dq):
            d,x,y=dq.pop(0)
            # check self
            if d > dp[x][y]:
                continue
            # check nbrs
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    w = 1 if ((x+y)%2 == 0) else 2
                    newdist = max(d+w, mt[nx][ny]+w)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.add((newdist,nx,ny))
        for i in range(n):
            print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441306775
eatfood,eatfood,276,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        cnt=0
        for i,ch in enumerate(s):
            d = ord(ch)-ord('0')
            cnt += d if (i % 2 == 0) else -d
        return cnt==0",1441284963
eatfood,eatfood,276,3637,python3,"'''
dp[d][num slots left][tot sum]
'''
from collections import defaultdict
mod=int(1e9+7)

f = [0] * 81
f[0] = 1
for i in range(1, 81):
    f[i] = f[i-1]*i % mod
fi = [0] * 81
fi[80] = pow(f[80], mod-2, mod)
for i in range(79, -1, -1):
    fi[i] = fi[i+1] * (i+1) % mod


# print(f[:10])
# print(fi[:10])

class Solution:
    def countBalancedPermutations(self, s: str) -> int:

        def choose(n,k):
            if k==0 or k==n:
                return 1
            if k>n or k<0:
                return 0
            return (f[n] * fi[k] * fi[n-k]) % mod
                
            
        arr=[ord(ch)-ord('0') for ch in s]
        freq=defaultdict(int)
        for x in arr:
            freq[x]+=1
        sm=sum(arr)
        if sm % 2 != 0:
            return 0
        tgt=sm//2
        slots=(len(arr)+1) // 2
        slots2 = len(arr)-slots
        # need to make tgt with exactly slots numbers
        dp=[[0]*(tgt+1) for _ in range(slots+1)]

        dp[slots][0]=1 # empty string

        num_processed = 0
        for x, fx in freq.items():
            # init dp2
            dp2=[[0]*(tgt+1) for _ in range(slots+1)]
            # for ns in range(len(dp)-1, -1, -1):
            for ns in range(len(dp)):
                for sm in range(len(dp[0])):
                    if dp[ns][sm] == 0:
                        continue
                    for k in range(0, fx+1): # pick k of x to continue this value
                        if k > ns:
                            break
                        if sm + k*x > tgt:
                            break
                        # pick k from ns to put the nums into
                        w1=choose(ns, k)
                        rem2 = slots2 - (num_processed - (slots-ns))
                        w2=choose(rem2, fx-k)
                        # print(ns, sm, k, x)
                        # print('w1', ns, k, w1)
                        # print('w2', rem2, fx-k, w2)
                        dp2[ns-k][sm + k*x] += dp[ns][sm] * (w1 * w2 % mod) % mod
                        dp2[ns-k][sm + k*x] %= mod
            
            num_processed += fx
            dp,dp2=dp2,dp
            
        #     print(x, fx)
        #     for row in dp:
        #         print(row)
        # print(tgt)
        return dp[0][tgt]
        ",1441390678
codinghermit05,codinghermit05,279,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        # Initialize distance array with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        
        # Priority queue to store (time, row, col)
        # Python's heapq is used instead of Java's PriorityQueue
        pq = [(0, 0, 0)]
        dist[0][0] = 0
        
        # All four directions: up, right, down, left
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            # Get current state with minimum time
            time, row, col = heapq.heappop(pq)
            
            # Skip if we've found a better path
            if time > dist[row][col]:
                continue
            
            # Try all four directions
            for dx, dy in dirs:
                new_row = row + dx
                new_col = col + dy
                
                # Check if new position is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate new time (wait until moveTime if necessary)
                    new_time = max(time, moveTime[new_row][new_col]) + 1
                    
                    # If found better path, update and add to queue
                    if new_time < dist[new_row][new_col]:
                        dist[new_row][new_col] = new_time
                        heapq.heappush(pq, (new_time, new_row, new_col))
        
        return dist[n-1][m-1]",1441322051
codinghermit05,codinghermit05,279,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        if not moveTime or not moveTime[0]:
            return 0
            
        n, m = len(moveTime), len(moveTime[0])
        
        # Directions for movement: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # Priority queue to store (current_time, is_odd_move, row, col)
        pq = [(0, False, 0, 0)]  # Start at (0,0) with time 0
        
        # Keep track of visited states including the odd/even move status
        visited = set()
        
        while pq:
            current_time, is_odd_move, row, col = heapq.heappop(pq)
            
            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return current_time
                
            # Skip if we've seen this state
            state = (row, col, is_odd_move)
            if state in visited:
                continue
            visited.add(state)
            
            # Try all possible moves
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy
                
                # Check if move is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Move cost alternates between 1 and 2 seconds
                    move_cost = 2 if is_odd_move else 1
                    
                    # Wait until we can enter the new room
                    wait_time = max(0, moveTime[new_row][new_col] - current_time)
                    
                    # Total time includes: current time + waiting time + move cost
                    new_time = current_time + wait_time + move_cost
                    
                    # Add new state to priority queue with flipped odd/even status
                    heapq.heappush(pq, (new_time, not is_odd_move, new_row, new_col))
        
        return -1  # If no path is found
",1441300207
codinghermit05,codinghermit05,279,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Initialize variables to store sums
        even_sum = 0
        odd_sum = 0
        
        # Iterate through the string using index
        for i in range(len(num)):
            # Convert character to integer
            digit = int(num[i])
            
            # If index is even, add to even_sum
            if i % 2 == 0:
                even_sum += digit
            # If index is odd, add to odd_sum
            else:
                odd_sum += digit
        
        # Return true if sums are equal, false otherwise
        return even_sum == odd_sum",1441284044
codinghermit05,codinghermit05,279,3637,python3,"class Solution(object):
    MOD = 1000000007

    def countBalancedPermutations(self, num):
        """"""
        Count the number of balanced permutations of a given number string.
        
        :type num: str
        :rtype: int
        """"""
        # Initialize basic variables
        length = len(num)
        total_sum = sum(int(digit) for digit in num)
        counts = [0] * 10
        for digit in num:
            counts[int(digit)] += 1
        
        # Early return if sum is odd (can't be balanced)
        if total_sum % 2 != 0:
            return 0
        
        half_sum = total_sum // 2
        m = (length + 1) // 2
        
        # Precompute factorials and their inverses
        factorial = [1] * (length + 1)
        for i in range(1, length + 1):
            factorial[i] = factorial[i - 1] * i % self.MOD
        
        inv_factorial = [1] * (length + 1)
        inv_factorial[length] = self.mod_inverse(factorial[length], self.MOD)
        for i in range(length - 1, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % self.MOD
        
        # Initialize DP table for counting balanced subsets
        dp = [[0] * (half_sum + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        # Fill DP table
        for d in range(10):
            if counts[d] == 0:
                continue
                
            for k in range(m, -1, -1):
                for s in range(half_sum, -1, -1):
                    if dp[k][s] == 0:
                        continue
                        
                    for t in range(1, counts[d] + 1):
                        if k + t > m or s + d * t > half_sum:
                            break
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + 
                                               dp[k][s] * 
                                               self.comb(counts[d], t, factorial, inv_factorial, self.MOD)) % self.MOD
        
        # Calculate final result
        w = dp[m][half_sum]
        result = factorial[m] * factorial[length - m] % self.MOD
        
        for d in range(10):
            result = result * inv_factorial[counts[d]] % self.MOD
            
        result = result * w % self.MOD
        return int(result)
    
    def mod_inverse(self, a, m):
        """"""
        Calculate modular multiplicative inverse using fast exponentiation.
        """"""
        result = 1
        p = m - 2
        base = a
        
        while p > 0:
            if p & 1:
                result = result * base % m
            base = base * base % m
            p >>= 1
            
        return result
    
    def comb(self, n, k, factorial, inv_factorial, m):
        """"""
        Calculate combination (n choose k) using precomputed factorials.
        """"""
        if k > n:
            return 0
        return factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m",1441354877
yaominzh,yaominzh,280,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  
        visited = [[False] * m for _ in range(n)]
        min_heap = [(0, 0, 0)]  # (time, x, y)
        
        while min_heap:
            current_time, x, y = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if visited[x][y]:
                continue
            visited[x][y] = True
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
                    wait_time = max(current_time + 1, moveTime[nx][ny]+1)
                    heapq.heappush(min_heap, (wait_time, nx, ny))
        return -1
",1441367140
yaominzh,yaominzh,280,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
        visited = [[float('inf')] * m for _ in range(n)]
        min_heap = [(0, 0, 0, 1)]  # (time, x, y, next_move_time)
        
        while min_heap:
            current_time, x, y, move_cost = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if current_time >= visited[x][y]:
                continue
            visited[x][y] = current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    wait_time = max(current_time + move_cost, moveTime[nx][ny]+move_cost)
                    next_move_cost = 1 if move_cost == 2 else 2
                    heapq.heappush(min_heap, (wait_time, nx, ny, next_move_cost))
        
        return -1 
    
",1441380163
yaominzh,yaominzh,280,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
    
        for i in range(len(num)):
            if i % 2 == 0:  
                even_sum += int(num[i])
            else:          
                odd_sum += int(num[i])
    
        return even_sum == odd_sum
        ",1441287516
yaominzh,yaominzh,280,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        mod = 10**9 + 7

        total_counts = [0] * 10
        for ch in num:
            total_counts[int(ch)] += 1

        n = len(num)
        n_even = (n + 1) // 2  # Number of even indices (0-based)
        n_odd = n // 2         # Number of odd indices

        max_sum = sum(d * c for d, c in enumerate(total_counts))
        if max_sum % 2 != 0:
            return 0
        half_sum = max_sum // 2

        MAX_N = n + 1
        factorials = [1] * (MAX_N)
        inv_factorials = [1] * (MAX_N)

        for i in range(1, MAX_N):
            factorials[i] = (factorials[i - 1] * i) % mod

        inv_factorials[MAX_N - 1] = pow(factorials[MAX_N - 1], mod - 2, mod)
        for i in range(MAX_N - 2, -1, -1):
            inv_factorials[i] = (inv_factorials[i + 1] * (i + 1)) % mod

        # Initialize DP array
        dp = [ [0] * (n_even + 1) for _ in range(half_sum + 1) ]
        dp[0][0] = 1  # Base case

        # Fill DP array
        for d in range(10):
            c_d = total_counts[d]
            if c_d == 0:
                continue
            # Precompute combinations C(c_d, k_d)
            comb = [1]  # C(c_d, 0)
            for k_d in range(1, c_d + 1):
                comb.append((comb[-1] * (c_d - k_d + 1) * pow(k_d, mod - 2, mod)) % mod)
            # Update DP array
            for s in range(half_sum, -1, -1):
                for k in range(n_even, -1, -1):
                    val = dp[s][k]
                    if val == 0:
                        continue
                    for count in range(1, min(c_d, n_even - k) + 1):
                        new_s = s + count * d
                        new_k = k + count
                        if new_s > half_sum or new_k > n_even:
                            break
                        dp[new_s][new_k] = (dp[new_s][new_k] + val * comb[count]) % mod

        ways = dp[half_sum][n_even]

        if ways == 0:
            return 0

        perm_even = factorials[n_even]
        perm_odd = factorials[n_odd]

        total_counts_product = 1
        for cnt in total_counts:
            total_counts_product = (total_counts_product * inv_factorials[cnt]) % mod

        answer = (ways * factorials[n_even] * factorials[n_odd]) % mod
        answer = (answer * total_counts_product) % mod

        return answer

",1441347489
Jie Chen,JustJie,282,3627,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<i64, int, int>;

constexpr i64 inf = i64(1e18) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({encode(i, j), t + p, p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -1, 1);
        while (!h.empty()) {
            auto [cur, t, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441324013
Jie Chen,JustJie,282,3628,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<int, int, int>;

constexpr int inf = int(2e9) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({t + p, encode(i, j), 1 ^ 2 ^ p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -2, 2);
        while (!h.empty()) {
            auto [t, cur, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441326480
Jie Chen,JustJie,282,3636,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < s.size(); i++) {
            if (i % 2 == 0) {
                sum += (s[i] - '0');
            } else {
                sum -= (s[i] - '0');
            }
        }
        return (sum == 0);
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441323288
Jie Chen,JustJie,282,3637,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

constexpr int D = 10;
constexpr int N = 81;
constexpr int LIM = 800;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();

        vector<int> cnt(D);
        vector<int> pre(D + 1);
        vector<int> pre2(D + 1);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            int d = s[i] - '0';
            sum += d;
            cnt[d]++;
        }
        for (int d = 0; d < D; d++) {
            pre[d + 1] = pre[d] + cnt[d];
            pre2[d + 1] = pre2[d] + cnt[d] * d;
        }

        if (sum & 1) {
            return 0;
        }

        int w = sum / 2;
        int e = (n + 1) / 2;
        vector dp(e + 1, vector<Z>(w + 1));
        dp[0][0] = 1;

        int o = n - e;
        for (int d = 0; d < D; d++) {
            if (cnt[d] == 0) {
                continue;
            }
            vector ndp(n, vector<Z>(w + 1));
            for (int ec = 0; ec <= e; ec++) {
                int oc = pre[d] - ec;
                for (int eps = 0; eps <= w; eps++) {
                    int ops = pre2[d] - eps;
                    if (dp[ec][eps].val() == 0) {
                        continue;
                    }
                    // cout << ""DP GOOD: "" << ec << "" "" << eps << "" "" << ops << ""\n"";
                    for (int euse = 0; euse <= cnt[d]; euse++) {
                        int ouse = cnt[d] - euse;
                        if (ec + euse > e) {
                            // cout << ""1\n"";
                            break;
                        }
                        if (eps + euse * d > w) {
                            // cout << ""2\n"";
                            break;
                        }
                        if (oc + ouse > o) {
                            // cout << ""3\n"";
                            continue;
                        }
                        if (ops + ouse * d > w) {
                            // cout << ""4\n"";
                            continue;
                        }
                        // cout << ec + euse << "" "" << eps + euse * d << "" "" << ops + ouse * d << ""\n"";
                        ndp[ec + euse][eps + euse * d] += (dp[ec][eps] * comb.binom(e - ec, euse) * comb.binom(o - oc, ouse));
                    }
                }
            }
            dp = std::move(ndp);
        }

        return dp[e][w].val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441380513
kavascg,kavascgjmd39,283,3627,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                 
                    ll val = max((ll)a[ni][nj]+1 , abs(top.first) + 1);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441328219
kavascg,kavascgjmd39,283,3628,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                    ll x = ((top.first >= 0 )? 1: 2);
                    ll val = max((ll)a[ni][nj]+x , abs(top.first) + x);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441327440
kavascg,kavascgjmd39,283,3636,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
class Solution {
public:
    bool isBalanced(string s) {
        ll sum1 = 0, sum2 = 0;
     for(int i = 0 ; i<s.size() ; i++ ){
         if(i & 1){
             sum1 += s[i]-'0';
         }
         else {
             sum2 += s[i]-'0';
         }
     }
        return sum1 == sum2;
    }
};",1441282187
kavascg,kavascgjmd39,283,3637,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
int dp[10][81][721];
vector<ll> fac, inv_fac;
ll binexpo(ll x, ll y, ll mod) {
    ll res = 1;
    while (y > 0) {
        if (y & 1)
            res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
void precompute_factorials(ll n, ll mod) {
    fac.resize(n + 1);
    inv_fac.resize(n + 1);
    fac[0] = fac[1] = 1;
    for (ll i = 2; i <= n; i++) {
        fac[i] = fac[i - 1] * i % mod;
    }
    inv_fac[n] = binexpo(fac[n], mod - 2, mod);
    for (ll i = n - 1; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
    }
}

class Solution {
    int count(vt<int>&a, int i , int len , int sum , int n, int s){
        if(i == 10){
            if(len == n/2 && sum == s){
                return (fac[n/2]*fac[n-n/2])%mod;
            }
            return 0;
        }
        if(dp[i][len][sum] != -1){
            return dp[i][len][sum];
        }
        ll res = 0;
        for(int j = 0  ; j<a[i]+1 ; j++){
            res += (ll)count(a, i+1 , len+j , sum + j*i, n, s) * (ll)(((ll)inv_fac[j] * (ll)inv_fac[a[i]-j]) % mod); res %= mod;
        }
        return dp[i][len][sum] = res;
    }
public:
    int countBalancedPermutations(string a) {
        memset(dp, -1 , sizeof(dp));
        precompute_factorials(81, mod);
        vt<int>v(10, 0);
        ll sum = 0;
        rep(i , 0 , a.size()){
           v[a[i]-'0']++;
            sum += (a[i]-'0');
        }
        if(sum & 1){return 0;}
        sum /= 2;
        ll res = count(v, 0 , 0 ,0 , a.size(), sum  );
       
        return res;
    }
};",1441382036
leetcode_3604,leetcode_3604,284,3627,cpp,"class Solution {
public:
       typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 1;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441387316
leetcode_3604,leetcode_3604,284,3628,cpp,"class Solution {
public:
   typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 2;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441386429
leetcode_3604,leetcode_3604,284,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd(0), even(0);
        for(int i = 0; i < num.size(); ++i) {
            if(i&1) odd += num[i]-'0';
            else even += num[i]-'0';
        }
        return odd == even;
    }
};",1441389379
leetcode_3604,leetcode_3604,284,3637,cpp,"class Solution {
public:
    typedef long long LL;
    LL dp[11][81][810];
    LL mod = 1000000007;
    LL C[90][90];
    int cnt[10];
    int countBalancedPermutations(string s) {
        memset(cnt, 0, sizeof(cnt));
        int sum(0);
        for(auto ch: s) {
            ++cnt[ch - '0'];
            sum += ch - '0';
        }
        if(sum % 2 == 1) return 0;
        memset(C, 0, sizeof(C));
        C[0][0] = 1;
        for(int i = 1; i <= 80; ++i) {
            C[i][0] = 1;
            for(int j = 1; j <= 80; ++j) {
                C[i][j] = C[i-1][j] + C[i-1][j-1];
                C[i][j]  %= mod;
            }
        }
        memset(dp, 0, sizeof(dp));
        //printf(""%lld %lld\n"", C[4][2], C[5][2]);
        int n = s.size();
        dp[0][0][0] = 1;
        int t(0);
        for(int i = 0; i < 10; ++i) {
            for(int j = 0; j <= cnt[i]; ++j) {
                //printf(""%d %d %d\n"", i, j, cnt[i]);
                for(int l = 0; j + l <= n/2; ++l) {
                    for(int k = 0; k + j * i <= sum/2; ++k) {
                        if(n-n/2 - (t - l) < 0) continue;
                        // 
                        dp[i+1][l+j][k+j*i] += C[n/2 - l][j] * C[n-n/2 - (t - l)][cnt[i]-j] % mod * dp[i][l][k] % mod;
                        dp[i+1][l+j][k+j*i] %= mod;
                        //printf(""%d %d %d %d %lld %lld\n"", i, j, l, k, dp[i+1][l+j][k+j*i], dp[i][l][k]);
                    }// 1254, 2145, 5214, 5412, 
                    // 2 * 2 * 2
                }
            }
            t += cnt[i];
        }
        LL ans = dp[10][n/2][sum/2] % mod;
        int f(0);
        for(int i = 0;i < 10; ++i) if (cnt[i] > 0) ++f;
        //if (n % 2 == 0 && f > 1) ans = ans * 2 % mod;
        return ans;
    }
};",1441356783
Sk Najir,Najir581,285,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        set<pair<int, pair<int, int>>> st;
        st.insert({0, {0, 0}});
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;
        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());
            int x = it.first;
            int i = it.second.first;
            int j = it.second.second;
            if (i == n - 1 and j == m - 1)
                return max(x , v[n - 1][m - 1]);
            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 and b >= 0 and a < n and b < m and vis[a][b] == 0) {
                    st.insert({max(x + 1, v[a][b]+1), {a, b}});
                    vis[a][b] = 1;
                }
            }
        }
        return 1;
    }
};",1441318252
Sk Najir,Najir581,285,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        
        set<pair<int, pair<int, pair<int, int>>>> st;
        st.insert({0, {1, {0, 0}}});
        
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;

        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());

            int x = it.first;
            int op = it.second.first;
            int i = it.second.second.first;
            int j = it.second.second.second;

            if (i == n - 1 && j == m - 1) {
                return max(x, v[n - 1][m - 1]);
            }

            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 && b >= 0 && a < n && b < m && vis[a][b] == 0) {
                    vis[a][b] = 1;
                    if (op == 1) {
                        st.insert({max(x + 1, v[a][b] + 1), {2, {a, b}}});
                    } else {
                        st.insert({max(x + 2, v[a][b] + 2), {1, {a, b}}});
                    }
                }
            }
        }
        // Add return statement for when no path is found to the destination.
        return -1;
    }
};
",1441335699
Sk Najir,Najir581,285,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n=s.size();
        int sm1=0,sm2=0;
        for(int i=0;i<n;i++){
            if(i%2)sm1+=(s[i]-'0');
            else sm2+=(s[i]-'0');
        }
        return sm1==sm2;
    }
};",1441283378
Sk Najir,Najir581,285,3637,cpp,"const int MOD = 1e9 + 7;
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
template<const int mod>
struct mint {
    int val;
    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}
    explicit operator int() const { return val; }
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }
    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }
    mint operator-() const { return val == 0 ? 0 : mod - val; }
    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }
    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }
    mint operator++(int32_t) { mint before = *this; ++*this; return before; }
    mint operator--(int32_t) { mint before = *this; --*this; return before; }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
};
using Mint = mint<MOD>;
 
namespace comb {
    int n(0);
    vector<Mint> _fac{1}, _invfac{1}, _inv{0};
    void init(int m) {
        m = min (m, MOD - 1);
        if (m <= n) return;
        _fac.resize(m + 1); _invfac.resize(m + 1); _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) _fac[i] = _fac[i - 1] * i;
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) _invfac[i - 1] = _invfac[i] * i, _inv[i] = _invfac[i] * _fac[i - 1];
        n = m;
    }
    Mint fac(int m) { if (m > n) init(2 * m); return _fac[m]; }
    Mint invfac(int m) { if (m > n) init(2 * m); return _invfac[m]; }
    Mint inv(int m) { if (m > n) init(2 * m); return _inv[m]; }
    Mint ncr(int n, int r) { if (n < r || r < 0) return 0; return fac(n) * invfac(r) * invfac(n - r); }
}
using comb::fac;
using comb::inv;
using comb::invfac;
using comb::ncr;
// shortcut type
typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<ll> vl;
typedef vector<vl> vll;
typedef pair<int, int> pi;
typedef pair<ll, ll> pl;

// Constants
class Solution {
int dp[82][1600][60];
string s;
int odd;
int f(int i,int sm,int odnum){
    if(odnum>odd)return 0;
    if(i<0){
        if(odd==odnum){
            return sm==0;
        }
        return 0;
    }
if(dp[i][sm+1000][odnum]!=-1)return dp[i][sm+1000][odnum];
    int x=f(i-1,sm+(s[i]-'0'),odnum+1);
    int y=f(i-1,sm-(s[i]-'0'),odnum);

    return dp[i][sm+1000][odnum]=((0LL+x+y)%MOD);
    
}
vi fact;
void pre(){
    fact.resize(90);
    fact[0]=1;
    for(int i=1;i<=89;i++){
        fact[i]=(1LL*fact[i-1]*i)%MOD;
    }
}
public:

    int countBalancedPermutations(string num) {
        pre();
        s=num;
        memset(dp,-1,sizeof(dp));
        int n=s.size();
        odd=n/2;
     map<int,int>m;
        for(auto it:s){
            m[it-'0']++;
        }
      int ans= f(n-1,0,0);
        ans=max(ans,0);
        //cout<<ans<<endl;
        Mint a=ans;
        a=(a*fact[odd]*fact[n-odd]);
        for(auto it:m){
            a=(a/(Mint)fact[it.second]);
        }
        return (int)a;
        
        
    }
};",1441395990
Michael Bao,tcmmichaelb139,286,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, -1));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            ans[v.first][v.second] = dist;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                q.push({max(dist + 1, moveTime[x][y]+1), {x, y}});
            }
        }
        for (int i= 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << ans[i][j] << "" \n""[j+1 == m];
            }
        }
        return ans[n-1][m-1];
    }
};",1441313231
Michael Bao,tcmmichaelb139,286,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, 2e9));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            if (v.first == n && v.second == m) break;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                int add = v.first+v.second;
                int ndist = max(dist, moveTime[x][y]) + 1+(add&1);
                if (ans[x][y] <= ndist) continue;
                ans[x][y] = ndist;
                q.push({ndist, {x, y}});
            }
        }
        return ans[n-1][m-1];
    }
};",1441328073
Michael Bao,tcmmichaelb139,286,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int osum = 0;
        int esum = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i&1) osum += num[i]-'0';
            else esum += num[i]-'0';
        }
        return osum == esum;
    }
};",1441284864
Michael Bao,tcmmichaelb139,286,3637,cpp,"class Solution {
public:
    long long MOD = 1e9+7;
    long long add(long long a, long long b) { return (a+b)%MOD;}
    long long mult(long long a, long long b) { return a*b%MOD; }

    long long binpow(long long a, long long b) {
        long long ret = 1;
        while (b) {
            if (b & 1) ret = mult(ret, a);
            a = mult(a, a);
            b >>=1;
        }
        return ret;
    }
    long long fac[50], inv[50];
    void init() {
        fac[0] = 1;
        fac[1] = 1;
        inv[0] = 1;
        inv[1] = 1;
        for (int i = 2; i < 50; i++) {
            fac[i] = mult(i, fac[i-1]);
            inv[i] = binpow(fac[i], MOD-2);
        }
    }
    long long nCr(long long a, long long b) {
        return mult(fac[a], mult(inv[b], inv[a-b]));
    }
    int countBalancedPermutations(string num) {
        init();
        int n = num.length();
        int sum = 0;
        map<int, int> cnt;
        for (int i = 0; i < n; i++) {
            sum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        int halfsum = sum/2+1;
        if (sum & 1) return 0;
        long long dp[11][halfsum][n/2+1];
        memset(dp, 0ll, sizeof dp);
        dp[0][0][0] = 1;
        int rem = 0;
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < halfsum;j++) {
                for (int k = 0; k <= n/2; k++) {
                    for (int a = 0; a <= cnt[i]; a++) {  
                        if (j + a*i >= halfsum) break;
                        if (k + a > n/2) break;
                        int kalt = rem - k;
                        if (kalt < 0) continue;
                        if ((n+1)/2 < cnt[i]-a + kalt) continue;
                        assert(n/2-k >= a);
                        assert((n+1)/2-kalt >= cnt[i]-a);
                        // cout << i << ' ' << j << ' ' << k << ' ' << kalt << ' ' << a << ' ' << dp[i][j][k] << '\n';
                        dp[i+1][j+a*i][k+a] = add(dp[i+1][j+a*i][k+a], 
                            mult(dp[i][j][k], 
                            mult(nCr(n/2-k, a), nCr(((n+1)/2)-kalt, cnt[i]-a))));
                    }
                }
            }
            rem += cnt[i];
        }
        return dp[10][halfsum-1][n/2];
    }
};",1441389966
quynhit,quynhit,287,3627,cpp,"#include <vector>
#include <queue>
#include <limits>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int R = moveTime.size();
        int C = moveTime[0].size();
        
        vector<vector<int>> dist(R, vector<int>(C, numeric_limits<int>::max()));
        auto cmp = [](const array<int, 3>& a, const array<int, 3>& b) { return a[0] > b[0]; };
        priority_queue<array<int, 3>, vector<array<int, 3>>, decltype(cmp)> pq(cmp);
        
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        auto inside = [&](int r, int c) -> bool{
            return r >= 0 && r < R && c >= 0 && c < C;
        };
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0], row = curr[1], col = curr[2];
            if (time > dist[row][col]) continue;
            for(int dir = 0; dir < 4; dir++){
                int newRow = row + dx[dir];
                int newCol = col + dy[dir];
                
                if (inside(newRow, newCol)) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[R - 1][C - 1];
    }
};",1441329395
quynhit,quynhit,287,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size(), m = moveTime[0].size();
        auto inside = [&](int r, int c){
            return r >= 0 && r < n && c >= 0 && c < m;
        };
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, LLONG_MAX)));
        d[0][0][0] = 0;
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> q;
        q.push({0, {0, 0, 0}});
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        while (!q.empty()) {
            auto [t, v] = q. top();
            q.pop();
            int i = v[0], j = v[1], p = v[2];
            if (t > d[i][j][p]) continue;
            for(int dir = 0; dir < 4; dir++){
                int ni = i + dx[dir], nj = j + dy[dir];
                if (inside(ni, nj)) {
                    int nt = max(t, 1LL * moveTime[ni][nj]) + (p ? 2 : 1);
                    if (nt < d[ni][nj][!p]) {
                        d[ni][nj][!p] = nt;
                        q.push({nt, {ni, nj, !p}});
                    }
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
        #undef int
    }
};",1441347079
quynhit,quynhit,287,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i = 0; i < size(num); i++){
            if(i & 1){
                odd += num[i] - '0';
            } else {
                even += num[i] - '0';
            }
        }
        return even == odd;
    }
};",1441280930
quynhit,quynhit,287,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
#define int long long

int power_mod(int base, int exponent) {
    int result = 1;
    base %= MOD;
    while (exponent > 0) {
        if (exponent & 1) {
            result = result * base % MOD;
        }
        base = base * base % MOD;
        exponent >>= 1;
    }
    return result;
}

class Solution {
public:
    #undef int
    int countBalancedPermutations(string num) {
        #define int long long 
        int total_sum = 0;
        vector<int> frequency(10, 0);
        for (auto c : num) {
            frequency[c - '0']++;
            total_sum += (c - '0');
        }
        if (total_sum & 1) return 0;
        int n = size(num);
        int half_sum = total_sum / 2, half_length = (n + 1) / 2;
        vector<int> factorial(n + 1, 1);
        for (int i = 1; i <= n; i++)
            factorial[i] = factorial[i - 1] * i % MOD;
        vector<int> inverse_factorial(n + 1, 1);
        inverse_factorial[n] = power_mod(factorial[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
            inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % MOD;
        vector<vector<int>> dp(half_length + 1, vector<int>(half_sum + 1, 0));
        dp[0][0] = 1;
        for (int digit = 0; digit <= 9; digit++) {
            if (frequency[digit] == 0) continue;
            for (int count = half_length; count >= 0; count--)
                for (int sum = half_sum; sum >= 0; sum--) {
                    if (dp[count][sum] == 0) continue;
                    for (int times = 1; times <= min(frequency[digit], half_length - count); times++) {
                        if (sum + digit * times > half_sum) break;
                        int combinations = (factorial[frequency[digit]] * inverse_factorial[times] % MOD) * inverse_factorial[frequency[digit] - times] % MOD;
                        dp[count + times][sum + digit * times] = (dp[count + times][sum + digit * times] + dp[count][sum] * combinations) % MOD;
                    }
                }
        }

        int valid_assignments = dp[half_length][half_sum];
        if (valid_assignments == 0) return 0;
        int product_factorials = 1;
        for (int digit = 0; digit <= 9; digit++)
            product_factorials = product_factorials * factorial[frequency[digit]] % MOD;
        int fk_fnk = (factorial[half_length] * factorial[n - half_length]) % MOD;
        int inv_product_factorials = power_mod(product_factorials, MOD - 2);
        return (((fk_fnk * valid_assignments) % MOD) * inv_product_factorials) % MOD;
        #undef int
    }
};",1441385400
Abhi7527,Abhi7527,288,3627,cpp,"class Solution {
public:
int dirr[4]={-1,0,1,0};
int dirc[4]={0,-1,0,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>>dp(moveTime.size(),vector<int>(moveTime[0].size(),INT_MAX));
        queue<pair<int,int>>q;
        dp[0][0]=0;
        q.push({0,0});
        while(!q.empty()){
            int row=q.front().first;
            int col=q.front().second;
            q.pop();
            for(int k=0;k<4;k++){
                int rowi=row+dirr[k];
                int coli=col+dirc[k];
                if(rowi<n && coli<m && rowi>=0 && coli>=0){
                    int l=dp[row][col];
                    int b=moveTime[rowi][coli];
                    int y=max(l,b);
                    if(dp[rowi][coli]>y+1){
                        dp[rowi][coli]=y+1;
                        q.push({rowi,coli});
                    }
                }
            }
        }
        return dp[n-1][m-1];
        
    }
};",1441298215
Abhi7527,Abhi7527,288,3628,cpp,"#include <vector>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

class Solution {
public:
    int dirr[4] = {-1, 0, 1, 0};
    int dirc[4] = {0, -1, 0, 1};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, pair<int,int>>>, vector<pair<int, pair<int, pair<int,int>>>>, greater<pair<int, pair<int, pair<int,int>>>>> pq;
        
        dp[0][0] = 0;
        pq.push({0, {0, {0,1}}}); // {time, {row, col}}

        while (!pq.empty()) {
           int dis=pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second.first;
            int step=pq.top().second.second.second;
            pq.pop();

            if (row == n - 1 && col == m - 1) {
                return dis;
            }

            for (int k = 0; k < 4; ++k) {
                int newRow = row + dirr[k];
                int newCol = col + dirc[k];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(dis, moveTime[newRow][newCol]);
                    if (dp[newRow][newCol] > newTime+step) {
                        dp[newRow][newCol] = newTime+step;
                        if(step==1){
                        pq.push({ dp[newRow][newCol], {newRow, {newCol,2}}});
                        }
                        else{
                            pq.push({ dp[newRow][newCol], {newRow, {newCol,1}}});
                            
                        }
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
",1441319049
Abhi7527,Abhi7527,288,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0;
        int b=0;
        for(int i=0;i<num.size();i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        if(a==b){
            return true;
        }
        return false;
    }
};",1441283773
Abhi7527,Abhi7527,288,3637,cpp,"class Solution {
public:
int mod=1e9+7;
int l;
int lena,lenb;
vector<vector<long long>>pnc;
int yi(vector<vector<long long>>&pn,int n,int r){
    if(n==r || r==0){
        return 1;
    }
    if(pn[n][r]!=-1){
        return pn[n][r];
    }
    return pn[n][r]=(yi(pn,n-1,r)+yi(pn,n-1,r-1))%mod;
}

long long y(vector<vector<vector<long long>>>&dp,int i,int sum,int len,vector<pair<int,int>>&vec,vector<int>&p){
    
    if(i==vec.size()){
        if(sum==0){
       return 1;
    }
        return 0;
    }
    if(dp[i][sum][len]!=-1){
        return dp[i][sum][len];
    }
    long long ans=0;
    int gh=p[i]-len;
    for(int k=0;k<=vec[i].second;k++){
        
        if(len>=k && gh>=vec[i].second-k && sum>=k*vec[i].first){
            
            long long h=(pnc[len][k]*pnc[gh][vec[i].second-k])%mod;
            ans=(ans+h*(y(dp,i+1,sum-k*vec[i].first,len-k,vec,p)%mod))%mod;
        }
    }
    return dp[i][sum][len]=ans%mod;
}

    int countBalancedPermutations(string num) {
        pnc=vector<vector<long long>>(41,vector<long long>(41,-1));
        for(int i=0;i<=40;i++){
            for(int j=0;j<=40;j++){
                if(i>=j){
                     pnc[i][j]=yi(pnc,i,j);
                }
               
            }
        }
        l=num.length();
        unordered_map<int,int>mp;
        int l=0;
        for(auto it:num){
           mp[it-'0']++;
            l+=it-'0';
        }
        vector<pair<int,int>>vec;
        vector<int>p;
        int li=num.length();
        for(auto it:mp){
            p.push_back(li);
            vec.push_back({it.first,it.second});
            li-=it.second;
        }
        
        if(l%2){
            return 0;
        }
        vector<vector<vector<long long>>>dp(vec.size(),vector<vector<long long>>(l/2+1,vector<long long>(num.length()/2+1,-1)));
        return y(dp,0,l/2,num.length()/2,vec,p);
        
    }
};",1441396105
Anshuman Kanungo,PeacefulGuy,291,3627,cpp,"#include <vector>
#include <queue>
#include <climits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        vector<vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.empty()) {
            vector<int> curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};
",1441372568
Anshuman Kanungo,PeacefulGuy,291,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        // 3D array to store minimum time
        int[][][] d = new int[n][m][2];
        for (int[][] layer : d) {
            for (int[] row : layer) {
                java.util.Arrays.fill(row, Integer.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        // Priority queue stores {time, x, y, p}
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        q.offer(new int[]{0, 0, 0, 0}); // {time, x, y, p}

        // Directions for movement (down, right, up, left)
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!q.isEmpty()) {
            int[] current = q.poll();
            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (int[] dir : directions) {
                int ni = i + dir[0];
                int nj = j + dir[1];

                // Check bounds
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 1 ? 2 : 1);

                    // Update minimum time if found a better path
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        q.offer(new int[]{nt, ni, nj, 1 - p}); // Update state
                    }
                }
            }
        }

        // Return the minimum time to reach the bottom-right corner
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441345048
Anshuman Kanungo,PeacefulGuy,291,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0'; // Convert char to integer

            if (i % 2 == 0) { // Even index
                evenSum += digit;
            } else { // Odd index
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}
",1441292483
Anshuman Kanungo,PeacefulGuy,291,3637,java,"import java.util.Arrays;

class Solution {
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;

    private long powerMod(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerMod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        long totalSum = 0;
        int[] freq = new int[10];

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;

        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;

        return (int) answer;
    }
}
",1441381843
Titas,ads3k,294,3627,python3,"from heapq import heappush, heappop
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        # Array to store minimum time to reach each cell
        dp = [[float('inf')] * m for _ in range(n)]
        dp[0][0] = 0

        # Priority queue to store (current_time, row, col)
        pq = [(0, 0, 0)]

        # Directions: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while pq:
            curr_time, row, col = heappop(pq)

            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return curr_time

            # Skip if we've found a better path
            if curr_time > dp[row][col]:
                continue

            # Try all possible directions
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy

                # Check if new position is within bounds
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate waiting time if needed
                    wait_time = max(0, moveTime[new_row][new_col] - curr_time)
                    next_time = curr_time + wait_time + 1  # Add 1 for movement

                    # Update if we found a better path
                    if next_time < dp[new_row][new_col]:
                        dp[new_row][new_col] = next_time
                        heappush(pq, (next_time, new_row, new_col))

        return dp[n - 1][m - 1]
",1441303344
Titas,ads3k,294,3628,python3,"import heapq

class Solution(object):
    # Dummy functions
    def dummyFunc1(self): pass
    def dummyFunc2(self): pass
    def dummyFunc3(self): pass
    def dummyFunc4(self): pass
    def dummyFunc5(self): pass
    def dummyFunc6(self): pass
    def dummyFunc7(self): pass
    def dummyFunc8(self): pass
    def dummyFunc9(self): pass
    def dummyFunc10(self): pass

    def minTimeToReach(self, mt):
        # Dummy variables
        a1, a2, a3, a4, a5, a6, a7, a8, a9, a0 = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        n = len(mt)
        m = len(mt[0])
        
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        pq = [(0, (0, 0, 0))]

        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            if t > d[i][j][p]:
                continue

            d_idx = 0  # Loop variable for direction indexing
            while d_idx < len(directions):
                di, dj = directions[d_idx]
                ni, nj = i + di, j + dj

                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, mt[ni][nj]) + (2 if p else 1)
                    
                    if nt < d[ni][nj][1 - p]:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))

                d_idx += 1  # Increment direction index

        return min(d[n-1][m-1][0], d[n-1][m-1][1])
",1441376394
Titas,ads3k,294,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Dummy variables
        a, b, c, d, e, f, g, h, i, j = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        
        # Dummy functions
        def dummy_func1(): pass
        def dummy_func2(): pass
        def dummy_func3(): pass
        def dummy_func4(): pass
        def dummy_func5(): pass
        def dummy_func6(): pass
        def dummy_func7(): pass
        def dummy_func8(): pass
        def dummy_func9(): pass
        def dummy_func10(): pass
        
        # Actual solution
        even_sum, odd_sum = 0, 0
        idx = 0
        length = len(num)
        
        while idx < length:
            digit = int(num[idx])
            if idx % 2 == 0:
                even_sum += digit
            else:
                odd_sum += digit
            idx += 1
            
        return even_sum == odd_sum
",1441293345
Titas,ads3k,294,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact;
vector<ll> inv_fact;

// Dummy variables
ll a1, a2, a3, a4, a5, a6, a7, a8, a9, a0;

ll power_mod_func(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    int i = 1; // Loop variable for while loop
    while (i <= n) {
        fact[i] = fact[i - 1] * i % MOD;
        i++;
    }
    inv_fact.assign(n + 1, 1);
    inv_fact[n] = power_mod_func(fact[n], MOD - 2);
    i = n - 1; // Reset loop variable for another while loop
    while (i >= 0) {
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        i--;
    }
}

class Solution {
public:
    // Dummy functions
    void dummyFunc1() {}
    void dummyFunc2() {}
    void dummyFunc3() {}
    void dummyFunc4() {}
    void dummyFunc5() {}
    void dummyFunc6() {}
    void dummyFunc7() {}
    void dummyFunc8() {}
    void dummyFunc9() {}
    void dummyFunc10() {}

    int countBalancedPermutations(string num) {
        int n = num.size();
        string s1 = num; // Replacing variable names with single-character ones
        string s2 = num;

        int freq[10] = {0};
        ll total_sum = 0;
        for (char c : num) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        ll sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(sum_half + 1, 0));
        dp[0][0] = 1;

        int d = 0; // Loop variable for the outer loop
        while (d <= 9) {
            if (freq[d] == 0) {
                d++;
                continue;
            }
            int c = k; // Loop variable for the next loop
            while (c >= 0) {
                ll s = sum_half; // Reset loop variable for the innermost loop
                while (s >= 0) {
                    if (dp[c][s] == 0) {
                        s--;
                        continue;
                    }
                    int t = 1; // Loop variable for the combination
                    while (t <= min(freq[d], k - c)) {
                        if (s + (ll)d * t > sum_half) break;
                        ll comb = (fact[freq[d]] * inv_fact[t] % MOD) * inv_fact[freq[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                c--;
            }
            d++;
        }

        ll valid_assignments = dp[k][sum_half];
        if (valid_assignments == 0) return 0;

        ll prod_fact_fd = 1;
        int f = 0; // Loop variable for the product calculation
        while (f <= 9) {
            prod_fact_fd = prod_fact_fd * fact[freq[f]] % MOD;
            f++;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_prod_fact_fd = power_mod_func(prod_fact_fd, MOD - 2);
        ll answer = (fk_fnk * valid_assignments) % MOD;
        answer = (answer * inv_prod_fact_fd) % MOD;

        return (int)answer;
    }
};
",1441375573
Sagnik Goswami,sagi_1523,295,3627,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<ppi, vector<ppi>, greater<ppi>> pq;  // {time, {row, col}}

        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it.first;
            int row = it.second.first;
            int col = it.second.second;

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);
                    
                    int newTime = waitTime + 1;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, {adjRow, adjCol}});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441339781
Sagnik Goswami,sagi_1523,295,3628,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;  // {time, row, col, prevMovePt (1 or 2)}

        pq.push({0, 0, 0, 2});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it[0];
            int row = it[1];
            int col = it[2];
            int prevMoveTime = it[3];

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);

                    int timeMove = (prevMoveTime == 1) ? 2 : 1;
                    int newTime = waitTime + timeMove;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, adjRow, adjCol, timeMove});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441338982
Sagnik Goswami,sagi_1523,295,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sumEven = 0, sumOdd = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sumOdd += num[i] - '0';
            else sumEven += num[i] - '0';
        }

        return sumEven == sumOdd;
    }
};",1441281467
Sagnik Goswami,sagi_1523,295,3637,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    vector<long long> fact;
    
    void precomputeFactorials(int n) {
        fact.resize(n + 1);
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
    }
    
    long long modPow(long long base, int exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp & 1) result = (result * base) % MOD;
            base = (base * base) % MOD;
            exp >>= 1;
        }
        return result;
    }
    
    vector<vector<vector<int>>> dp;
    vector<int> freq, remFreq;
    string num;
    int n;
    
    int solve(int pos, int sumNeeded, int remLen) {
        if (sumNeeded < 0 || remLen < 0) return 0;
        if (pos == n) return (remLen == 0 && sumNeeded == 0);
        
        if (dp[pos][sumNeeded][remLen] != -1) 
            return dp[pos][sumNeeded][remLen];
        
        long long res = solve(pos + 1, sumNeeded, remLen);
        
        int digit = num[pos] - '0';
        if (remFreq[digit] > 0) {
            remFreq[digit]--;
            freq[digit]++;
            
            res = (res + solve(pos + 1, sumNeeded - digit, remLen - 1)) % MOD;
            
            freq[digit]--;
            remFreq[digit]++;
        }
        
        return dp[pos][sumNeeded][remLen] = res;
    }
    
    long long getPermutations() {
        long long evenDenominator = 1, oddDenominator = 1;
        
        for (int i = 0; i < 10; i++) {
            if (freq[i]) evenDenominator = (evenDenominator * fact[freq[i]]) % MOD;
            if (remFreq[i]) oddDenominator = (oddDenominator * fact[remFreq[i]]) % MOD;
        }
        
        long long evenWays = (fact[(n + 1) / 2] * modPow(evenDenominator, MOD - 2)) % MOD;
        long long oddWays = (fact[n / 2] * modPow(oddDenominator, MOD - 2)) % MOD;
        return (evenWays * oddWays) % MOD;
    }
    
public:
    int countBalancedPermutations(string s) {
        num = s;
        n = num.length();
        
        int sum = 0;
        freq.assign(10, 0);
        remFreq.assign(10, 0);
        
        for (char c : num) {
            sum += c - '0';
            remFreq[c - '0']++;
        }
        
        if (sum & 1) return 0;
        
        int halfSum = sum / 2;
        int evenPos = (n + 1) / 2;
        
        dp.assign(n + 1, vector<vector<int>>(halfSum + 1, vector<int>(evenPos + 1, -1)));
        precomputeFactorials(n);
        
        int ways = solve(0, halfSum, evenPos);
        if (ways == 0) return 0;
        
        return (ways * getPermutations()) % MOD;
    }
};",1441389799
Jaeha Yi,jaehayi1,296,3627,python3,"from heapq import heapify, heappush, heappop

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        '''
        greedy, sort by moveTime
        '''

        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[2e9] * m for _ in range(n)]
        dp[0][0] = 0
        heappush(pq, (0, 0, 0))

        vis = set()

        while pq:
            t, i, j = heappop(pq)

            if (i, j) in vis: continue
            vis.add((i, j))

            if i + 1 < n: 
                dp[i + 1][j] = min(dp[i + 1][j], max(dp[i][j] + 1, moveTime[i + 1][j] + 1))
                heappush(pq, (dp[i + 1][j], i + 1, j))
                
            if j + 1 < m: 
                dp[i][j + 1] = min(dp[i][j + 1], max(dp[i][j] + 1, moveTime[i][j + 1] + 1))
                heappush(pq, (dp[i][j + 1], i, j + 1))

            if i - 1 >= 0: 
                dp[i - 1][j] = min(dp[i - 1][j], max(dp[i][j] + 1, moveTime[i - 1][j] + 1))
                heappush(pq, (dp[i - 1][j], i - 1, j))

            if j - 1 >= 0: 
                dp[i][j - 1] = min(dp[i][j - 1], max(dp[i][j] + 1, moveTime[i][j - 1] + 1))
                heappush(pq, (dp[i][j - 1], i, j - 1))

            # print(pq)

        # print(dp)

        return dp[n - 1][m - 1]
                ",1441311233
Jaeha Yi,jaehayi1,296,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[[2e9] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        heappush(pq, (0, 0, 0, 0))

        vis = set()

        while pq:
            t, i, j, mode = heappop(pq)

            if (i, j, mode) in vis: continue
            vis.add((i, j, mode))
            mode2 = (mode + 1) % 2
            add = (1 if mode == 0 else 2)

            for i2, j2 in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]: 
                if i2 < 0 or j2 < 0 or i2 >= n or j2 >= m: continue
                    
                dp[i2][j2][mode2] = min(dp[i2][j2][mode2], max(dp[i][j][mode] + add, moveTime[i2][j2] + add))
                heappush(pq, (dp[i2][j2][mode2], i2, j2, mode2))

        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]) ",1441324275
Jaeha Yi,jaehayi1,296,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)): 
            x = int(num[i])
            if i % 2 == 0: 
                # print(""even"", x)
                even += x
            else: 
                odd += x

        if even == odd: 
            return True
        return False",1441282985
Jaeha Yi,jaehayi1,296,3637,python3,"import math
from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        '''
        max sum = 80 * 9 / 2 = ~ 360

        dp[sum1][i] = num ways to achieve sums1 with i numbers used in sum1

        Two options: 
            keep number i in sum1, or throw away (put in sum2)

        Space complexity: 360 * 360 * 80 = 10^7
        '''

        mod = int(1e9 + 7)
        n = len(num)
        sn = sum([int(num[i]) for i in range(n)])
        if sn % 2 != 0: return 0
        
        goal = sn // 2

        dp = [[0] * (n // 2 + 1) for _ in range(goal + 1)]
        dp[0][0] = 1
        if int(num[0]) <= goal: dp[int(num[0])][1] = 1
        
        for i in range(1, n): 
            d = int(num[i])
            for x in range(goal, -1, -1): 
                for j in range(i + 1, -1, -1): 
                    if x - d >= 0 and j - 1 >= 0 and j < (n // 2 + 1): 
                        dp[x][j] = (dp[x][j] + dp[x - d][j - 1]) 
        
        factor = (math.factorial(n // 2) * math.factorial(n - n // 2))
        res = dp[goal][n // 2] * factor
        
        c = Counter(num)
        for d in c: 
            res = res // math.factorial(c[d])
        
        return res % mod
                
                

        ",1441391166
Edwin Chen,echen5503,297,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0] = 0
        while pq:
            time, i, j = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+1
                if dist[x, y] > t:
                    dist[x, y] = t
                    heapq.heappush(pq, (t, x, y))

        return dist[n-1, m-1]
                ",1441293027
Edwin Chen,echen5503,297,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0,0] = 0
        while pq:
            time, i, j, state = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+state+1
                if dist[x, y, state^1] > t:
                    dist[x, y, state^1] = t
                    heapq.heappush(pq, (t, x, y, state^1))

        return min(dist[n-1, m-1, 0], dist[n-1, m-1, 1])
                ",1441295224
Edwin Chen,echen5503,297,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = sum(int(x) for x in num[0:n:2])
        b = sum(int(x) for x in num[1:n:2])

        return a == b",1441281001
Edwin Chen,echen5503,297,3637,python3,"M = int(1e9+7)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(int(x) for x in num)
        n = len(num)
        cnt = Counter(num)
        tot = sum(num)

        if tot % 2 != 0:
            return 0

        @cache
        def fact(n):
            return 1 if n == 0 else n*fact(n-1)

        def inv(x):
            return pow(x, M-2, M)
            
        @cache
        def dp(i, s, used):
            if i == 10:
                if s == tot//2 and (used == n//2 or used == ceil(n/2)):
                    return (fact(used) * fact(n-used)) % M
                return 0

            if used > ceil(n/2):
                return 0
            if s > tot//2:
                return 0
            if sum(cnt[x] for x in range(i, 10)) + used < n//2:
                return 0
            ans = 0
            for amt in range(0, cnt[i]+1):
                ans += dp(i+1, s+amt*i, used+amt) * inv(fact(amt)) * inv(fact(cnt[i]-amt))
                ans %= M
            return ans
            
        ans = dp(0, 0, 0)
        if n % 2 == 1:
            ans *= inv(2)
            ans %= M
        return ans",1441392050
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3627,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] travelTime) { // Renamed to match the call
        int rows = travelTime.length;
        int cols = travelTime[0].length;
        int[][] minTime = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(minTime[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));

        queue.offer(new int[]{0, 0, 0});
        minTime[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int currentTime = current[0];
            int x = current[1];
            int y = current[2];

            if (currentTime > minTime[x][y]) continue;

            for (int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int updatedTime = Math.max(currentTime, travelTime[newX][newY]) + 1;

                    if (updatedTime < minTime[newX][newY]) {
                        minTime[newX][newY] = updatedTime;
                        queue.offer(new int[]{updatedTime, newX, newY});
                    }
                }
            }
        }

        return minTime[rows - 1][cols - 1];
    }
}
",1441324048
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3628,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        // 3D dp table to store minimum time to reach each cell with both parities (0 and 1)
        int[][][] minTime = new int[rows][cols][2];
        for (int[][] row : minTime) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        minTime[0][0][0] = 0;

        // Deque for BFS-like traversal with time-based ordering
        Deque<int[]> deque = new ArrayDeque<>();
        deque.offerFirst(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        // Directions for moving up, down, left, and right
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!deque.isEmpty()) {
            int[] state = deque.pollFirst();
            int currTime = state[0];
            int row = state[1];
            int col = state[2];
            int parity = state[3];

            if (currTime > minTime[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int nextTime = Math.max(currTime, moveTime[newRow][newCol]) + (parity == 1 ? 2 : 1);

                    if (nextTime < minTime[newRow][newCol][1 - parity]) {
                        minTime[newRow][newCol][1 - parity] = nextTime;
                        if (parity == 0) {
                            deque.offerFirst(new int[]{nextTime, newRow, newCol, 1 - parity});
                        } else {
                            deque.offerLast(new int[]{nextTime, newRow, newCol, 1 - parity});
                        }
                    }
                }
            }
        }

        return Math.min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }
}
",1441312124
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';  // Convert character to integer
            
            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }
        
        return evenSum == oddSum;
    }
}
",1441283653
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3637,java,"import java.util.*;

public class Solution {
    static final int MOD = 1000000007;
    long[] fact;
    long[] invFact;

    private long powerModFunc(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerModFunc(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long totalSum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;

        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = fact[freq[d]] * invFact[t] % MOD * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = fact[k] * fact[n - k] % MOD;
        long invProdFactFd = powerModFunc(prodFactFd, MOD - 2);
        long answer = fkFnk * validAssignments % MOD * invProdFactFd % MOD;

        return (int) answer;
    }
}
",1441391551
choudharykritik,choudharykritik,299,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 1: 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441390056
choudharykritik,choudharykritik,299,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 2 : 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441388976
choudharykritik,choudharykritik,299,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sm1=0,sm2=0;
        for(int i=0;i<num.size();i+=2){
            sm1+=(num[i]-'0');
        }
        for(int i=1;i<num.size();i+=2){
            sm2+=(num[i]-'0');
        }
        if(sm1==sm2){
            return true;
        }
        return false;
    }
};",1441285033
choudharykritik,choudharykritik,299,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact, inv_fact;

ll mod_pow(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;

    inv_fact.assign(n + 1, 1);
    inv_fact[n] = mod_pow(fact[n], MOD - 2);
    for (int i = n - 1; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> f(10, 0);
        ll sum = 0;

        for (char c : num) {
            int d = c - '0';
            f[d]++;
            sum += d;
        }

        if (sum % 2 != 0) return 0;
        ll half = sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (f[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (ll s = half; s >= 0; s--) {
                    if (dp[c][s] == 0) continue;
                    for (int t = 1; t <= min(f[d], k - c); t++) {
                        if (s + (ll)d * t > half) break;
                        ll comb = (fact[f[d]] * inv_fact[t] % MOD) * inv_fact[f[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                    }
                }
            }
        }

        ll valid = dp[k][half];
        if (valid == 0) return 0;

        ll fact_prod = 1;
        for (int d = 0; d <= 9; d++) {
            fact_prod = fact_prod * fact[f[d]] % MOD;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_fact_prod = mod_pow(fact_prod, MOD - 2);
        ll ans = (fk_fnk * valid % MOD) * inv_fact_prod % MOD;

        return (int)ans;
    }
};
",1441386306
GoIsTheBestLang,__golang__,300,3627,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    dis[v] = max(d + w, moveTime[i][j] + 1)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441326693
GoIsTheBestLang,__golang__,300,3628,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    if (i + j) & 1:
                        dis[v] = max(d + w, moveTime[i][j] + 1)
                    else:
                        dis[v] = max(d + w + 1, moveTime[i][j] + 2)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441329752
GoIsTheBestLang,__golang__,300,3637,python3,"MOD = 10 ** 9 + 7

MAX = 100

fac = [0] * MAX
inv = [0] * MAX

fac[0] = 1
inv[0] = 1
for i in range(1, MAX):
    fac[i] = fac[i - 1] * i % MOD
    inv[i] = pow(fac[i], MOD-2, MOD)

def comb(n, k):
    return fac[n] * inv[k] % MOD * inv[n - k] % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        cnt = Counter(list(map(int, num)))
        tot = sum(int(ch) for ch in num)
        if tot & 1:
            return 0
        @cache
        def dfs(i, s, c):
            if s > tot // 2:
                return 0
            if i == 10:
                if s != tot // 2:
                    return 0
                if c == len(num) // 2:
                    return fac[len(num) // 2] * fac[(len(num) + 1) // 2] % MOD
                return 0
            ans = 0
            for j in range(cnt[i] + 1):
                ans += dfs(i + 1, s + j * i, c + j) * inv[j] * inv[cnt[i] - j] % MOD
                ans %= MOD
            return ans
        return dfs(0, 0, 0)
            
        
        ",1441302966
forwarding7,forwarding7,301,3627,cpp,"
class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + 1, x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + 1, x, y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + 1, x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + 1, x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441303584
forwarding7,forwarding7,301,3628,cpp,"class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 1, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, next, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + next, 3 - next,
                              x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + next, 3 - next, x,
                              y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + +next, 3 - next,
                              x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + +next, 3 - next,
                              x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441305751
forwarding7,forwarding7,301,3637,cpp,"class Solution {
  public:
    using ll = long long;
    int countBalancedPermutations(std::string num) {
        constexpr int mod = 1e9 + 7;

        int n = (int)num.size();
        ll res;

        std::vector<int> nums;
        int sum = 0;
        for (auto c : num) {
            nums.emplace_back(c - '0');
            sum += (c - '0');
        }
        if (sum % 2 == 1) {
            return 0;
        }

        int target = sum / 2;
        int target_size = (int)nums.size() / 2;
        std::vector<std::vector<int>> dp(target_size + 1,
                                         std::vector<int>(target + 1, 0));
        dp[0][0] = 1;
        for (auto number : nums) {
            for (int i = target_size; i >= 1; --i) {
                for (int j = target; j >= number; --j) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - number]) % mod;
                }
            }
        }

        auto factorialMod = [](ll n) -> ll {
            ll result = 1;
            for (ll i = 2; i <= n; ++i) {
                result = (result * i) % mod;
            }
            return result;
        };

        // 计算每个数字的频率
        std::unordered_map<int, int> freq;
        for (auto number : nums) {
            freq[number]++;
        }

        // 计算排列数的去重因子
        ll duplicateFactor = 1;
        for (const auto &[key, value] : freq) {
            duplicateFactor = (duplicateFactor * factorialMod(value)) % mod;
        }

        auto f = dp[target_size][target];
        if (nums.size() % 2 == 0) {
            auto a = factorialMod(target_size);
            res = ((a * a) % mod * f) % mod;
        } else {
            auto a = factorialMod(target_size);
            auto b = factorialMod(target_size + 1);
            res = ((a * b) % mod * f) % mod;
        }

        res = (res * modInverse(duplicateFactor, mod)) % mod;
        return (int)(res);
    }

  private:
    // 快速幂求逆元
    ll modInverse(ll a, ll m) {
        ll m0 = m, t, q;
        ll x0 = 0, x1 = 1;
        if (m == 1)
            return 0;
        while (a > 1) {
            q = a / m;
            t = m;
            m = a % m, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0)
            x1 += m0;
        return x1;
    }
};",1441330435
arunkumar saranga,arunkumarsaranga,302,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] a) {
        int x = a.length;
        int y = a[0].length;
        int[][][] b = f(x, y);
        b[0][0][0] = 0;
        PriorityQueue<int[]> c = new PriorityQueue<>((d, e) -> Integer.compare(d[0], e[0]));
        c.offer(new int[]{0, 0, 0, 0});
        int[][] g = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!c.isEmpty()) {
            h(c, b, g, a, x, y);
        }
        
        return Math.min(b[x - 1][y - 1][0], b[x - 1][y - 1][1]);
    }
    
    private int[][][] f(int x, int y) {
        int[][][] b = new int[x][y][2];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                b[i][j][0] = Integer.MAX_VALUE;
                b[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return b;
    }
    
    private void h(PriorityQueue<int[]> c, int[][][] b, int[][] g, int[][] a, int x, int y) {
        int[] i = c.poll();
        int j = i[0];
        int k = i[1];
        int l = i[2];
        int m = i[3];
        
        if (j > b[k][l][m]) return;
        
        for (int[] n : g) {
            int o = k + n[0];
            int p = l + n[1];
            if (o >= 0 && o < x && p >= 0 && p < y) {
                int q = Math.max(j, a[o][p]) + (m == 0 ? 1 : 2);
                int r = 1 - m;
                
                if (q < b[o][p][r]) {
                    b[o][p][r] = q;
                    c.offer(new int[]{q, o, p, r});
                }
            }
        }
    }
}
",1441377032
arunkumar saranga,arunkumarsaranga,302,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        l=list(map(int,s))
        x=l[0::2]
        # print(x)
        y=l[1::2]
        # print(y)
        return sum(x)==sum(y)",1441349852
arunkumar saranga,arunkumarsaranga,302,3637,python3,"MOD = 1000000007

def p(x, y):
    z = 1
    x %= MOD
    while y > 0:
        if y & 1:
            z = z * x % MOD
        x = x * x % MOD
        y >>= 1
    return z

a = []
b = []

def b_init(m):
    global a, b
    a = [1] * (m + 1)
    for c in range(1, m + 1):
        a[c] = a[c - 1] * c % MOD
    b = [1] * (m + 1)
    b[m] = p(a[m], MOD - 2)
    for c in range(m - 1, -1, -1):
        b[c] = b[c + 1] * (c + 1) % MOD

class Solution:
    def countBalancedPermutations(self, q: str) -> int:
        m = len(q)
        n = [0] * 10
        r = 0
        for x in q:
            s = int(x)
            n[s] += 1
            r += s

        if r % 2 != 0:
            return 0
        g = r // 2
        h = (m + 1) // 2
        b_init(m)
        
        dp = [[0] * (g + 1) for _ in range(h + 1)]
        dp[0][0] = 1
        
        for s in range(10):
            if n[s] == 0:
                continue
            for t in range(h, -1, -1):
                for u in range(g, -1, -1):
                    if dp[t][u] == 0:
                        continue
                    for v in range(1, min(n[s], h - t) + 1):
                        if u + s * v > g:
                            break
                        w = (a[n[s]] * b[v] % MOD) * b[n[s] - v] % MOD
                        dp[t + v][u + s * v] = (dp[t + v][u + s * v] + dp[t][u] * w) % MOD

        x = dp[h][g]
        if x == 0:
            return 0

        y = 1
        for s in range(10):
            y = y * a[n[s]] % MOD

        z = a[h] * a[m - h] % MOD
        i_y = p(y, MOD - 2)

        result = (z * x % MOD) * i_y % MOD
        return result
",1441386739
klu2200031955,klu2200031955,303,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] d = initializeDistanceMatrix(n, m);
        PriorityQueue<Node> queue = initializeQueue();

        queue.offer(new Node(0, 0, 0, 0));

        return processQueue(queue, d, moveTime, n, m);
    }

    private int[][][] initializeDistanceMatrix(int rows, int cols) {
        int[][][] distanceMatrix = new int[rows][cols][2];
        for (int[][] row : distanceMatrix) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        distanceMatrix[0][0][0] = 0;  // Starting point
        return distanceMatrix;
    }

    private PriorityQueue<Node> initializeQueue() {
        return new PriorityQueue<>();
    }

    private int[][] getDirections() {
        return new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    }

    private int processQueue(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, int n, int m) {
        int[][] directions = getDirections();

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.time > distance[node.x][node.y][node.parity]) continue;

            updateDistances(queue, distance, moveTime, node, directions, n, m);
        }

        return Math.min(distance[n - 1][m - 1][0], distance[n - 1][m - 1][1]);
    }

    private void updateDistances(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, Node node, int[][] directions, int n, int m) {
        for (int[] dir : directions) {
            int ni = node.x + dir[0];
            int nj = node.y + dir[1];

            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                // Calculate the new time with corrected parity handling
                int newTime = Math.max(node.time, moveTime[ni][nj]) + ((node.parity == 1) ? 2 : 1);

                if (newTime < distance[ni][nj][1 - node.parity]) {
                    distance[ni][nj][1 - node.parity] = newTime;
                    queue.offer(new Node(newTime, ni, nj, 1 - node.parity));
                }
            }
        }
    }

    private static class Node implements Comparable<Node> {
        int time, x, y, parity;

        Node(int time, int x, int y, int parity) {
            this.time = time;
            this.x = x;
            this.y = y;
            this.parity = parity;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.time, other.time);
        }
    }
}
",1441331711
klu2200031955,klu2200031955,303,3636,java,"class SumCalculator {
    public int calculateEvenSum(String num) {
        int evenSum = 0;
        for (int i = 0; i < num.length(); i += 2) {
            evenSum += num.charAt(i) - '0';
        }
        return evenSum;
    }

    public int calculateOddSum(String num) {
        int oddSum = 0;
        for (int i = 1; i < num.length(); i += 2) {
            oddSum += num.charAt(i) - '0';
        }
        return oddSum;
    }
}

class Solution {
    private SumCalculator calculator = new SumCalculator();

    public boolean isBalanced(String num) {
        int evenSum = calculator.calculateEvenSum(num);
        int oddSum = calculator.calculateOddSum(num);
        return evenSum == oddSum;
    }
}
",1441335004
klu2200031955,klu2200031955,303,3637,java,"import java.util.Arrays;

class MathUtils {
    static final int MOD = 1000000007;

    static long power_mod_func(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    static class FactorialResult {
        long[] fact;
        long[] inv_fact;

        FactorialResult(long[] fact, long[] inv_fact) {
            this.fact = fact;
            this.inv_fact = inv_fact;
        }
    }

    static FactorialResult initializeFactorials(int n) {
        long[] fact = new long[n + 1];
        long[] inv_fact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        inv_fact[n] = power_mod_func(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        }
        return new FactorialResult(fact, inv_fact);
    }
}

class Solution {
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long total_sum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        long sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        MathUtils.FactorialResult factorials = MathUtils.initializeFactorials(n);
        long[] fact = factorials.fact;
        long[] inv_fact = factorials.inv_fact;

        long[][] dp = new long[k + 1][(int) (sum_half + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sum_half; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + (long) d * t > sum_half) break;
                        long comb = (fact[freq[d]] * inv_fact[t] % MathUtils.MOD) * inv_fact[freq[d] - t] % MathUtils.MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MathUtils.MOD;
                    }
                }
            }
        }

        long valid_assignments = dp[k][(int) sum_half];
        if (valid_assignments == 0) return 0;

        long prod_fact_fd = 1;
        for (int d = 0; d <= 9; d++) {
            prod_fact_fd = prod_fact_fd * fact[freq[d]] % MathUtils.MOD;
        }

        long fk_fnk = (fact[k] * fact[n - k]) % MathUtils.MOD;
        long inv_prod_fact_fd = MathUtils.power_mod_func(prod_fact_fd, MathUtils.MOD - 2);
        long answer = (fk_fnk * valid_assignments) % MathUtils.MOD;
        answer = (answer * inv_prod_fact_fd) % MathUtils.MOD;

        return (int) answer;
    }
}
",1441380869
Ratnakar Gautam,ratnakarg,304,3627,cpp,"#define ll long long
class Solution {
public:
    vector<vector<int>> dir = {{1,0} , {0,1} , {0,-1} , {-1,0}};
    bool coords(int r, int c, int n, int m){
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool check(int mid , vector<vector<int>>& mvt) {
        int n = mvt.size() , m = mvt[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        dis[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cst = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cst <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + dir[i][0], ncol = c + dir[i][1];
                if (coords(nrow, ncol, n, m)) {
                    long long tmp = max(cst + 1, 1LL*mvt[nrow][ncol] + 1);
                    if (tmp < dis[nrow][ncol] && tmp <= mid) {
                        dis[nrow][ncol] = tmp;
                        q.push({tmp , nrow , ncol});
                    }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& mvt) {
        int n = mvt.size(), m = mvt[0].size();
        long long low = 0 , high = 1e13;
        long long ans = -1;
        while(low <= high) {
            long long mid = low + (high-low) / 2;

            if(check(mid , mvt)) {
                ans = mid;
                high = mid-1;
            }
            else low = mid+1;
        } 

        return ans;
    }
};",1441369613
Ratnakar Gautam,ratnakarg,304,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441292383
Ratnakar Gautam,ratnakarg,304,3637,cpp,"#define ll long long
const int mod = 1e9+7;

class Solution {
public:
    ll modPow(ll base, ll exp, ll mod) {
        ll res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    ll inv(ll num) {
        return modPow(num, mod - 2, mod);
    }

    // int solve(vector<int>& num, int k){
    //     int n = num.size();
    
    //     vector<int> prev(k + 1, 0);
    
    //     prev[0] = 1;
    
    //     if (num[0] <= k) {
    //         prev[num[0]] = 1;
    //     }
    
    //     for (int ind = 1; ind < n; ind++) {
    //         vector<int> cur(k + 1, 0);
    
    //         cur[0] = 1;
    
    //         for (int target = 1; target <= k; target++) {
    //             int notTaken = prev[target];
    //             int taken = 0;
    //             if (num[ind] <= target) {
    //                 taken = prev[target - num[ind]];
    //             }
    
    //             cur[target] = notTaken + taken;
    //         }
    
    //         prev = cur;
    //     }
    
    //     return prev[k];
    // }

    int countBalancedPermutations(string num){
        vector<int> v;
        int n = num.size();
        map<int,int> freq;
        for(char x:num){
            v.push_back((int)x-'0');
            freq[v.back()]++;
            
        }
        int tot = accumulate(v.begin(),v.end(),0ll);
        int mod = 1e9+7;
        // vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (9*n , vector<int> (n,-1)));
        // function<int(int,int,int)> rec = [&](int i,int sum,int k){
        //     if(i==n)return (int)(k==n/2 && sum*2==tot);
        //     if(dp[i][sum][k]!=-1)return dp[i][sum][k];
        //     ll ans = 0;
        //     ans+=rec(i+1,sum,k);
        //     ans%=mod;
        //     ans+=rec(i+1,sum+v[i],k+1);
        //     ans%=mod;
        //     return dp[i][sum][k]=(int)ans;
        // };
        // ll cnt=rec(0,0,0);

        if (tot % 2 != 0) return 0;
        int halfSum = tot / 2;
         vector<vector<int>> dp(halfSum + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> next = dp;
            for (int sum = 0; sum <= halfSum; sum++){
                for (int k=0;k<=n/2;k++){
                    if(dp[sum][k]>0){
                        // next[sum][k]=(next[sum][k]+dp[sum][k])%mod;
                        if (k + 1 <= n / 2 && sum + v[i] <= halfSum){
                            next[sum + v[i]][k + 1] = (next[sum + v[i]][k + 1] + dp[sum][k]) % mod;
                        }
                    }
                }
            }
            dp = next;
        }

        ll cnt = dp[halfSum][n/2];

        // cout<<cnt<<endl;

        vector<ll> f(100);
        f[0]=1;
        for(int i=1;i<100;i++){
            f[i]=f[i-1]*i;
            f[i]%=mod;
        }
        int a = n/2 , b = n - a;
        ll ans = (((f[a]*f[b])%mod)*cnt)%mod;

        for(int i=0;i<=9;i++){
            ans*=inv(f[freq[i]]);
            ans%=mod;
        }
        return ans;
    }
};",1441357011
Sean,shaun001280,305,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        // Distance matrix to store minimum times
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        // Priority queue to store {time, {row, col}}
        priority_queue<pair<int, pair<int, int>>, 
                      vector<pair<int, pair<int, int>>>,
                      greater<pair<int, pair<int, int>>>> pq;
        
        // Directions: right, down, left, up
        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        // Start from (0,0)
        dist[0][0] = moveTime[0][0];
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            int currTime = pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second;
            pq.pop();
            
            if (currTime > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir.first;
                int newCol = col + dir.second;
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(currTime + 1, moveTime[newRow][newCol] + 1);
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};",1441395871
Sean,shaun001280,305,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum0 = 0, sum1 = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sum1 += num[i] - '0';
            else sum0 += num[i] - '0';
        }
        return sum0 == sum1;
    }
};",1441371592
Sean,shaun001280,305,3637,cpp,"class Solution {
private:
    static constexpr int MOD = 1000000007;
    vector<vector<int>> C;
    vector<int> cnt;
    int target_sum;
    unordered_map<string, int> memo;
    
    string getKey(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        return to_string(pos) + "","" + to_string(sum_odd) + "","" + 
               to_string(sum_even) + "","" + to_string(odd_spots) + "","" + 
               to_string(even_spots);
    }
    
    int dfs(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        if (pos == 10) {
            return (sum_odd == target_sum && sum_even == target_sum) ? 1 : 0;
        }
        
        string key = getKey(pos, sum_odd, sum_even, odd_spots, even_spots);
        if (memo.count(key)) {
            return memo[key];
        }
        
        if (sum_odd > target_sum || sum_even > target_sum) {
            return 0;
        }
        
        if (cnt[pos] == 0) {
            int result = dfs(pos + 1, sum_odd, sum_even, odd_spots, even_spots);
            memo[key] = result;
            return result;
        }
        
        int result = 0;
        for (int i = 0; i <= cnt[pos]; i++) {
            if (i <= odd_spots && (cnt[pos] - i) <= even_spots) {
                long long new_sum_odd = sum_odd + (long long)i * pos;
                long long new_sum_even = sum_even + (long long)(cnt[pos] - i) * pos;
                
                if (new_sum_odd <= target_sum && new_sum_even <= target_sum) {
                    long long ways = 1;
                    ways = ((long long)C[odd_spots][i] * C[even_spots][cnt[pos] - i]) % MOD;
                    ways = (ways * dfs(pos + 1, new_sum_odd, new_sum_even, 
                            odd_spots - i, even_spots - (cnt[pos] - i))) % MOD;
                    result = (result + ways) % MOD;
                }
            }
        }
        
        memo[key] = result;
        return result;
    }
    
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int n_odd = (n + 1) / 2;
        int n_even = n / 2;
        
        cnt.resize(10);
        int total_sum = 0;
        
        for (char x : num) {
            total_sum += x - '0';
            cnt[x - '0']++;
        }
        
        if (total_sum % 2 == 1) {
            return 0;
        }
        
        target_sum = total_sum / 2;
        
        C.resize(n + 1, vector<int>(n + 1));
        for (int i = 0; i <= n; i++) {
            C[i][0] = 1;
            C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        
        memo.clear();
        return dfs(0, 0, 0, n_odd, n_even);
    }
};",1441367965
roush_70700,roush_70700,306,3627,cpp,"class Solution {
public:
    vector <pair<int,int>> rc = {{1,0} , {0,1} , {0,-1} , {-1,0}};

    bool IsValid(int r, int c, int n, int m) {
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool IsPossible(int mid , vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        vector<vector<long long>> minTime(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        minTime[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cost = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cost <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + rc[i].first, ncol = c + rc[i].second;
                if (IsValid(nrow, ncol, n, m)) {
                    long long newCost = max(cost + 1, 1LL*moveTime[nrow][ncol] + 1);
                    if (newCost < minTime[nrow][ncol] && newCost <= mid) {
                        minTime[nrow][ncol] = newCost;
                        q.push({newCost , nrow , ncol});
                    }

                    // if(newCost <= mid && !vis[nrow][ncol]) {
                    //     vis[nrow][ncol] = 1;
                    //     // minTime[nrow][ncol] = newCost;
                    //     q.push({newCost , nrow , ncol});
                    // }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        long long l = 0 , r = 1e13;
        long long ans = -1;
        while(l <= r) {
            long long mid = l + (r-l) / 2;

            if(IsPossible(mid , moveTime)) {
                ans = mid;
                r = mid-1;
            }
            else l = mid+1;
        } 

        return ans;
    }
};
",1441345035
roush_70700,roush_70700,306,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441282228
roush_70700,roush_70700,306,3637,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    long long modular_power(long long base, long long exp, long long mod) {
        long long res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    long long fun(long long num) {
        return modular_power(num, mod - 2, mod);
    }

    long long solve(int sum, int n, vector<int>& temp) {
        int req = sum / 2;
        vector<vector<int>> dp(req + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> dp_next = dp;
            for (int s = 0; s <= req; s++) {
                for (int k = 0; k <= n / 2; k++) {
                    if (dp[s][k] > 0) {
                        if (k + 1 <= n / 2 && s + temp[i] <= req) {
                            dp_next[s + temp[i]][k + 1] = (dp_next[s + temp[i]][k + 1] + dp[s][k]) % mod;
                        }
                    }
                }
            }
            dp = dp_next;
        }
        return dp[req][n / 2];
    }
    int countBalancedPermutations(string num) {
        vector<int> temp;
        int n = num.size();
        unordered_map<int, int> mp;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            temp.push_back(num[i] - '0');
            mp[temp.back()]++;
            sum += temp[i];
        }

        if (sum % 2 != 0)
            return 0;

        long long cnt = solve(sum, n, temp);
        vector<long long> res(100);
        res[0] = 1;
        for (int i = 1; i < 100; i++) {
            res[i] = (res[i - 1] * i) % mod;
        }
        
        int a = n / 2, b = n - a;
        long long ans = (((res[a] * res[b]) % mod) * cnt) % mod;
        for (int i = 0; i <= 9; i++) {
            ans = (ans * fun(res[mp[i]])) % mod;
        }
        return ans;
    }
};
",1441389790
xy-li,xy-li,307,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # for i in range(len(moveTime)):
        #     for j in range(len(moveTime[0])):
        #         if i!=0 or j!=0:
        #             moveTime[i][j] += 1
        # moveTime[0][0] = 0
        
        n, m = len(moveTime), len(moveTime[0])
        start = (0, 0)
        seen = [[False] * m for _ in range(n)]
        dist = [[float('inf')] * m for _ in range(n)]
        h = [(0, 0, 0)]
        dist[0][0] = 0
        
        while h:
            d, i, j = heapq.heappop(h)
            if d > dist[i][j]:
                continue
            if i == n - 1 and j == m - 1:
                return d
            seen[i][j] = True
            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
                if 0 <= x < n and 0 <= y < m and not seen[x][y]:
                    new_dist = min(max(d, moveTime[x][y])+1, dist[x][y])
                    if new_dist < dist[x][y]:
                        dist[x][y] = new_dist
                        heapq.heappush(h, (new_dist, x, y))
            
        return dist[n - 1][m - 1]

                ",1441384467
xy-li,xy-li,307,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        digits = [int(x) for x in num]
        odd_sum = sum(digits[::2])
        even_sum = sum(digits[1::2])
        return odd_sum == even_sum
        ",1441281451
xy-li,xy-li,307,3637,python3,"M = 10**9 + 7

fraq = [1]

for i in range(80):
    fraq.append((fraq[-1] * (i+1)) % M)

fraq_inv = [pow(i, M - 2, M) for i in fraq]

# print(fraq_inv[:10])

from collections import Counter
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = [int(i) for i in num]
        cnt = Counter(nums)
        s = sum(nums)
        if s % 2 != 0:
            return 0
        n = len(nums)
        k = n // 2
        target_sum = s // 2
        
        dp = [[0] * (target_sum + 1) for _ in range(k + 1)]
        dp[0][0] = 1  # Base case: one way to get sum 0 with 0 elements

        # Fill the DP table
        for num in nums:
            # Update dp table in reverse to avoid reusing elements in the same iteration
            for j in range(k, 0, -1):
                for s in range(target_sum, num - 1, -1):
                    dp[j][s] = (dp[j][s] + dp[j - 1][s - num]) % M
                    
        res = dp[-1][-1] * fraq[n - k] * fraq[k] % M
        # print(dp[-1][-1], fraq[n - k])
        for num in cnt:
            res = (res * fraq_inv[cnt[num]]) % M
        return res
                
        
        ",1441365474
lucasomee006,lucasomee006,308,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #dijkstra's?
        distances = [[float('inf') for i in range(len(moveTime[0]))] for j in range(len(moveTime))]
        # distances[0][0] = 0
        queue = [((0, 0), 0)]
        def neighbors(i, j):
            ans = []
            if i < len(moveTime)-1:
                ans.append((i+1, j))
            if j < len(moveTime[0])-1:
                ans.append((i, j+1))
            if i > 0:
                ans.append((i-1, j))
            if j > 0:
                ans.append((i, j-1))
            return ans
            
        while len(queue):
            coords, weight = heapq.heappop(queue)
            i, j = coords
            if weight >= distances[i][j]:
                continue
            distances[i][j] = weight
            for n in neighbors(i, j):
                heapq.heappush(queue, (n, max(weight+1, moveTime[n[0]][n[1]]+1)))
        # print(neighbors(1, 1))
        # print(distances)
        return distances[-1][-1]
            
            ",1441313817
lucasomee006,lucasomee006,308,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(num[i]) for i in range(1, len(num), 2)]) == sum([int(num[i]) for i in range(0, len(num), 2)])",1441281675
lucasomee006,lucasomee006,308,3637,python3,"from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        #basically we're dividing it into 2 equal sized groups (max diff of 1)
        #and those two groups have to have the same sum
        d = defaultdict(int)
        for char in num:
            d[int(char)] += 1
        x = [factorial(d[y]) for y in d]
        a = 1
        for i in range(len(x)):
            a *= x[i]
        if len(num) % 2 == 1:
            a *= 2
        #so for each number we can put it into one of the two groups
        #so total number of permutations assuming each char is distinct, but divided by num of each char
        #factorial
        mod = 10**9 + 7
        ans = 0
        finalAns = 0
        #dp(i, curSumDif, numOneGroup) returns
        s = sum([int(char) for char in num])
        @cache
        def dp(i, curSumDif, numOneGroup):
            
            if i == len(num) and curSumDif == 0 and abs(numOneGroup) <= 1:
                return 1
            if i == len(num):
                return 0
            if abs(curSumDif) > s//2+2:
                return 0
            if abs(numOneGroup) > len(num)//2+2:
                return 0
            return dp(i+1, curSumDif+int(num[i]), numOneGroup + 1) + dp(i+1, curSumDif-int(num[i]), numOneGroup-1)
        x = dp(0, 0, 0)
        dp.cache_clear()
        perm = factorial(len(num)//2)*factorial(len(num)-len(num)//2)
        return perm * x // a % mod
        
        ",1441385645
bramar2,bramar2,310,3627,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dp(n, vector<ll>(m));
        dp[0][0] = 0;
        for(int i = 1; i < n; i++) {
            dp[i][0] = max((ll)moveTime[i][0] + 1, dp[i - 1][0] + 1);
        }
        for(int i = 1; i < m; i++) {
            dp[0][i] = max((ll)moveTime[0][i] + 1, dp[0][i - 1] + 1);
        }

        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                dp[i][j] = max({
                    (ll)moveTime[i][j] + 1,
                    min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
                });
            }
        }
        auto cmax = [&](int i, int j, ll val) {
            if(i == 0 && j == 0) return false;
            ll prev = dp[i][j];
            dp[i][j] = min((ll)moveTime[i][j] + 1, val);
            return (dp[i][j] != prev);
        };
        bool change = true;
        while(change) {
            change = false;
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < m; j++) {
                    if(i == 0 && j == 0) continue;
                    ll prev = dp[i][j];
                    ll mn = 1e16;
                    if(i > 0) {
                        mn = min(mn, dp[i-1][j] + 1);
                    }
                    if(j > 0) {
                        mn = min(mn, dp[i][j-1] + 1);
                    }
                    if(i+1 < n) {
                        mn = min(mn, dp[i+1][j] + 1);
                    }
                    if(j+1 < m) {
                        mn = min(mn, dp[i][j+1] + 1);
                    }
                    dp[i][j] = max((ll)moveTime[i][j] + 1, mn);
                    if(prev != dp[i][j]) change = true;
                }
            }
        }
        return dp.back().back();
    }
};

int main1() {
    fastio;
    return 0;
}",1441302783
bramar2,bramar2,310,3636,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                sum1 += num[i]-'0';
            }else {
                sum2 += num[i]-'0';
            }
        }
        return sum1 == sum2;
    }
};

int main1() {
    fastio;
    return 0;
}",1441290674
bramar2,bramar2,310,3637,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

vector<ll> memoFactorial {1,1,2};
long long modfactorial(long long n) {
    if(n < (ll)memoFactorial.size()) return memoFactorial[n];
    for(ll i = memoFactorial.size(); i <= n; i++) {
        memoFactorial.push_back((i * memoFactorial[i - 1]) % MOD);
    }
    return memoFactorial[n];
}

bool init() {
    fastio;
    modfactorial(210);
    return true;
}
bool y = init();

ll dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(const string& numStr) {
        int n = numStr.size();
        int freq[10] {};
        ll targetSum = 0;
        for(char c : numStr) {
            freq[c-'0']++;
            targetSum += (c-'0');
        }
        if(targetSum % 2 == 1) return 0;
        targetSum /= 2;
        
        ll targetLen = n/2;
        ll ways = (memoFactorial[targetLen] * memoFactorial[n-targetLen]) % MOD;

        vector<vector<vector<ll>>> dp(10, vector<vector<ll>>(n+1, vector<ll>(targetSum+1, -1)));
        function<ll(ll,ll,ll)> go = [&](ll i, ll len1, ll sum1) {
            if(i >= 10) {
                if(len1 == targetLen && sum1 == targetSum) {
                    // dbg(len1, sum1);
                    return ways;
                }
                return 0LL;
            }
            if(sum1 > targetSum) {
                return 0LL;
            }
            if(dp[i][len1][sum1] >= 0) return dp[i][len1][sum1];
            ll ans = 0;
            for(ll take = 0; take <= freq[i]; take++) {
                ll w = (go(i + 1, len1 + take, sum1 + take*i) * mod_exp(memoFactorial[take], MOD-2, MOD)) % MOD;
                w = (w * mod_exp(memoFactorial[freq[i]-take], MOD-2, MOD)) % MOD;
                ans = (ans + w) % MOD;
            }
            return dp[i][len1][sum1] = ans;
        };
        return go(0, 0, 0);
    }
};

int main1() {
    fastio;
    return 0;
}",1441380016
Kumar sai,E22CSEU0567,311,3627,python3,"class Solution:
    def minTimeToReach(self, alpha: List[List[int]]) -> int:
        n, m = len(alpha), len(alpha[0])
        beta = [[float('inf')] * m for _ in range(n)]
        beta[0][0] = 0
        import heapq
        gamma = [(0, 0, 0)]
        delta = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while gamma:
            theta, iota, kappa = heapq.heappop(gamma)
            if theta > beta[iota][kappa]:
                continue
            for dx, dy in delta:
                lambda_, mu = iota + dx, kappa + dy
                if 0 <= lambda_ < n and 0 <= mu < m:
                    nu = max(0, alpha[lambda_][mu] - theta)
                    xi = theta + nu + 1
                    if xi < beta[lambda_][mu]:
                        beta[lambda_][mu] = xi
                        heapq.heappush(gamma, (xi, lambda_, mu))
        
        return beta[n-1][m-1]
",1441290681
Kumar sai,E22CSEU0567,311,3628,python3,"class Solution:
    def minTimeToReach(self, sai: List[List[int]]) -> int:
        n, m = len(sai), len(sai[0])
        preksha = [[[float('inf'), 0] for _ in range(m)] for _ in range(n)]
        preksha[0][0] = [0, 0]
        gamma = [row[:] for row in sai]
        import heapq
        delta = [(0, 0, 0, 0)]
        epsilon = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while delta:
            zeta, eta, theta, iota = heapq.heappop(delta)
            if zeta > preksha[theta][iota][0]:
                continue
            for dx, dy in epsilon:
                kappa, lambda_ = theta + dx, iota + dy
                if 0 <= kappa < n and 0 <= lambda_ < m:
                    xi = 1 if eta % 2 == 0 else 2
                    nu = max(0, gamma[kappa][lambda_] - zeta)
                    omicron = zeta + nu + xi
                    rho = eta + 1
                    if omicron < preksha[kappa][lambda_][0]:
                        preksha[kappa][lambda_] = [omicron, rho]
                        heapq.heappush(delta, (omicron, rho, kappa, lambda_))
        
        return preksha[n-1][m-1][0]
",1441293005
Kumar sai,E22CSEU0567,311,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sai = sum(int(num[i]) for i in range(0, len(num), 2))
        preksha = sum(int(num[i]) for i in range(1, len(num), 2))
        
        return sai == preksha
",1441286642
beaaan,beaaan,312,3627,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 3>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + 1;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441291244
beaaan,beaaan,312,3628,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 4>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0, 1});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y, cost_to_move] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + cost_to_move;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny, cost_to_move == 1 ? 2 : 1});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441293138
beaaan,beaaan,312,3636,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  bool isBalanced(string num) {
    int n = (int)num.size();
    int sum = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        sum -= num[i] - '0';
      } else {
        sum += num[i] - '0';
      }
    }
    return sum == 0;
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441281844
Manyu,ManyuD,313,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j

                if not (0 <= x < m and 0 <= y < n) or ((x, y) in vis and vis[(x, y)] <= max(t + 1, 1 + moveTime[x][y])):
                    continue

                vis[(x, y)] = max(t + 1, 1 + moveTime[x][y])
                heapq.heappush(h, (max(t + 1, 1 + moveTime[x][y]), x, y))
            

",1441289870
Manyu,ManyuD,313,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0, True)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j, dur = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j
                
                if not (0 <= x < m and 0 <= y < n):
                    continue
                    
                next_time = max(t + (1 if dur else 2), (1 if dur else 2) + moveTime[x][y])

                if ((x, y) in vis and vis[(x, y)] <= next_time):
                    continue

                vis[(x, y)] = next_time
                heapq.heappush(h, (next_time, x, y, not dur))
                
            

",1441293154
Manyu,ManyuD,313,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:

        l = r = 0
        bit = False
        
        for i in num:
            if bit:
                l += int(i)
            else:
                r += int(i)
            bit = not bit

        return l == r
            ",1441281031
mmb L,mammothb,314,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0)]
        while h:
            time, i, j = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j))
",1441292192
mmb L,mammothb,314,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0, 0)]
        while h:
            time, i, j, move = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1 + move
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j, (move + 1) % 2))
",1441294258
mmb L,mammothb,314,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281209
David Yee,yeedaKing,315,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+1
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l))

        return 0",1441293091
David Yee,yeedaKing,315,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 1)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j, flag = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+flag
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l, 2 if flag == 1 else 1))

        return 0",1441294688
David Yee,yeedaKing,315,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sum1 = sum2 = 0
        for i in range(len(num)):
            if i%2:
                sum1 += int(num[i])

            else:
                sum2 += int(num[i])

        return sum1 == sum2",1441280847
killer-whale,killer-whale,316,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start)]
        dist = defaultdict(lambda: inf, {start: 0})
        while h:
            cost, node = heappop(h)
            if dist[node] != cost:
                continue
            if node == target:
                return cost
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx] + 1
                    nw = max(w, cost + 1)
                    if dist[ny, nx] > nw:
                        dist[ny, nx] = nw
                        heappush(h, (nw, (ny, nx)))",1441290248
killer-whale,killer-whale,316,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start, 1)]
        dist = defaultdict(lambda: inf, {(start, 1): 0})
        while h:
            cost, node, cnt = heappop(h)
            if dist[node, cnt] != cost:
                continue
            if node == target:
                return cost
            cnt += 1
            cnt %= 2
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx]
                    nw = max(w, cost) + cnt + 1
                    #print(cnt, nw)
                    if dist[(ny, nx), cnt] > nw:
                        dist[(ny, nx), cnt] = nw
                        heappush(h, (nw, (ny, nx), cnt))",1441294773
killer-whale,killer-whale,316,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o=e=0
        for i, x in enumerate(num):
            if i % 2:
                o += int(x)
            else:
                e += int(x)
        return o==e",1441290328
SirTechnical,SirTechnical,317,3627,cpp,"struct State {
    int i;
    int j;
    int t;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, 0x3f3f3f3f));
        dist[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0});
        while (!pq.empty()) {
            auto [i,j,t] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+1;
                if (tt < dist[ti][tj]) {
                    dist[ti][tj] = tt;
                    pq.push({ti,tj,tt});
                }
            }
        }
        return dist[N-1][M-1];
    }
};",1441291831
SirTechnical,SirTechnical,317,3628,cpp,"struct State {
    int i;
    int j;
    int t;
    int d;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

inline int alt(int d) {
    if (d == 1) return 2;
    return 1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist1(N, vector<int>(M, 0x3f3f3f3f));
        vector<vector<int>> dist2(N, vector<int>(M, 0x3f3f3f3f));
        dist1[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0,1});
        while (!pq.empty()) {
            auto [i,j,t,d] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+d;
                if (d == 1) {
                    if (tt < dist2[ti][tj]) {
                        dist2[ti][tj] = tt;
                        pq.push({ti,tj,tt,2});
                    }
                } else {
                    if (tt < dist1[ti][tj]) {
                        dist1[ti][tj] = tt;
                        pq.push({ti,tj,tt,1});
                    }
                }
                
            }
        }
        return min(dist1[N-1][M-1], dist2[N-1][M-1]);
    }
};",1441294968
SirTechnical,SirTechnical,317,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sa = 0;
        int sb = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i%2 == 0) sa += num[i]-'0';
            else sb += num[i]-'0';
        }
        return sa == sb;
    }
};",1441280907
Sanjay Grover,SanjayGrover,318,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0)]
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + 1 + waitTime
                    
                    if newTime < visited[nx][ny]:
                        visited[nx][ny] = newTime
                        heapq.heappush(pq, (newTime, nx, ny))
        
        return -1",1441289381
Sanjay Grover,SanjayGrover,318,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0, 1)]
        visited = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        visited[0][0][1] = 0
        
        while pq:
            time, x, y, nextMoveTime = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + nextMoveTime + waitTime
                    
                    alter = 2 if nextMoveTime == 1 else 1
                    
                    if newTime < visited[nx][ny][alter - 1]:
                        visited[nx][ny][alter - 1] = newTime
                        heapq.heappush(pq, (newTime, nx, ny, alter))
        
        return -1",1441295001
Sanjay Grover,SanjayGrover,318,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int even = 0;
        int odd = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i % 2 == 0) even += num.charAt(i) - '0';
            else odd += num.charAt(i) - '0';
        }
        return odd == even;
    }
}",1441283075
Andwerp,Andwerp,319,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> q;
        q.push({0, {0, 0}});
        vector<vector<bool>> v(n, vector<bool>(m, false));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.first;
            int c = q.top().second.second;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c] || d[r][c] != cur_t) {
                continue;
            }
            v[r][c] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int next_t = max(mt[nr][nc] + 1, cur_t + 1);
                if(next_t < d[nr][nc] && !v[nr][nc]) {
                    d[nr][nc] = next_t;
                    q.push({-next_t, {nr, nc}});
                }
            }
        }
        return d[n - 1][m - 1];
    }
};",1441291525
Andwerp,Andwerp,319,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        //i, j, move parity
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2e9)));
        d[0][0][0] = 0;
        priority_queue<pair<int, pair<int, pair<int, int>>>> q;
        q.push({0, {0, {0, 0}}});
        vector<vector<vector<bool>>> v(n, vector<vector<bool>>(m, vector<bool>(2, false)));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.second.first;
            int c = q.top().second.second.second;
            int p = q.top().second.first;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c][p] || d[r][c][p] != cur_t) {
                continue;
            }
            v[r][c][p] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                int np = p == 1? 0 : 1;
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int inc = p == 0? 1 : 2;
                int next_t = max(mt[nr][nc] + inc, cur_t + inc);
                if(next_t < d[nr][nc][np] && !v[nr][nc][np]) {
                    d[nr][nc][np] = next_t;
                    q.push({-next_t, {np, {nr, nc}}});
                }
            }
        }
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};",1441295219
Andwerp,Andwerp,319,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.size(); i++){
            sum += (num[i] - '0') * (i % 2 == 0? 1 : -1);
        }
        return sum == 0;
    }
};",1441281071
Raymond Jones Jr.,TheRealRaymondJones,320,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    heapq.heappush(heap,(waitTime,nr,nc))
        return -1
            ",1441293065
Raymond Jones Jr.,TheRealRaymondJones,320,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0, False))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c, has_extra_step = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    if has_extra_step:
                        waitTime += 1
                    heapq.heappush(heap,(waitTime,nr,nc, not has_extra_step))
        return -1",1441295429
Raymond Jones Jr.,TheRealRaymondJones,320,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                evens += int(digit)
            else:
                odds += int(digit)
        return evens == odds",1441281456
IvanHugh,ivanc-e,324,3627,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0)]
        
        while heap:  
            current_time, x, y = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + 1  
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny))  
        
        return -1",1441293828
IvanHugh,ivanc-e,324,3628,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0, 0)]
        
        while heap:  
            current_time, x, y, cnt = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + (1 if cnt % 2 == 0 else 2)
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny, cnt+1))  
        
        return -1",1441296218
IvanHugh,ivanc-e,324,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
        ",1441281390
Wilsano,Wilsano,325,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;
        pq.push({0, 0, 0});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441294111
Wilsano,Wilsano,325,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>>> pq;
        pq.push({0, 0, 0, 1});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c, cost] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + cost;
                    int next_cost = (cost == 1) ? 2 : 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc, next_cost});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441296324
Wilsano,Wilsano,325,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int weight = 1;
        for(int i = 0; i < num.length(); ++i){
            sum += (num[i] - '0') * weight;
            weight *= -1;
        }
        return sum == 0;
    }
};",1441281006
Fuad Qarayev,fuad720,326,3627,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m];
        bool vis[n][m];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j] = 2e9;
                vis[i][j] = 0;
            }
        }
        dist[0][0] = 0;
        pq.push({0,{0,0}});
        while(pq.size()) {
            auto [x,y] = pq.top().second;
            pq.pop();
            if(vis[x][y])continue;
            vis[x][y] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny] > max(moveTime[nx][ny]+1, dist[x][y]+1)) {
                        dist[nx][ny] = max(moveTime[nx][ny]+1, dist[x][y]+1);
                        pq.push({-dist[nx][ny], {nx, ny}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441293590
Fuad Qarayev,fuad720,326,3628,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, array<int,3>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m][2];
        bool vis[n][m][2];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j][0] = dist[i][j][1] =  2e9;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }
        dist[0][0][0] = 0;
        pq.push({0,{0,0,0}});
        while(pq.size()) {
            auto [x,y,w] = pq.top().second;
            pq.pop();
            if(vis[x][y][w])continue;
            vis[x][y][w] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny][w^1] > max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w)) {
                        dist[nx][ny][w^1] = max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w);
                        pq.push({-dist[nx][ny][w^1], {nx, ny, w^1}});
                    }
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441296391
Fuad Qarayev,fuad720,326,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0;i<num.size();i+=2) {
            sum+=num[i]-'0';
        }
        for(int i = 1;i<num.size();i+=2) {
            sum-=num[i]-'0';
        }
        return (sum==0);
    }
};",1441282333
Roushan Kumar Singh,r-tron19,327,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0)))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1, moveTime[x][y]+1)
                s.add((T, (x, y)))
        
        return -1",1441294937
Roushan Kumar Singh,r-tron19,327,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0), 0))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord, ext = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1 + ext, moveTime[x][y]+1+ext)
                s.add((T, (x, y), ext ^ 1))
        
        return -1",1441296682
Roushan Kumar Singh,r-tron19,327,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o, e = 0, 0
        for i,el in enumerate(num):
            if i%2:
                o += int(el)
            else:
                e += int(el)
        return o == e",1441281649
cro_poder,cro_poder,328,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX));
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        
        while (!pq.empty()) {
            auto [curr, i, j] = pq.top();
            pq.pop();
            if (i == n - 1 && j == m - 1) return curr;  
            
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = max(curr + 1, 1+moveTime[ni][nj]);
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj);
                    }
                }
            }
        }
        return -1;
    }
};
",1441292077
cro_poder,cro_poder,328,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX)); 
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0, 1); 
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!pq.empty()) {
            auto [curr, i, j, moveCost] = pq.top();
            pq.pop();
            
            if (i == n - 1 && j == m - 1) return curr;  
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = moveCost+max(curr, moveTime[ni][nj]);
                    int nextMoveCost = (moveCost == 1) ? 2 : 1;  
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj, nextMoveCost);
                    }
                }
            }
        }
        
        return -1;   
    }
};
",1441296768
cro_poder,cro_poder,328,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s1 = 0, s2 = 0;
        
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s1 += num[i] - '0';  
            } else {
                s2 += num[i] - '0';   
            }
        }
        
        return s1 == s2;
    }
};
",1441281358
Leonyhenn,leonyhenn,329,3627,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+1 if moveTime[dx][dy] > time else time+1
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy))
        return
                
                    
            
        
        ",1441294685
Leonyhenn,leonyhenn,329,3628,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0,1),(0,0,0,2)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y,step) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+step if moveTime[dx][dy] > time else time+step
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy,2 if step == 1 else 1))
        return
                
                    
            
        
        ",1441296987
Leonyhenn,leonyhenn,329,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281088
Jeel27,Jeel27,330,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0)]
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            current_time, x, y = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    next_time = arrival_time + 1
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny))
        
        return -1",1441289971
Jeel27,Jeel27,330,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0, 0)]  # (time, x, y, step)
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while heap:
            current_time, x, y, step = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    move_cost = 1 if step % 2 == 0 else 2
                    next_time = arrival_time + move_cost
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny, step + 1))

        return -1",1441291277
Jeel27,Jeel27,330,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum",1441281450
Burger Monstah,WRWRW,331,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0)]
        v = {}
        while h:
            t, r, c = heapq.heappop(h)
            # print(t, r, c)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + 1, rr, cc))",1441291563
Burger Monstah,WRWRW,331,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0, 1)]
        v = {}
        while h:
            
            # print(h)
            t, r, c, cost = heapq.heappop(h)
            # print(t, r, c, cost)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + cost, rr, cc, 1 if cost == 2 else 2))",1441297068
Burger Monstah,WRWRW,331,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        
        for i, c in enumerate(num):
            if i % 2 == 0:
                a += int(c)
            else:
                a -= int(c)
        return a == 0
                
        ",1441281726
uwi,uwi,1,3627,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur] + 1, moveTime[nr][nc]+1);
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441290571
uwi,uwi,1,3628,java,"	class Solution {
		public int minTimeToReach(int[][] moveTime) {
			int n = moveTime.length;
			int m = moveTime[0].length;
			long[] td = new long[n*m];
			Arrays.fill(td, Long.MAX_VALUE / 2);
			MinHeapL q = new MinHeapL(n*m);
			q.add(0, 0);
			td[0] = 0;

			int[] dr = {1, 0, -1, 0};
			int[] dc = {0, 1, 0, -1};

			while(q.size() > 0){
				int cur = q.argmin();
				q.remove(cur);

				int r = cur / m, c = cur % m;
				for(int k = 0;k < 4;k++){
					int nr = r + dr[k], nc = c + dc[k];
					if(nr >= 0 && nr < n && nc >= 0 && nc < m){
						int next = nr*m+nc;
						long nd = Math.max(td[cur], moveTime[nr][nc]) + (r+c)%2+1;
						if(nd < td[next]){
							td[next] = nd;
							q.update(next, nd);
						}
					}
				}
			}

			return (int)td[(n-1)*m+m-1];
		}

		public static class MinHeapL {
			public long[] a;
			public int[] map;
			public int[] imap;
			public int n;
			public int pos;
			public static long INF = Long.MAX_VALUE;

			public MinHeapL(int m)
			{
				n = Integer.highestOneBit((m+1)<<1);
				a = new long[n];
				map = new int[n];
				imap = new int[n];
				Arrays.fill(a, INF);
				Arrays.fill(map, -1);
				Arrays.fill(imap, -1);
				pos = 1;
			}

			public long add(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}
				return ret != -1 ? a[ret] : x;
			}

			public long update(int ind, long x)
			{
				int ret = imap[ind];
				if(imap[ind] < 0){
					a[pos] = x; map[pos] = ind; imap[ind] = pos;
					pos++;
					up(pos-1);
				}else{
					a[ret] = x;
					up(ret);
					down(ret);
				}
				return x;
			}

			public long remove(int ind)
			{
				if(pos == 1)return INF;
				if(imap[ind] == -1)return INF;

				pos--;
				int rem = imap[ind];
				long ret = a[rem];
				map[rem] = map[pos];
				imap[map[pos]] = rem;
				imap[ind] = -1;
				a[rem] = a[pos];
				a[pos] = INF;
				map[pos] = -1;

				up(rem);
				down(rem);
				return ret;
			}

			public long min() { return a[1]; }
			public int argmin() { return map[1]; }
			public int size() {	return pos-1; }
			public long get(int ind){ return a[imap[ind]]; }

			private void up(int cur)
			{
				//		for(int c = cur, p = c>>>1;p >= 1 && (a[p] > a[c] || a[p] == a[c] && map[p] > map[c]);c>>>=1, p>>>=1){
				for(int c = cur, p = c>>>1;p >= 1 && a[p] > a[c];c>>>=1, p>>>=1){
					long d = a[p]; a[p] = a[c]; a[c] = d;
					int e = imap[map[p]]; imap[map[p]] = imap[map[c]]; imap[map[c]] = e;
					e = map[p]; map[p] = map[c]; map[c] = e;
				}
			}

			private void down(int cur)
			{
				for(int c = cur;2*c < pos;){
					//			int b = a[2*c] < a[2*c+1] || a[2*c] == a[2*c+1] && map[2*c] < map[2*c+1] ? 2*c : 2*c+1;
					//			if(a[b] < a[c] || a[b] == a[c] && map[b] < map[c]){
					int b = a[2*c] < a[2*c+1] ? 2*c : 2*c+1;
					if(a[b] < a[c]){
						long d = a[c]; a[c] = a[b]; a[b] = d;
						int e = imap[map[c]]; imap[map[c]] = imap[map[b]]; imap[map[b]] = e;
						e = map[c]; map[c] = map[b]; map[b] = e;
						c = b;
					}else{
						break;
					}
				}
			}
		}


	}
",1441292405
uwi,uwi,1,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        long bal = 0;
        for(int i = 0;i < num.length();i++){
            bal = -bal + num.charAt(i) - '0';
        }
        return bal == 0;
    }
}",1441280931
uwi,uwi,1,3637,java,"	class Solution {
		public int countBalancedPermutations(String num) {
			int[] f = new int[10];
			int s = 0;
			for(char c : num.toCharArray()){
				f[c-'0']++;
				s += c-'0';
			}
			if(s % 2 != 0)return 0;
			final int mod = 1000000007;
			s /= 2;

			int n = num.length();
			long[][] dp = new long[n/2+1][s+1];
			int[][] fif = enumFIF(1000, mod);
			dp[0][0] = (long)fif[0][n/2] * fif[0][n-n/2] % mod;
			for(int i = 0;i <= 9;i++){
				long[][] ndp = new long[n/2+1][s+1];
				for(int j = n/2;j >= 0;j--){
					for(int k = s;k >= 0;k--){
						if(dp[j][k] == 0)continue;
						for(int t = 0;t <= f[i] && k+i*t <= s && j+t <= n/2;t++){
							ndp[j+t][k+i*t] += dp[j][k] * fif[1][t] % mod * fif[1][f[i]-t];
							ndp[j+t][k+i*t] %= mod;
						}
					}
				}
				dp = ndp;
			}
			return (int)dp[n/2][s];
		}

		public static int[][] enumFIF(int n, int mod) {
			int[] f = new int[n + 1];
			int[] invf = new int[n + 1];
			f[0] = 1;
			for (int i = 1; i <= n; i++) {
				f[i] = (int) ((long) f[i - 1] * i % mod);
			}
			long a = f[n];
			long b = mod;
			long p = 1, q = 0;
			while (b > 0) {
				long c = a / b;
				long d;
				d = a;
				a = b;
				b = d % b;
				d = p;
				p = q;
				q = d - c * q;
			}
			invf[n] = (int) (p < 0 ? p + mod : p);
			for (int i = n - 1; i >= 0; i--) {
				invf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);
			}
			return new int[][]{f, invf};
		}

	}
",1441300564
green_pig,green_pig,2,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291673
green_pig,green_pig,2,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        d = [[[inf] * m for _ in range(n)] for _ in range(2)]
        d[0][0][0] = 0
        q = [(0, 0, 0, 0)]
        ds = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        while q:
            w, i, j, k = heappop(q)
            if w > d[k][i][j]: continue
            for di, dj in ds:
                x, y, z = i+di, j+dj, k ^ 1
                if not (0 <= x < n and 0 <= y < m): continue
                v = max(w, moveTime[x][y]) + k + 1
                if v < d[z][x][y]:
                    d[z][x][y] = v
                    heappush(q, (d[z][x][y], x, y, z))
        return min(d[0][n-1][m-1], d[1][n-1][m-1])
",1441291255
green_pig,green_pig,2,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280737
green_pig,green_pig,2,3637,python3,"M = 10**9+7
F = [1] * 100
for i in range(1, len(F)):
    F[i] = F[i-1]*i%M
I = [pow(x, -1, M) for x in F]
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        a = [0] * 10
        for n in map(int, num):
            a[n] += 1
        s, t = len(num[::2]), len(num[1::2])
        @cache
        def f(i, d, m, n):
            if m > s or n > t: return 0
            if i == 10:
                return int(d == 0)
            r = 0
            for j in range(a[i]+1):
                k = a[i] - j
                r += I[j] * I[k] * f(i+1, d+i*(j-k), m+j, n+k) % M
            return r % M
        return F[s] * F[t] * f(0, 0, 0, 0) % M
",1441305429
Chris Ho,Chris_ho,3,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        pq = [(0, 0, 0)]
        
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            curr_time, row, col = heapq.heappop(pq)
            
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(moveTime[new_row][new_col] - curr_time, 0)
                    next_time = curr_time + 1 + wait_time
                    
                    if next_time < visited[new_row][new_col]:
                        visited[new_row][new_col] = next_time
                        heapq.heappush(pq, (next_time, new_row, new_col))
        
        return -1",1441299988
Chris Ho,Chris_ho,3,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        min_time = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        min_time[0][0][0] = 0
        heap = [(0, 0, 0, 0)]
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    
        while heap:
            current_time, i, j, parity = heapq.heappop(heap)
            
            if current_time > min_time[i][j][parity]:
                continue
            
            for dx, dy in directions:
                ni, nj = i + dx, j + dy
                if 0 <= ni < n and 0 <= nj < m:
                    move_duration = 1 if parity == 0 else 2
                    start_time = max(current_time, moveTime[ni][nj])
                    arrival_time = start_time + move_duration
                    new_parity = 1 - parity
                    if arrival_time < min_time[ni][nj][new_parity]:
                        min_time[ni][nj][new_parity] = arrival_time
                        heapq.heappush(heap, (arrival_time, ni, nj, new_parity))
                            
        return min(min_time[n - 1][m - 1][0], min_time[n - 1][m - 1][1])
",1441307226
Chris Ho,Chris_ho,3,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = sum(int(x) for x in num[0::2])
        y = sum(int(x) for x in num[1::2])
        return x==y
        
        ",1441280968
Chris Ho,Chris_ho,3,3637,python3,"MOD = 10**9 + 7
from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        cnt_d = [0] * 10
        total_sum = sum(map(int, num))
        for ch in num:
            cnt_d[int(ch)] += 1
        if total_sum % 2 != 0:
            return 0
        S = total_sum // 2
        NE = (N + 1) // 2
        NO = N // 2
        fac = [1] * (N + 1)
        for i in range(1, N + 1):
            fac[i] = fac[i - 1] * i % MOD
        inv_fac = [1] * (N + 1)
        inv_fac[N] = pow(fac[N], MOD - 2, MOD)
        for i in range(N, 0, -1):
            inv_fac[i - 1] = inv_fac[i] * i % MOD
        def C(n, k):
            if k < 0 or k > n:
                return 0
            return fac[n] * inv_fac[k] % MOD * inv_fac[n - k] % MOD
        dp = defaultdict(int)
        dp[(0, 0)] = 1
        for d in range(10):
            cnt = cnt_d[d]
            if cnt == 0:
                continue
            dp_new = dp.copy()
            for (s1, c1), ways1 in dp.items():
                max_k = min(cnt, NE - c1)
                for k in range(1, max_k + 1):
                    s = s1 + k * d
                    c = c1 + k
                    ways = ways1 * C(cnt, k) % MOD
                    dp_new[(s, c)] = (dp_new.get((s, c), 0) + ways) % MOD
            dp = dp_new
        total_ways = 0
        for (s, c), ways in dp.items():
            if c == NE and s == S:
                total_ways = (total_ways + ways) % MOD
        total_permutations = total_ways * fac[NE] % MOD * fac[NO] % MOD
        for d in range(10):
            total_permutations = total_permutations * inv_fac[cnt_d[d]] % MOD
        return total_permutations
",1441302114
superfearless,superfearless,4,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        import heapq
        n, m = len(moveTime), len(moveTime[0])
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if t > dist[x][y]:
                continue
            for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    t_move = max(t, moveTime[nx][ny])
                    t_neighbor = t_move + 1
                    if dist[nx][ny] > t_neighbor:
                        dist[nx][ny] = t_neighbor
                        heapq.heappush(heap, (t_neighbor, nx, ny))
        return dist[n-1][m-1]        ",1441288089
superfearless,superfearless,4,3628,python3,"class Solution:
	def minTimeToReach(S,moveTime):
		D=moveTime;E,F=len(D),len(D[0]);N=float('inf');A=[[[N]*2 for A in range(F)]for A in range(E)];G=[(0,0,0,0)];A[0][0][0]=0
		while G:
			K,L,M,H=heapq.heappop(G)
			if A[L][M][H]<K:continue
			for(O,P)in[(-1,0),(1,0),(0,-1),(0,1)]:
				B,C=L+O,M+P
				if 0<=B<E and 0<=C<F:
					Q=1 if H==0 else 2;R=max(K,D[B][C]);I=R+Q;J=(H+1)%2
					if I<A[B][C][J]:A[B][C][J]=I;heapq.heappush(G,(I,B,C,J))
		return min(A[E-1][F-1])      ",1441295837
superfearless,superfearless,4,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                even_sum += int(d)
            else:
                odd_sum += int(d)
        return even_sum == odd_sum       ",1441287048
superfearless,superfearless,4,3637,python3,"class Solution:
	def countBalancedPermutations(c,num):
		A=10**9+7;from math import comb;from collections import defaultdict as S;I=[0]*10;J=0;C=len(num);B=C//2;V=C-B
		for W in num:D=int(W);I[D]+=1;J+=D
		if J%2!=0:return 0
		X=J//2;Y=B*9;G=[S(int)for A in range(B+1)];G[0][0]=1;F=[1]*(C+1);K=[1]*(C+1)
		for E in range(1,C+1):F[E]=F[E-1]*E%A
		K[C]=pow(F[C],A-2,A)
		for E in range(C-1,-1,-1):K[E]=K[E+1]*(E+1)%A
		for D in range(10):
			L=I[D]
			if L==0:continue
			M=[S(int)for A in range(B+1)]
			for H in range(B+1):
				for T in G[H]:
					Z=G[H][T]
					for N in range(0,min(L,B-H)+1):
						O=H+N;P=T+N*D
						if O<=B and P<=Y:a=comb(L,N);M[O][P]=(M[O][P]+Z*a)%A
			G=M
		U=G[B].get(X,0)
		if U==0:return 0
		b=F[V]*F[B]%A;Q=1
		for D in range(10):Q=Q*F[I[D]]%A
		R=U*b%A;R=R*pow(Q,A-2,A)%A;return R        ",1441292392
LayCurse,LayCurse,5,3627,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441295459
LayCurse,LayCurse,5,3628,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
template <class T> struct DijkstraHeap{
  int*hp;
  int*place;
  int size;
  char*visited;
  T*val;
  void malloc(int N){
    hp = (int*)std::malloc(N*sizeof(int));
    place = (int*)std::malloc(N*sizeof(int));
    visited = (char*)std::malloc(N*sizeof(char));
    val = (T*)std::malloc(N*sizeof(T));
  }
  void free(){
    std::free(hp);
    std::free(place);
    std::free(visited);
    std::free(val);
  }
  void walloc(int N, void **mem=&wmem){
    walloc1d(&hp, N, mem);
    walloc1d(&place, N, mem);
    walloc1d(&visited, N, mem);
    walloc1d(&val, N, mem);
  }
  void malloc(int N, int init_fg){
    malloc(N);
    if(init_fg){
      init(N);
    }
  }
  void walloc(int N, int init_fg, void **mem=&wmem){
    walloc(N,mem);
    if(init_fg){
      init(N);
    }
  }
  void init(int N){
    int i;
    size = 0;
    for(i=(0);i<(N);i++){
      place[i]=-1;
    }
    for(i=(0);i<(N);i++){
      visited[i]=0;
    }
  }
  void up(int n){
    int m;
    while(n){
      m=(n-1)/2;
      if(val[hp[m]]<=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void down(int n){
    int m;
    for(;;){
      m=2*n+1;
      if(m>=size){
        break;
      }
      if(m+1<size&&val[hp[m]]>val[hp[m+1]]){
        m++;
      }
      if(val[hp[m]]>=val[hp[n]]){
        break;
      }
      swap(hp[m],hp[n]);
      swap(place[hp[m]],place[hp[n]]);
      n=m;
    }
  }
  void change(int n, T v){
    if(visited[n]||(place[n]>=0&&val[n]<=v)){
      return;
    }
    val[n]=v;
    if(place[n]==-1){
      place[n]=size;
      hp[size++]=n;
      up(place[n]);
    }
    else{
      up(place[n]);
    }
  }
  int pop(void){
    int res=hp[0];
    place[res]=-1;
    size--;
    if(size){
      hp[0]=hp[size];
      place[hp[0]]=0;
      down(0);
    }
    visited[res]=1;
    return res;
  }
}
;
struct dimcomp3{
  int B;
  int C;
  dimcomp3(){
  }
  ;
  dimcomp3(int b, int c){
    B = b;
    C = c;
  }
  dimcomp3(int a, int b, int c){
    B = b;
    C = c;
  }
  inline void set(int b, int c){
    B = b;
    C = c;
  }
  inline void set(int a, int b, int c){
    B = b;
    C = c;
  }
  inline int mask(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline int operator()(int a, int b, int c){
    return (a * B + b) * C + c;
  }
  inline void para(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
  inline void operator()(int mask, int &a, int &b, int &c){
    a = mask / (B*C);
    b = mask % (B*C) / C;
    c = mask % C;
  }
}
;
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
class Solution{
  public:
  int minTimeToReach(vector<vector<int>>& A){
    dummy_main();
    int X = A.size();
    int Y = A[0].size();
    int node = 2 * X * Y;
    int res;
    int t;
    int x;
    int y;
    int c;
    int nt;
    int nx;
    int ny;
    int nc;
    int mask;
    dimcomp3 dm(2,X,Y);
    DijkstraHeap<int> hp;
    hp.walloc(node, 1);
    hp.change(dm(0,0,0), 0);
    for(;;){
      mask = hp.pop();
      c = hp.val[mask];
      dm(mask, t, x, y);
      if(x == X-1 && y == Y-1){
        res = c;
        break;
      }
      {
        static int WKqLrJHZ[4] = {-1, 0, 0, 1};
        static int QAAnbtfa[4] = {0, -1, 1, 0};
        int om7Ebh6q;
        for(om7Ebh6q=(0);om7Ebh6q<(4);om7Ebh6q++){
          nx = (x) + WKqLrJHZ[om7Ebh6q];
          ny = (y) + QAAnbtfa[om7Ebh6q];
          if(0 <= nx  &&  nx < X && 0 <= ny  &&  ny < Y){
            nt = t ^ 1;
            nc =max_L(c, A[nx][ny])+ 1 + t;
            hp.change( dm(nt,nx,ny), nc );
          }
        }
      }
    }
    return res;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// 
// class Solution {
// public:
//   int minTimeToReach(vector<vector<int>>& A) {
//     dummy_main();
// 
//     int X = A.size();
//     int Y = A[0].size();
//     int node = 2 * X * Y;
//     int res;
//     int t, x, y, c, nt, nx, ny, nc, mask;
// 
//     dimcomp3 dm(2,X,Y);
//     DijkstraHeap<int> hp;
// 
//     hp.walloc(node, 1);
//     hp.change(dm(0,0,0), 0);
// 
//     for(;;){
//       mask = hp.pop();
//       c = hp.val[mask];
//       dm(mask, t, x, y);
//       if(x == X-1 && y == Y-1) res = c, break;
// 
//       rep_dist(nx,ny,x,y) if(0 <= nx < X && 0 <= ny < Y){
//         nt = t ^ 1;
//         nc = max(c, A[nx][ny]) + 1 + t;
//         hp.change( dm(nt,nx,ny), nc );
//       }
//     }
// 
//     return res;
//   }
// };
",1441294873
LayCurse,LayCurse,5,3636,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define main dummy_main
int main(){
  return 0;
}
#undef main
class Solution{
  public:
  bool isBalanced(string A){
    int i;
    int N = A.size();
    int res = 0;
    for(i=(0);i<(N);i+=(2)){
      res += A[i] - '0';
    }
    for(i=(1);i<(N);i+=(2)){
      res -= A[i] - '0';
    }
    return res == 0;
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// class Solution {
// public:
//   bool isBalanced(string A) {
//     int N = A.size(), res = 0;
//     rep(i,0,N,2) res += A[i] - '0';
//     rep(i,1,N,2) res -= A[i] - '0';
//     return res == 0;
//   }
// };
",1441281284
LayCurse,LayCurse,5,3637,cpp,"#pragma GCC optimize(""Ofast"")
#pragma GCC optimize(""unroll-loops"")
#pragma GCC optimize(""inline"")
#include<bits/stdc++.h>
using namespace std;
#define MD (1000000007U)
template<class T> struct cLtraits_identity{
  using type = T;
}
;
template<class T> using cLtraits_try_make_signed =
  typename conditional<
    is_integral<T>::value,
    make_signed<T>,
    cLtraits_identity<T>
    >::type;
template <class S, class T> struct cLtraits_common_type{
  using tS = typename cLtraits_try_make_signed<S>::type;
  using tT = typename cLtraits_try_make_signed<T>::type;
  using type = typename common_type<tS,tT>::type;
}
;
void*wmem;
char memarr[96000000];
template<class S, class T> inline auto max_L(S a, T b)
-> typename cLtraits_common_type<S,T>::type{
  return (typename cLtraits_common_type<S,T>::type) a >= (typename cLtraits_common_type<S,T>::type) b ? a : b;
}
template<class S, class T> inline S chmax(S &a, T b){
  if(a<b){
    a=b;
  }
  return a;
}
template<class T> inline void walloc1d(T **arr, int x, void **mem = &wmem){
  static int skip[16] = {0, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
  (*mem) = (void*)( ((char*)(*mem)) + skip[((unsigned long long)(*mem)) & 15] );
  (*arr)=(T*)(*mem);
  (*mem)=((*arr)+x);
}
template<class T> inline void walloc1d(T **arr, int x1, int x2, void **mem = &wmem){
  walloc1d(arr, x2-x1, mem);
  (*arr) -= x1;
}
struct Modint{
  unsigned val;
  Modint(){
    val=0;
  }
  Modint(int a){
    val = ord(a);
  }
  Modint(unsigned a){
    val = ord(a);
  }
  Modint(long long a){
    val = ord(a);
  }
  Modint(unsigned long long a){
    val = ord(a);
  }
  inline unsigned ord(unsigned a){
    return a%MD;
  }
  inline unsigned ord(int a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned ord(unsigned long long a){
    return a%MD;
  }
  inline unsigned ord(long long a){
    a %= (int)MD;
    if(a < 0){
      a += MD;
    }
    return a;
  }
  inline unsigned get(){
    return val;
  }
  inline Modint &operator++(){
    val++;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator--(){
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return *this;
  }
  inline Modint operator++(int a){
    Modint res(*this);
    val++;
    if(val >= MD){
      val -= MD;
    }
    return res;
  }
  inline Modint operator--(int a){
    Modint res(*this);
    if(val == 0){
      val = MD - 1;
    }
    else{
      --val;
    }
    return res;
  }
  inline Modint &operator+=(Modint a){
    val += a.val;
    if(val >= MD){
      val -= MD;
    }
    return *this;
  }
  inline Modint &operator-=(Modint a){
    if(val < a.val){
      val = val + MD - a.val;
    }
    else{
      val -= a.val;
    }
    return *this;
  }
  inline Modint &operator*=(Modint a){
    val = ((unsigned long long)val*a.val)%MD;
    return *this;
  }
  inline Modint &operator/=(Modint a){
    return *this *= a.inverse();
  }
  inline Modint operator+(Modint a){
    return Modint(*this)+=a;
  }
  inline Modint operator-(Modint a){
    return Modint(*this)-=a;
  }
  inline Modint operator*(Modint a){
    return Modint(*this)*=a;
  }
  inline Modint operator/(Modint a){
    return Modint(*this)/=a;
  }
  inline Modint operator+(int a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(int a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(int a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(int a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator+(long long a){
    return Modint(*this)+=Modint(a);
  }
  inline Modint operator-(long long a){
    return Modint(*this)-=Modint(a);
  }
  inline Modint operator*(long long a){
    return Modint(*this)*=Modint(a);
  }
  inline Modint operator/(long long a){
    return Modint(*this)/=Modint(a);
  }
  inline Modint operator-(void){
    Modint res;
    if(val){
      res.val=MD-val;
    }
    else{
      res.val=0;
    }
    return res;
  }
  inline operator bool(void){
    return val!=0;
  }
  inline operator int(void){
    return get();
  }
  inline operator long long(void){
    return get();
  }
  inline Modint inverse(){
    int a = val;
    int b = MD;
    int u = 1;
    int v = 0;
    int t;
    Modint res;
    while(b){
      t = a / b;
      a -= t * b;
      swap(a, b);
      u -= t * v;
      swap(u, v);
    }
    if(u < 0){
      u += MD;
    }
    res.val = u;
    return res;
  }
  inline Modint pw(unsigned long long b){
    Modint a(*this);
    Modint res;
    res.val = 1;
    while(b){
      if(b&1){
        res *= a;
      }
      b >>= 1;
      a *= a;
    }
    return res;
  }
  inline bool operator==(int a){
    return ord(a)==val;
  }
  inline bool operator!=(int a){
    return ord(a)!=val;
  }
}
;
inline Modint operator+(int a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(int a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(int a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(int a, Modint b){
  return Modint(a)/=b;
}
inline Modint operator+(long long a, Modint b){
  return Modint(a)+=b;
}
inline Modint operator-(long long a, Modint b){
  return Modint(a)-=b;
}
inline Modint operator*(long long a, Modint b){
  return Modint(a)*=b;
}
inline Modint operator/(long long a, Modint b){
  return Modint(a)/=b;
}
template<class T> struct Comb{
  int mem_fact;
  T*factri;
  T*ifactri;
  int mem_dfact;
  T*dfactri;
  int mem_pw2;
  int mem_pw3;
  int mem_pw10;
  int mem_rep1;
  T*pw2c;
  T*pw3c;
  T*pw10c;
  T*rep1c;
  int mem_ipw2;
  int mem_ipw3;
  int mem_ipw10;
  T*ipw2c;
  T*ipw3c;
  T*ipw10c;
  Comb(){
    mem_fact = 0;
    mem_dfact = 0;
    mem_pw2 = mem_pw3 = mem_pw10 = mem_rep1 = 0;
    mem_ipw2 = mem_ipw3 = mem_ipw10 = 0;
  }
  inline void expand_fact(int k){
    int i;
    if(k <= mem_fact){
      return;
    }
    chmax(k, 2 * mem_fact);
    if(mem_fact == 0){
      factri = (T*)malloc(k * sizeof(T));
      ifactri = (T*)malloc(k * sizeof(T));
      factri[0] = 1;
      for(i=(1);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(0);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    else{
      factri = (T*)realloc(factri, k * sizeof(T));
      ifactri = (T*)realloc(ifactri, k * sizeof(T));
      for(i=(mem_fact);i<(k);i++){
        factri[i] = i * factri[i-1];
      }
      ifactri[k-1] = 1 / factri[k-1];
      for(i=(k-1)-1;i>=(mem_fact);i--){
        ifactri[i] = (i+1) * ifactri[i+1];
      }
    }
    mem_fact = k;
  }
  inline T fac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return factri[k];
  }
  inline T ifac(int k){
    if(mem_fact < k+1){
      expand_fact(k+1);
    }
    return ifactri[k];
  }
  inline T C(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[b] * ifactri[a-b];
  }
  inline T P(int a, int b){
    if(b < 0 || b > a){
      return 0;
    }
    if(mem_fact < a+1){
      expand_fact(a+1);
    }
    return factri[a] * ifactri[a-b];
  }
  inline T H(int a, int b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    if(mem_fact < a+b){
      expand_fact(a+b);
    }
    return C(a+b-1, b);
  }
  inline T Multinomial(int sz, int a[]){
    int i;
    int s = 0;
    T res;
    for(i=(0);i<(sz);i++){
      s += a[i];
    }
    if(mem_fact < s+1){
      expand_fact(s+1);
    }
    res = factri[s];
    for(i=(0);i<(sz);i++){
      res *= ifactri[a[i]];
    }
    return res;
  }
  inline T Multinomial(int a){
    return 1;
  }
  inline T Multinomial(int a, int b){
    if(mem_fact < a+b+1){
      expand_fact(a+b+1);
    }
    return factri[a+b] * ifactri[a] * ifactri[b];
  }
  inline T Multinomial(int a, int b, int c){
    if(mem_fact < a+b+c+1){
      expand_fact(a+b+c+1);
    }
    return factri[a+b+c] * ifactri[a] * ifactri[b] * ifactri[c];
  }
  inline T Multinomial(int a, int b, int c, int d){
    if(mem_fact < a+b+c+d+1){
      expand_fact(a+b+c+d+1);
    }
    return factri[a+b+c+d] * ifactri[a] * ifactri[b] * ifactri[c] * ifactri[d];
  }
  inline T Catalan(int n){
    if(n < 0){
      return 0;
    }
    if(mem_fact < 2*n+1){
      expand_fact(2*n+1);
    }
    return factri[2*n] * ifactri[n] * ifactri[n+1];
  }
  inline T Catalan(int n, int m, int k){
    if(k <= 0){
      return C(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C(n+m, m) - C(n+m, k-1);
  }
  inline T Catalan_s(long long n, long long m, long long k){
    if(k <= 0){
      return C_s(n+m, n);
    }
    if(n < k || m < k){
      return 0;
    }
    return C_s(n+m, m) - C_s(n+m, k-1);
  }
  inline T C_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    if(b > a - b){
      b = a - b;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
      res /= i + 1;
    }
    return res;
  }
  inline T P_s(long long a, long long b){
    long long i;
    T res;
    if(b < 0 || b > a){
      return 0;
    }
    res = 1;
    for(i=(0);i<(b);i++){
      res *= a - i;
    }
    return res;
  }
  inline T H_s(long long a, long long b){
    if(a==0 && b==0){
      return 1;
    }
    if(a <= 0 || b < 0){
      return 0;
    }
    return C_s(a+b-1, b);
  }
  inline T per_s(long long n, long long k){
    T d;
    int m;
    if(n < 0 || k < 0){
      return 0;
    }
    if(n == k  &&  k == 0){
      return 1;
    }
    if(n == 0 || k == 0){
      return 0;
    }
    if(k==1){
      return 1;
    }
    if(k==2){
      d = n / 2;
      return d;
    }
    if(k==3){
      d = (n-1) / 6;
      m = (n-1) % 6;
      if(m==0){
        return 3 * d * d + d;
      }
      if(m==1){
        return 3 * d * d + 2 * d;
      }
      if(m==2){
        return 3 * d * d + 3 * d + 1;
      }
      if(m==3){
        return 3 * d * d + 4 * d + 1;
      }
      if(m==4){
        return 3 * d * d + 5 * d + 2;
      }
      if(m==5){
        return 3 * d * d + 6 * d + 3;
      }
    }
    assert(0 && ""per_s should be k <= 3"");
    return -1;
  }
  inline void expand_dfact(int k){
    int i;
    if(k <= mem_dfact){
      return;
    }
    chmax(k, 3);
    chmax(k, 2 * mem_dfact);
    if(mem_dfact==0){
      dfactri = (T*)malloc(k * sizeof(T));
      dfactri[0] = dfactri[1] = 1;
      for(i=(2);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    else{
      dfactri = (T*)realloc(dfactri, k * sizeof(T));
      for(i=(mem_dfact);i<(k);i++){
        dfactri[i] = i * dfactri[i-2];
      }
    }
    mem_dfact = k;
  }
  inline void expand_pw2(int k){
    int i;
    if(k <= mem_pw2){
      return;
    }
    chmax(k, 2 * mem_pw2);
    if(mem_pw2==0){
      pw2c = (T*)malloc(k * sizeof(T));
      pw2c[0] = 1;
      for(i=(1);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    else{
      pw2c = (T*)realloc(pw2c, k * sizeof(T));
      for(i=(mem_pw2);i<(k);i++){
        pw2c[i] = 2 * pw2c[i-1];
      }
    }
    mem_pw2 = k;
  }
  inline void expand_ipw2(int k){
    int i;
    if(k <= mem_ipw2){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw2);
    if(mem_ipw2==0){
      ipw2c = (T*)malloc(k * sizeof(T));
      ipw2c[0] = 1;
      ipw2c[1] = ipw2c[0] / 2;
      for(i=(1);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    else{
      ipw2c = (T*)realloc(ipw2c, k * sizeof(T));
      for(i=(mem_ipw2);i<(k);i++){
        ipw2c[i] = ipw2c[1] * ipw2c[i-1];
      }
    }
    mem_ipw2 = k;
  }
  inline void expand_pw3(int k){
    int i;
    if(k <= mem_pw3){
      return;
    }
    chmax(k, 2 * mem_pw3);
    if(mem_pw3==0){
      pw3c = (T*)malloc(k * sizeof(T));
      pw3c[0] = 1;
      for(i=(1);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    else{
      pw3c = (T*)realloc(pw3c, k * sizeof(T));
      for(i=(mem_pw3);i<(k);i++){
        pw3c[i] = 3 * pw3c[i-1];
      }
    }
    mem_pw3 = k;
  }
  inline void expand_ipw3(int k){
    int i;
    if(k <= mem_ipw3){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw3);
    if(mem_ipw3==0){
      ipw3c = (T*)malloc(k * sizeof(T));
      ipw3c[0] = 1;
      ipw3c[1] = ipw3c[0] / 3;
      for(i=(1);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    else{
      ipw3c = (T*)realloc(ipw3c, k * sizeof(T));
      for(i=(mem_ipw3);i<(k);i++){
        ipw3c[i] = ipw3c[1] * ipw3c[i-1];
      }
    }
    mem_ipw3 = k;
  }
  inline void expand_pw10(int k){
    int i;
    if(k <= mem_pw10){
      return;
    }
    chmax(k, 2 * mem_pw10);
    if(mem_pw10==0){
      pw10c = (T*)malloc(k * sizeof(T));
      pw10c[0] = 1;
      for(i=(1);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    else{
      pw10c = (T*)realloc(pw10c, k * sizeof(T));
      for(i=(mem_pw10);i<(k);i++){
        pw10c[i] = 10 * pw10c[i-1];
      }
    }
    mem_pw10 = k;
  }
  inline void expand_ipw10(int k){
    int i;
    if(k <= mem_ipw10){
      return;
    }
    chmax(k, 2);
    chmax(k, 2 * mem_ipw10);
    if(mem_ipw10==0){
      ipw10c = (T*)malloc(k * sizeof(T));
      ipw10c[0] = 1;
      ipw10c[1] = ipw10c[0] / 10;
      for(i=(1);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    else{
      ipw10c = (T*)realloc(ipw10c, k * sizeof(T));
      for(i=(mem_ipw10);i<(k);i++){
        ipw10c[i] = ipw10c[1] * ipw10c[i-1];
      }
    }
    mem_ipw10 = k;
  }
  inline void expand_rep1(int k){
    int i;
    if(k <= mem_rep1){
      return;
    }
    chmax(k, 2 * mem_rep1);
    if(mem_rep1==0){
      rep1c = (T*)malloc(k * sizeof(T));
      rep1c[0] = 0;
      for(i=(1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    else{
      rep1c = (T*)realloc(rep1c, k * sizeof(T));
      for(i=(mem_rep1);i<(k);i++){
        rep1c[i] = 10 * rep1c[i-1] + 1;
      }
    }
    mem_rep1 = k;
  }
  inline T dfac(int k){
    if(k >= 0){
      if(mem_dfact < k+1){
        expand_dfact(k+1);
      }
      return dfactri[k];
    }
    if(k==-1){
      return 1;
    }
    k = - k - 2;
    if(k % 4 == 1){
      return 1 / (-dfac(k));
    }
    return 1 / dfac(k);
  }
  inline T pw2(int k){
    if(k >= 0){
      if(mem_pw2 < k+1){
        expand_pw2(k+1);
      }
      return pw2c[k];
    }
    else{
      k = -k;
      if(mem_ipw2 < k+1){
        expand_ipw2(k+1);
      }
      return ipw2c[k];
    }
  }
  inline T pw3(int k){
    if(k >= 0){
      if(mem_pw3 < k+1){
        expand_pw3(k+1);
      }
      return pw3c[k];
    }
    else{
      k = -k;
      if(mem_ipw3 < k+1){
        expand_ipw3(k+1);
      }
      return ipw3c[k];
    }
  }
  inline T pw10(int k){
    if(k >= 0){
      if(mem_pw10 < k+1){
        expand_pw10(k+1);
      }
      return pw10c[k];
    }
    else{
      k = -k;
      if(mem_ipw10 < k+1){
        expand_ipw10(k+1);
      }
      return ipw10c[k];
    }
  }
  inline T repunit(int k){
    if(mem_rep1 < k+1){
      expand_rep1(k+1);
    }
    return rep1c[k];
  }
}
;
template<> inline Modint Comb<Modint>::C_s(long long a, long long b){
  long long i;
  Modint res;
  Modint d;
  if(b < 0 || b > a){
    return 0;
  }
  if(b > a - b){
    b = a - b;
  }
  res = d = 1;
  for(i=(0);i<(b);i++){
    res *= a - i;
    d *= i + 1;
  }
  return res / d;
}
#define main dummy_main
int main(){
  wmem = memarr;
  return 0;
}
#undef main
Modint dp[50][2000];
Modint nx[50][2000];
Comb<Modint> comb;
class Solution{
  public:
  int countBalancedPermutations(string A){
    int i, k;
    int N = A.size();
    int x;
    int y;
    int mx;
    int g;
    int c;
    int u;
    int xx;
    int yy;
    x = N / 2;
    y = N - x;
    u = 0;
    g =max_L(x, y)* 9 + 4;
    mx = g * 2 + 1;
    int h[10] = {};
    for(i=(0);i<(N);i++){
      h[A[i]-'0']++;
    }
    for(i=(0);i<(x+1);i++){
      int j;
      for(j=(0);j<(mx);j++){
        dp[i][j] = 0;
      }
    }
    dp[x][g] = 1;
    for(k=(0);k<(10);k++){
      if(h[k]){
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            nx[i][j] = 0;
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            if(dp[i][j]){
              int m;
              for(m=(0);m<(h[k]+1);m++){
                xx = i;
                yy = N - u - i;
                if(xx < m || yy < h[k]-m){
                  continue;
                }
                nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
              }
            }
          }
        }
        for(i=(0);i<(x+1);i++){
          int j;
          for(j=(0);j<(mx);j++){
            dp[i][j] = nx[i][j];
          }
        }
        u += h[k];
      }
    }
    return dp[0][g];
  }
}
;
// cLay version 20241019-1

// --- original code ---
// #define main dummy_main
// {}
// #undef main
// 
// Modint dp[50][2000], nx[50][2000];
// Comb<Modint> comb;
// 
// class Solution {
// public:
//   int countBalancedPermutations(string A) {
//     int N = A.size();
//     int x, y, mx, g, c, u, xx, yy;
//     x = N / 2;
//     y = N - x;
//     u = 0;
//     g = max(x,y) * 9 + 4;
//     mx = g * 2 + 1;
// 
//     int h[10] = {};
//     rep(i,N) h[A[i]-'0']++;
// 
//     rep(i,x+1) rep(j,mx) dp[i][j] = 0;
//     dp[x][g] = 1;
// 
//     rep(k,10) if(h[k]){
//       rep(i,x+1) rep(j,mx) nx[i][j] = 0;
// 
//       rep(i,x+1) rep(j,mx) if(dp[i][j]) rep(m,h[k]+1){
//         xx = i;
//         yy = N - u - i;
//         if(xx < m || yy < h[k]-m) continue;
//         nx[i-m][j - (m - (h[k]-m)) * k] += dp[i][j] * comb.C(xx, m) * comb.C(yy, h[k]-m);
//       }
// 
//       rep(i,x+1) rep(j,mx) dp[i][j] = nx[i][j];
//       u += h[k];
//     }
// 
//     return dp[0][g];
//   }
// };
",1441310437
Yiming Li,lympanda,7,3627,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295795
Yiming Li,lympanda,7,3628,cpp,"#define _int64 long long

int neigh[4][2]={{0,1},{1,0},{0,-1},{-1,0}};

_int64 d[800][800][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int i,j,k,o,m,n,x,y,z,xx,yy,zz;
        _int64 v,vv;
        priority_queue<pair<_int64,pair<pair<int,int>,int> > > pq;
        m=a.size();
        n=a[0].size();
        while (!pq.empty()) pq.pop();
        for (i=0;i<m;i++)
            for (j=0;j<n;j++)
                for (k=0;k<2;k++)
                    d[i][j][k]=(1LL<<60);
        d[0][0][0]=0;
        pq.push(make_pair(0,make_pair(make_pair(0,0),0)));
        while (!pq.empty()) {
            v=-pq.top().first;
            x=pq.top().second.first.first;
            y=pq.top().second.first.second;
            z=pq.top().second.second;
            pq.pop();
            if (d[x][y][z]!=v) continue;
            for (o=0;o<4;o++) {
                xx=x+neigh[o][0];
                yy=y+neigh[o][1];
                if ((xx>=0)&&(xx<m)&&(yy>=0)&&(yy<n))
                {
                    zz=1-z;
                    vv=max(v,(_int64)a[xx][yy])+z+1;
                    if (vv<d[xx][yy][zz]) {
                        d[xx][yy][zz]=vv;
                        pq.push(make_pair(-vv,make_pair(make_pair(xx,yy),zz)));
                    }
                }
            }
        }
        return min(d[m-1][n-1][0],d[m-1][n-1][1]);
    }
};",1441295250
Yiming Li,lympanda,7,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1,sum2,i;
        sum1=0;sum2=0;
        for (i=0;i<num.length();i++)
            {
                if (i%2==0) sum1+=num[i]-'0';
                else sum2+=num[i]-'0';
            }
        if (sum1==sum2) return true;
        else return false;
    }
};",1441281135
Yiming Li,lympanda,7,3637,cpp,"#define _int64 long long
#define mo 1000000007

int inited=0;

#define faclim 310000

_int64 fac[faclim];
_int64 invfac[faclim];

_int64 pow1(int x,int y)
{
	int i;
	_int64 ret;
	ret=1;
	for (i=30;i>=0;i--)
	{
		ret=ret*ret%mo;
		if (((1<<i)&y)!=0) ret=ret*x%mo;
	}
	return ret;
}
_int64 inv(int x)
{
	return pow1(x,mo-2);
}
_int64 c(int x,int y)
{
	return fac[x]*invfac[y]%mo*invfac[x-y]%mo;
}
void init()
{
	int i;
	fac[0]=1;
	for (i=1;i<faclim;i++)
		fac[i]=fac[i-1]*i%mo;
	invfac[faclim-1]=inv(fac[faclim-1]);
	for (i=faclim-1;i>0;i--)
		invfac[i-1]=invfac[i]*i%mo;
}

_int64 d[2][2100][50];

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (inited==0)
        {
            init();
            inited=1;
        }
        int cnt[10];
        int i,j,k,o,rem,nn,now,n1,n2;
        memset(cnt,0,sizeof(cnt));
        for (i=0;i<num.length();i++)
            cnt[num[i]-'0']++;
        memset(d[0],0,sizeof(d[0]));
        nn=(num.length()+1)/2;
        d[0][1000][nn]=1;
        rem=num.length();
        now=0;
        for (i=0;i<10;i++) {
            memset(d[1-now],0,sizeof(d[1-now]));
            for (j=0;j<2100;j++)
                for (k=0;k<=nn;k++) {
                    if (d[now][j][k]==0) continue;
                    //cout<<""i,j,k:""<<i<<"" ""<<j<<"" ""<<k<<"" ""<<d[now][j][k]<<endl;
                    n1=k;n2=rem-k;
                    for (o=0;o<=cnt[i];o++) {
                        if (o>n1) continue;
                        if (cnt[i]-o>n2) continue;
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]+=d[now][j][k]*c(n1,o)%mo*c(n2,cnt[i]-o);
                        d[1-now][j+(o+o-cnt[i])*i][n1-o]%=mo;
                    }
                }
            rem-=cnt[i];
            now=1-now;
        }
        return d[now][1000][0];
    }
};",1441310647
Rakesh_Reddy7,Naruto_x,8,3627,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0: return -1
        m = len(moveTime[0])
        if m == 0: return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[float('inf')] * m for i in range(n)]
        t2[0][0] = 0
        pq = [(0, 0, 0)] 
        while pq:
            curt, x, y = heapq.heappop(pq)
            
            if x == n - 1 and y == m - 1:
                return int(curt)
            
            if curt > t2[x][y]:
                continue
            
            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    at = max(curt, moveTime[nx][ny]) + 1

                    if at < t2[nx][ny]:
                        t2[nx][ny] = at
                        heapq.heappush(pq, (at, nx, ny))
        
        return -1
",1441309684
Rakesh_Reddy7,Naruto_x,8,3628,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        if n == 0:
            return -1
        m = len(moveTime[0])
        if m == 0:
            return -1

        direc = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        t2 = [[[float('inf')] * 2 for i in range(m)] for j in range(n)]
        t2[0][0][0] = 0
        pq = [(0, 0, 0, 0)]  

        while pq:
            curt, x, y, z = heapq.heappop(pq)

            if x == n - 1 and y == m - 1:
                return int(curt)

            if curt > t2[x][y][z]:
                continue

            for dx, dy in direc:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    m1 = 1 if z == 0 else 2
                    t1 = max(curt, moveTime[nx][ny]) + m1
                    pp = 1 - z

                    if t1 < t2[nx][ny][pp]:
                        t2[nx][ny][pp] = t1
                        heapq.heappush(pq, (t1, nx, ny, pp))

        return -1
",1441310581
Rakesh_Reddy7,Naruto_x,8,3636,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        
        for i in range(len(num)):
            k = int(num[i])
            
            if i % 2 == 0:
                evens += k
            else:
                odds += k
                
        return evens == odds
",1441311289
Rakesh_Reddy7,Naruto_x,8,3637,python3,"''' Author : Rakesh Reddy '''
class lazy_segtree():
    def update(self,k):self.d[k]=self.op(self.d[2*k],self.d[2*k+1])
    
    def all_apply(self,k,f):
        self.d[k]=self.mapping(f,self.d[k])
        if (k<self.size):self.lz[k]=self.composition(f,self.lz[k])
        
    def push(self,k):
        self.all_apply(2*k,self.lz[k])
        self.all_apply(2*k+1,self.lz[k])
        self.lz[k]=self.identity
        
    def __init__(self,V,OP,E,MAPPING,COMPOSITION,ID):
        self.n=len(V)
        self.log=(self.n-1).bit_length()
        self.size=1<<self.log
        self.d=[E for i in range(2*self.size)]
        self.lz=[ID for i in range(self.size)]
        self.e=E
        self.op=OP
        self.mapping=MAPPING
        self.composition=COMPOSITION
        self.identity=ID
        for i in range(self.n):self.d[self.size+i]=V[i]
        for i in range(self.size-1,0,-1):self.update(i)
        
    def set(self,p,x):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=x
        for i in range(1,self.log+1):self.update(p>>i)
        
    def get(self,p):
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        return self.d[p]
        
    def prod(self,l,r):
        if l==r:return self.e
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push(r>>i)
        sml,smr=self.e,self.e
        while(l<r):
            if l&1:
                sml=self.op(sml,self.d[l])
                l+=1
            if r&1:
                r-=1
                smr=self.op(self.d[r],smr)
            l>>=1
            r>>=1
        return self.op(sml,smr)
        
    def all_prod(self):return self.d[1]
    
    def apply_point(self,p,f):
        assert 0<=p and p<self.n
        p+=self.size
        for i in range(self.log,0,-1):self.push(p>>i)
        self.d[p]=self.mapping(f,self.d[p])
        for i in range(1,self.log+1):self.update(p>>i)
        
    def apply(self,l,r,f):
        if l==r:return
        l+=self.size
        r+=self.size
        for i in range(self.log,0,-1):
            if (((l>>i)<<i)!=l):self.push(l>>i)
            if (((r>>i)<<i)!=r):self.push((r-1)>>i)
        l2,r2=l,r
        while(l<r):
            if (l&1):
                self.all_apply(l,f)
                l+=1
            if (r&1):
                r-=1
                self.all_apply(r,f)
            l>>=1
            r>>=1
        l,r=l2,r2
        for i in range(1,self.log+1):
            if (((l>>i)<<i)!=l):self.update(l>>i)
            if (((r>>i)<<i)!=r):self.update((r-1)>>i)
            
    def max_right(self,l,g):
        if l==self.n:return self.n
        l+=self.size
        for i in range(self.log,0,-1):self.push(l>>i)
        sm=self.e
        while(1):
            while(l%2==0):l>>=1
            if not(g(self.op(sm,self.d[l]))):
                while(l<self.size):
                    self.push(l)
                    l=(2*l)
                    if (g(self.op(sm,self.d[l]))):
                        sm=self.op(sm,self.d[l])
                        l+=1
                return l-self.size
            sm=self.op(sm,self.d[l])
            l+=1
            if (l&-l)==l:break
        return self.n
        
    def min_left(self,r,g):
        if r==0:return 0
        r+=self.size
        for i in range(self.log,0,-1):self.push((r-1)>>i)
        sm=self.e
        while(1):
            r-=1
            while(r>1 and (r%2)):r>>=1
            if not(g(self.op(self.d[r],sm))):
                while(r<self.size):
                    self.push(r)
                    r=(2*r+1)
                    if g(self.op(self.d[r],sm)):
                        sm=self.op(self.d[r],sm)
                        r-=1
                return r+1-self.size
            sm=self.op(self.d[r],sm)
            if (r&-r)==r:break
        return 0

def is_prime(n):
    if n <= 1:
        return False
    if n == 2 or n == 7 or n == 61:
        return True
    if n % 2 == 0:
        return False
    d = n - 1
    while d % 2 == 0:
        d //= 2
    bases = [2, 7, 61]
    for a in bases:
        t = d
        y = pow_mod(a, t, n)
        while t != n - 1 and y != 1 and y != n - 1:
            y = y * y % n
            t <<= 1
        if y != n - 1 and t % 2 == 0:
            return False
    return True

def primitive_root(m):
    if m == 2:
        return 1
    if m in (167772161, 469762049, 754974721, 998244353):
        return 3
    divs = [2]
    x = (m - 1) // 2
    while x % 2 == 0:
        x //= 2
    i = 3
    while i * i <= x:
        if x % i == 0:
            divs.append(i)
            while x % i == 0:
                x //= i
        i += 2
    if x > 1:
        divs.append(x)

    g = 2
    while True:
        ok = True
        for d in divs:
            if pow_mod(g, (m - 1) // d, m) == 1:
                ok = False
                break
        if ok:
            return g
        g += 1
        
def zs(s):
    n = len(s)
    ret = [0] * n
    l = 1
    ll = 0
    r = 0
    while l < len(s):
        if l < r:
            ret[l] = min(ret[l-ll],r-l)
        
        i = ret[l]
        while l+i < len(s) and s[i] == s[l+i]:
            ret[l] +=1
            
            i +=1
        if ret[l] >0:
            if l+i-1 > r:
                ll = l
                r = max(r,l+i-1)        
        l+=1
    return ret

mod = 10**9 + 7

def pow_mod(a, b):
    res = 1
    a %= mod
    while b > 0:
        if b & 1:
            res = res * a % mod
        a = a * a % mod
        b >>= 1
    return res

class Factorials:
    def __init__(self, n):
        self.fact = [1] * (n + 1)
        for i in range(1, n + 1):
            self.fact[i] = self.fact[i - 1] * i % mod
        self.invf = [1] * (n + 1)
        self.invf[n] = pow_mod(self.fact[n], mod - 2)
        for i in range(n - 1, -1, -1):
            self.invf[i] = self.invf[i + 1] * (i + 1) % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        tot = 0
        for ch in num:
            freq[int(ch)] += 1
            tot += int(ch)

        if tot % 2 != 0:
            return 0

        tsum = tot // 2
        k = (n + 1) // 2
        l = n // 2
        factorial = Factorials(n)
        fact = factorial.fact
        invf = factorial.invf

        dp = [[0] * (k + 1) for i in range(tsum + 1)]
        dp[0][0] = 1

        for d in range(10):
            if freq[d] == 0:
                continue
            for s in range(tsum, -1, -1):
                for c in range(k, -1, -1):
                    if dp[s][c] == 0:
                        continue
                    for t in range(1, freq[d] + 1):
                        if s + t * d > tsum or c + t > k:
                            break
                        dp[s + t * d][c + t] = (dp[s + t * d][c + t] + dp[s][c] * ((fact[freq[d]] * invf[t] % mod) * invf[freq[d] - t] % mod)) % mod

        validx = dp[tsum][k]
        if validx == 0:
            return 0

        ifreq = 1
        for d in range(10):
            if freq[d] > 0:
                ifreq = ifreq * invf[freq[d]] % mod

        ans = validx * fact[k] % mod
        ans = ans * fact[l] % mod
        ans = ans * ifreq % mod

        return ans
",1441308446
arignote,arignote,10,3627,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[3]);;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + 1, poll[1] - 1, poll[2] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + 1, poll[1], poll[2] - 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + 1, poll[1], poll[2] + 1 });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + 1, poll[1] + 1, poll[2] });
            }
        }
    }
}",1441307297
arignote,arignote,10,3628,java,"class Solution {

    public int minTimeToReach(int[][] moveTime) {
        PriorityQueue<int[]> queue = new PriorityQueue<>((o, p) -> o[0] - p[0]);
        Integer[][] dp = new Integer[moveTime.length][moveTime[0].length];
        for (queue.offer(new int[] { 0, 0, 0, 1 });;) {
            int[] poll = queue.poll();
            if (poll[1] == moveTime.length - 1 && poll[2] == moveTime[0].length - 1) {
                return poll[0];
            } else if (poll[1] >= 0 && poll[1] < moveTime.length && poll[2] >= 0 && poll[2] < moveTime[0].length && dp[poll[1]][poll[2]] == null) {
                dp[poll[1]][poll[2]] = poll[0];
                queue.offer(new int[] { Math.max(poll[0], poll[1] > 0 ? moveTime[poll[1] - 1][poll[2]] : 0) + poll[3], poll[1] - 1, poll[2], 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] > 0 ? moveTime[poll[1]][poll[2] - 1] : 0) + poll[3], poll[1], poll[2] - 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[2] < moveTime[0].length - 1 ? moveTime[poll[1]][poll[2] + 1] : 0) + poll[3], poll[1], poll[2] + 1, 3 - poll[3] });
                queue.offer(new int[] { Math.max(poll[0], poll[1] < moveTime.length - 1 ? moveTime[poll[1] + 1][poll[2]] : 0) + poll[3], poll[1] + 1, poll[2], 3 - poll[3] });
            }
        }
    }
}",1441307185
arignote,arignote,10,3636,java,"class Solution {

    public boolean isBalanced(String num) {
        int sum = 0;
        for (int i = 0; i < num.length(); i++) {
            sum += (i % 2 > 0 ? 1 : -1) * (num.charAt(i) - '0');
        }
        return sum == 0;
    }
}",1441307472
arignote,arignote,10,3637,java,"class Solution {

    public int countBalancedPermutations(String num) {
        int count[] = new int[10], sum = 0, f[][] = new int[num.length() + 1][num.length() + 1], dp[][][] = new int[11][num.length() / 2 + 1][361];
        for (char c : num.toCharArray()) {
            count[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 0) {
            for (int i = 0; i <= num.length(); i++) {
                for (int j = f[i][0] = f[i][i] = dp[0][0][0] = 1; j < i; j++) {
                    f[i][j] = (f[i - 1][j - 1] + f[i - 1][j]) % 1000000007;
                }
            }
            for (int i = 0, s = 0, t = 0; i < 10; s += i * count[i], t += count[i++]) {
                for (int j = 0; j <= t && j <= num.length() / 2; j++) {
                    for (int k = 0; k <= s && k <= sum / 2; k++) {
                        for (int l = 0; dp[i][j][k] > 0 && l <= count[i] && l + j <= num.length() / 2 && l * i + k <= sum / 2; l++) {
                            dp[i + 1][j + l][l * i + k] = (int) ((dp[i + 1][j + l][l * i + k] + (long) dp[i][j][k] * f[num.length() / 2 - j][l] % 1000000007 * f[num.length() - num.length() / 2 - t + j][count[i] - l] % 1000000007) % 1000000007);
                        }
                    }
                }
            }
        }
        return dp[10][num.length() / 2][sum / 2];
    }
}",1441307111
Nguyen Quang Long,mbfibat,11,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 1), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441295120
Nguyen Quang Long,mbfibat,11,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};
        
        typedef pair<int, int> ii;
        typedef pair<ii, ii> iv;
        priority_queue<iv, vector<iv>, greater<iv>> pq;
        pq.emplace(ii(0, 1), ii(0, 0));

        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;

        while (!pq.empty()) {
            iv dt = pq.top();
            int dxy = dt.first.first, t = dt.first.second, x = dt.second.first, y = dt.second.second;
            pq.pop();
            if (dxy != d[x][y]) continue;
 
            for (int i = 0; i < 4; i++) {
                int xx = x + dx[i], yy = y + dy[i];
                if (0 <= xx && xx < n && 0 <= yy && yy < m) {
                    int nxt_d = max(d[x][y], moveTime[xx][yy]) + t;                    
                    if (d[xx][yy] > nxt_d) {
                        d[xx][yy] = nxt_d;
                        pq.emplace(ii(d[xx][yy], 3 - t), ii(xx, yy));
                    }
                }
            }
        }

        return d[n - 1][m - 1];
    }
};",1441294784
Nguyen Quang Long,mbfibat,11,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum_0 = 0, sum_1 = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = (num[i] - '0');
            if (i % 2) sum_1 += d;
            else sum_0 += d;
        }
        return (sum_0 == sum_1);
    }
};",1441280868
Nguyen Quang Long,mbfibat,11,3637,cpp,"const int mod = 1e9 + 7;

int fact[101], re_fact[101];

int qp(int a, int b) {
    if (b == 0) return 1;
    int tmp = qp(a, b / 2);
    if (b % 2 == 0) return 1LL * tmp * tmp % mod;
    return 1LL * a * tmp % mod * tmp % mod;
}

int f[11][81][721];
bool g[11][81][721];

class Solution {
private:
    int tot_cnt = 0;
    int occ[10];
    int tot_sum = 0;
    int sz1 = 0, sz2 = 0;
public:
    int dp(int pos, int cnt1, int sum1) {
        if (pos >= 10) {
            int sum2 = tot_sum - sum1;            
            int cnt2 = tot_cnt - cnt1;
            if (cnt1 == sz1 && cnt2 == sz2 && sum1 == sum2)
                return 1LL * fact[cnt1] * fact[cnt2] % mod;
            return 0;
        }

        if (g[pos][cnt1][sum1])
            return f[pos][cnt1][sum1];

        int ans = 0;
        for (int i = 0; i <= occ[pos]; i++) {
            int val = 1LL * dp(pos + 1, cnt1 + i, sum1 + pos * i) * re_fact[i] % mod * re_fact[occ[pos] - i] % mod;
            ans = (ans + val) % mod;
        }
        g[pos][cnt1][sum1] = true;
        return f[pos][cnt1][sum1] = ans;
    }

    int countBalancedPermutations(string num) {
        fact[0] = 1;
        for (int i = 1; i <= 100; i++)
            fact[i] = 1LL * fact[i - 1] * i % mod;
        re_fact[100] = qp(fact[100], mod - 2);
        for (int i = 100; i >= 1; i--)
            re_fact[i - 1] = 1LL * re_fact[i] * i % mod;

        for (int i = 0; i <= 9; i++) occ[i] = 0;
        
        for (char c : num) {
            occ[c - '0']++;
            tot_sum += (c - '0');
        }
        tot_cnt = num.size();
        sz1 = (tot_cnt + 1) / 2;
        sz2 = tot_cnt /2;
        
        for (int i = 0; i <= 9; i++)
            for (int j = 0; j <= tot_cnt; j++)
                for (int l = 0; l <= tot_sum; l++)
                    g[i][j][l] = false;
        return dp(0, 0, 0);
    }
};",1441314636
BERNARD BRAHIMCHA,BERNARB01,12,3627,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441315189
BERNARD BRAHIMCHA,BERNARB01,12,3628,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

template <class T>
using rpq = priority_queue<T, vector<T>, greater<T>>;

class Solution {
 public:
  int minTimeToReach(vector<vector<int>>& t) {
    int n = int(t.size());
    int m = int(t[0].size());
    const int inf = INT_MAX;
    vector dist(n, vector(m, vector<int>(2, inf)));
    dist[0][0][0] = 0;
    rpq<tuple<int, int, int, int>> s;
    s.emplace(0, 0, 0, 0);
    const int di[4] = {-1, 1, 0, 0};
    const int dj[4] = {0, 0, -1, 1};
    auto Valid = [&](int i, int j) {
      return (0 <= i && i < n && 0 <= j && j < m);
    };
    while (!s.empty()) {
      auto [D, i, j, p] = s.top();
      s.pop();
      if (dist[i][j][p] != D) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int ni = i + di[k];
        int nj = j + dj[k];
        if (!Valid(ni, nj)) {
          continue;
        }
        int np = p ^ 1;
        if (max(D, t[ni][nj]) + 1 + p < dist[ni][nj][np]) {
          dist[ni][nj][np] = max(D, t[ni][nj]) + 1 + p;
          s.emplace(dist[ni][nj][np], ni, nj, np);
        }
      }
    }
    return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441314619
BERNARD BRAHIMCHA,BERNARB01,12,3636,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

class Solution {
 public:
  bool isBalanced(string s) {
    int n = int(s.length());
    int se = 0, so = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        so += int(s[i] - '0');
      } else {
        se += int(s[i] - '0');
      }
    }
    return (se == so);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441307439
BERNARD BRAHIMCHA,BERNARB01,12,3637,cpp,"/**
 *    author:  BERNARD B.01
**/
#include <bits/stdc++.h>

using namespace std;

#ifdef B01
#include ""deb.h""
#else
#define deb(...)
#endif

const int N = 102;
const int md = int(1e9) + 7;

int iv[N], f1[N], f2[N], p2[N], ip2[N];

inline void add(int& a, int b) {
  a += b;
  if (a >= md) a -= md;
}

inline void sub(int& a, int b) {
  a -= b;
  if (a < 0) a += md;
}

inline int mul(int a, int b) {
  return int(int64_t(a) * b % md);
}

template <typename T>
inline int po(int b, T p) {
  int r = 1;
  while (p > 0) {
    if (p & 1) {
      r = mul(r, b);
    }
    b = mul(b, b);
    p >>= 1;
  }
  return r;
}

inline int inv(int a) {
  a %= md;
  if (a < 0) a += md;
  int b = md, u = 0, v = 1;
  while (a) {
    int t = b / a;
    b -= t * a; swap(a, b);
    u -= t * v; swap(u, v);
  }
  assert(b == 1);
  if (u < 0) u += md;
  return u;
}

inline int C(int n, int k) {
  if (k < 0 || n < k) return 0;
  return mul(f1[n], mul(f2[k], f2[n - k]));
}

inline int nck(int n, int k) {
  int r = 1;
  for (int i = 1; i <= k; i++) {
    r = mul(r, mul(n - i + 1, inv(i)));
  }
  return r;
}

void bldmd() {
  iv[1] = 1;
  for (int i = 2; i < N; i++) {
    iv[i] = md - mul(md / i, iv[md % i]);
  }
  f1[0] = f2[0] = p2[0] = ip2[0] = 1;
  for (int i = 1; i < N; i++) {
    f1[i] = mul(f1[i - 1], i);
    f2[i] = mul(f2[i - 1], iv[i]);
    p2[i] = (p2[i - 1] << 1);
    if (p2[i] >= md) p2[i] -= md;
    ip2[i] = mul(ip2[i - 1], iv[2]);
  }
}

int ne, f;
int sum;
int cnt[10];
int dp[10][402][41];

int sol(int i, int j, int k) {
  if (i == 10) {
    if (j != sum || k != ne) {
      return 0;
    }
    return f;
  }
  int& ret = dp[i][j][k];
  if (ret != -1) {
    return ret;
  }
  ret = 0;
  for (int u = 0; u <= cnt[i]; u++) {
    if (j + u * i <= sum && k + u <= ne) {
      add(ret, mul(mul(f2[u], f2[cnt[i] - u]), sol(i + 1, j + u * i, k + u)));
    }
  }
  return ret;
}

class Solution {
 public:
  int countBalancedPermutations(string s) {
    bldmd();
    for (int i = 0; i < 10; i++) {
      cnt[i] = 0;
    }
    int n = int(s.length());
    sum = 0;
    for (char c : s) {
      sum += int(c - '0');
      ++cnt[int(c - '0')];
    }
    if (sum & 1) {
      return 0;
    }
    sum /= 2;
    ne = n / 2;
    int no = n - ne;
    f = mul(f1[ne], f1[no]);
    memset(dp, -1, sizeof dp);
    return sol(0, 0, 0);
  }
};

#ifdef B01
int main() {
  Solution sl;
  
}
#endif
",1441305879
LucasLyu,Lucas595,13,3627,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0) ]
    
        while heap:
            t, x, y = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 1
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny))
    
        return -1
        
        ",1441291623
LucasLyu,Lucas595,13,3628,python3,"import heapq


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        dist = [ [float('inf')] * m for _ in range(n) ]
        dist[0][0] = 0
        heap = [ (0, 0, 0, 1) ]
    
        while heap:
            t, x, y, odd = heapq.heappop(heap)
    
            if (x, y) == (n-1, m-1):
                return t
    
            if t > dist[x][y]:
                continue
    
            for dx, dy in [ (0,1), (1,0), (0,-1), (-1,0) ]:
                nx, ny = x + dx, y + dy
    
                if 0 <= nx < n and 0 <= ny < m:
                    start_time = max(t, moveTime[nx][ny])
                    arrival_time = start_time + 2 - odd
    
                    if dist[nx][ny] > arrival_time:
                        dist[nx][ny] = arrival_time
                        heapq.heappush(heap, (arrival_time, nx, ny, 1 - odd))
    
        return -1
        
        ",1441307713
LucasLyu,Lucas595,13,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        diff = 0
        for i, k in enumerate(num):
            if i & 1:
                diff += int(k)
            else:
                diff -= int(k)
        return not diff
        ",1441282133
LucasLyu,Lucas595,13,3637,python3,"from math import comb
from collections import defaultdict


MOD = int(1e9 + 7)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        counts = [0] * 10
        N = len(num)
        for ch in num:
            counts[int(ch)] += 1

        total_sum = sum(d * counts[d] for d in range(10))
        if total_sum & 1:
            return 0

        target_sum = total_sum // 2
        N_even = (N + 1) // 2
        N_odd = N // 2

        max_N = N + 1
        factorials = [1] * max_N
        inv_factorials = [1] * max_N
        for i in range(1, max_N):
            factorials[i] = factorials[i - 1] * i % MOD

        inv_factorials[-1] = pow(factorials[-1], MOD - 2, MOD)
        for i in range(max_N - 2, -1, -1):
            inv_factorials[i] = inv_factorials[i + 1] * (i + 1) % MOD

        total_counts_fact = 1
        for c in counts:
            total_counts_fact = total_counts_fact * factorials[c] % MOD

        memo = {}

        def dp(d, s, c):
            key = (d, s, c)
            if key in memo:
                return memo[key]
            if s > target_sum or c > N_even:
                return 0
            if d == 10:
                if s == target_sum and c == N_even:
                    return 1
                else:
                    return 0
            res = 0
            for k in range(counts[d] + 1):
                s_new = s + k * d
                c_new = c + k
                if s_new > target_sum or c_new > N_even:
                    break
                ways = comb(counts[d], k)
                res = (res + dp(d + 1, s_new, c_new) * ways) % MOD
            memo[key] = res
            return res

        total_ways = dp(0, 0, 0) * factorials[N_even] % MOD
        total_ways = total_ways * factorials[N_odd] % MOD
        total_ways = total_ways * pow(total_counts_fact, MOD - 2, MOD) % MOD
        return total_ways
        ",1441315468
Ma Lin,Ma_Lin,14,3627,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f;
    int m, n, res, MAX = 2000000000;
    bool done[100][100];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d;
        set<pair<int, pair<int, int>>> S;
        f = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[i][j] = MAX;
                done[i][j] = false;
            }
                
        f[0][0] = 0;
        S.insert({0, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[i][j] || f[i][j] == MAX) continue;
            if (f[i][j] != d) continue;
            done[i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[nx][ny]){
                    v = max(a[nx][ny] + 1, f[i][j] + 1);
                    if (v < f[nx][ny]){
                        f[nx][ny] = v;
                        S.insert({v, {nx, ny}});
                    }
                }
            }
        }

        return f[m - 1][n - 1];
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441293809
Ma Lin,Ma_Lin,14,3628,cpp,"class Solution {
public:
    int dx[4] = {0,1,0,-1};
    int dy[4] = {1,0,-1,0};
    vector<vector<int> > a, f[2];
    int m, n, res, MAX = 2000000000;
    bool done[2][800][800];

    int calc_dist(){
        int i, j, k, v, nx, ny, p, w, d, q;
        set<pair<pair<int, int>, pair<int, int> > > S;
        f[0] = a;
        f[1] = a;
        for (i = 0; i < m; ++i) 
            for (j = 0; j < n; ++j){
                f[0][i][j] = f[1][i][j] = MAX;
                done[0][i][j] = done[1][i][j] = false;
            }
                
        f[0][0][0] = 0;
        S.insert({{0, 0}, {0, 0}});
        while (S.size() > 0){
            d = S.begin()->first.first;
            q = S.begin()->first.second;
            i = S.begin()->second.first;
            j = S.begin()->second.second;
            S.erase(S.begin());
            if (done[q][i][j] || f[q][i][j] == MAX) continue;
            if (f[q][i][j] != d) continue;
            done[q][i][j] = true;
            for (k = 0; k < 4; ++k){
                nx = i + dx[k];
                ny = j + dy[k];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !done[1 - q][nx][ny]){
                    v = max(a[nx][ny] + (q + 1), f[q][i][j] + (q + 1));
                    if (v < f[1 - q][nx][ny]){
                        f[1 - q][nx][ny] = v;
                        S.insert({{v, 1 - q}, {nx, ny}});
                    }
                }
            }
        }

        return min(f[0][m - 1][n - 1], f[1][m - 1][n - 1]);
    }
    
    int minTimeToReach(vector<vector<int>>& aa) {
        int i, j;
        a = aa;
        m = a.size();
        n = a[0].size();
        return calc_dist();
    }
};",1441299307
Ma Lin,Ma_Lin,14,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int x = 0, i;
        for (i = 0; i < s.size(); ++i)
            if (i % 2 == 0) x += s[i] - '0';
            else x -= s[i] - '0';
        
        return x == 0;
    }
};",1441280955
Ma Lin,Ma_Lin,14,3637,cpp,"class Solution {
public:
    int f[2][90][1600];
    int countBalancedPermutations(string s) {
        int mo = 1000000007;
        int C[100][100], n = s.size(), i, j, k, mid, yj, p[2], ge[10], old, now = 0, d, t, nk;
        C[0][0] = 1;
        for (i = 1; i <= n; ++i){
            C[i][0] = C[i][i] = 1;
            for (j = 1; j < i; ++j)
                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mo;
        }
        
        p[0] = p[1] = 0;
        for (i = 0; i < 10; ++i) ge[i] = 0;
        for (i = 0; i < n; ++i){
            ++p[i % 2];
            ++ge[s[i] - '0'];
        }
        
        mid = n * 9;
        for (j = 0; j <= p[0]; ++j)
            for (k = 0; k <= mid + mid; ++k)
                f[now][j][k] = 0;
        f[now][0][mid] = 1;
        yj = 0;
        for (i = 0; i < 10; ++i){
            old = now;
            now = 1 - now;
            for (j = 0; j <= p[0]; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    f[now][j][k] = 0;
            for (j = 0; j <= p[0] && j <= yj; ++j)
                for (k = 0; k <= mid + mid; ++k)
                    if (f[old][j][k] > 0){
                        for (d = 0; d <= ge[i]; ++d)
                            if (j + d <= p[0] && yj - j + (ge[i] - d) <= p[1]){
                                t = (1LL * C[p[0] - j][d] * C[p[1] - (yj - j)][ge[i] - d]) % mo;
                                t = (1LL * t * f[old][j][k]) % mo;
                                nk = k + d * i - (ge[i] - d) * i;
                                f[now][j + d][nk] = (f[now][j + d][nk] + t) % mo;
                            }
                    }
            yj += ge[i];
        }
        
        return f[now][p[0]][mid];
    }
};",1441316423
plevande,plevande,15,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time = [[float('inf') for j in range(m)] for i in range(n)]
        true_time[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0])
        while len(H) > 0:
            t, x, y = heapq.heappop(H)
            if true_time[x][y]==t:
                for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                    if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                        t2 = max(t+1, moveTime[x2][y2]+1)
                        if t2 < true_time[x2][y2]:
                            true_time[x2][y2] = t2 
                            heapq.heappush(H, [t2, x2, y2])
        return true_time[n-1][m-1]",1441290714
plevande,plevande,15,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        true_time1 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2 = [[float('inf') for j in range(m)] for i in range(n)]
        true_time2[0][0] = 0 
        H = []
        heapq.heappush(H, [0, 0, 0, 2])
        while len(H) > 0:
            t, x, y, my_case = heapq.heappop(H)
            if my_case==1:
                if true_time1[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+2, moveTime[x2][y2]+2)
                            if t2 < true_time2[x2][y2]:
                                true_time2[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 2])
            else:
                if true_time2[x][y]==t:
                    for x2, y2 in [[x-1, y], [x+1, y], [x, y-1], [x, y+1]]:
                        if 0 <= x2 <= n-1 and 0 <= y2 <= m-1:
                            t2 = max(t+1, moveTime[x2][y2]+1)
                            if t2 < true_time1[x2][y2]:
                                true_time1[x2][y2] = t2 
                                heapq.heappush(H, [t2, x2, y2, 1])
        return min(true_time1[n-1][m-1], true_time2[n-1][m-1])",1441296393
plevande,plevande,15,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a1 = 0 
        a2 = 0 
        n = len(num)
        for i in range(n):
            if i % 2==0:
                a1+=int(num[i])
            else:
                a2+=int(num[i])
        return a1==a2",1441281094
plevande,plevande,15,3637,python3,"p = 10**9+7
binom = [[1], [1, 1]]
for i in range(81):
    row = binom[-1]
    new_row = [1]
    for j in range(len(row)-1):
        new_row.append((row[j]+row[j+1]) % p)
    new_row.append(1)
    binom.append(new_row)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int, num))
        if s % 2==1:
            return 0
        my_count = [0 for i in range(10)]
        for x in num:
            my_count[int(x)]+=1
        target = s//2
        poss = {(0, n//2, n-n//2): 1}
        for i in range(10):
            new_poss = {}
            c = my_count[i]
            for a, b, b2 in poss:
                for x in range(c+1):
                    if b2-(c-x) >=0 and b-x >= 0 and a+x*i <= target:
                        new_a = a+x*i
                        new_b = b-x
                        new_b2 = b2-(c-x)
                        new_ways = (poss[(a, b, b2)]*binom[b][x]*binom[b2][c-x]) % p
                        if (new_a, new_b, new_b2) not in new_poss:
                            new_poss[(new_a, new_b, new_b2)] = 0
                        new_poss[(new_a, new_b, new_b2)]+=new_ways 
                        new_poss[(new_a, new_b, new_b2)]%=p 
            poss = new_poss
        if (target, 0, 0) not in poss:
            return 0
        return poss[(target, 0, 0)]
        """"""
        how many ways are there
        to get target in n
        """"""",1441310112
BarryBondsOfLC,BarryBondsOfLC,19,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310608
BarryBondsOfLC,BarryBondsOfLC,19,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        vector<array<int, 2>> DS = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int R = A.size(), C = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> q;
        q.push({0, 0, 0, 1});
        
        vector DIST(R, vector<int>(C, INT_MAX));
        while (!q.empty()) {
            auto [t, r, c, dt] = q.top();
            q.pop();
            
            for (const auto& [dr, dc] : DS) {
                auto nr = r + dr, nc = c + dc;
                if (nr < 0 || nc < 0 || nr >= R || nc >= C) continue;
                auto nt = max(t + dt, A[nr][nc] + dt);
                
                if (nt < DIST[nr][nc]) {
                    DIST[nr][nc] = nt;
                    q.push({nt, nr, nc, dt == 1 ? 2 : 1});
                }
            }
        }
        
        return DIST[R - 1][C - 1];
    }
};",1441310295
BarryBondsOfLC,BarryBondsOfLC,19,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for (int i = 0; i < num.size(); ++i) {
            (i % 2 ? o : e) += num[i] - '0';
        }
        return e == o;
    }
};",1441305906
BarryBondsOfLC,BarryBondsOfLC,19,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int MOD = 1e9 + 7;

ll mul(ll a, ll b) { return a * b % MOD; }

ll power(ll base, ll exp = MOD - 2) {
    ll res = 1, y = base;
    while (exp) {
        if (exp & 1)
            res = mul(res, y);
        y = mul(y, y);
        exp >>= 1;
    }
    return res;
}

struct Math {
    vector<ll> fact, inv;

    Math(int n = 1) {
        fact.resize(n + 1);
        inv.resize(n + 1);
        fact[0] = inv[0] = 1;
        for (int i = 1; i <= n; i++)
            fact[i] = mul(fact[i - 1], i);
        inv[n] = power(fact[n]);
        for (int i = n; i > 1; i--)
            inv[i - 1] = mul(inv[i], i);
    }

    ll comb(int n, int k) {
        if (n < k)
            return 0;
        return mul(mul(fact[n], inv[k]), inv[n - k]);
    }

    ll perm(int n, int k) {
        if (n < k)
            return 0;
        return mul(fact[n], inv[n - k]);
    }

    ll multi(vector<int> v) {
        ll res = fact[accumulate(v.begin(), v.end(), 0)];
        for (int i : v)
            res = mul(res, inv[i]);
        return res;
    }

} math(100005);

class Solution {
public:
    int countBalancedPermutations(string S) {
        int n = S.size();
        vector<int> fm(10);
        int total = 0;
        for (auto c : S) {
            ++fm[c - '0'];
            total += c - '0';
        }
        if (total % 2)
            return 0;
        int T = total / 2;
        int E = (n + 1) / 2, O = n - E;
        vector p_dp(T + 1, vector(E + 1, 0LL));
        p_dp[0][0] = 1;
        for (int d = 0; d < 10; ++d) {
            vector c_dp(T + 1, vector(E + 1, 0LL));
            for (int s = 0; s <= T; ++s) {
                for (int c = 0; c <= E; ++c) {
                    if (p_dp[s][c] == 0)
                        continue;
                    for (int k = 0; k <= fm[d] && k <= E - c && s + k * d <= T;  ++k) {
                        c_dp[s + k * d][c + k] += p_dp[s][c] * math.inv[k] % MOD * math.inv[fm[d] - k] % MOD % MOD;
                        c_dp[s + k * d][c + k] %= MOD;
                    }
                }
            }
            p_dp = move(c_dp);
        }
        return p_dp[T][E] * math.fact[E] % MOD * math.fact[O] % MOD;
    }
};",1441305590
dirigibility,dirigibility,20,3627,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,0,0)]
        visited = set()
        while True:
            t,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (i0,j0) in visited:
                continue
            visited.add((i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+1,i,j))",1441294813
dirigibility,dirigibility,20,3628,python3,"dirs = ((1,0),(0,1),(-1,0),(0,-1))
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        heap = [(0,1,0,0)]
        visited = set()
        while True:
            t,dt,i0,j0 = heappop(heap)
            if i0 == m-1 and j0 == n-1:
                return t
            if (dt,i0,j0) in visited:
                continue
            visited.add((dt,i0,j0))
            for di,dj in dirs:
                if 0 <= (i := i0+di) < m and 0 <= (j := j0+dj) < n and (3-dt,i,j) not in visited:
                    heappush(heap,(max(moveTime[i][j],t)+dt,3-dt,i,j))",1441296704
dirigibility,dirigibility,20,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])",1441281104
dirigibility,dirigibility,20,3637,python3,"mod = 10**9+7
@cache
def fac(n):
    return (n*fac(n-1))%mod if n else 1
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if (s := sum(map(int,num)))%2:
            return 0
        c = Counter(map(int,num))
        @cache
        def f(d,need,need_sum):
            if need < 0 or need_sum < 0:
                return 0
            if d == 10:
                return int(need == need_sum == 0)
            return sum(pow(fac(take)*fac(c[d]-take),-1,mod)*f(d+1,need-take,need_sum-d*take) for take in range(0,c[d]+1))%mod
        try:
            l = len(num)
            return (f(0,l//2,s//2)*fac(l//2)*fac(l-l//2))%mod
        finally:
            f.cache_clear()",1441317496
physics0523,physics0523,21,3627,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int clk=max(od.first,moveTime[nx][ny])+1;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441292885
physics0523,physics0523,21,3628,cpp,"int dx4[4]={1,-1,0,0};
int dy4[4]={0,0,1,-1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> d(n,vector<int>(m,2e9));
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;
        d[0][0]=0;
        pq.push({0,{0,0}});
        while(!pq.empty()){
            auto od=pq.top(); pq.pop();
            int x=od.second.first;
            int y=od.second.second;
            if(x==(n-1) && y==(m-1)){return od.first;}
            if(d[x][y]!=od.first){continue;}
            for(int k=0;k<4;k++){
                int nx=x+dx4[k];
                int ny=y+dy4[k];
                if(!(0<=nx && nx<n)){continue;}
                if(!(0<=ny && ny<m)){continue;}
                int dlt;
                if((x+y)%2==0){dlt=1;}
                else{dlt=2;}
                int clk=max(od.first,moveTime[nx][ny])+dlt;
                if(d[nx][ny]>clk){
                    d[nx][ny]=clk;
                    pq.push({clk,{nx,ny}});
                }
            }
        }
        return -1;
    }
};",1441295080
physics0523,physics0523,21,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int h=0;
        for(int i=0;i<num.size();i++){
            if(i%2){h+=(num[i]-'0');}
            else{h-=(num[i]-'0');}
        }
        return (h==0);
    }
};",1441281668
physics0523,physics0523,21,3637,cpp,"#define mod 1000000007

int md(int x){
    if(x>=mod){return x-mod;}
    return x;
}

int mul(long long x,long long y){
    return (x*y)%mod;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<vector<int>> nCr(105,vector<int>(105,0));
        nCr[0][0]=1;
        for(int i=1;i<105;i++){
            for(int j=0;j<=i;j++){
                if(j>0){nCr[i][j]+=nCr[i-1][j-1];}
                nCr[i][j]=md(nCr[i][j]);
                if(j<i){nCr[i][j]+=nCr[i-1][j];}
                nCr[i][j]=md(nCr[i][j]);
            }
        }
        // for(int i=0;i<5;i++){
        //     for(int j=0;j<5;j++){cout << nCr[i][j] << "" "";}
        //     cout << ""\n"";
        // }
        
        vector<int> bk(10,0);
        for(auto &nx : num){
            bk[nx-'0']++;
        }
        int rem=num.size();
        int ofs=400;
        int n=num.size();
        int x=(n+1)/2;
        int y=n/2;
        vector<vector<vector<int>>> dp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
        dp[x][y][ofs]=1;
        for(int tr=0;tr<10;tr++){
            vector<vector<vector<int>>> ndp(x+1,vector<vector<int>>(y+1,vector<int>(800,0)));
            for(int cx=0;cx<=x;cx++){
                int cy=rem-cx;
                if(!(0<=cy && cy<=y)){continue;}
                for(int i=0;i<800;i++){
                    if(dp[cx][cy][i]==0){continue;}
                    for(int sx=0;sx<=bk[tr];sx++){
                        int sy=bk[tr]-sx;
                        int nx=cx-sx;
                        int ny=cy-sy;
                        if(!(0<=nx && nx<=x)){continue;}
                        if(!(0<=ny && ny<=y)){continue;}
                        int dlt=tr*(sx-sy);
                        int mv=dp[cx][cy][i];
                        // cout << x << "" "" << y << "" "" << i << "" -> "" << nx << "" "" << ny << "" "" << i+dlt << ""\n"";
                        // cout << mv << "" "" << nCr[cx][sx] << "" "" << nCr[cy][sy] << ""\n"";
                        mv=mul(mv,nCr[cx][sx]);
                        mv=mul(mv,nCr[cy][sy]);
                        ndp[nx][ny][i+dlt]=md(ndp[nx][ny][i+dlt]+mv);
                    }
                }
            }
            rem-=bk[tr];
            dp=ndp;
        }
        
        return dp[0][0][ofs]%mod;
    }
};",1441310947
ssk4988,ssk4988,22,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, i, j = heappop(heap)
            # print(i, j, t)
            if i == n-1 and j == m-1: return t
            if (i, j) in seen: continue
            seen.add((i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, (1 + max(moveTime[i1][j1], t), i1, j1))",1441295578
ssk4988,ssk4988,22,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = []
        heappush(heap, (0, 0, 0, 0))
        ds = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        seen = set()
        while heap:
            t, p, i, j = heappop(heap)
            # print(i, j, p, t)
            if i == n-1 and j == m-1: return t
            if (p, i, j) in seen: continue
            seen.add((p, i, j))
            for dr, dc in ds:
                i1 = i + dr
                j1 = j + dc
                if 0 <= i1 < n and 0 <= j1 < m:
                    heappush(heap, ((2 if p == 1 else 1) + max(moveTime[i1][j1], t), 1-p, i1, j1))",1441298603
ssk4988,ssk4988,22,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(v) for i,v in enumerate(num) if i % 2 == 0]) == sum([int(v) for i,v in enumerate(num) if i % 2 == 1])",1441281276
ssk4988,ssk4988,22,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        freq = [0] * 10
        for d in num:
            freq[int(d)] += 1
        mod = 1000000007
        @cache
        def combmod(n, k):
            return comb(n, k) % mod
        @cache
        def dp(dig, lefteven, leftodd, evmodd):
            if dig == 10:
                return 1 if evmodd == 0 and lefteven == 0 and leftodd == 0 else 0
            ans = 0
            for toeven in range(0, 1 + min(lefteven, freq[dig])):
                toodd = freq[dig] - toeven
                if toodd > leftodd: continue
                res = dp(dig+1, lefteven - toeven, leftodd - toodd, evmodd + (toeven - toodd) * dig)
                ways = (combmod(lefteven, toeven) * combmod(leftodd, toodd)) % mod
                ans = (ans + res * ways) % mod
            return ans
        n = len(num)
        return dp(0, n // 2, n - n // 2, 0)",1441311262
Balakrishnan Varadarajan,balakrishnan_v,23,3627,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>> min_times(n,vector<int>(m,-1));
        vector<vector<bool>> done(n,vector<bool>(m,false));
        set<vector<int>> Q;
        Q.insert({0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j]) continue;
            done[i][j]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj]!=-1 && min_times[ni][nj]<=nt) continue;
                if (min_times[ni][nj]!=-1) {
                    Q.erase({min_times[ni][nj],ni,nj});
                }
                min_times[ni][nj]=nt;
                Q.insert({nt,ni,nj});
            }
        }
        return ans;
    }
};",1441317168
Balakrishnan Varadarajan,balakrishnan_v,23,3628,cpp,"
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<vector<int>>> min_times(n,vector<vector<int>>(m,vector<int>(2,-1)));
        vector<vector<vector<bool>>> done(n,vector<vector<bool>>(m,vector<bool>(2,false)));
        set<vector<int>> Q;
        Q.insert({0,0,0,0});
        int dx[]={-1,1,0,0};
        int dy[]={0,0,-1,1};
        int ans=-1;
        while(!Q.empty()) {
            auto it = Q.begin();
            int t = it->at(0);
            int i = it->at(1);
            int j = it->at(2);
            int p = it->at(3);
            Q.erase(it);
            if (i==n-1 && j==m-1) {
                if (ans==-1 || ans>t) ans=t;
            }
            if (done[i][j][p]) continue;
            done[i][j][p]=true;
            for(int k=0;k<4;k++) {
                int ni=i+dx[k];
                int nj=j+dy[k];
                if (ni<0||ni>=n||nj<0||nj>=m) continue;
                int nt = 1+p+max(t,moveTime[ni][nj]);
                if (min_times[ni][nj][1-p]!=-1 && min_times[ni][nj][1-p]<=nt) continue;
                if (min_times[ni][nj][1-p]!=-1) {
                    Q.erase({min_times[ni][nj][1-p],ni,nj,1-p});
                }
                min_times[ni][nj][1-p]=nt;
                Q.insert({nt,ni,nj,1-p});
            }
        }
        return ans;
    }
};",1441314130
Balakrishnan Varadarajan,balakrishnan_v,23,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0=0;
        int s1=0;
        int n=num.size();
        for(int i=0;i<n;i++) {
            int d=num[i]-'0';
            if (i%2==0) s0+=d;
            else s1+=d;
        }
        return s0==s1;
    }
};",1441318653
Balakrishnan Varadarajan,balakrishnan_v,23,3637,cpp,"#define MODD 1000000007
#define NUM_DIGS 10
#define MAXN 80
#define ll long long
class Solution {
public:
    
    ll fact[MAXN+2];
    ll factinv[MAXN+2];
    
    int dp[NUM_DIGS+1][MAXN+2][MAXN*9];
    
    int Solve(const vector<int>& counts, int d, int num_even_left, int sum_even_left) {
        if (d==NUM_DIGS) {
            return num_even_left==0 && sum_even_left==0;
        }
        
        if (dp[d][num_even_left][sum_even_left]!=-1) return dp[d][num_even_left][sum_even_left];
        
        ll ans = 0;
        for(int x=0;x<=min(num_even_left,counts[d]);x++) {
            if (sum_even_left-x*d<0) break;
            ans += Solve(counts, d+1, num_even_left-x,sum_even_left-x*d) * factinv[x]%MODD*factinv[counts[d]-x]%MODD;
            ans %= MODD;
        }
        return dp[d][num_even_left][sum_even_left]=ans;
    }
    
    ll modpow(ll x, ll y) {
        ll xs = x;
        ll answer = 1;
        while(y) {
            if (y&1) {
                answer = (answer * xs) % MODD;
            }
            y >>= 1;
            xs = (xs * xs) % MODD;
        }
        return answer;
    }

    

    int countBalancedPermutations(string num) {
        
        
        int n=num.size();
        fact[0]=factinv[0]=1;
        for(int i=1;i<=n;i++) {
            fact[i]=fact[i-1]*i%MODD;
            factinv[i]=modpow(fact[i],MODD-2);
        }
        vector<int> counts(10,0);
        int s=0;
        for(char c : num) {
            counts[c-'0']++;
            s += c-'0';
        }
        if (s&1) return 0;
        
        int num_odd_pos=0;
        int num_even_pos=0;
        for(int i=0;i<n;i++) {
            if (i%2) num_odd_pos++;
            else num_even_pos++;
        }
        
        for(int d=0;d<=NUM_DIGS;d++) {
            for(int num_even_left=0;num_even_left<=num_even_pos;num_even_left++) {
                for(int sum_even_left=0;sum_even_left<=s/2;sum_even_left++) {
                    dp[d][num_even_left][sum_even_left]=-1;
                }
            }
        }
        
        ll ans = Solve(counts, 0, num_even_pos, s/2);
        ans = ans*fact[num_odd_pos]%MODD*fact[num_even_pos]%MODD;
        
        // split each digit
        
        return ans;
        
    }
};",1441298327
leetgoat_dot_dev,leetgoat_dot_dev,26,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c to min time
        heap = [(0, 0, 0)] # time, r, c
        while heap:
            time, r, c = heapq.heappop(heap)
            if minDists[(r, c)] <= time:
                continue
            minDists[(r, c)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newTime = max(time + 1, moveTime[newR][newC] + 1)
                if newTime >= minDists[(newR, newC)]:
                    continue
                heapq.heappush(heap, (newTime, newR, newC))
        return minDists[(len(moveTime) - 1, len(moveTime[0]) - 1)]
            ",1441293052
leetgoat_dot_dev,leetgoat_dot_dev,26,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        minDists = defaultdict(lambda: inf) # maps r, c, parity to min time
        heap = [(0, 0, 0, 0)] # time, r, c, parity
        while heap:
            time, r, c, parity = heapq.heappop(heap)
            if minDists[(r, c, parity)] <= time:
                continue
            minDists[(r, c, parity)] = time
            for rDiff, cDiff in [[1,0],[-1,0],[0,1],[0,-1]]:
                newR, newC = r + rDiff, c + cDiff
                if newR < 0 or newR == len(moveTime) or newC < 0 or newC == len(moveTime[0]):
                    continue
                newDelta = 1 if parity == 0 else 2
                newTime = max(time + newDelta, moveTime[newR][newC] + newDelta)
                # if newTime >= minDists[(newR, newC)]:
                #     continue
                heapq.heappush(heap, (newTime, newR, newC, parity^1))
        return min(
            minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 0)],
             minDists[(len(moveTime) - 1, len(moveTime[0]) - 1, 1)],
        )
            ",1441295559
leetgoat_dot_dev,leetgoat_dot_dev,26,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i in range(len(num)):
            if i % 2 == 0:
                evens += int(num[i])
            else:
                odds += int(num[i])
        return evens == odds",1441280912
leetgoat_dot_dev,leetgoat_dot_dev,26,3637,python3,"# template by: https://github.com/agrawalishaan/leetcode

# n in the constructor is basically the biggest number we will operate on. So for instance finding n! % MOD. But also things like interleaving two sequences of length 500 and length 700 would require n=1200. To be safe, can always just put a big number like 1e5.
class ModCalc:
    def __init__(self, n, primeMod):
        self.n = n
        self.mod = primeMod # If this is not prime, anything using modInv may break (fermat's little theorem)
        # O(n) time to build a factorial mod array
        self.factorialsWithMod = self._buildFactorialsWithMod()
        # O(n) time to build an inverse factorial mod array
        self.inverseFactorialsWithMod = self._buildInverseFactorialsWithMod()

    # ********** STUFF WITH FACTORIALS **********

    # O(n) time to build a factorial mod array
    def _buildFactorialsWithMod(self):
        factorialsWithMod = [1] # 0 factorial is 1
        for factorial in range(1, self.n + 1):
            factorialsWithMod.append(factorialsWithMod[-1] * factorial % self.mod)
        return factorialsWithMod

    # O(n) time to build an inverse factorial mod array
    def _buildInverseFactorialsWithMod(self):
        inverseFactorialsWithMod = [1] * (self.n + 1)
        inverseFactorialsWithMod[self.n] = self.modInv(self.factorialsWithMod[self.n])
        for i in range(self.n - 1, 0, -1):
            inverseFactorialsWithMod[i] = inverseFactorialsWithMod[i + 1] * (i + 1) % self.mod
        return inverseFactorialsWithMod

    # Gets (x! % MOD)
    # O(1) time
    def getFactorialWithMod(self, factorial):
        return self.factorialsWithMod[factorial]

    # Gets (1/x! % MOD)
    # O(1) time
    def getInverseFactorialWithMod(self, inverseFactorial):
        return self.inverseFactorialsWithMod[inverseFactorial]

    # Given two sequences of length X and Y, such as ""123"" and ""4567"", find the # of ways to interleave them.  Note we don't care about the actual items in each sequence, we just care about the # of ways we can interleave the two. We don't even get the actual sequences themselves, just their lengths.
    # O(1) time
    def interleaveTwoSequencesWithMod(self, length1, length2):
        # Interleaving a sequence of length 3 and 4 would be like 7!/(3!4!), which is 7! * (1/3!) * (1/4!)
        combinedLength = length1 + length2
        if combinedLength >= len(self.factorialsWithMod):
            raise ValueError(f""To interleave {length1} and {length2} items, we need at least {combinedLength + 1} items in the factorial array."")
        numerator = self.getFactorialWithMod(combinedLength)
        denominator1 = self.getInverseFactorialWithMod(length1)
        denominator2 = self.getInverseFactorialWithMod(length2)
        return self.modMultiply(numerator, denominator1, denominator2)


    # Calculates the # of ways to select k items from n unique items. Order does not matter.
    # Formula for C(n, k) = n! / (k!(n-k)!)
    # Denominator is 1/k! * 1/(n-k)!
    # O(1) time
    def nChooseKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator1 = self.getInverseFactorialWithMod(k)
        denominator2 = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator1, denominator2)

    # Calculates the # of ways to select k items from n unique items. Order matters.
    # Formula for P(n, k) = n! / (n-k)!
    # Denominator is 1/(n-k)!
    # O(1) time
    def nPermuteKWithMod(self, n, k):
        if k > n:
            return 0
        numerator = self.getFactorialWithMod(n)
        denominator = self.getInverseFactorialWithMod(n - k)
        return self.modMultiply(numerator, denominator)

    # Calculate the # of ways to distribute n identical items into k distinct buckets (relates to stars and bars)
    # Formula for allowing empty buckets is C(n+k-1, k-1), which is: (n+k-1)! * 1/(n-1)! * 1/k!
    # Formula for NOT allowing empty buckets is C(n-1, k-1), which is: (n-1)! * 1/(n-k)! * 1/k!
    # O(1) time
    def waysToPutIdenticalItemsIntoDistinctBucketsWithMod(self, items, buckets, allowEmptyBuckets=True):
        if allowEmptyBuckets:
            return self.nChooseKWithMod(items + buckets - 1, buckets - 1)
        return self.nChooseKWithMod(items - 1, buckets - 1)

    # Putting n distinct items into k distinct buckets is just k options for the first item, k for the second, etc, so k^n. This is if we allow empty buckets. If we don't allow empty buckets, we need Stirling numbers of the second kind.
    # O(log items) time due to modPow, but modPow can be cached
    def waysToPutDistinctItemsIntoDistinctBucketsAllowingEmptyWithMod(self, items, buckets):
        return self.modPow(buckets, items)

    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        # need to figure out how to do this in O(1) if it is possible lol
        pass

    # ********** NO FACTORIALS NEEDED **********

    # Multiples k numbers together
    # O(k) time
    def modMultiply(self, *args):
        result = 1
        for num in args:
            result = (result * num) % self.mod
        return result

    # Calculates base^exponent % MOD
    # Can add caching if we are using the same base a lot. But if we are using one instance of the ModCalc class across all test cases, maybe that would MLE? I think no cache by default is better, since it is very fast already.
    # O(log exponent) time (even without caching)
    # @cache # uncomment to cache
    def modPow(self, base, exponent):
        return pow(base, exponent, self.mod)

    # Gets 1/x % MOD
    # Could cache this, if we are calling the same range of numbers a lot. If this class is created once across all test cases, could maybe MLE? Also num needs to be coprime to MOD.
    # O(log MOD) time
    # @cache # uncomment to cache
    def modInv(self, num):
        return self.modPow(num, self.mod - 2)


class MoreAdvancedStirlingStuff:
    def __init__(self, maxPossibleDistinctItemCount, maxPossibleBucketCount, mod):
        self.maxPossibleDistinctItemCount = maxPossibleDistinctItemCount
        self.maxPossibleBucketCount = maxPossibleBucketCount
        self.mod = mod

        # # Build a basic modCalc so we can get factorial mods
        self.modCalc = ModCalc(maxPossibleBucketCount, mod)

        # O(maxPossibleDistinctItemCount * maxPossibleBucketCount) build time
        self.stirling2Dp = self._buildStirling2Dp()

    def _buildStirling2Dp(self):
        dp = [[0] * (self.maxPossibleBucketCount + 1) for _ in range(self.maxPossibleDistinctItemCount + 1)]
        dp[0][0] = 1
        for i in range(1, self.maxPossibleDistinctItemCount + 1):
            for j in range(1, self.maxPossibleBucketCount + 1):
                dp[i][j] = (dp[i - 1][j - 1] + j * dp[i - 1][j]) % self.mod
        return dp

    # Calculate the # of ways to distribute n distinct items into k identical non-empty buckets. For instance with items 'A' and 'B' and 2 buckets, there's only one way, since the buckets are identical.
    # This is stirling2 numbers.
    # O(1) time
    def waysToPutDistinctItemsIntoIdenticalNonemptyBucketsWithMod(self, items, buckets):
        return self.stirling2Dp[items][buckets]

    # Calculate the # of ways to distribute n distinct items into k distinct non-empty buckets.
    # O(1) time
    def waysToPutDistinctItemsIntoDistinctNonemptyBucketsWithMod(self, items, buckets):
        waysAssumingIdenticalBuckets = self.stirling2Dp[items][buckets]
        bucketOrderings = self.modCalc.getFactorialWithMod(buckets)
        return self.modCalc.modMultiply(waysAssumingIdenticalBuckets, bucketOrderings)

    
calc = ModCalc(10000, 10**9 + 7)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        c = Counter(int(l) for l in num)
        
        evens = len(num) // 2
        odds = len(num) - evens
        
        M = 10**9 + 7
        
        @cache
        def dp(digit, evenSurplus, evensUsed, oddsUsed):
            if digit == 10:
                return 1 if not evenSurplus else 0
            
            resHere = 0
            for distributeToOdds in range(c[digit] + 1):
                newOdds = oddsUsed + distributeToOdds
                if newOdds > odds:
                    break
                distributeToEvens = c[digit] - distributeToOdds
                newEvens = evensUsed + distributeToEvens
                if newEvens > evens:
                    continue
                oddGain = distributeToOdds * digit
                evenGain = distributeToEvens * digit
                evenNet = evenGain - oddGain
                
                oddSpotsLeft = odds - oddsUsed
                evenSpotsLeft = evens - evensUsed
                
                waysToDistributeOdds = calc.nChooseKWithMod(oddSpotsLeft, distributeToOdds)
                waysToDistEvens = calc.nChooseKWithMod(evenSpotsLeft, distributeToEvens)
                resHere += calc.modMultiply(dp(digit + 1, evenSurplus + evenNet, newEvens, newOdds), waysToDistributeOdds, waysToDistEvens)
            return resHere % M
        
        a = dp(0,0,0,0)
        dp.cache_clear()
        return a
            
            
            ",1441306558
Chinnu,chinnu11,27,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&t){
        int n=t.size(),m=t[0].size();
        vector<pair<int,int>>d={{-1,0},{1,0},{0,-1},{0,1}};
        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));
        dist[0][0]=0;
        
        priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<>>q;
        q.emplace(0,0,0);
        
        while(!q.empty()){
            auto[ct,i,j]=q.top();q.pop();
            if(i==n-1&&j==m-1)return ct;
            if(ct>dist[i][j])continue;
            
            for(auto[di,dj]:d){
                int ni=i+di,nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m){
                    int ns=max(ct,t[ni][nj]);
                    int at=ns+1;
                    if(at<dist[ni][nj]){
                        dist[ni][nj]=at;
                        q.emplace(at,ni,nj);
                    }
                }
            }
        }
        return -1;
    }
};",1441287083
Chinnu,chinnu11,27,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n=t.size(), m=t[0].size();
        vector<pair<int,int>> d={{-1,0},{1,0},{0,-1},{0,1}};
        const int inf=INT_MAX;
        vector<int> dist(n*m*2,inf);
        dist[0]=0;
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>> q;
        q.emplace(0,0);
        
        while(!q.empty()) {
            auto [c,s]=q.top(); q.pop();
            int p=s%2, pos=s/2, i=pos/m, j=pos%m;
            if(i==n-1&&j==m-1) return c;
            if(c>dist[s]) continue;
            
            for(auto &[di,dj]:d) {
                int ni=i+di, nj=j+dj;
                if(ni>=0&&ni<n&&nj>=0&&nj<m) {
                    int st=max(c,t[ni][nj]), dur=p==0?1:2, nt=st+dur, np=1-p;
                    int ns=(ni*m+nj)*2+np;
                    if(nt<dist[ns]) {
                        dist[ns]=nt;
                        q.emplace(nt,ns);
                    }
                }
            }
        }
        return -1;
    }
};",1441290452
Chinnu,chinnu11,27,3636,cpp,"class Solution{
public:
    bool isBalanced(string n){
        int e=0,o=0;
        for(int i=0;i<n.size();++i){
            int d=n[i]-'0';
            if(i%2==0)e+=d;
            else o+=d;
        }
        return e==o;
    }
};
",1441281159
Chinnu,chinnu11,27,3637,cpp,"typedef long long ll;
const int M=1'000'000'007;

ll pmod(ll x,ll y,ll m){
    ll r=1;
    x%=m;
    while(y>0){
        if(y&1)r=r*x%m;
        x=x*x%m;
        y>>=1;
    }
    return r;
}

ll inv(ll x,ll m){
    return pmod(x,m-2,m);
}

int cBalPerms(string num){
    int n=num.size();
    vector<ll>f(n+1,1),invf(n+1,1);
    for(int i=1;i<=n;i++)f[i]=f[i-1]*i%M;
    invf[n]=inv(f[n],M);
    for(int i=n-1;i>=0;i--)invf[i]=invf[i+1]*(i+1)%M;

    int fr[10]={0};
    ll ts=0;
    for(char c:num)fr[c-'0']++,ts+=(c-'0');
    if(ts%2!=0)return 0;
    ll tgt=ts/2;
    int k=(n+1)/2,m=n-k;

    vector<vector<ll>>dp(tgt+1,vector<ll>(k+1,0));
    dp[0][0]=1;

    for(int d=0;d<=9;d++){
        if(fr[d]==0)continue;
        vector<vector<ll>>d2(tgt+1,vector<ll>(k+1,0));
        for(int s=0;s<=tgt;s++){
            for(int c=0;c<=k;c++){
                if(dp[s][c]==0)continue;
                for(int a=0;a<=fr[d]&&a+c<=k;a++){
                    if(s+d*a>tgt)break;
                    ll comb=f[fr[d]]*invf[a]%M*invf[fr[d]-a]%M;
                    d2[s+d*a][c+a]=(d2[s+d*a][c+a]+dp[s][c]*comb)%M;
                }
            }
        }
        dp=d2;
    }

    ll assign=dp[tgt][k];
    if(assign==0)return 0;

    ll prod_f=1;
    for(int d=0;d<=9;d++)prod_f=prod_f*f[fr[d]]%M;

    ll fk=f[k],fm=f[m],invp=inv(prod_f,M);
    ll tot=assign*fk%M*fm%M*invp%M;

    return (int)tot;
}

class Solution{
public:
    int countBalancedPermutations(string num){
        return cBalPerms(num);
    }
};
",1441313189
Larry,LarryNY,28,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + 1:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + 1
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441290449
Larry,LarryNY,28,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R = len(moveTime)
        C = len(moveTime[0])
        INF = 10 ** 20
        
        h = []
        best = [[INF] * C for _ in range(R)]
        best[0][0] = 0

        heapq.heappush(h, (0, 0, 0))

        directions = [
            (0, 1), (1, 0), (-1, 0), (0, -1),
        ]
        
        while len(h) > 0:
            d, x, y = heapq.heappop(h)
            
            if best[x][y] < d:
                continue
                
            if x == R - 1 and y == C - 1:
                break
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                p = 2 - ((nx + ny) % 2)
                
                if 0 <= nx < R and 0 <= ny < C and best[nx][ny] > max(d, moveTime[nx][ny]) + p:
                    best[nx][ny] = max(d, moveTime[nx][ny]) + p
                    heapq.heappush(h, (best[nx][ny], nx, ny))
                    
        return best[R - 1][C - 1]                ",1441293459
Larry,LarryNY,28,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        N = len(num)
        
        a = [0] * 2
        for i in range(N):
            a[i % 2] += int(num[i])
            
        return a[0] == a[1]",1441280862
Larry,LarryNY,28,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        arr = [int(x) for x in num]
        N = len(arr)
        f = [0] * 10
        for x in arr:
            f[x] += 1

        fact = [1]
        ifact = [pow(1, -1, MOD)]
        for i in range(1, N + 1):
            fact.append((fact[-1] * i) % MOD)
            ifact.append(pow(fact[-1], -1, MOD))

        numer = 1
        if N % 2 == 0:
            numer = (fact[(N // 2)] * fact[(N // 2)]) % MOD
        else:
            numer = (fact[((N + 1) // 2)] * fact[(N // 2)]) % MOD
            
        @cache
        def go(index, delta_count, delta_sum):
            if index == len(f):
                if delta_sum != 0:
                    return 0

                if N % 2 == 0:
                    if delta_count != 0:
                        return 0
                    return 1
                else:
                    if delta_count == 1:
                        return 1
                    return 0
        
            total = 0
            for i in range(f[index] + 1):
                left = i
                right = f[index] - i
                total += go(index + 1, delta_count + (left - right), delta_sum + (left - right) * index) * ifact[left] * ifact[right]
                total %= MOD
            return total % MOD
        
        return (go(0, 0, 0) * numer) % MOD",1441320693
Nguyễn Thảo,nguyenquocthao00,30,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + 1, i2,j2))
            
        ",1441292016
Nguyễn Thảo,nguyenquocthao00,30,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime), len(moveTime[0])
        def nb(i,j):
            for i2,j2 in ((i+1,j),(i-1,j),(i,j+1),(i,j-1)):
                if 0<=i2<m and 0<=j2<n: yield i2,j2
        marked=[[False]*n for _ in range(m)]
        h=[(0,0,0)]
        while h:
            t,i,j = heappop(h)
            if marked[i][j]: continue
            marked[i][j]=True
            if i==m-1 and j==n-1: return t
            added = 1 if (i+j)%2==0 else 2
            for i2,j2 in nb(i,j):
                heappush(h, (max(moveTime[i2][j2], t) + added, i2,j2))
            
        
        ",1441294941
Nguyễn Thảo,nguyenquocthao00,30,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x,y = 0,0
        for i,ch in enumerate(num):
            if i%2==0: x+=int(ch)
            else: y+=int(ch)
        return x==y
        ",1441281098
Nguyễn Thảo,nguyenquocthao00,30,3637,python3,"MOD = 10**9 + 7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        count=[0]*10
        for ch in num: count[int(ch)]+=1
        s= sum(i*v for i,v in enumerate(count))
        if s%2==1: return 0
        # target=s//2
        @lru_cache(None)
        def dp(v,n,t):
            if v<0: return 0 if (n!=0 or t!=0) else 1
            if count[v]==0: return dp(v-1,n,t)
            n2,s2 = len(num)-n, s-t
            for v2 in range(9, v,-1):
                n2-=count[v2]
                s2-=count[v2]*v2
            if n<0 or t<0 or n2<0 or s2<0: return 0
            res=0
            for i in range(count[v]+1):
                res += math.comb(n, i) * math.comb(n2, count[v]-i) * dp(v-1, n-i, t-i*v)
            return res%MOD
        return dp(9, len(num)//2, s//2)
            
        ",1441321719
hxu10,hxu10,31,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                newt = max(t, moveTime[newi][newj]) + 1
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]
            
        
        
        ",1441293045
hxu10,hxu10,31,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        heap = []
        m = len(moveTime)
        n = len(moveTime[0])
        
        inf = 10**10
        
        
        dp = [[inf for _ in range(n)] for _ in range(m)]
        direc = [[0,1],[0,-1],[1,0],[-1,0]]
        
        
        heapq.heappush(heap,(0,0,0))
        
        while heap:
           # print(heap)
            ele = heapq.heappop(heap)
            (t,i,j) = ele
            if dp[i][j] <= t:  continue 
                
            dp[i][j] = t
            
            for d in range(4):
                newi = i + direc[d][0]
                newj = j + direc[d][1]
                if newi < 0 or newi >= m or newj < 0 or newj >= n:  continue 
                    
                
                newt = max(t, moveTime[newi][newj]) + 2 - (i+j+1) % 2 
                if dp[newi][newj] <= newt:  continue 
                heapq.heappush(heap, (newt,newi,newj))
                
        return dp[m-1][n-1]",1441298013
hxu10,hxu10,31,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s1 = num[::2]
        s2 = num[1::2]
        
        tot1 = 0
        for c in s1:
            tot1 += int(c)
            
        tot2 = 0
        for c in s2:
            tot2 += int(c)
            
        return tot1==tot2
    ",1441281054
hxu10,hxu10,31,3637,python,"

M = 10**9 + 7

def fastfrac(a,b):
    numb = pow(b,M-2,M)
    return ((a%M)*(numb%M))%M


factor = [1]
invfactor = [1]

for _ in range(100):
    factor.append(factor[-1]*len(factor)%M)
    invfactor.append(fastfrac(1,factor[-1])%M)
    

                     
    
    
    
    
    
    

class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        
        
        fre = [0]*10
        
        s = 0
        
        for c in num:
            fre[int(c)] += 1
            s += int(c) 
            
            
        if s%2==1:
            return 0
        
        

        
        
        
            
            
            
        target = len(num) // 2
        
        tsum = s // 2
        
        
    
        
        
        dic = {}
        
        def getnext(index,totc,totnum):
            
            
            if index==10:
                if totc==target and totnum==tsum:
                    return 1
                return 0
            
            if totc > target or totnum > tsum:
                return 0
            
            
            #print(index,totc,totnum)
            
            if (index,totc,totnum) in dic:  
                return dic[(index,totc,totnum)]
            
            
            res = 0
            for d in range(fre[index]+1):
                xi = invfactor[d] * invfactor[fre[index]-d] 
                res += getnext(index+1, totc+d, totnum+d*index) * xi % M
                res %= M
                
            dic[(index,totc,totnum)] = res
            return res
        
        ans = getnext(0,0,0) * factor[target] * factor[len(num)-target] % M
        
        
        

        
        return ans 
                
            
             
            
            
        
                
            
            
            ",1441322214
kzyKT,kzyKT,32,3627,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<ll,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m];
    rep(i,n)rep(j,m) d[i][j]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(0,P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F;
      if(d[x][y]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+1;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1);
          if(d[xx][yy]>cc) {
            d[xx][yy]=cc;
            que.push(PP(cc,P(xx,yy)));
          }
        }
      }
    }
    return d[n-1][m-1];
  }
};
",1441291418
kzyKT,kzyKT,32,3628,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;
typedef pair<P,P> PP;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& a) {
    ll n=a.size(),m=a[0].size();
    ll d[n][m][2];
    rep(i,n)rep(j,m)rep(k,2) d[i][j][k]=MAXL;
    priority_queue<PP,vector<PP>,greater<PP> > que;
    que.push(PP(P(0,0),P(0,0)));
    while(!que.empty()) {
      PP p=que.top();que.pop();
      ll x=p.S.F,y=p.S.S,c=p.F.F,k=p.F.S;
      if(d[x][y][k]<c) continue;
      rep(i,4) {
        ll xx=x+dx[i],yy=y+dy[i],cc=c+k+1,kk=(k+1)%2;
        if(check(n,m,xx,yy)) {
          cc=max(cc,(ll)a[xx][yy]+1+k);
          if(d[xx][yy][kk]>cc) {
            d[xx][yy][kk]=cc;
            que.push(PP(P(cc,kk),P(xx,yy)));
          }
        }
      }
    }
    return min(d[n-1][m-1][0],d[n-1][m-1][1]);
  }
};
",1441293902
kzyKT,kzyKT,32,3636,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;

class Solution {
public:
  bool isBalanced(string s) {
    ll c[2];mem(c);
    rep(i,s.size()) c[i%2]+=s[i]-'0';
    return c[0]==c[1];
  }
};
",1441281289
kzyKT,kzyKT,32,3637,cpp,"#define F first
#define S second
#define R cin>>
#define ll long long
#define ln cout<<'\n'
#define in(a) insert(a)
#define pb(a) push_back(a)
#define pd(a) printf(""%.10f\n"",a)
#define mem(a) memset(a,0,sizeof(a))
#define all(c) (c).begin(),(c).end()
#define iter(c) __typeof((c).begin())
#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)
#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)
#define rep(i,n) REP(i,0,n)
#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)
ll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}void pr(){ln;}
template<class A,class...B>void pr(const A &a,const B&...b){cout<<a<<(sizeof...(b)?"" "":"""");pr(b...);}
template<class A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}
const ll MAX=1e9+7,MAXL=1LL<<61,dx[8]={0,-1,0,1,-1,-1,1,1},dy[8]={-1,0,1,0,-1,1,1,-1};
typedef pair<ll,ll> P;


void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;r0=x;r1=y;a0=1;a1=0;b0=0;b1=1;
  while(r1>0){q=r0/r1;r2=r0%r1;a2=a0-q*a1;b2=b0-q*b1;r0=r1;r1=r2;a0=a1;a1=a2;b0=b1;b1=b2;}
  *c=r0;*a=a0;*b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll fact[2100],fact_inv[2100];

void init() {
  fact[0]=1;
  REP(i,1,2100) fact[i]=fact[i-1]*i%MAX;
  fact_inv[2050]=get_inv(fact[2050],MAX);
  rrep(i,2050)fact_inv[i]=fact_inv[i+1]*(i+1)%MAX;
}

ll nCr(ll N,ll K){
  if(K<0||K>N)return 0;
  return fact[N]*fact_inv[K]%MAX*fact_inv[N-K]%MAX;
}

ll dp[11][44][444];
class Solution {
public:
  int countBalancedPermutations(string s) {
    init();
    ll n=s.size();
    ll c[26],sum=0;
    mem(c);
    rep(i,n) c[s[i]-'0']++;
    rep(i,10) sum+=i*c[i];
    if(sum%2) return 0;
    ll n1=n/2+n%2,n2=n/2,e=0;
    rep(i,11)rep(j,n1+1)rep(k,400) dp[i][j][k]=0;
    dp[0][0][0]=1;
    rep(i,10) {
      rep(j,n1+1) {
        rep(k,400) {
          rep(l,c[i]+1) {
            if(j+l>n1||k+l*i>400) break;
            ll nn=e-j;
            if(n2-nn<0) continue;
            dp[i+1][j+l][k+l*i]+=dp[i][j][k]*nCr(n1-j,l)%MAX*nCr(n2-nn,c[i]-l);
            dp[i+1][j+l][k+l*i]%=MAX;
          }
        }
      }
      e+=c[i];
    }
    return dp[10][n1][sum/2];
  }
};",1441309238
nimish7866,nimish7866,33,3627,cpp,"
    
    class Solution {
public:


int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = moveTime.size();
        int m = moveTime[0].size();
        

        vector<pair<int, int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        

        vector<vector<long long>> arrival(n, vector<long long>(m, LLONG_MAX));
        arrival[0][0] = 0; 
        

        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>, 
                      greater<>> pq;
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            auto [currentTime, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            

            if (currentTime > arrival[row][col]) continue;
            

            for (const auto& [dx, dy] : directions) {
                int newRow = row + dx;
                int newCol = col + dy;
                

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {

                    long long nextTime = max(currentTime, (long long)moveTime[newRow][newCol]);
                    nextTime += 1;  
                    

                    if (nextTime < arrival[newRow][newCol]) {
                        arrival[newRow][newCol] = nextTime;
                        pq.push({nextTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return (int)arrival[n-1][m-1];
}
    };
        
    
",1441297861
nimish7866,nimish7866,33,3628,cpp,"class Solution {
public:
    typedef pair<long long, pair<int, int>> P;

    long long minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        vector<pair<int, int>> dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        vector<vector<vector<long long>>> dp(n, vector<vector<long long>>(m, vector<long long>(2, LLONG_MAX)));

        dp[0][0][0] = 0;

        priority_queue<pair<long long, tuple<int, int, int>>, vector<pair<long long, tuple<int, int, int>>>, greater<>> pq;
        pq.push({0, {0, 0, 0}});

        while (!pq.empty()) {
            auto [curT, state] = pq.top();
            auto [r, c, mv] = state;
            pq.pop();

            if (curT > dp[r][c][mv % 2]) continue;

            for (const auto& [dx, dy] : dir) {
                int nr = r + dx;
                int nc = c + dy;

                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int mvTime = (mv % 2 == 0) ? 1 : 2;
                    long long nextT = max(curT, (long long)mt[nr][nc]);
                    nextT += mvTime;

                    if (nextT < dp[nr][nc][(mv + 1) % 2]) {
                        dp[nr][nc][(mv + 1) % 2] = nextT;
                        pq.push({nextT, {nr, nc, (mv + 1) % 2}});
                    }
                }
            }
        }

        return (int)min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441300894
nimish7866,nimish7866,33,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

    for (size_t i = 0; i < num.length(); ++i) {
        int digit = num[i] - '0';  
        if (i % 2 == 0) {
            es += digit;  
        } else {
            os += digit;  
        }
    }

    return es == os;
    }
};",1441281030
nimish7866,nimish7866,33,3637,cpp,"using ll = long long;
using vll = vector<ll>;
using vvll = vector<vll>; 

class Solution {
public:
    const int MOD = 1'000'000'007; 

    int countBalancedPermutations(string n) {
        int L = n.size();
        int E = (L + 1) / 2;
        int O = L / 2;

        string v = n;
        int cnt[10] = {0};
        countDigits(n, cnt);

        ll total = calcTotal(cnt);
        if (total % 2 != 0) return 0;

        ll target = total / 2;

        vll fact = preFact();
        vll invFact = preInvFact(fact);

        vvll dp = initDP(E, target); 
        fillDP(dp, cnt, fact, invFact, E, target); 

        return calcAns(dp, E, target, cnt, L); 
    }

private:
    void countDigits(const string& n, int* cnt) {
        for (char ch : n) cnt[ch - '0']++;
    }

    ll calcTotal(int* cnt) {
        ll sum = 0;
        for (int d = 0; d < 10; d++) {
            sum += (ll)d * cnt[d];
        }
        return sum;
    }

    vll preFact() {
        const int MAX = 80;
        vll fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        return fact;
    }

    vll preInvFact(const vll& fact) {
        const int MAX = 80;
        vll invFact(MAX + 1, 1);
        invFact[MAX] = power(fact[MAX], MOD - 2, MOD);
        for (int i = MAX - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
        return invFact;
    }

    ll comb(int a, int b, const vll& fact, const vll& invFact) {
        if (b > a) return 0;
        return fact[a] * invFact[b] % MOD * invFact[a - b] % MOD;
    }

    vvll initDP(int E, ll target) {
        vvll dp(E + 1, vll(target + 1, 0));
        dp[0][0] = 1;
        return dp;
    }

    void fillDP(vvll& dp, int* cnt, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            updateDP(dp, cnt[d], d, fact, invFact, E, target); 
        }
    }

    void updateDP(vvll& dp, int digitCount, int digit, const vll& fact, const vll& invFact, int E, ll target) { 
        for (int t = E; t >= 0; t--) {
            for (ll s = target; s >= 0; s--) {
                if (dp[t][s] == 0) continue;
                for (int k = 1; k <= digitCount && t + k <= E && s + (ll)digit * k <= target; k++) {
                    dp[t + k][s + (ll)digit * k] = (dp[t + k][s + (ll)digit * k] + dp[t][s] * comb(digitCount, k, fact, invFact)) % MOD;
                }
            }
        }
    }

    int calcAns(const vvll& dp, int E, ll target, int* cnt, int L) { 
        ll valid = dp[E][target];
        ll prodFact = calcProductFact(cnt);
        ll ans = (valid * preFact()[E] % MOD * preFact()[L / 2] % MOD) * power(prodFact, MOD - 2, MOD) % MOD;
        return (int)ans;
    }

    ll calcProductFact(int* cnt) {
        ll prodFact = 1;
        for (int d = 0; d < 10; d++) {
            prodFact = prodFact * preFact()[cnt[d]] % MOD;
        }
        return prodFact;
    }

    ll power(ll b, ll e, ll m) {
        ll r = 1; 
        b %= m;
        while (e > 0) {
            if (e & 1) r = r * b % m;
            b = b * b % m; 
            e >>= 1;
        }
        return r;
    }
};",1441316156
Zejun Wu,watashi,34,3627,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 1;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441293776
Zejun Wu,watashi,34,3628,cpp,"class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    static constexpr int INF = 1900000007;
    static constexpr int DX[] = { 0, 1, 0, -1 };
    static constexpr int DY[] = { 1, 0, -1, 0 };

    const int n = moveTime.size();
    const int m = moveTime[0].size();
    vector<vector<int>> d(n, vector<int>(m, INF));
    priority_queue<pair<int, pair<int, int>>> pq;
    d[0][0] = 0;
    pq.emplace(0, make_pair(0, 0));
    while (!pq.empty()) {
      int z, x, y;
      tie(x, y) = pq.top().second;
      z = -pq.top().first;
      pq.pop();
      if (d[x][y] < z) {
        continue;
      }
      for (int k = 0; k < 4; ++k) {
        int xx = x + DX[k];
        int yy = y + DY[k];
        if (xx < 0 || xx >= n || yy < 0 || yy >= m) {
          continue;
        }
        int zz = max(z, moveTime[xx][yy]) + 2 - (xx + yy) % 2;
        if (d[xx][yy] > zz) {
          d[xx][yy] = zz;
          pq.emplace(-zz, make_pair(xx, yy));
        }
      }
    }
    return d[n - 1][m - 1];
  }
};",1441298622
Zejun Wu,watashi,34,3636,cpp,"class Solution {
public:
  bool isBalanced(string num) {
    int s = 0, f = 1;
    for (char c : num) {
      s += (c - '0') * f;
      f *= -1;
    }
    return s == 0;
  }
};",1441281479
Zejun Wu,watashi,34,3637,cpp,"class Solution {
  static constexpr int64_t MOD = 1000000007;

  // a * x + b * y = gcd(a, b) >= 0
  long long extGcd(long long a, long long b, long long& x, long long& y) {
    if (b == 0) {
      x = a >= 0 ? 1 : -1;
      y = 0;
      return abs(a);
    }
    else {
      int g = extGcd(b, a % b, y, x);
      y -= a / b * x;
      return g;
    }
  }

  // ASSUME: gcd(a, m) == 1
  long long modInv(long long a, long long m) {
    long long x, y;
    extGcd(a, m, x, y);
    return (x % m + m) % m;
  }

public:
  int countBalancedPermutations(string num) {
    vector<int64_t> fac(800), inv(800);
    fac[0] = inv[0] = 1;
    for (int i = 1; i < inv.size(); ++i) {
      fac[i] = fac[i - 1] * i % MOD;
      inv[i] = modInv(fac[i], MOD);
    }

    int s = 0;
    vector<int> c(10, 0);
    for (char ch : num) {
      ++c[ch - '0'];
      s += ch - '0';
    }
    if (s % 2 != 0) {
      return 0;
    }

    int n = num.length();
    int m = n / 2;
    int z = 0;
    s /= 2;
    vector<vector<int64_t>> dp(m + 1, vector<int64_t>(s + 1, 0));
    dp[0][0] = 1;
    for (int x = 0; x < 10; ++x) {
      vector<vector<int64_t>> pre(m + 1, vector<int64_t>(s + 1, 0));
      pre.swap(dp);
      for (int y = 0; y <= c[x]; ++y) { // 80
        for (int i = y; i <= m; ++i) {
          for (int j = x * y; j <= s; ++j) {
            dp[i][j] += pre[i - y][j - x * y] * inv[y] % MOD * inv[c[x] - y] % MOD;
          }
        }
      }
      for (auto& i : dp) {
        for (auto& j : i) {
          j %= MOD;
        }
      }
    }

    int64_t ret = dp[m][s];
    for (int i = 1; i <= m; ++i) {
      ret = ret * i % MOD;
    }
    for (int i = 1; i <= n - m; ++i) {
      ret = ret * i % MOD;
    }
    return (int)ret;
  }
};",1441316290
SayA,usaya,36,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        dist = [[float('inf') for _ in range(m)] for _ in range(n)]
        dist[0][0] = 0
        
        hp = [(0, 0, 0)] # (time, x, y)
        while hp:
            t, x, y = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(hp, (nt, nx, ny))
        return -1",1441293531
SayA,usaya,36,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        DIR = [(-1,0), (1,0), (0,-1), (0,1)]
        
        dp = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        hp = [(0, 0, 0, 0)] # (time, x, y, z)
        
        while hp:
            t, x, y, z = heappop(hp)
            if x == n - 1 and y == m - 1:
                return t
            if t > dp[x][y][z]:
                continue
            for dx, dy in DIR:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + (1 if z == 0 else 2)
                    nz = 1 - z
                    if nt < dp[nx][ny][nz]:
                        dp[nx][ny][nz] = nt
                        heappush(hp, (nt, nx, ny, nz))
        return -1",1441301029
SayA,usaya,36,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = s2 = 0
        for idx, d in enumerate(num):
            if idx % 2 == 0:
                s1 += ord(d) - ord('0')
            else:
                s2 += ord(d) - ord('0')
        return s1 == s2",1441288801
SayA,usaya,36,3637,python3,"MOD = 10**9 + 7
MAXN = 85

fact = [1] * (MAXN + 1)
for i in range(1, MAXN + 1):
    fact[i] = fact[i-1] * i % MOD

inv = [1] * (MAXN + 1)
inv[MAXN] = pow(fact[MAXN], MOD-2, MOD)
for i in range(MAXN, 0, -1):
    inv[i-1] = inv[i] * i % MOD

comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for i in range(MAXN + 1):
    comb[i][0] = 1
    for j in range(1, i + 1):
        comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for d in num:
            cnt[int(d)] += 1
        cnt_e, cnt_o = (n + 1) // 2, n // 2

        s = sum(int(ch) for ch in num)
        if s & 1:
            return 0
        hs = s // 2

        @cache
        def dfs(d, r_e, r_s):
            if d == 10:
                if r_e ==0 and r_s ==0:
                    return 1
                else:
                    return 0
            res = 0
            for t in range(0, min(cnt[d], r_e) + 1):
                if t * d > r_s:
                    continue
                res = (res + dfs(d + 1, r_e - t, r_s - t * d) * comb[cnt[d]][t]) % MOD
            return res

        ans = dfs(0, cnt_e, hs) * fact[cnt_e] * fact[cnt_o] % MOD
        for d in range(10):
            ans = ans * inv[cnt[d]] % MOD
        return ans",1441323871
funsquared,funsquared,37,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))
        
            ",1441323726
funsquared,funsquared,37,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            t, r, c = heappop(q)
            if dist[r, c] != t:
                continue
            if (r, c) == (R - 1, C - 1):
                return t
            for dr, dc in (0, 1), (1, 0), (0, -1), (-1, 0):
                r2, c2 = r + dr, c + dc
                if 0 <= r2 < R and 0 <= c2 < C:
                    t2 = max(t, moveTime[r2][c2]) + 1 + (r + c) % 2
                    if dist.get((r2, c2), inf) > t2:
                        dist[r2, c2] = t2
                        heappush(q, (t2, r2, c2))",1441323530
funsquared,funsquared,37,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))",1441323951
funsquared,funsquared,37,3637,python3,"MAX = 80
MOD = 10 ** 9 + 7

fact = [1]
for x in range(1, MAX + 1):
    fact.append(fact[-1] * x % MOD)
inv_fact = [None] * (MAX + 1)
inv_fact[MAX] = pow(fact[MAX], -1, MOD)
for x in range(MAX - 1, -1, -1):
    inv_fact[x] = inv_fact[x + 1] * (x + 1) % MOD

def choose(n, k):
    if n < k:
        return 0
    return fact[n] * inv_fact[n - k] % MOD * inv_fact[k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        S = sum(map(int, num))
        if S % 2 == 1:
            return 0
        cnt = [0] * 10
        for d in map(int, num):
            cnt[d] += 1
        target = S // 2
        @cache
        def count(d, o, e, s):
            if d == 10:
                return int(s == target)
            res = 0
            for c in range(min(cnt[d], o) + 1):
                if cnt[d] - c > e:
                    continue
                res = (res + choose(o, c) * choose(e, cnt[d] - c) % MOD * count(d + 1, o - c, e - (cnt[d] - c), s + c * d) % MOD) % MOD
            return res
        return count(0, n // 2, (n + 1) // 2, 0)",1441323285
Ethan,ethanrao,38,3627,cpp,"#include<bits/stdc++.h>>
using namespace std;

class Solution {
public:
    int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    queue<tuple<int, int, int>> q;
    
    int bfs(vector<vector<int>>& cost) {
        int n = cost.size(), m = cost[0].size();
        vector<vector<int>> dp(n, vector<int>(m, 1e9+3000));
        dp[0][0] = 0;
        
        while (!q.empty()) {
            auto [x, y, t] = q.front();
            q.pop();
            for (int i=0;i<4;i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
                    int tt = max(cost[xx][yy], t);
                    if (tt + 1 < dp[xx][yy]) {
                        q.push({xx, yy, tt + 1});
                        dp[xx][yy] = tt + 1;
                    }
                    else continue;
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        q.push({0, 0, 0});
        return bfs(moveTime);
    }
};
",1441315400
Ethan,ethanrao,38,3628,cpp,"class Solution {
public:
    int a[755][755], n, m, dis[755][755][2];
    struct node{
        int x, y, z, d;
    };
    struct cmp{
        bool operator()(node x, node y){
            return x.d > y.d;      
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        m = moveTime[0].size();
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                a[i][j] = moveTime[i - 1][j - 1];
        priority_queue <node, std::vector <node>, cmp> q;
        q.push((node){1, 1, 0, 0});
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                dis[i][j][0] = dis[i][j][1] = 1.5e9;
        dis[1][1][0] = 0;
        while(q.size()){
            node u = q.top(); q.pop();
            if(u.d > dis[u.x][u.y][u.z]) continue;
            if(u.x > 1){
                int d = std::max(u.d, a[u.x - 1][u.y]) + u.z + 1;
                if(d < dis[u.x - 1][u.y][u.z ^ 1]){
                    dis[u.x - 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x - 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.x < n){
                int d = std::max(u.d, a[u.x + 1][u.y]) + u.z + 1;
                if(d < dis[u.x + 1][u.y][u.z ^ 1]){
                    dis[u.x + 1][u.y][u.z ^ 1] = d;
                    q.push((node){u.x + 1, u.y, u.z ^ 1, d});
                }
            }
            if(u.y > 1){
                int d = std::max(u.d, a[u.x][u.y - 1]) + u.z + 1;
                if(d < dis[u.x][u.y - 1][u.z ^ 1]){
                    dis[u.x][u.y - 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y - 1, u.z ^ 1, d});
                }
            }
            if(u.y < m){
                int d = std::max(u.d, a[u.x][u.y + 1]) + u.z + 1;
                if(d < dis[u.x][u.y + 1][u.z ^ 1]){
                    dis[u.x][u.y + 1][u.z ^ 1] = d;
                    q.push((node){u.x, u.y + 1, u.z ^ 1, d});
                }
            }
        }
        return std::min(dis[n][m][0], dis[n][m][1]);
    }
};",1441324125
Ethan,ethanrao,38,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ct1 = 0, ct2 = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                ct1 += digit;
            } else {
                ct2 += digit;
            }
        }
        
        return ct1 == ct2;
    }
};
",1441310208
Ethan,ethanrao,38,3637,cpp,"class Solution {
public:
    int n, n1, n2;
    const int mod = 1e9 + 7;
    int c[10];
    inline int mul(int x, int y){
        return 1ll * x * y % mod;
    }
    inline int add(int x, int y){
        return x + y >= mod ? x + y - mod : x + y;
    }
    int C[85][85], f[11][85][361];
    int countBalancedPermutations(string num) {
        n = num.size();
        n1 = n2 = 0;
        int S = 0;
        for(int i = 0; i < n; ++i){
            if(i % 2 == 0) ++n1;
            else ++n2;
            ++c[num[i] - '0'];
            S += num[i] - '0';
        }
        if(S % 2){
            return 0;
        }
        C[0][0] = 1;
        for(int i = 1; i <= n; ++i)
            for(int j = 0; j <= i; ++j){
                if(j == 0) C[i][j] = 1;
                else C[i][j] = add(C[i - 1][j - 1], C[i - 1][j]);
            }
        f[0][0][0] = 1;
        int s = 0;
        for(int i = 1; i <= 10; ++i){
            int t = c[i - 1];
            for(int sum = 0; sum <= 360; ++sum){
                for(int j = 0; j <= n1; ++j){
                    for(int k = 0; k <= j && k <= t; ++k){
                        int pn1 = j - k, pn2 = s - pn1, sa = k * (i - 1);
                        if(pn2 < 0 || pn2 > n2 || sa > sum) continue;
                        f[i][j][sum] = add(f[i][j][sum], mul(f[i - 1][pn1][sum - sa], mul(C[n1 - pn1][k], C[n2 - pn2][t - k])));
                    } 
                }
            }
            s += t;
        }
        return f[10][n1][S / 2];
    }
};",1441309618
zaneyu2005,zaneyu2005,41,3627,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int x=z/m,y=z%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[a*m+b]<=max(arr[a][b],dist[z])+1){
                    continue;
                }
                dist[a*m+b]=max(arr[a][b],dist[z])+1;
                pq.push({dist[a*m+b],a*m+b});
            }
        }
        return dist[n*m-1];
    }
    
};",1441292757
zaneyu2005,zaneyu2005,41,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& arr) {
        int n=sz(arr),m=sz(arr[0]);
        vector<int> dist(2*n*m,INF);
        priority_queue<pii,vector<pii>,greater<pii>> pq;
        pq.push({0,0});
        dist[0]=0;
        while(sz(pq)){
            int z=pq.top().s;
            if(pq.top().f>dist[z]){
                pq.pop();
                continue;
            }
            pq.pop();
            int st=z%2;
            int x=(z/2)/m,y=(z/2)%m;
            REP(k,4){
                int a=x+dx[k],b=y+dy[k];
                if(a<0 or a>=n or b<0 or b>=m or dist[(a*m+b)*2+1-st]<=max(arr[a][b],dist[z])+(st+1)){
                    continue;
                }
                dist[(a*m+b)*2+1-st]=max(arr[a][b],dist[z])+st+1;
                pq.push({dist[(a*m+b)*2+1-st],(a*m+b)*2+1-st});
            }
        }
        return min(dist[2*(n*m-1)],dist[2*n*m-1]);
    }
    
};",1441296463
zaneyu2005,zaneyu2005,41,3636,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
class Solution {
public:
    bool isBalanced(string s) {
        int n=sz(s);
        int sum=0;
        REP(i,n){
            if(i%2) sum+=s[i]-'0';
            else sum-=s[i]-'0';
        }
        return (sum==0);
    }
};",1441280925
zaneyu2005,zaneyu2005,41,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
typedef tree<long long,null_type,less_equal<long long>,rb_tree_tag,tree_order_statistics_node_update> indexed_set;
#pragma GCC optimize(""Ofast"")
//#pragma GCC target(""avx2"")
//order_of_key #of elements less than x
// find_by_order kth element
using ll=long long;
using ld=long double;
using pii=pair<int,int>;
#define f first
#define s second
#define pb push_back
#define REP(i,n) for(int i=0;i<n;i++)
#define REP1(i,n) for(ll i=1;i<=n;i++)
#define FILL(n,x) memset(n,x,sizeof(n))
#define ALL(_a) _a.begin(),_a.end()
#define sz(x) (int)x.size()
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()),c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
const ll maxn=1e6+5;
const ll maxlg=__lg(maxn)+2;
const ll INF64=9e18;
const int INF=0x3f3f3f3f;
const int MOD=1e9+7;
const ld PI=acos(-1);
const ld eps=1e-6;
#define lowb(x) x&(-x)
#define MNTO(x,y) x=min(x,(__typeof__(x))y)
#define MXTO(x,y) x=max(x,(__typeof__(x))y)
template<typename T1,typename T2>
ostream& operator<<(ostream& out,pair<T1,T2> P){
    out<<P.f<<' '<<P.s;
    return out;
}
template<typename T>
ostream& operator<<(ostream& out,vector<T> V){
    REP(i,sz(V)) out<<V[i]<<((i!=sz(V)-1)?"" "":"""");
    return out;
}
int dp[100][1000],ndp[100][1000];
int c[100][100];
class Solution {
public:
    int countBalancedPermutations(string num) {
        REP(i,50) REP(j,1000) dp[i][j]=ndp[i][j]=0;
        REP(i,100){
            c[i][0]=1;
            REP1(j,i){
                c[i][j]=(c[i-1][j-1]+c[i-1][j])%MOD;
            }
        }
        dp[0][0]=1;
        int cnt[10];
        REP(i,10) cnt[i]=0;
        int s=0;
        for(auto x:num){
            cnt[x-'0']++;
            s+=(x-'0');
        }
        if(s%2){
            return 0;
        }
        s/=2;
        int o=sz(num)/2;
        int e=sz(num)-o;
        int pf=0;
        REP(i,10){
            REP(a,o+1) REP(b,s+1) ndp[a][b]=0;
            REP(a,o+1){
                REP(b,s+1){
                    if(!dp[a][b]) continue;
                    REP(j,cnt[i]+1){
                        if(a+j>o or b+j*i>s) continue;
                        ndp[a+j][b+j*i]+=1LL*dp[a][b]*c[o-a][j]%MOD*c[e-(pf-a)][cnt[i]-j]%MOD;
                        if(ndp[a+j][b+j*i]>=MOD) ndp[a+j][b+j*i]-=MOD;
                    }
                }
            }
            pf+=cnt[i];
            REP(a,o+1) REP(b,s+1) dp[a][b]=ndp[a][b];
        }
        return dp[o][s];
    }
};",1441312046
Ayush,as_313,42,3627,python3,"import heapq

class Solution:
    def is_valid(self, i, j, n, m):
        return 0 <= i < n and 0 <= j < m
    
    def get_neighbors(self, r, c, n, m):
        dirs = [(1,0), (-1,0), (0,1), (0,-1)]
        for dr, dc in dirs:
            nr, nc = r + dr, c + dc
            if self.is_valid(nr, nc, n, m):
                yield nr, nc
    
    def init_distance(self, n, m):
        return [[float('inf')]*m for _ in range(n)]
    
    def process_node(self, t, r, c, g, d, q):
        if t > d[r][c]:
            return
        
        n, m = len(g), len(g[0])
        for nr, nc in self.get_neighbors(r, c, n, m):
            new_time = max(t, g[nr][nc]) + 1
            if new_time < d[nr][nc]:
                d[nr][nc] = new_time
                heapq.heappush(q, (new_time, nr, nc))
    
    def minTimeToReach(self, g):
        n, m = len(g), len(g[0])
        d = self.init_distance(n, m)
        q = [(0, 0, 0)]
        d[0][0] = 0
        
        while q:
            t, r, c = heapq.heappop(q)
            self.process_node(t, r, c, g, d, q)
            
        return d[n-1][m-1]",1441325790
Ayush,as_313,42,3628,python3,"class Solution:
    def minTimeToReach(self, t: List[List[int]]) -> int:
        n, m = len(t), len(t[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        q = [(0, 0, 0, 2)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def is_within_bounds(a, b): return 0 <= a < n and 0 <= b < m
        
        def calculate_next_time(x, a, b, nv): return max(x, t[a][b]) + nv
        
        def explore_neighbors(x, r, c, v):
            for i, j in dirs:
                a, b = r + i, c + j
                if is_within_bounds(a, b):
                    nv = 1 if v == 2 else 2
                    y = calculate_next_time(x, a, b, nv)
                    if y < d[a][b]: 
                        d[a][b] = y
                        heappush(q, (y, a, b, nv))
        
        while q:
            x, r, c, v = heappop(q)
            if r == n - 1 and c == m - 1: return x
            if x > d[r][c]: continue
            explore_neighbors(x, r, c, v)
        
        return d[n-1][m-1]
",1441301088
Ayush,as_313,42,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i, d in enumerate(num):
            if i % 2 == 0: e += int(d)
            else: o += int(d)
        return e == o
",1441284192
Ayush,as_313,42,3637,python3,"class Solution:
    def countBalancedPermutations(self, s):
        MOD = 10**9 + 7
        
        def power_mod(x, y):
            r, x = 1, x % MOD
            while y:
                if y & 1: r = r * x % MOD
                x, y = x * x % MOD, y >> 1
            return r
        
        n = len(s)
        f = [1] + [0] * n
        v = [1] + [0] * n
        for i in range(1, n + 1): f[i] = f[i-1] * i % MOD
        v[n] = power_mod(f[n], MOD - 2)
        for i in range(n-1, -1, -1): v[i] = v[i+1] * (i+1) % MOD
        
        c = [s.count(str(i)) for i in range(10)]
        total = sum(int(ch) for ch in s)
        if total % 2: return 0
        
        k, target = (n + 1) // 2, total // 2
        dp = [[0] * (target + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d, cnt in enumerate(c):
            new_dp = [[0] * (target + 1) for _ in range(k + 1)]
            for i in range(k + 1):
                for j in range(target + 1):
                    if dp[i][j]:
                        for x in range(min(cnt, k - i) + 1):
                            if j + d * x <= target:
                                new_dp[i + x][j + d * x] = (
                                    new_dp[i + x][j + d * x] + 
                                    dp[i][j] * v[x] % MOD * v[cnt - x]
                                ) % MOD
            dp = new_dp
        
        return f[k] * f[n-k] % MOD * dp[k][target] % MOD
",1441319728
scanhex,scanhex,45,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441295664
scanhex,scanhex,45,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        const int oo = 0x3f3f3f3f;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(2, oo)));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>> q;
        q.push({0, 0, 0, 0});
        vector<int> dx = {0, 1, 0, -1}, dy = {1, 0, -1, 0};
        int ans = oo;
        while (q.size()) {
            const auto [dd, x, y, t] = q.top();
            q.pop();
            if (dp[x][y][t] != -dd) {
                continue;
            }
            for (int k = 0; k < 4; ++k) {
                int xx = x + dx[k], yy = y + dy[k];
                if (xx < 0 || xx >= n || yy < 0 || yy >= m) continue;
                int tt = (1 + t + max(a[xx][yy], dp[x][y][t]));
                if (tt < dp[xx][yy][t ^ 1]) {
                    dp[xx][yy][t ^ 1] = tt;
                    q.push({-dp[xx][yy][t ^ 1], xx, yy, t ^ 1});
                }
            }
            if (x == n - 1 && y == m - 1)
                ans = min(ans, dp[x][y][t]);
        }
        return ans;
    }
};
",1441294951
scanhex,scanhex,45,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(i) for i in str(num)[::2]]) == sum([int(i) for i in str(num)[1::2]])",1441296619
scanhex,scanhex,45,3637,cpp,"class Solution {
public:
  const int mod = 1e9 + 7;
  int countBalancedPermutations(string num) {
    int ceven = num.size() / 2, codd = num.size() - ceven;
    int n = num.size();
    vector<vector<int>> c(n + 1, vector<int>(n + 1));
    c[0][0] = 1;
    for (int i = 1; i <= n; ++i)
      for (int j = 0; j <= i; ++j)
        c[i][j] = ((j == 0 ? 0 : c[i - 1][j - 1]) + c[i - 1][j]) % mod;
    const int MX = 2 * 100 * 9;
    const int ZERO = MX / 2;
    vector<vector<int>> dp(ceven + 1, vector<int>(MX));
    dp[0][ZERO] = 1;
    int totcnt = 0;
    for (int i = 0; i < 10; ++i) {
      int cnt = 0;
      for (char ch : num)
        if (ch - '0' == i)
          ++cnt;
      auto dpp = vector<vector<int>>(ceven + 1, vector<int>(MX));
      for (int j = ceven; j >= 0; --j) {
        for (int k = ceven; k >= 0; --k) {
          if (j + k > ceven || k > cnt)
            continue;
          for (int l = 0; l < MX; ++l) {
            if (dp[j][l] == 0)
              continue;
            int nodd = cnt - k;
            int totodd = totcnt - j;
            int nl = l + (k - nodd) * i;
            if (nl < 0 || nl >= MX)
              continue;
            dpp[j + k][nl] += 1LL * dp[j][l] * c[j + k][k] % mod *
                             c[totodd + nodd][nodd] % mod;
            if (dpp[j + k][nl] >= mod)
              dpp[j + k][nl] -= mod;
          }
        }
      }
      dp = dpp;
      totcnt += cnt;
    }
    return dp[ceven][ZERO];
  }
};
",1441314395
Shuqi Shang,sshang,46,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        seen = set()
        
        while q:
            t, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1, ni, nj))",1441291881
Shuqi Shang,sshang,46,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        m, n = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0, 0)]
        seen = set()
        
        while q:
            t, state, i, j = heapq.heappop(q)
            if (i, j) in seen:
                continue
            seen.add((i, j))
            
            if i == m-1 and j == n-1:
                return t
            
            for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:
                    nt = max(t, moveTime[ni][nj])
                    heapq.heappush(q, (nt + 1 + state, 1 - state, ni, nj))",1441294899
Shuqi Shang,sshang,46,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        odd, even = 0, 0
        for i, c in enumerate(num):
            if i % 2:
                odd += int(c)
            else:
                even += int(c)
        return odd == even",1441281285
Shuqi Shang,sshang,46,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        mod = 10 ** 9 + 7
        
        n = len(num)
        size = n // 2
        
        total = 0
        cnter = {}
        l = []
        for c in num:
            digit = int(c)
            total += digit
            
            if digit in cnter:
                cnter[digit] += 1
            else:
                cnter[digit] = 1
                bisect.insort(l, digit)
                
        l.reverse()
        presum = [0]
        precnt = [0]
        for num in l:
            cnt = cnter[num]
            precnt.append(precnt[-1] + cnt)
            presum.append(presum[-1] + num * cnt)
            
        if total % 2:
            return 0
        
        target = total // 2
        
        @lru_cache(None)
        def dfs(i, cur_size, cur):
            if i == len(l):
                if cur_size == size and cur == target:
                    return 1
                else:
                    return 0
                
            op_size = precnt[i] - cur_size
                
            num = l[i]
            cnt = cnter[num]
            res = 0
            for j in range(cnt + 1):
                ncur_size = cur_size + j
                ncur = cur + j * num
                nop_size = precnt[i+1] - ncur_size
                nop_sum = presum[i+1] - ncur
                
                if ncur_size <= size and nop_size <= n - size and ncur <= target and nop_sum <= target:
                    mul = (math.comb(size - cur_size, j) % mod) * (math.comb(n - size - op_size, cnt - j) % mod) % mod
                    res += dfs(i+1, ncur_size, ncur) * mul % mod
            return res % mod
            
        return dfs(0, 0, 0)",1441327864
Milind Gupta,milind0110,48,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + 1;
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny});
                }
            }
        }
        return -1;
    }
};",1441298834
Milind Gupta,milind0110,48,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mat) {
        int n = (int)mat.size();
        int m = (int)mat[0].size();
        const int inf = 2e9;
        vector<vector<int>> dis(n,vector<int>(m,inf));
        priority_queue<array<int,4>> q;
        q.push({0,0,0});
        int dx[] = {-1,0,1,0};
        int dy[] = {0,-1,0,1}; 
        while(!q.empty()){
            auto [d,x,y,turn] = q.top();
            d *= -1;
            if(d > dis[x][y]) continue;
            q.pop();
            if(x == n - 1 && y == m - 1) return d;
            for(int i = 0; i < 4; i++){
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                int ndis = max(mat[nx][ny],d) + (turn == 0 ? 1 : 2);
                if(ndis < dis[nx][ny]){
                    dis[nx][ny] = ndis;
                    q.push({-ndis,nx,ny,turn ^ 1});
                }
            }
        }
        return -1;
    }
};",1441297775
Milind Gupta,milind0110,48,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int ans = 0;
        int n = (int)s.size();
        for(int i = 0; i < n; i++){
            if(i & 1){
                ans += s[i] - '0';
            } else {
                ans -= s[i] - '0';
            }
        }
        return (ans == 0);
    }
};",1441281507
Milind Gupta,milind0110,48,3637,cpp,"const int N = 100;
const int mod = 1e9 + 7;
using uint = unsigned int;
using ll = long long;
using ull = unsigned long long;
constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }
template <class T> using V = vector<T>;
template <class T> using VV = V<V<T>>;

template <uint MD> struct ModInt {
    using M = ModInt;
    const static M G;
    uint v;
    ModInt(ll _v = 0) { set_v(_v % MD + MD); }
    M& set_v(uint _v) {
        v = (_v < MD) ? _v : _v - MD;
        return *this;
    }
    explicit operator bool() const { return v != 0; }
    M operator-() const { return M() - *this; }
    M operator+(const M& r) const { return M().set_v(v + r.v); }
    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }
    M operator*(const M& r) const { return M().set_v(ull(v) * r.v % MD); }
    M operator/(const M& r) const { return *this * r.inv(); }
    M& operator+=(const M& r) { return *this = *this + r; }
    M& operator-=(const M& r) { return *this = *this - r; }
    M& operator*=(const M& r) { return *this = *this * r; }
    M& operator/=(const M& r) { return *this = *this / r; }
    bool operator==(const M& r) const { return v == r.v; }
    M pow(ll n) const {
        M x = *this, r = 1;
        while (n) {
            if (n & 1) r *= x;
            x *= x;
            n >>= 1;
        }
        return r;
    }
    M inv() const { return pow(MD - 2); }
    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }
};
using Mint = ModInt<mod>;
template<> const Mint Mint::G = Mint(3);

// template <class Mint> void nft(bool type, V<Mint>& a) {
//     int n = int(a.size()), s = 0;
//     while ((1 << s) < n) s++;
//     assert(1 << s == n);

//     static V<Mint> ep, iep;
//     while (int(ep.size()) <= s) {
//         ep.push_back(Mint::G.pow(Mint(-1).v / (1 << ep.size())));
//         iep.push_back(ep.back().inv());
//     }
//     V<Mint> b(n);
//     for (int i = 1; i <= s; i++) {
//         int w = 1 << (s - i);
//         Mint base = type ? iep[i] : ep[i], now = 1;
//         for (int y = 0; y < n / 2; y += w) {
//             for (int x = 0; x < w; x++) {
//                 auto l = a[y << 1 | x];
//                 auto r = now * a[y << 1 | x | w];
//                 b[y | x] = l + r;
//                 b[y | x | n >> 1] = l - r;
//             }
//             now *= base;
//         }
//         swap(a, b);
//     }
// }

// template <class Mint> V<Mint> multiply(const V<Mint>& a, const V<Mint>& b) {
//     assert(false);
//     incase of cross-correlation reverse b and the answer will be at length of reversed array - the index for answer
//     int n = int(a.size()), m = int(b.size());
//     if (!n || !m) return {};
//     int lg = 0;
//     while ((1 << lg) < n + m - 1) lg++;
//     int z = 1 << lg;
//     auto a2 = a, b2 = b;
//     a2.resize(z);
//     b2.resize(z);
//     nft(false, a2);
//     nft(false, b2);
//     for (int i = 0; i < z; i++) a2[i] *= b2[i];
//     nft(true, a2);
//     a2.resize(n + m - 1);
//     Mint iz = Mint(z).inv();
//     for (int i = 0; i < n + m - 1; i++) a2[i] *= iz;
//     return a2;
// }

Mint fact[N];
Mint inv[N];
void precalc(){
    fact[0] = 1;
    for(int i = 1; i < N; i++){
        fact[i] = fact[i - 1];
        fact[i] *= i;
    }
    for(int i = 0; i < N; i++){
        inv[i] = 1;
        inv[i] /= fact[i];
    }
}
Mint ncrmodp(int n,int r){
    if(n < 0 || n < r)
        return 0;
    return fact[n]*inv[n-r]*inv[r];
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        precalc();
        int n = (int)s.length();
        const int mx = 10;
        vector<int> cnt(mx);
        int sum = 0;
        for(auto i : s){
            cnt[i - '0']++;
            sum += (i - '0');
        }
        if(sum & 1) return 0;
        sum /= 2;
        int len = n / 2;
        vector<vector<Mint>> dp(len + 1,vector<Mint>(sum + 1));
        dp[0][0] = fact[len] * fact[n - len];
        for(int i = 0; i < mx; i++){
            vector<vector<Mint>> ndp(len + 1,vector<Mint>(sum + 1));
            for(int clen = 0; clen <= len; clen++){
                for(int csum = 0; csum <= sum; csum++){
                    for(int take = 0; take <= cnt[i]; take++){
                        if(take + clen > len) break;
                        int nsum = csum + take * i;
                        if(nsum > sum) break;
                        ndp[clen + take][nsum] += dp[clen][csum] * inv[take] * inv[cnt[i] - take];
                    }
                }
            }
            swap(dp,ndp);
        }
        // for(int i = 0; i <= len; i++){
        //     for(int j = 0; j <= sum; j++){
        //         cout << i << "" "" << j << "" "" << dp[i][j].v << ""\n"";
        //     }
        // }
        return dp[len][sum].v;

    }
};",1441328324
07dishwasherbob8,07dishwasherbob8,50,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1, moveTime[tx][ty] + 1), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441328119
07dishwasherbob8,07dishwasherbob8,50,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dp(n,vector<int>(m,-1));

        vector<int> dx = {0,0,-1,1}, dy = {-1,1,0,0};

        priority_queue<array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;
        pq.push({0,0,0});
        while(pq.size()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if(dp[x][y] != -1) continue;
            dp[x][y] = t;

            for(int i = 0; i < 4; i++) {
                int tx = x + dx[i], ty = y + dy[i];
                if(tx >= 0 && tx < n && ty >= 0 && ty < m && dp[tx][ty] == -1) {
                    pq.push({max(t + 1 + ((x + y) & 1), moveTime[tx][ty] + 1 + ((x + y) & 1)), tx, ty});
                }
            }
            
        }
        return dp[n-1][m-1];
    }
};",1441327239
07dishwasherbob8,07dishwasherbob8,50,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for(int i = 1; i < num.size(); i+=2) {
            s0 += num[i] - '0';
        }
        for(int i = 0; i < num.size(); i+=2) {
            s1 += num[i] - '0';
        }
        return s0 == s1;
    }
};",1441329956
07dishwasherbob8,07dishwasherbob8,50,3637,cpp,"typedef long long ll;
typedef long double ld;

template<class T>
constexpr T power(T a, ll b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

//Modular Division currently uses Little Fermat's Theorem, so won't work for nonprime p. 
template<int P>
struct Mint {
    int x;
    constexpr Mint(): x{} {}
    constexpr Mint(ll x): x{norm(x % getMod())} {}

    static int Mod;
    constexpr static int getMod() {
        if(P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if(x < 0) {
            x += getMod();
        }
        if(x >= getMod()) { //not sure why this is needed
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    constexpr Mint operator-() const {
        Mint res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr Mint inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr Mint &operator*=(Mint rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr Mint &operator+=(Mint rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr Mint &operator-=(Mint rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr Mint &operator/=(Mint rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr Mint operator*(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr Mint operator+(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr Mint operator-(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr Mint operator/(Mint lhs, Mint rhs) {
        Mint res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, Mint &a) {
        ll v;
        is >> v;
        a = Mint(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const Mint &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(Mint lhs, Mint rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(Mint lhs, Mint rhs) {
        return lhs.val() != rhs.val();
    }
};

constexpr int P = 1000000007;
using Z = Mint<P>;

class Solution {

public:
    int countBalancedPermutations(string num) {
        vector<Z> factorials(800);
        vector<Z> ifactorials(800);
        factorials[0] = 1;
        ifactorials[0] = 1;
        for(int i = 1; i < 800; i++) {
            factorials[i] = factorials[i-1] * i;
            ifactorials[i] = 1 / factorials[i];
        }

        vector<int> cnts(10);
        int sum = 0;
        for(char c : num) {
            cnts[c - '0']++;
            sum += c - '0';
        }

        
        if(sum & 1) {
            return 0;
        }
        
        // cout << ""sum : "" << sum << '\n';

        vector<vector<Z>> dp(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));
        vector<vector<Z>> next(num.size() / 2 + 1, vector<Z>(sum / 2 + 1));

        dp[0][0] = 1;

        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    next[j][k] = 0;
                }
            }
            
            for(int j = 0; j <= num.size() / 2; j++) {
                for(int k = 0; k <= sum / 2; k++) {
                    for(int l = 0; l + j <= num.size() / 2 && k + (i * l) <= sum / 2 && l <= cnts[i]; l++) {
                        next[l+j][k + i * l] += dp[j][k] * ifactorials[l] * ifactorials[cnts[i] - l];
                    }
                }
            }
            // cout << ""i : "" << i << '\n';
            // for(int j = 0; j <= num.size() / 2; j++) {
            //     for(int k = 0; k <= sum / 2; k++) {
            //         // cout << ""i : "" << i << "" j : "" << j << "" k : "" << k << "" val : "" << dp[j][k] << '\n';
            //         cout << next[j][k] << "" "";
            //     }
            //     cout << '\n';
            // }
            swap(dp,next);
        }
        return (dp[num.size() / 2][sum / 2] * factorials[num.size() / 2] * factorials[(num.size() + 1) / 2]).x;
    }
};",1441315453
wuaws,wuaws,51,3627,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int>,vector<tuple<ll,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        vpi dirs={{-1,0},{1,0},{0,-1},{0,1}};
        const ll INF=1e18;
        mll d(n,vll(m,INF));
        d[0][0]=0;
        pq pq;
        pq.emplace(0,0,0);
        
        while(!pq.empty()){
            auto[t,i,j]=pq.top();
            pq.pop();
            
            if(i==n-1&&j==m-1)return(int)t;
            
            if(t>d[i][j])continue;
            
            for(auto&[di,dj]:dirs){
                int ni=i+di,nj=j+dj;
                
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                
                ll at=max(t,(ll)mt[ni][nj])+1;
                if(at<d[ni][nj]){
                    d[ni][nj]=at;
                    pq.emplace(at,ni,nj);
                }
            }
        }
        return -1;
    }
};",1441329816
wuaws,wuaws,51,3628,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
typedef priority_queue<tuple<ll,int,int,int>,vector<tuple<ll,int,int,int>>,greater<>> pq;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution{
public:
    int minTimeToReach(mi&mt){
        int n=mt.size(),m=mt[0].size();
        mll d0(n,vll(m,1e18)),d1(n,vll(m,1e18));
        d0[0][0]=0;
        pq pq;
        pq.emplace(0,0,0,0);
        vector<pair<int,int>> dirs={{-1,0},{1,0},{0,-1},{0,1}};
        
        while(!pq.empty()){
            auto[t,i,j,p]=pq.top(); pq.pop();
            if(i==n-1&&j==m-1)return t;
            if((p==0&&t>d0[i][j])||(p==1&&t>d1[i][j]))continue;

            for(auto& d:dirs){
                int ni=i+d.first,nj=j+d.second;
                if(ni<0||ni>=n||nj<0||nj>=m)continue;
                ll ts=max((ll)t,(ll)mt[ni][nj]),at=ts+(p==0?1:2);
                int np=1-p;
                if((np==0&&at<d0[ni][nj])||(np==1&&at<d1[ni][nj])){
                    (np==0?d0[ni][nj]:d1[ni][nj])=at;
                    pq.emplace(at,ni,nj,np);
                }
            }
        }
        return -1;
    }
};",1441329602
wuaws,wuaws,51,3636,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

class Solution {
public:
    bool isBalanced(string num) {
        int e=0,o=0;
        FOR(i,0,num.length()){
            int d=num[i]-'0';
            if(i%2==0) e+=d;
            else o+=d;
        }
        return e==o;
    }
};",1441330062
wuaws,wuaws,51,3637,cpp,"// #pragma GCC optimize(""O3"")
// #include <atcoder/all>
#include <bits/stdc++.h>
using namespace std;
#define FOR(i, a, b) for(int i = a; i < b; i ++)
#define FORS(i, a, b, c) for(int i = a; i < b; i += c)
#define FORN(i, a, b) for(int i = a; i <= b; i ++)
#define FORD(i, a, b) for(int i = a-1; i >= b; i --)
#define FORE(i, b) for(auto &i:b)
#define REP(i, b) FOR(i, 0, b)
#define REPN(i, b) FORN(i, 0, b)
#define SQ(i) (i*i)
#define ALL(a) a.begin(), a.end()
#define ALLA(a,n) a, a+n
#define SORT(a) sort(ALL(a))
#define SORTA(a, n) sort(ALLA(a, n))
#define REV(a) reverse(ALL(a))
#define REVA(a, n) reverse(ALLA(a, n))
#define MIN(v) (*min_element((v).begin(), (v).end()))
#define MAX(v) (*max_element((v).begin(), (v).end()))
#define IN(a, b) (a.find(b) != a.end())
#define BACK(a) a.back(); a.RB()
#define QBACK(a) a.top(); a.pop()
#define PRINT(a) FORE(i, a) cout << i << "" ""; cout << endle 
#define MY_PI     3.14159265358979323846
#define MY_E      2.7182818284590452354
#define INF     (INT_MAX / 2)
#define LINF    (LLONG_MAX / 2)
#define RFOR(i, a, b) for(int i = (b) - 1; i >= (a); --i)
#define RREP(i, n) RFOR(i, 0, n)
#define EACH(e, v) for(auto &e : v)
#define ITR(it, v) for(auto it = (v).begin(); it != (v).end(); ++it)
#define RITR(it, v) for(auto it = (v).rbegin(); it != (v).rend(); ++it)
#define CASE break; case
#define DEFAULT break; default
#define RALL(v) (v).rbegin(), (v).rend()
#define SZ(v) int((v).size())
#define EXIST(s, e) ((s).find(e) != (s).end())
#define RSORT(v) sort((v).rbegin(), (v).rend())
#define SUM(v, type) accumulate((v).begin(), (v).end(), (type) 0)
#define ARGMIN(v) (min_element((v).begin(), (v).end()) - (v).begin())
#define ARGMAX(v) (max_element((v).begin(), (v).end()) - (v).begin())
#define REVERSE(v) reverse((v).begin(), (v).end())
#define ARANGE(v) iota((v).begin(), (v).end(), 0)
#define COUNT(v, e) count((v).begin(), (v).end(), e)
#define ROTATE_L(v) rotate((v).begin(), (v).begin()+1, (v).end())
#define ROTATE_R(v) rotate((v).rbegin(), (v).rbegin()+1, (v).rend())
#define FILTER(src, tgt, func) copy_if(begin(src), end(src), back_inserter(tgt), func)
#define CTOI(c) (c - '0')
#define HEADSTR(str, n) str.substr(0, (n))
#define TAILSTR(str, n) str.substr((str).length() - (n))
#define CONTAINS(str, c) ((str).find(c) != string::npos)
#define INSPOS(v, a) (lower_bound((v).begin(), (v).end(), a) - (v).begin())
// デバッグ用
#define dump(x)  cerr << #x << "" = "" << (x) << endl;
#define debug(x) cerr << #x << "" = "" << (x) << "" (L"" << __LINE__ << "")"" << "" "" << __FILE__ << endl;

#define PB  push_back
#define RB  pop_back
#define RF  pop_front
#define INS insert
#define F   first
#define S   second
#define UM  unordered_map
#define US  unordered_set
#define PQ  priority_queue
#define IO ios_base::sync_with_stdio(false); cin.tie(NULL)

typedef long long ll;
typedef unsigned long long ull;

template<class T> vector<size_t> argsort(const vector<T> &vec, bool asc=true){
    vector<size_t> index(vec.size()); iota(index.begin(), index.end(), 0);
    sort(index.begin(), index.end(), [&vec, &asc](size_t i, size_t j){return asc ? (vec[i] < vec[j]):(vec[i] > vec[j]);});
    return index;
}

// 表示系
template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) {
    os << ""("" << p.first << "", "" << p.second << "")"";
    return os;
}
template<class... T> ostream& operator<<(ostream& os, const tuple<T...>& t) {
    os << ""(""; apply([&os](auto&&... args) {((os << args << "", ""), ...);}, t);
    os << "")""; return os;
}
template<class T, size_t N> ostream& operator<<(ostream& os, const array<T, N>& ary) {
    os << ""[ ""; for ( const T& item : ary ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const vector<T>& vec) {
    os << ""[ ""; for ( const T& item : vec ) os << item << "", "";
    os << ""]""; return os;
}
template<class T> ostream& operator<<(ostream& os, const set<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T> ostream& operator<<(ostream& os, const multiset<T>& s) {
    os << ""{ ""; for ( const T& item : s ) os << item << "", "";
    os << ""}""; return os;
}
template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1, T2>& m) {
    os << ""{ ""; for ( const auto &[key, value] : m ) os << key << "":""<< value << "", "";
    os << ""}""; return os;
}
template <class Head> void OUT(Head&& head) {cout << head << endl;}
template <class Head, class... Tail> void OUT(Head&& head, Tail&&... tail) {cout << head << "" "";OUT(forward<Tail>(tail)...);}
// 入力系
template<class T1, class T2> istream& operator>>(istream& is, pair<T1, T2>& p) {
    is >> p.first >> p.second;
    return is;
}
template<class... T> istream& operator>>(istream& is, tuple<T...>& t) {
    apply([&is](auto&&... args) {((is >> args), ...);}, t);
    return is;
}
template<class T, size_t N> istream& operator>>(istream& is, array<T, N>& ary) {
    for ( T& item : ary ) is >> item;
    return is;
}
template<class T> istream& operator>>(istream& is, vector<T>& vec) {
    for ( T& item : vec ) is >> item;
    return is;
}
// 集合演算
template<class T> set<T> operator&(const set<T>& a, const set<T>& b) {// 共通集合
    set<T> ans; set_intersection(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator|(const set<T>& a, const set<T>& b) {// 和集合
    set<T> ans; set_union(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}
template<class T> set<T> operator-(const set<T>& a, const set<T>& b) {// 差集合
    set<T> ans; set_difference(a.begin(), a.end(), b.begin(), b.end(), inserter(ans, ans.end()));
    return ans;
}

typedef vector<int> vi;
typedef vector<double> vd;
typedef vector<string> vs;
typedef vector<ll> vll;
typedef pair<int,int> pi;
typedef pair<double,double> pd;
typedef pair<ll,ll> pll;
typedef queue<int> qi;
typedef queue<double> qd;
typedef queue<ll> qll;
typedef US<int> si;
typedef US<double> sd;
typedef US<ll> sll;
typedef vector<vi> mi;
typedef vector<vd> md;
typedef vector<vll> mll;
typedef vector<pi> vpi;
typedef vector<pd> vpd;
typedef vector<pll> vpll;
using MII = map<int,int>; using MLL = map<ll,ll>;
using SI = set<int>; using SL = set<ll>;
using MSI = multiset<int>; using MSL = multiset<ll>;
template<class T> using MAXPQ = priority_queue<T>;
template<class T> using MINPQ = priority_queue< T, vector<T>, greater<T> >;
// int -> str: to_string(i)
// str -> int: stoi(s)
// vec -> set: set<int> s(ALL(v));
// 1が立っている数: __builtin_popcount(i), __builtin_popcountll(i)
// 上位ビットの連続した0の数: __builtin_clz(i), __builtin_clzll(i) // i=0未定義
// 下位ビットの連続した0の数: __builtin_ctz(i), __builtin_ctzll(i) // i=0未定義

istringstream debug_iss(R""(
デバッグ時はここに入力を貼り付けて下記マクロのコメントアウトを外す
)"");
// #define cin debug_iss

const int MOD=1e9+7;

ll fast_power(ll x,ll y,ll mod){
    ll r=1; x%=mod;
    while(y>0){
        if(y&1)r=r*x%mod;
        x=x*x%mod; y>>=1;
    }
    return r;
}

class Solution {
public:
    int countBalancedPermutations(string n){
        int c[10]={0}; ll s=0;
        for(char d:n){c[d-'0']++; s+=d-'0';}
        if(s&1)return 0;
        ll t=s/2; int sz=n.size(),e=(sz+1)/2,o=sz/2;
        
        vector<ll> f(sz+1,1),ivf(sz+1,1);
        FOR(i,1,sz+1)f[i]=f[i-1]*i%MOD;
        ivf[sz]=fast_power(f[sz],MOD-2,MOD);
        FORD(i,sz,0)ivf[i]=ivf[i+1]*(i+1)%MOD;
        
        vector<pair<int,int>>d;
        FOR(dg,0,10)if(c[dg])d.PB({dg,c[dg]});
        
        mll dp(t+1,vector<ll>(e+1,0));
        dp[0][0]=1;
        
        FORE(dg,d){
            mll ndp(t+1,vector<ll>(e+1,0));
            FOR(k,0,t+1)FOR(m,0,e+1)if(dp[k][m]){
                int mx=min(dg.S,e-m);
                FOR(x,0,mx+1){
                    ll nk=k+x*dg.F; if(nk>t)continue;
                    int nm=m+x;
                    ndp[nk][nm]=(ndp[nk][nm]+dp[k][m]*ivf[x]%MOD*ivf[dg.S-x]%MOD)%MOD;
                }
            }
            dp=ndp;
        }
        
        ll a=(t<=t&&e<=e)?dp[t][e]:0;
        
        return (int)(f[e]*f[o]%MOD*a%MOD);
    }
};",1441329386
Meng-Hsuan Wu,meng-hsuan,55,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + 1, tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441305853
Meng-Hsuan Wu,meng-hsuan,55,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]
        best = [[None] * m for _ in range(n)]
        pq = []
        heappush(pq, (0, 0, 0))
        
        while len(pq):
            tm, r, c = heappop(pq)
            if best[r][c] != None:
                continue
            
            best[r][c] = tm
            for dr, dc in dirs:
                if 0 <= (tr := r + dr) < n and 0 <= (tc := c + dc) < m and best[tr][tc] == None:
                    heappush(pq, (max(best[r][c], moveTime[tr][tc]) + (1 if (tr + tc) % 2 else 2), tr, tc))
        
        #for i in best:
        #    print(i)
        
        return best[n - 1][m - 1]
    ",1441307123
Meng-Hsuan Wu,meng-hsuan,55,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) * (1 if i % 2 else -1) for i in range(n)) == 0",1441282661
Meng-Hsuan Wu,meng-hsuan,55,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(ch) for ch in num) % 2:
            return 0
        
        MODULI = 10 ** 9 + 7
        n = len(num)
        no = n >> 1
        ne = n - no
        C = Counter(num)
        
        choose = [[1]]
        for n_ in range(1, n + 1):
            choose.append([1])
            for r in range(1, n_):
                choose[-1].append((choose[-2][r - 1] + choose[-2][r]) % MODULI)
            choose[-1].append(1)
        #for i in choose:
        #    print(i)
        
        curr = {(ne, no, 0): 1}
        for i in range(10):
            prev = curr
            curr = collections.defaultdict(int)
            qty = C[str(i)]
            
            for ce in range(qty + 1):
                co = qty - ce
                dbal = (ce - co) * i
                
                for pe, po, pbal in prev:
                    if pe >= ce and po >= co:
                        curr[key := (pe - ce, po - co, pbal + dbal)] += prev[(pe, po, pbal)] * choose[pe][ce] % MODULI * choose[po][co] % MODULI
                        curr[key] %= MODULI
        
        return curr[(0, 0, 0)]
    ",1441331806
haohao,cchao,56,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 3>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        vector<vector<int>> d(n, vector<int>(m, inf));
        d[0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2];
            if (dis != d[x][y]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir];
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + 1;
                if (nd < d[tx][ty]) {
                    d[tx][ty] = nd;
                    q.push({nd, tx, ty});
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441295427
haohao,cchao,56,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ts) {
        using A = array<int, 4>;
        priority_queue<A, vector<A>, greater<A>> q;
        q.push({0, 0, 0, 0});
        const int n = ts.size(), m = ts[0].size();
        const int inf = 2e9;
        int d[n][m][2];
        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {
            d[i][j][0] = d[i][j][1] = inf;
        }
        d[0][0][0] = 0;
        while (q.size()) {
            auto t = q.top(); q.pop();
            const int dis = t[0], x = t[1], y = t[2], z = t[3];
            if (dis != d[x][y][z]) continue;
            const int dx[] = {1, 0, -1, 0};
            const int dy[] = {0, 1, 0, -1};
            for (int dir = 0; dir < 4; ++dir) {
                const int tx = x + dx[dir], ty = y + dy[dir], tz = z ^ 1;
                if (tx < 0 || ty < 0 || tx >= n || ty >= m) continue;
                const int nd = max(ts[tx][ty], dis) + (z + 1);
                if (nd < d[tx][ty][tz]) {
                    d[tx][ty][tz] = nd;
                    q.push({nd, tx, ty, tz});
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441301451
haohao,cchao,56,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        return sum(int(x) for x in num[0::2]) == sum(int(x) for x in num[1::2])",1441283080
haohao,cchao,56,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cnt = [0] * 10
        for c in num:
            cnt[ord(c) - ord('0')] += 1

        mod = 10 ** 9 + 7
        inv = lambda x : pow(x, mod - 2, mod)
        fac = [1] * 100
        ifac = [1] * 100
        for i in range(1, len(fac)):
            fac[i] = fac[i-1] * i % mod
            ifac[i] = inv(fac[i])
        
        @cache
        def f(cap1, cap2, diff, index):
            if cap1 < 0 or cap2 < 0:
                return 0
            if cap1 == 0 and cap2 == 0:
                return diff == 0
            ans = 0
            for i in range(cnt[index] + 1):
                j = cnt[index] - i
                if cap1 >= i and cap2 >= j:
                    m1 = fac[cap1] * ifac[i] * ifac[cap1 - i]
                    m2 = fac[cap2] * ifac[j] * ifac[cap2 - j]
                    r = f(cap1 - i, cap2 - j, diff + index * (i - j), index + 1)
                    r = r * m1 % mod
                    r = r * m2 % mod
                    ans = (ans + r) % mod
            return ans % mod
        return f(n//2, n-n//2, 0, 0)",1441332143
Ernest Lu,ernestlu,57,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 1);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441318385
Ernest Lu,ernestlu,57,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        auto& a = moveTime;
        const int n = (int)a.size(), m = (int)a[0].size();

        using ll = long long;
        const ll INF = 1e15;
        vector dp(n, vector(m, vector<ll>(2, INF)));
        dp[0][0][0] = 0;

        using info = array<ll, 4>;
        priority_queue<info, vector<info>, greater<info>> dij;
        const vector<int> dx = {-1, 1, 0, 0}, dy = {0, 0, -1, 1};
        dij.push({0, 0, 0, 0});

        vector v(n, vector(m, vector<bool>(2, false)));
        while (!dij.empty()) {
            auto [dist, x, y, k] = dij.top();
            dij.pop();

            if (v[x][y][k])
                continue;
            v[x][y][k] = true;
           // cout << dist << "" "" << x << ' ' << y << ' ' << k << '\n';
            for (int i = 0; i < 4; i++) {
                ll nx = x + dx[i], ny = y + dy[i];
                ll c = (k == 0 ? 1 : 2);
                if (nx < n and nx >= 0 and ny < m and ny >= 0) {
                    ll to = max(a[nx][ny] + c, dist + c);
                    if (!v[nx][ny][k ^ 1] and dp[nx][ny][k ^ 1] > to) {
                        dp[nx][ny][k ^ 1] = to;
                        dij.push({to, nx, ny, k ^ 1});
                    }
                }
            }
        }
        
        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441317334
Ernest Lu,ernestlu,57,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = (int)num.size();
        vector<int> a(n);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
            if (i % 2 == 0)
                sum += a[i];
        }
        const int sum_2 = accumulate(a.begin(), a.end(), 0);
        if (sum + sum == sum_2)
            return true;
        return false;
    }
};",1441319837
Ernest Lu,ernestlu,57,3637,cpp,"using ll = long long;
const ll MOD = 1e9 + 7;
struct mint {
    int x;
    mint() : x(0) {}
    template <class T> mint(T value) : x(value % MOD) { if (x < 0) x += MOD; }
    mint & operator+=(const mint &oth) { x += oth.x; if (x >= MOD) x -= MOD; return *this; }
    mint & operator-=(const mint &oth) { x -= oth.x; if (x < 0) x += MOD; return *this; }
    mint & operator*=(const mint &oth) { x = (long long) x * oth.x % MOD; return *this; }
    friend mint operator+(mint l, const mint &r) { return l += r; }
    friend mint operator-(mint l, const mint &r) { return l -= r; }
    friend mint operator*(mint l, const mint &r) { return l *= r; }
    mint & operator--() { if (--x == -1) x = MOD - 1; return *this; }
    mint & operator++() { if (++x == MOD) x = 0; return *this; }
    mint operator--(int) { mint temp = *this; --*this; return temp; }
    mint operator++(int) { mint temp = *this; ++*this; return temp; }
    mint operator-() const { return 0 - *this; }
    mint operator+() const { return *this; }
    friend bool operator==(const mint &l, const mint &r) { return l.x == r.x; }
    friend bool operator!=(const mint &l, const mint &r) { return l.x != r.x; }
    friend ostream & operator<<(ostream &out, const mint &a) { return out << a.x; }
    mint pow(long long e = MOD - 2) const {
        mint ans = 1, b = *this;
        while (e > 0) {
            if (e % 2 == 1) {
                ans *= b;
            }
            b *= b;
            e /= 2;
        }
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        // * even! * odd!
        // divide by how many we choose at each level?
        // maintain sum

        int n = (int)num.size();
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            a[i] = num[i] - '0';
        }

        const int tot = accumulate(a.begin(), a.end(), 0);
        if (tot % 2 == 1) {
            return 0;
        }
        const int target = tot / 2;

 

        vector<int> f(10);
        for (auto u : a)
            f[u]++;

        const int B = n + 101;
        vector<mint> fac(B, 1), inv(B, 1);
        for (int i = 1; i < B; i++)
            fac[i] = fac[i - 1] * i;
        inv[B - 1] = fac[B - 1].pow();
        for (int i = B - 2; i >= 0; i--)
            inv[i] = inv[i + 1] * (i + 1);

        const int even = n / 2, odd = n - even;
        vector dp(even + 1, vector<mint>(target + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            vector new_dp(even + 1, vector<mint>(target + 1, 0));
            for (int num_vals = 0; num_vals <= even; num_vals++) {
                for (int val = 0; val <= target; val++) {
                    for (int fc = 0; fc <= f[i]; fc++) {
                        mint ways_t = inv[fc] * inv[f[i] - fc];
                        const int new_val = val + fc * i;
                        if (num_vals + fc <= even and new_val <= target) {
                            new_dp[num_vals + fc][new_val] += dp[num_vals][val] * ways_t;
                        }
                    }
                }
            }
            swap(dp, new_dp);
        }
        
        const mint ans = dp[even][target] * fac[even] * fac[odd];
        return ans.x;
    }
};",1441299220
Xiaomeng Yang,yangxm,58,3627,cpp,"#define X first
#define Y second

constexpr int MAX = 64;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti3 = tuple<int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX];
priority_queue<Ti3, vector<Ti3>, greater<Ti3>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y] = 0;
  que.emplace(0, src.X, src.Y);
  while (!que.empty()) {
    auto [d, x, y] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y];
    }
    if (d > dis[dst.X][dst.Y]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y]) + 1;
      if (dis[xx][yy] > dis[x][y] + w) {
        dis[xx][yy] = dis[x][y] + w;
        que.emplace(dis[xx][yy], xx, yy);
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441295829
Xiaomeng Yang,yangxm,58,3628,cpp,"#define X first
#define Y second

constexpr int MAX = 1024;
constexpr int INF = 0x3F3F3F3F;
constexpr int DX[] = {0, -1, 0, 1};
constexpr int DY[] = {-1, 0, 1, 0};

using Pii = pair<int, int>;
using Ti4 = tuple<int, int, int, int>;

int mat[MAX][MAX], dis[MAX][MAX][2];
priority_queue<Ti4, vector<Ti4>, greater<Ti4>> que;

int Dijkstra(const Pii& src, const Pii& dst) {
  memset(dis, 0x3F, sizeof(dis));
  while (!que.empty()) {
    que.pop();
  }
  dis[src.X][src.Y][0] = 0;
  que.emplace(0, src.X, src.Y, 0);
  while (!que.empty()) {
    auto [d, x, y, k] = que.top();
    que.pop();
    if (x == dst.X && y == dst.Y) {
      return dis[dst.X][dst.Y][k];
    }
    if (d > dis[dst.X][dst.Y][k]) {
      continue;
    }
    for (int i = 0; i < 4; ++i) {
      int xx = x + DX[i], yy = y + DY[i];
      if (mat[xx][yy] == -1) {
        continue;
      }
      int w = max(0, mat[xx][yy] - dis[x][y][k]) + k + 1;
      if (dis[xx][yy][k ^ 1] > dis[x][y][k] + w) {
        dis[xx][yy][k ^ 1] = dis[x][y][k] + w;
        que.emplace(dis[xx][yy][k ^ 1], xx, yy, (k ^ 1));
      }
    }
  }
  return -1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
      int n = moveTime.size(), m = moveTime[0].size();
      memset(mat, -1, sizeof(mat));
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          mat[i + 1][j + 1] = moveTime[i][j];
        }
      }
      return Dijkstra(make_pair(1, 1), make_pair(n, m));
    }
};",1441299693
Xiaomeng Yang,yangxm,58,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      int n = num.length(), x = 0, y = 0;
      for (int i = 0; i < n; ++i) {
        int v = num[i] - '0';
        if (i & 1) {
          x += v;
        } else {
          y += v;
        }
      }
      return x == y;
    }
};",1441281670
Xiaomeng Yang,yangxm,58,3637,cpp,"constexpr int MAXM = 128;
constexpr int MAXN = 1024;
constexpr int MOD = 1000000007;

using i64 = long long;

int cnt[16];
i64 c[MAXM][MAXM], dp[MAXM][MAXN];

void Init() {
  memset(c, 0, sizeof(c));
  for (int i = 0; i < MAXM; ++i) {
    c[i][0] = 1;
    for (int j = 1; j <= i; ++j) {
      c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;
    }
  }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
      static bool init = []() {
        Init();
        return true;
      }();
      
      int n = num.length(), m = 0;
      memset(cnt, 0, sizeof(cnt));
      for (char ch : num) {
        int x = ch - '0';
        m += x;
        ++cnt[x];
      }
      
      if (m & 1) {
        return false;
      }
      
      memset(dp, 0, sizeof(dp));
      for (int i = 0; i <= cnt[0]; ++i) {
        dp[i][0] = 1;
      }
      int v = cnt[0], w = 0;
      for (int i = 1; i < 10; ++i) {
        if (cnt[i] == 0) {
          continue;
        }
        v += cnt[i];
        w += cnt[i] * i;
        for (int j = v; j >= 0; --j) {
          for (int k = w; k >= 0; --k) {
            i64 sum = 0;
            for (int d = 0; d <= j && d <= cnt[i] && d * i <= k; ++d) {
              int p = j, q = v - j;
              i64 cur = c[p][d] * c[q][cnt[i] - d] % MOD;
              sum = (sum + dp[j - d][k - d * i] * cur) % MOD;
            }
            dp[j][k] = sum;
          }
        }
      }
      return dp[(n + 1) / 2][m / 2];
    }
};",1441327081
raincoat911,raincoat911,60,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<int>> dp(r, vector<int>(c, INT_MAX));
        dp[0][0] = 0;
        priority_queue<array<int, 3>, vector<array<int, 3>>, greater<>> pq;
        pq.push({0,0,0});
        vector<vector<bool>> seen(r, vector<bool>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2];
            if (seen[i][j]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j] = true;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y]) continue;
                int nt = max(t, moveTime[x][y]) + 1;
                if (dp[x][y] > nt) {
                    dp[x][y] = nt;
                    pq.push({nt, x, y});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441294180
raincoat911,raincoat911,60,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int r = moveTime.size(), c = moveTime[0].size();
        vector<vector<array<int, 2>>> dp(r, vector<array<int, 2>>(c, {INT_MAX, INT_MAX}));
        dp[0][0][0] = 0;
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<>> pq;
        pq.push({0,0,0,0});
        vector<vector<array<bool, 2>>> seen(r, vector<array<bool, 2>>(c));
        while (!pq.empty()) {
            auto p = pq.top(); pq.pop();
            int t = p[0], i = p[1], j = p[2], z = p[3];
            if (seen[i][j][z]) continue;
            if (i == r - 1 && j == c - 1) {
                return t;
            }
            seen[i][j][z] = true;
            int nz = z ^ 1;
            for (int k = 0; k < 4; k++) {
                int x = i + d[k], y = j + d[k + 1];
                if (x < 0 || x == r || y < 0 || y == c || seen[x][y][nz]) continue;
                int nt = max(t, moveTime[x][y]) + (z == 0 ? 1 : 2);
                if (dp[x][y][nz] > nt) {
                    dp[x][y][nz] = nt;
                    pq.push({nt, x, y, nz});
                }
            }
        }
        return 0;
    }
    
private:
    int d[5] = {-1,0,1,0,-1};
};",1441298517
raincoat911,raincoat911,60,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0,  e = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return o == e;
    }
};",1441281089
raincoat911,raincoat911,60,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int l = num.size(), o = (l + 1) / 2, e = l - o, s = 0;
        vector<int> arr(10);
        for (char c : num) {
            arr[c - '0']++;
            s += c - '0';
        }
        if (s & 1) return 0;
        int n = 0;
        vector<vector<int>> dp(s / 2 + 1, vector<int>(o + 1));
        arr2.resize(o + 1, vector<int>(o + 1));
        dp[0][0] = 1;
        for (int i = 0; i < 10; i++) {
            // cout << i << endl;
            if (arr[i] == 0) continue;
            vector<vector<int>> dp2(s / 2 + 1, vector<int>(o + 1));
            for (int j = 0; j < dp.size(); j++) {
                for (int d = 0; d <= o; d++) {
                    if (dp[j][d] == 0) continue;
                    for (int k = 0; k <= arr[i] && d + k <= o && j + k * i < dp.size(); k++) {
                        if (e - (n - d) < arr[i] - k) continue;
                        // cout << i << "" "" << j << "" "" << k << "" "" << d << endl;
                        // cout << j + k * i << "" "" << d + k << "" "" << o - d << "" "" << k << "" "" << e - (n - d) << "" "" << arr[i] - k << endl;
                        dp2[j + k * i][d + k] += (((long)dp[j][d] * cnk(o - d, k)) % M * cnk(e - (n - d), arr[i] - k)) % M;
                        dp2[j + k * i][d + k] %= M;
                        // cout << ""done"" << endl;
                    }
                }
            }
            swap(dp, dp2);
            n += arr[i];
        }
        // cout << ""aaa"" << endl;
        return dp.back().back();
    }
    
private:
    int M = 1e9 + 7;
    vector<vector<int>> arr2;
    
    int cnk(int n, int k) {
        // cout << n << "" "" << k << endl;
        if (n == k || k == 0) return 1;
        if (arr2[n][k]) return arr2[n][k];
        return arr2[n][k] = (cnk(n - 1, k - 1) + cnk(n - 1, k)) % M;
    }
};",1441328822
OTTFF,OTTFF,62,3627,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

class Solution {
public:
typedef array<int, 3> A3;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        vector<vector<int>> dis(n, vector<int>(m, INF));
        vector<vector<int>> vis(n, vector<int>(m, 0));

        priority_queue<A3, vector<A3>, greater<A3>> qu;
        dis[0][0] = 0;
        qu.push({0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny] = qu.top(); qu.pop();
            if (vis[nx][ny]) continue;
            vis[nx][ny] = 1;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny]) + 1;
                if (dis[x][y] <= nd) {
                    continue;
                }
                dis[x][y] = nd;
                qu.push({nd, x, y});
            }
        }

        return dis[n - 1][m - 1];
    }
};",1441298205
OTTFF,OTTFF,62,3628,cpp,"int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

const int M = 755;
int dis[M][M][2];
int vis[M][M][2];

class Solution {
public:
typedef array<int, 4> A4;
    int INF = 0x3f3f3f3f;
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        // vector<vector<int>> dis(n, vector<int>(m, INF));
        // vector<vector<int>> vis(n, vector<int>(m, 0));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                dis[i][j][0] = dis[i][j][1] = INF;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }

        priority_queue<A4, vector<A4>, greater<A4>> qu;
        dis[0][0][0] = 0;
        qu.push({0, 0, 0, 0});

        while (!qu.empty()) {
            auto [_, nx, ny, nt] = qu.top(); qu.pop();
            if (vis[nx][ny][nt]) continue;
            vis[nx][ny][nt] = 1;

            // cout << nx << ' ' << ny << ' ' << nt << ' ' << dis[nx][ny][nt] << endl;

            if (nx == n - 1 && ny == m - 1) break;

            for (int i = 0; i < 4; i++) {
                int x = dx[i] + nx, y = dy[i] + ny;
                if (x < 0 || n <= x || y < 0 || m <= y || vis[x][y][nt]) {
                    continue;
                }
                int nd = max(a[x][y], dis[nx][ny][nt]) + (nt ? 2 : 1);
                if (dis[x][y][nt ^ 1] <= nd) {
                    continue;
                }
                dis[x][y][nt ^ 1] = nd;
                qu.push({nd, x, y, nt ^ 1});
            }
        }

        return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441304611
OTTFF,OTTFF,62,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int i = 0;
        for (char c : num) {
            if (i & 1) {
                sum += c - '0';
            } else {
                sum -= c - '0';
            }
            i++;
        }
        return sum == 0;
    }
};",1441281671
OTTFF,OTTFF,62,3637,cpp,"template<long long Mo=998244353> struct ModInt {
  static long long MO;
  static void setMo(long long mo) { MO = mo; }
  long long x;
  ModInt(long long x=0) : x(x){ norm(); }
  friend istream &operator>>(istream& in, ModInt &B) { in>>B.x; return in; }
  friend ostream &operator<<(ostream& out, const ModInt &B) { 
    out<<B.x; return out; }
  // ModInt operator=(int x_) { x=x_; norm(); return *this; }
  void norm() { x = (x%MO + MO) % MO; }
  long long get() { return x; }

  ModInt operator-() const { return ModInt(MO - x); }
  ModInt operator+=(const ModInt &B) { x+=B.x; if(x>=MO) x-=MO; return *this; }
  ModInt operator-=(const ModInt &B) { x-=B.x; if(x<0) x+=MO; return *this; }
  ModInt operator*=(const ModInt &B) { x=x*B.x%MO; return *this; }
  ModInt operator+(const ModInt &B) const { ModInt ans=*this; return ans+=B; }
  ModInt operator-(const ModInt &B) const { ModInt ans=*this; return ans-=B; }
  ModInt operator*(const ModInt &B) const { ModInt ans=*this; return ans*=B; }
  ModInt operator^(long long n) const  {
    ModInt a=*this; ModInt ans(1);
    while(n) { if(n&1) ans*=a; a*=a; n>>=1; }
    return ans;
  }
  ModInt inv() const { return (*this)^(MO-2); } // if MO is prime
  ModInt operator/=(const ModInt &B) { (*this)*=B.inv(); return *this; }
  ModInt operator/(const ModInt &B) const { ModInt ans=*this; return ans/=B; }

  bool operator<(const ModInt &B) const { return x<B.x; }
  bool operator==(const ModInt &B) const { return x==B.x; }
  bool operator!=(const ModInt &B) const { return x!=B.x; }
};
template<long long Mo> long long ModInt<Mo>::MO = Mo;
// typedef ModInt<998244353> Mint;
typedef ModInt<1'000'000'007> Mint;

vector<Mint> inv, fa, ifa;
void init_mod(int n) {
    inv.assign(n + 1, Mint(1));
    fa.assign(n + 1, Mint(1));
    ifa.assign(n + 1, Mint(1));
    for(int i = 2; i <= n; i++) {
        fa[i] = fa[i-1] * i;
        inv[i] = Mint(Mint::MO - Mint::MO / i) * inv[Mint::MO % i];
        ifa[i] = inv[i] * ifa[i-1];
    }
}
inline Mint C(int n,int m) {
  return (m<0 || n<m) ? Mint(0) : fa[n]*ifa[m]*ifa[n-m]; }
inline Mint A(int n,int m) { return fa[n]*ifa[n-m]; }

const int M = 85;
int f = 0;
void init() {
    if (f) return;
    f = 1;
    init_mod(M);
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        
        int n = s.length();
        int sum = 0;
        vector<int> cnt(10);
        for (int i = 0; i < n; i++) {
            sum += s[i] - '0';
            cnt[s[i] - '0']++;
        }
        if (sum & 1) {
            return 0;
        } 

        int m = n / 2;
        int tar = sum / 2;

        vector<vector<Mint>> dp(m + 1, vector<Mint>(tar + 1)), tmp(m + 1, vector<Mint>(tar + 1));
        dp[0][0] = 1;

        int tot = 0;
        for (int v = 0; v < 10; v++) {
            swap(dp, tmp);
            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= tar; j++) {
                    dp[i][j] = 0;
                }
            }

            for (int sel = 0; sel <= cnt[v]; sel++) {
                for (int i = 0; i + sel <= m; i++) {
                    for (int j = 0; j + v * sel <= tar; j++) {
                        dp[i + sel][j + v * sel] += tmp[i][j] * C(m - i, sel) * C(n - m - (tot - i), cnt[v] - sel);
                    }
                }
            }

            tot += cnt[v];
        }

        return dp[m][tar].x;
    }
};",1441322604
Wanjun Li,wjli,63,3627,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					tt = max(moveTime[xx][yy] + 1, t + 1);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};",1441291066
Wanjun Li,wjli,63,3628,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		int n = moveTime.size(), m = moveTime[0].size(), i, j, k, INF = 2E9, x, y, xx, yy, t, tt, dt;
		int v[4][2] = { 1,0,0,1,-1,0,0,-1 };
		VVI dp(n, VI(m, INF));
		priority_queue<VI> q;	// -t, x, y
		dp[0][0] = 0;
		q.push({ 0,0, 0 });

		while (!q.empty()) {
			t = -q.top()[0]; 
			x = q.top()[1];
			y = q.top()[2];
			q.pop();
			if (t > dp[x][y]) continue;

			FOR(k, 4) {
				xx = x + v[k][0], yy = y + v[k][1];
				if (xx >= 0 && xx < n && yy >= 0 && yy < m) {
					if ((xx + yy) & 1) dt = 1;
					else dt = 2;
					tt = max(moveTime[xx][yy] + dt, t + dt);
					if (tt < dp[xx][yy]) {
						dp[xx][yy] = tt;
						q.push({ -tt, xx, yy });
					}
				}
			}
		}

		int ans = dp[n - 1][m - 1];
		return ans;
	}
};

",1441292925
Wanjun Li,wjli,63,3636,cpp,"


// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class Solution {
public:
	bool isBalanced(string num) {
		int n = num.size(), i, j, k;
		VI s(2, 0);
		FOR(i, n) s[i & 1] += num[i] - '0';
		return s[0] == s[1];
	}
};
",1441281367
Wanjun Li,wjli,63,3637,cpp,"

// COPY ALL MACROS BELOW

typedef long long LL;
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define LB lower_bound
#define UB upper_bound
#define SZ(x) ((int)x.size())
#define LEN(x) ((int)x.length())
#define ALL(x) begin(x), end(x)
#define RSZ resize
#define ASS assign
#define REV(x) reverse(x.begin(), x.end());
#define trav(a, x) for (auto& a : x)
typedef pair<LL, LL> PL;
typedef vector<LL> VL;
typedef vector<PL> VPL;
typedef vector<VL> VVL;
typedef vector<VVL> VVVL;
typedef vector<VVVL> VVVVL;
typedef vector<string> VS;
typedef pair<int, int> PI;
typedef vector<int> VI;
typedef vector<PI> VPI;
typedef vector<vector<int>> VVI;
typedef vector<vector<PI>> VVPI;
#define MAX(x) *max_element(ALL(x))
#define MIN(x) *min_element(ALL(x))
#define FOR(i, n) for (int i = 0; i < n; i++) 
#define FOR1(i, n) for (int i = 1; i <= n; i++) 
#define SORT(x) sort(x.begin(), x.end())
#define RSORT(x) sort(x.rbegin(), x.rend())
#define SUM(x) accumulate(x.begin(), x.end(), 0LL)


class factorial {
public:
    LL MAXX, MOD;
    VL f, ff;

    factorial(LL maxx = 200010, LL mod = 998244353) {
        MAXX = maxx;
        MOD = mod;

        f.RSZ(MAXX);
        ff.RSZ(MAXX);

        f[0] = 1;
        for (int i = 1; i < MAXX; i++) f[i] = (f[i - 1] * i) % MOD;
        for (int i = 0; i < MAXX; i++) ff[i] = mul_inv(f[i], MOD);
    }

    long long mul_inv(long long a, long long b)
    {
        long long b0 = b, t, q;
        long long x0 = 0, x1 = 1;
        if (b == 1) return 1;
        while (a > 1) {
            q = a / b;
            t = b, b = a % b, a = t;
            t = x0, x0 = x1 - q * x0, x1 = t;
        }
        if (x1 < 0) x1 += b0;
        return x1;
    }

    long long division(long long a, long long b) {		// (a / b) mod p = ((a mod p) * (b^(-1) mod p)) mod p
        long long ans, inv;
        inv = mul_inv(b, MOD);
        ans = ((a % MOD) * inv) % MOD;
        return ans;
    }

    LL calcc(LL n, LL a) {
        if (n == a) return 1;
        if (n == 0) return 0;
        if (n < a) return 0;
        LL ans = (f[n] * ff[a]) % MOD;
        ans = (ans * ff[n - a]) % MOD;
        return ans;
    }

    LL calcp(LL n, LL a) {
        LL ans = (f[n] * ff[n - a]) % MOD;
        return ans;
    }

    LL ball_in_box(LL box, LL ball) {    // # of ways of putting k balls to n boxes; boxes can be empty
        if (box == 0) return (ball == 0);
        LL ans = calcc(ball + box - 1, ball);
        return ans;
    }


    LL exp(LL base, LL n, LL MODD = -1) {
        LL mod;
        if (MODD == -1) mod = MOD;
        else mod = MODD;

        base %= mod;
        LL ans = 1, x = base, MAXLEVEL = 60, i;

        for (i = 0; i < MAXLEVEL; i++) {
            if ((1LL << i) > n) break;
            if ((1LL << i) & n) ans = (ans * x) % mod;
            x = (x * x) % mod;
        }
        return ans;
    }

    LL exp_abc(LL a, LL b, LL c) {  // a ^ (b ^ c) $ MOD where b and c can be very big
        // https://www.geeksforgeeks.org/find-power-power-mod-prime/#
        // Fermat's Little: a ^ (MOD - 1) = 1 % MOD
        // a ^ (b ^ c) % MOD = a ^ (b ^ c % (MOD - 1)) % MOD

        LL bc = exp(b, c, MOD - 1);
        LL ans = exp(a, bc);
        return ans;
    }


    LL sum_arithmetic_sequence(LL first_item, LL difference, LL n) {
        LL ans, last = (first_item + difference * (n - 1)) % MOD;
        ans = ((first_item + last) * n / 2) % MOD;

        return ans;
    }

    LL sum_geometry_sequence(LL first_item, LL ratio, LL n) {
        LL ans;

        if (ratio == 1) ans = (first_item * n) % MOD;
        else if (n == 1) ans = first_item;
        else {
        https://www.mathsisfun.com/algebra/sequences-sums-geometric.html
            LL rn = exp(ratio, n);
            ans = (first_item * (1 - rn + MOD)) % MOD;
            ans = division(ans, 1 - ratio + MOD) % MOD;
        }
        return ans;
    }
};

class Solution {
public:
	int countBalancedPermutations(string num) {
		LL n = num.length(), i, j, k, ans = 0, MOD = 1000000007, s, m, ss, sss, cc;
		VL ct(10, 0);
		s = 0;
		FOR(i, n) {
			ct[num[i] - '0']++;
			s += num[i] - '0';
		}
        factorial f(n + 100, MOD);

		if (s & 1) return 0;
        ss = s / 2;

		m = n / 2;

		// dp[digit][ct][sum] = # of ways
        VVL dp(m + 1, VL(ss + 1, 0)), dp2 = dp; 
        cc = 0;
        dp[0][0] = 1;
        FOR(i, 10) {
            if (ct[i] == 0) continue;
            cc += ct[i];
            swap(dp, dp2);
            dp.assign(m + 1, VL(ss + 1, 0));

            FOR(j, m + 1) {
                FOR(k, ss + 1) {
                    if (dp2[j][k] == 0) continue;

                    sss = k;
                    FOR(v, ct[i] + 1) {
                        if ((v + j > m) || (sss > ss)) break;
                        
                        LL x = (f.calcc(j + v, v) * f.calcc(cc - (j + v), (ct[i] - v))) % MOD;
						dp[j + v][sss] = (dp[j + v][sss] + dp2[j][k] * x) % MOD;
                        sss += i;
                    }
                }
            }

            k = 0;
        }

        ans = dp[m][ss];

		ans %= MOD;
		return ans;
	}
};

",1441316234
Kishan Jaiswal,kishan_jaiswal,64,3627,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) { return {dx, dy}; }

    vector<pair<int, int>> getDirections() {
        return {addDirection(-1, 0), addDirection(1, 0), addDirection(0, -1),
                addDirection(0, 1)};
    }

    int maxSum(int a, int b) { return max(a, b) + 1; }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();

        vector<vector<int>> minTime(
            rows, vector<int>(cols, numeric_limits<int>::max()));
        minTime[0][0] = 0;

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            queue;
        queue.push({0, 0, 0});

        auto directions = getDirections();

        while (!queue.empty()) {
            auto [currentTime, x, y] = queue.top();
            queue.pop();

            if (x == rows - 1 && y == cols - 1) {
                return currentTime;
            }

            if (currentTime > minTime[x][y]) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int newX = x + dx;
                int newY = y + dy;

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int newTime = maxSum(currentTime, moveTime[newX][newY]);

                    if (newTime < minTime[newX][newY]) {
                        minTime[newX][newY] = newTime;
                        queue.push({newTime, newX, newY});
                    }
                }
            }
        }

        return -1;
    }
};",1441321018
Kishan Jaiswal,kishan_jaiswal,64,3628,cpp,"class Solution {
public:
    pair<int, int> addDirection(int dx, int dy) {
    return {dx, dy};
}

vector<pair<int, int>> getDirections() {
    return {addDirection(1, 0), addDirection(-1, 0), addDirection(0, 1), addDirection(0, -1)};
}

int calculateNextTime(int time, int moveTime, int moveDuration) {
    return max(time, moveTime) + moveDuration;
}

int minTimeToReach(vector<vector<int>>& moveGrid) {
    int rows = moveGrid.size(), cols = moveGrid[0].size();
    vector<vector<array<int, 2>>> minDist(rows, vector<array<int, 2>>(cols, {numeric_limits<int>::max(), numeric_limits<int>::max()}));
    
    minDist[0][0][0] = 0;
    
    priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> queue;
    queue.push({0, 0, 0, 0});

    auto directions = getDirections();

    while (!queue.empty()) {
        auto [time, x, y, parity] = queue.top();
        queue.pop();

        if (x == rows - 1 && y == cols - 1) {
            return time;
        }

        if (time > minDist[x][y][parity]) {
            continue;
        }

        int moveDuration = (parity == 0) ? 1 : 2;

        for (auto [dx, dy] : directions) {
            int newX = x + dx;
            int newY = y + dy;

            if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                int nextTime = calculateNextTime(time, moveGrid[newX][newY], moveDuration);
                int nextParity = 1 - parity;

                if (nextTime < minDist[newX][newY][nextParity]) {
                    minDist[newX][newY][nextParity] = nextTime;
                    queue.push({nextTime, newX, newY, nextParity});
                }
            }
        }
    }

    return -1;
}
};",1441322853
Kishan Jaiswal,kishan_jaiswal,64,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long  cnt=1;
        int n=num.size();
        long long  sum1=0;
        long long  sum2=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                sum1+=(num[i]-'0')%10;
            }else{
                sum2+=(num[i]-'0')%10;
            }
        }
        return sum1==sum2?true:false;
    }
};",1441301786
Kishan Jaiswal,kishan_jaiswal,64,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>
#include <numeric>

using namespace std;

class Solution {
public:
    int countBalancedPermutations(string n) {
        const int MOD = 1000000007;
        int length = n.length();
        int totalSum = 0;
        vector<int> digitCount(10, 0);
        
        for (char digit : n) {
            digitCount[digit - '0']++;
            totalSum += (digit - '0');
        }
        if (totalSum % 2 != 0) return 0;
        
        int halfSum = totalSum / 2;
        int halfLength = (length + 1) / 2;
        vector<long> factorials(length + 1);
        factorials[0] = 1;
        
        for (int i = 1; i <= length; i++) 
            factorials[i] = multiply(factorials[i - 1], i, MOD);
        
        vector<long> inverseFactorials(length + 1);
        inverseFactorials[length] = calculateModInverse(factorials[length], MOD);
        
        for (int i = length - 1; i >= 0; i--) 
            inverseFactorials[i] = multiply(inverseFactorials[i + 1], (i + 1), MOD);
        
        vector<vector<long>> dpTable(halfLength + 1, vector<long>(halfSum + 1, 0));
        dpTable[0][0] = 1;

        for (int digit = 0; digit <= 9; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int k = halfLength; k >= 0; k--) {
                for (int s = halfSum; s >= 0; s--) {
                    if (dpTable[k][s] == 0) continue;
                    for (int t = 1; t <= digitCount[digit] && k + t <= halfLength && s + digit * t <= halfSum; t++) {
                        dpTable[k + t][s + digit * t] = add(dpTable[k + t][s + digit * t], multiply(dpTable[k][s], computeCombination(digitCount[digit], t, factorials, inverseFactorials, MOD), MOD), MOD);
                    }
                }
            }
        }

        long ways = dpTable[halfLength][halfSum];
        long result = multiply(factorials[halfLength], factorials[length - halfLength], MOD);
        
        for (int digit = 0; digit <= 9; digit++) {
            result = multiply(result, inverseFactorials[digitCount[digit]], MOD);
        }
        
        result = multiply(result, ways, MOD);
        return static_cast<int>(result);
    }

private:
    long add(long a, long b, int mod) {
        return (a + b) % mod;
    }

    long multiply(long a, long b, int mod) {
        return (a * b) % mod;
    }

    long calculateModInverse(long a, int mod) {
        long result = 1;
        long exponent = mod - 2;
        long base = a;
        while (exponent > 0) {
            if ((exponent & 1) == 1) {
                result = multiply(result, base, mod);
            }
            base = multiply(base, base, mod);
            exponent >>= 1;
        }
        return result;
    }

    long computeCombination(int n, int k, const vector<long>& factorials, const vector<long>& invFactorials, int mod) {
        if (k > n) return 0;
        return multiply(factorials[n], multiply(invFactorials[k], invFactorials[n - k], mod), mod);
    }
};
",1441329757
SheenYangYun,SheenYangYun,65,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vvi dp = init(n, m);
        dp[0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(stateStart(0, 0, 0));
        vector<int> directions = { -1, 0, 1, 0, -1 };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (ff(current, n, m)) return current.time;
            if (fff(current, dp)) continue;
            children(current, moveTime, dp, pq, directions, n, m);
        }
        return -1;
    }

private:
    vvi init(int n, int m) {
        return vvi(n, vector<int>(m, INT32_MAX));
    }

    State stateStart(int time, int x, int y) {
        return State{ time, x, y };
    }

    bool ff(const State& state, int n, int m) {
        return state.x == n - 1 && state.y == m - 1;
    }

    bool fff(const State& state, const vvi& dp) {
        return state.time > dp[state.x][state.y];
    }

    bool chek(int x, int y, int n, int m) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    void children(const State& current, const vvi& moveTime, 
                         vvi& dp, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vector<int>& directions, int n, int m) {
        for(int k = 0; k < 4; ++k){
            int newX = current.x + directions[k];
            int newY = current.y + directions[k + 1];
            if(chek(newX, newY, n, m)){
                int newTime = max(current.time, moveTime[newX][newY]) + 1;
                if(newTime < dp[newX][newY]){
                    dp[newX][newY] = newTime;
                    pq.push(stateStart(newTime, newX, newY));
                }
            }
        }
    }
};

",1441321118
SheenYangYun,SheenYangYun,65,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

struct State {
    int time;
    int x;
    int y;
    int p;
};

struct cmp {
    bool operator()(const State& a, const State& b) const {
        return a.time > b.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vvi> dist = init(n, m);
        dist[0][0][0] = 0;
        priority_queue<State, vector<State>, cmp> pq;
        pq.push(start(0, 0, 0, 0));
        vvi dirs = { {1,0},{-1,0},{0,1},{0,-1} };
        while (!pq.empty()) {
            State current = pq.top();
            pq.pop();
            if (solved(current, n, m)) return current.time;
            if (possible(current, dist)) continue;
            chuildren(current, moveTime, dist, pq, dirs, n, m);
        }
        return -1;
    }

private:
    vector<vvi> init(int n, int m) {
        return vector<vvi>(n, vvi(m, vector<int>(2, INT32_MAX)));
    }

    State start(int time, int x, int y, int p) {
        return State{ time, x, y, p };
    }

    bool solved(const State& state, int n, int m) {
        return state.x == n -1 && state.y == m -1;
    }

    bool possible(const State& state, const vector<vvi>& dist) {
        return state.time > dist[state.x][state.y][state.p];
    }

    bool check(int x, int y, int n, int m) {
        return x >=0 && x <n && y >=0 && y <m;
    }

    void chuildren(const State& current, const vvi& moveTime, 
                         vector<vvi>& dist, 
                         priority_queue<State, vector<State>, cmp>& pq,
                         const vvi& dirs, int n, int m) {
        int moveDuration = current.p == 0 ? 1 : 2;
        for(auto &d : dirs){
            int nx = current.x + d[0];
            int ny = current.y + d[1];
            if(check(nx, ny, n, m)){
                int nextTime = max(current.time, moveTime[nx][ny]) + moveDuration;
                int nextP = current.p == 0 ? 1 : 0;
                if(nextTime < dist[nx][ny][nextP]){
                    dist[nx][ny][nextP] = nextTime;
                    pq.push(start(nextTime, nx, ny, nextP));
                }
            }
        }
    }
};
",1441314554
SheenYangYun,SheenYangYun,65,3636,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vvi(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    bool isBalanced(const string &num)
    {
        int cnt1 = 0;
        int cnt2 = 0;

        for (int i = 0; i < num.size(); ++i)
        {
            int digit = num[i] - '0';
            if (i & 1)
            {
                cnt2 += digit;
                continue;
            }

            cnt1 += digit;
        }

        return cnt1 == cnt2;
    }
};
",1441323172
SheenYangYun,SheenYangYun,65,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define loop(i, a, n) for (lli i = (a); i < (n); ++i)
#define loopD(i, a, n) for (lli i = (a); i >= (n); --i)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define sz(a) ((int)a.size())
#define YES cout << ""YES"" << endl;
#define NO cout << ""NO"" << endl;
#define endl '\n'
#define fastio std::ios::sync_with_stdio(false), cin.tie(NULL), cout.tie(NULL);
#define pb push_back
#define pp pop_back()
#define fi first
#define si second
#define v(a) vector<int>(a)
#define vv(a) vector<vector<int>>(a)
#define present(c, x) ((c).find(x) != (c).end())
#define set_bits __builtin_popcountll
// #define MOD 1000000007
// #define int long long

typedef long long lli;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<lli, lli> pll;
typedef pair<int, int> pii;
typedef unordered_map<int, int> umpi;
typedef map<int, int> mpi;
typedef vector<pii> vp;
typedef vector<lli> vll;
typedef vector<vll> vvll;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int freq[10] = {0};
        for (char c : num)
        {
            freq[c - '0']++;
        }

        int n = num.size();
        int nEven = (n + 1) / 2;
        int nOdd = n / 2;

        ll sum = 0;
        for (int d = 0; d < 10; d++)
        {
            sum += (ll)d * freq[d];
        }

        if (sum & 1)
        {
            return 0;
        }

        ll des = sum / 2;

        vector<vector<ll>> dp(nEven + 1, vector<ll>(des + 1, 0));
        dp[0][0] = 1;

        vector<ll> fact(n + 1, 1);
        for (int i = 1; i <= n; i++)
        {
            fact[i] = fact[i - 1] * i % MOD;
        }

        auto pow_mod = [&](ll a, ll b) -> ll
        {
            ll res = 1;
            a %= MOD;
            while (b > 0)
            {
                if (b & 1)
                {
                    res = res * a % MOD;
                }
                a = a * a % MOD;
                b >>= 1;
            }
            return res;
        };

        vector<ll> invFact(n + 1, 1);
        invFact[n] = pow_mod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
        {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }

        ll inFact = 1;
        for (int d = 0; d < 10; d++)
        {
            inFact = inFact * invFact[freq[d]] % MOD;
        }

        for (int d = 0; d < 10; d++)
        {
            int c = freq[d];
            if (c == 0)
                continue;

            for (int k = nEven; k >= 0; k--)
            {
                for (ll s = des; s >= 0; s--)
                {
                    if (dp[k][s] == 0)
                    {
                        continue;
                    }

                    int max_m = min(c, nEven - k);
                    for (int m = 1; m <= max_m; m++)
                    {
                        ll newK = k + m;
                        ll newS = s + (ll)d * m;
                        if (newS > des)
                        {
                            break;
                        }

                        ll comb_val = fact[c] * invFact[m] % MOD;
                        comb_val = comb_val * invFact[c - m] % MOD;

                        dp[newK][newS] = (dp[newK][newS] + dp[k][s] * comb_val) % MOD;
                    }
                }
            }
        }

        ll ans = dp[nEven][des];
        if (ans != 0)
        {

            ans = ans * fact[nEven] % MOD;
            ans = ans * fact[nOdd] % MOD;
            ans = ans * inFact % MOD;

            return (int)(ans);
        }

        return 0;
    }
};
",1441307925
Tin,tin_le,67,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, std::greater<array<ll, 3>>> minHeap;
        minHeap.push({0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<ll>> dp(n, vector<ll>(m, INF));
        dp[0][0] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)(cost + 1), (ll)moveTime[row][col] + 1);
                if(newCost < dp[row][col]) {
                    dp[row][col] = newCost;
                    minHeap.push({newCost, row, col});
                }
            }
        }
        return -1;
    }
};",1441296900
Tin,tin_le,67,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using ll = long long;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, std::greater<array<ll, 4>>> minHeap;
        minHeap.push({0, 0, 0, 0});
        int n = moveTime.size(), m = moveTime[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dp(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        dp[0][0][0] = dp[0][0][1] = 0;
        const vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // UP, DOWN, LEFT, RIGHT
        while(!minHeap.empty()) {
            auto [cost, i, j, k] = minHeap.top(); minHeap.pop();
            if(i == n - 1 && j == m - 1) return cost;
            if(cost > dp[i][j][k]) continue;
            for(auto &dir : dirs) {
                int row = i + dir[0], col = j + dir[1];
                if(row < 0 || col < 0 || row >= n || col >= m) continue;
                ll newCost = max((ll)cost, (ll)moveTime[row][col]) + (k == 0 ? 1 : 2);
                if(newCost < dp[row][col][!k]) {
                    dp[row][col][!k] = newCost;
                    minHeap.push({newCost, row, col, !k});
                }
            }
        }
        return -1;
    }
};",1441301018
Tin,tin_le,67,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        int n = num.size();
        for(int i = 0; i < n; i++) {
            if(i & 1) odd += num[i] - '0';
            else even += num[i] - '0';
        }
        return odd == even;
    }
};",1441280985
Tin,tin_le,67,3637,cpp,"//████████╗██╗███╗░░██╗  ██╗░░░░░███████╗
//╚══██╔══╝██║████╗░██║  ██║░░░░░██╔════╝
//░░░██║░░░██║██╔██╗██║  ██║░░░░░█████╗░░
//░░░██║░░░██║██║╚████║  ██║░░░░░██╔══╝░░
//░░░██║░░░██║██║░╚███║  ███████╗███████╗
//░░░╚═╝░░░╚═╝╚═╝░░╚══╝  ╚══════╝╚══════╝
//   __________________
//  | ________________ |
//  ||          ____  ||
//  ||   /\    |      ||
//  ||  /__\   |      ||
//  || /    \  |____  ||
//  ||________________||
//  |__________________|
//  \###################\
//   \###################\
//    \        ____       \
//     \_______\___\_______\
// An AC a day keeps the doctor away.

#pragma GCC optimize(""Ofast"")
#pragma GCC optimize (""unroll-loops"")
#pragma GCC target(""popcnt"")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
using namespace std;
template<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
#define vt vector
#define all(x) begin(x), end(x)
#define allr(x) rbegin(x), rend(x)
#define ub upper_bound
#define lb lower_bound
#define db double
#define ld long db
#define ll long long
#define pll pair<ll, ll>    
#define vll vt<ll>  
#define vpll vt<pll>
#define vvpll vt<vpll>
#define vvvll vt<vvll>
#define vi vector<int>
#define pii pair<int, int>
#define vpii vector<pair<int, int>>
#define vs vector<string>
#define vb vector<bool>
#define vvpii vector<vpii>
#define vvi vector<vi>
#define vd vector<db>
#define ar(x) array<int, x>
#define var(x) vector<ar(x)>
#define pq priority_queue
#define mset(m, v) memset(m, v, sizeof(m))
#define pb push_back
#define ff first
#define ss second
#define sv string_view
#define MP make_pair
#define MT make_tuple
#define rsz resize
#define sum(x) accumulate(all(x), 0LL)
#define srt(x) sort(all(x))
#define srtR(x) sort(allr(x))
#define srtU(x) sort(all(x)), (x).erase(unique(all(x)), (x).end())
#define rev(x) reverse(all(x))
#define gcd(a, b) __gcd(a, b)
#define lcm(a, b) (a * b) / gcd(a, b)
#define MAX(a) *max_element(all(a)) 
#define MIN(a) *min_element(all(a))
const static ll INF = 1LL << 60;
const static int MK = 20;
const static int MX = 2e6 + 5;
const static int MOD = 1e9 + 7;
int modExpo(ll base, ll exp, ll mod) { ll res = 1; base %= mod; while(exp) { if(exp & 1) res = (res * base) % mod; base = (base * base) % mod; exp >>= 1; } return res; }
class Combinatoric {    
    public: 
    int n;  
    vll fact, inv;   
    Combinatoric(int n) {   
        this->n = n;    
        fact.rsz(n + 1), inv.rsz(n + 1);
        init();
    }
        
    void init() {   
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {   
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        inv[n] = modExpo(fact[n], MOD - 2, MOD);
        for(int i = n - 1; i >= 0; i--) {   
            inv[i] = (inv[i + 1] * (i + 1)) % MOD;
        }
    }
    
    ll choose(ll a, ll b) {  
		if(a < b) return 0;
        return fact[a] * inv[b] % MOD * inv[a - b] % MOD;
    }
};
class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        int freq[10] = {};
        for(auto& x : s) {
            freq[x - '0']++;
        }
        ll sm = 0;
        for(int i = 0; i <= 9; i++) {
            sm += (ll)i * freq[i];
        }
        if(sm % 2) return 0;
        ll target = sm / 2;
        int k = (n + 1) / 2, l = n / 2;
        Combinatoric comb(n + 1);
        vector<vector<ll>> dp(k + 1, vector<ll>(target + 1));
        dp[0][0] = 1;
        for(int d = 0; d <= 9; d++) {
            if(freq[d] == 0) continue;
            for(int c = k; c >= 0; c--) {
                for(ll S = target; S >= 0; S--) {
                    if(dp[c][S] == 0) continue;
                    for(int cnt = 1; cnt <= freq[d] && cnt <= k - c; cnt++) {
                        if(S + d * cnt > target) break;
                        auto& A = dp[c + cnt][S + d * cnt];
                        A = (A + dp[c][S] * comb.choose(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        ll prod = 1;
        for(int d = 0; d <= 9; d++) {
            prod = prod * comb.fact[freq[d]] % MOD;
        }
        return (dp[k][target]) * comb.fact[k] % MOD * comb.fact[l] % MOD * modExpo(prod, MOD - 2, MOD) % MOD;
    }
};",1441323448
despair of athkatla,nibbas,68,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        vis = [[math.inf] * m for _ in range(n)]
        heap = [(0, 0, 0)]
        vis[0][0] = 0
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y = heapq.heappop(heap)
            if x == n-1 and y == m-1:
                return t
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(t, moveTime[nx][ny]) + 1
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(heap, (nt, nx, ny))",1441292174
despair of athkatla,nibbas,68,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        INF = math.inf
        dist = [[INF]*m for _ in range(n)]
        dist[0][0] = 0
        heap = []
        heappush(heap, (0, 0, 0, 0))
        dirs = [(-1,0),(1,0),(0,-1),(0,1)]
        while heap:
            t, x, y, p = heappop(heap)
            if x == n-1 and y == m-1:
                return t
            if t > dist[x][y]:
                continue
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0<=nx<n and 0<=ny<m:
                    d = 1 if p ==0 else 2
                    nt = max(t, moveTime[nx][ny]) + d
                    if nt < dist[nx][ny]:
                        dist[nx][ny] = nt
                        heappush(heap, (nt, nx, ny, 1 - p))
        return -1",1441298863
despair of athkatla,nibbas,68,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441282709
despair of athkatla,nibbas,68,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
  
  const long long INF = 9223372036854775807;

  #ifndef ONLINE_JUDGE
  #define WATCH(key, val)                                                        \
    printf(""Watched %s ->  %s \n"", key, std::to_string(val).c_str());
  #define WATCH_CONTAINER(key, val)                                              \
    printf(""Watched %s : "", key);                                                \
    for (auto e : val)                                                           \
      printf("" %s"", std::to_string(e).c_str());                                  \
    printf(""\n"");
  #define WATCH_MAP(map)                                                         \
    printf(""Watching Map\n"");                                                    \
    for (auto e : map)                                                           \
      printf(""%s -> %s\n"", std::to_string(e.first).c_str(),                      \
            std::to_string(e.second).c_str());                                  \
    printf(""\n"");
  #else
  #define WATCH(key, val)                                                        \
    do {                                                                         \
    } while (false);
  #define WATCH_CONTAINER(key, val)                                              \
    do {                                                                         \
    } while (false);
  #define WATCH_MAP(map)                                                         \
    do {                                                                         \
    } while (false);
  #endif

  #ifdef FAST_EXECUTION
  #pragma GCC optimize(""O3"")
  #pragma comment(linker, ""/stack:247474112"")
  #endif

  #define REP(n) for(int t=0; t<n; t++)
  #define FOR(i, n) for (i = 0; i < n; i++)
  #define FFOR(i, j, n) for(i = j; j < n; j++)
  #define FOR_S(i, n, k) for (i = 0; i < n; i += k)
  #define RFOR(i, n) for (i = n - 1; i >= 0; i--)
  #define RFOR_S(i, n, k) for (i = n - 1; i >= 0; i -= k)
  #define MAX_OF(x, y) ((x > y) ? x : y)
  #define MIN_OF(x, y) ((x > y) ? y : x)
  #define MIN_IN(A) *(std::min_element(A.begin(), A.end()));
  #define MAX_IN(A) *(std::max_element(A.begin(), A.end()));
  #define MAX_AT(A) (std::max_element(A.begin(), A.end()) - A.begin());
  #define MIN_AT(A) (std::min_element(A.begin(), A.end()) - A.begin());
  #define TESTCASE                                                              \
    int testcase;                                                               \
    std::cin>>testcase;                                                         \
    while(testcase--)
  #define GCD(a,b) std::__gcd(a,b);
  #define LCM(a,b) (a)*((b)/std::__gcd(a,b));
  #define SORT(A) std::sort(A.begin(), A.end());
  #define RSORT(A) std::sort(A.rbegin(), A.rend());
  #define REVERSE(A) std::reverse(A.begin(), A.end());
  #define ANY(container, result, condition)                                      \
    result = false;                                                              \
    for (const auto &e : container)                                              \
      if (condition(e)) {                                                        \
        result = true;                                                           \
        break;                                                                   \
      }
  #define ALL(container, result, condition)                                      \
    result = true;                                                               \
    for (const auto &e : container)                                              \
      if (!condition(e)) {                                                       \
        result = false;                                                          \
        break;                                                                   \
      }
  #ifdef INTERACTIVE_MODE
  #define iprint(...)                                                            \
    printf(__VA_ARGS__);                                                         \
    fflush(stdout);
  #else
  #define iprint(...) printf(__VA_ARGS__);
  #endif

  #define LL long long
  #define L long
  #define ULL unsigned long long
  #define I int
  #define D double
  #define UI unsigned int
  #define VEC(i) std::vector<i>
  #define MAP(a, b) std::map<a, b>
  #define UMAP(a, b) std::unordered_map<a, b>
  #define SET(a) std::set<a>
  #define USET(a) std::unordered_set<a>
  #define MSET(a) std::multiset<a>
  #define STR std::string
  #define PAIR(a,b) std::pair<a,b>
  #define PAIRI std::pair<int, int>
  #define READ_INT(var) scanf(""%d"", &var)
  #define READ_STR(var) std::cin >> var
  #define READ_LONG(var) scanf(""%lld"", &var)
  #define WRITE_INT(var) printf(""%d"", var)
  #define WRITE_LONG(var) printf(""%lld"", var)
  #define WRITE_STR(var) std::cout << var
  #define WRITE_VEC_LL(val)                                                      \
    for (auto e : val)                                                           \
      printf(""%lld "", e);
  #define WRITE_VEC_I(val)                                                       \
    for (auto e : val)                                                           \
      printf(""%d "", e);
      
  #define pb push_back
  #define eb emplace_back


class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> cnt(10, 0);
        int S = 0;
        for (char ch : s) {
            cnt[ch - '0']++;
            S += (ch - '0');
        }
        
        if (S % 2 != 0) return 0;
        
        int T = S / 2;
        int K = (n + 1) / 2;
    
        vector<long long> F(n + 1, 1), IF(n + 1, 1);
        for (int i = 1; i <= n; i++) F[i] = F[i - 1] * i % MOD;

        auto pw = [&](ll a, ll b) -> ll {
            ll R = 1;
            a %= MOD;
            while (b > 0) {
                if (b & 1) R = R * a % MOD;
                a = a * a % MOD;
                b >>= 1;
            }
            return R;
        };
        
        IF[n] = pw(F[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) IF[i] = IF[i + 1] * (i + 1) % MOD;
        
        vector<vector<long long>> dp(K + 1, vector<long long>(T + 1, 0));
        dp[0][0] = 1;
        
        for (int d = 0; d <= 9; d++) {
            if (cnt[d] == 0) continue;
            for (int t = K; t >= 0; t--) {
                for (int s = T; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int x = 1; x <= min(cnt[d], K - t) && s + x * d <= T; x++) {
                        dp[t + x][s + x * d] = (dp[t + x][s + x * d] + dp[t][s] * F[cnt[d]] % MOD * IF[x] % MOD * IF[cnt[d] - x] % MOD) % MOD;
                    }
                }
            }
        }
        
        ll R = dp[K][T] * F[K] % MOD * F[n - K] % MOD;
        for (int d = 0; d <= 9; d++) {
            R = R * IF[cnt[d]] % MOD;
        }
        
        return (int)R;
    }
};
",1441316716
Lucky Orb,megurine,69,3627,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + 1, xx, yy))
        # print(f)
        return f[n - 1][m - 1]
        ",1441300238
Lucky Orb,megurine,69,3628,python3,"inf = 10 ** 15
class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        f = [[inf] * m for _ in range(n)]
        Q = [(0, 0, 0)]
        while Q:
            d, x, y = heappop(Q)
            # print(d, x, y)
            if f[x][y] <= d:
                continue
            f[x][y] = d
            for dx, dy in (-1, 0), (0, -1), (1, 0), (0, 1):
                xx, yy = x + dx, y + dy
                if 0 <= xx < n and 0 <= yy < m:
                    heappush(Q, (max(d, g[xx][yy]) + (x + y) % 2 + 1, xx, yy))
        print(f)
        return f[n - 1][m - 1]
""""""
[[0,58],[27,69]]
71
""""""",1441304557
Lucky Orb,megurine,69,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        return sum(map(int, s[::2])) == sum(map(int, s[1::2]))",1441281574
Lucky Orb,megurine,69,3637,cpp,"#include <bits/stdc++.h>

#ifdef MEGURINE
#include ""algo/debug.h""
#include ""algo/debug_lc.h""
#else
#define debug(...) 42
#endif

using namespace std;

auto __fast_io__ = [] {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    return 0;
}();

#define itr(it) begin(it), end(it)

// @formatter:off
template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a;
        swap(a, m);
        u -= t * v;
        swap(u, v);
    }
    assert(m == 1);
    return u;
}

template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() :
        value() {}

    template <typename U>
    Modular(const U &x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U &x) {
        Type v;
        if (-mod() <= x && x < mod())
            v = static_cast<Type>(x);
        else
            v = static_cast<Type>(x % mod());
        if (v < 0)
            v += mod();
        return v;
    }

    const Type &operator()() const { return value; }

    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }

    constexpr static Type mod() { return T::value; }

    Modular &operator+=(const Modular &other) {
        if ((value += other.value) >= mod())
            value -= mod();
        return *this;
    }

    Modular &operator-=(const Modular &other) {
        if ((value -= other.value) < 0)
            value += mod();
        return *this;
    }

    template <typename U>
    Modular &operator+=(const U &other) { return *this += Modular(other); }

    template <typename U>
    Modular &operator-=(const U &other) { return *this -= Modular(other); }

    Modular &operator++() { return *this += 1; }
    Modular &operator--() { return *this -= 1; }

    Modular operator++(int) {
        Modular result(*this);
        *this += 1;
        return result;
    }

    Modular operator--(int) {
        Modular result(*this);
        *this -= 1;
        return result;
    }

    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type &operator*=(
        const Modular &rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }

    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type &abs(const Modular &x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename U>
    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);

    template <typename V, typename U>
    friend V &operator>>(V &stream, Modular<U> &number);

    template <typename V>
    operator V() { return (V)value; }

private:
    Type value;
};

template <typename T>
bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }

template <typename T, typename U>
bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }

template <typename T, typename U>
bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }

template <typename T>
bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }

template <typename T, typename U>
bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }

template <typename T>
bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }

template <typename T>
Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }

template <typename T, typename U>
Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }

template <typename T>
Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T, typename U>
Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }

template <typename T>
Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T, typename U>
Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }

template <typename T>
Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T, typename U>
Modular<T> power(const Modular<T> &a, const U &b) {
    if (b < 0)
        return 1 / power(a, -b);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1)
            res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}

template <typename T>
bool IsZero(const Modular<T> &number) {
    return number() == 0;
}

template <typename T>
string to_string(const Modular<T> &number) {
    return to_string(number());
}

// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U &operator<<(U &stream, const Modular<T> &number) {
    return stream << number();
}

// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U &operator>>(U &stream, Modular<T> &number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}

//using ModType = int;
//
//struct VarMod { static ModType value; };
//ModType VarMod::value;
//ModType &md = VarMod::value;
//using Mint = Modular<VarMod>;

// constexpr int md = 998244353;
constexpr int md = 1e9 + 7;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
// @formatter:on

vector<Mint> fact;
vector<Mint> inv_fact;

Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int)fact.size() < n + 1) {
        if (fact.empty()) {
            fact = inv_fact = {1};
            continue;
        }
        fact.push_back(fact.back() * (int)fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        int m = 0, k1 = (s.size() + 1) / 2, k2 = s.size() - k1;
        vector<int> cnt(10);
        for (char x : s)
            m += x - '0', cnt[x - '0']++;
        if (m % 2)
            return 0;
        m /= 2;
        if (m == 0)
            return 1;
        vector f(k2 + 1, vector<Mint>(m + 1));
        f[0][0] = 1;
        int p = 0, q = 0;
        for (int x = 0; x < 10; ++x) {
            if (!cnt[x]) continue;
            vector h(k2 + 1, vector<Mint>(m + 1));
            p += cnt[x], q += cnt[x] * x;
            for (int i = 0; i <= k2 && i + cnt[x] <= p; ++i) {
                for (int j = 0; j <= m; ++j) {
                    for (int k = 0; k <= cnt[x]; ++k) {
                        int ii = i + k, jj = j + x * k;
                        if (ii <= k2 && jj <= m && p - ii <= k1 && q - jj <= m) {
                            h[ii][jj] += f[i][j] * C(k2 - i, k) * C(k1 - (p - cnt[x] - i), cnt[x] - k);
                        }
                    }
                }
            }
            h.swap(f);
        }
        return f[k2][m];
    }
};

#ifdef MEGURINE

int main() {
    freopen(""../input.txt"", ""r"", stdin);
    freopen(""../output.txt"", ""w"", stdout);
    clock_t start_time = clock();
    int T;
    cin >> T;
    getchar();
    while (T--) {
        Solution sol;
        test<string>(sol, &Solution::countBalancedPermutations);
    }
    cout << ""\nExecution Time: "" << static_cast<double>(clock() - start_time) / CLOCKS_PER_SEC * 1000 << ""ms"" << endl;
    return 0;
}

#endif
",1441330841
4dalols,4dalols,70,3627,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441317045
4dalols,4dalols,70,3628,cpp,"class Solution {
public:
    #define T pair<int,pair<int,int>>
    #define fi first
    #define se second
    int minTimeToReach(vector<vector<int>>& g) {
        int n=g.size(),m=g[0].size(); 
        vector<vector<int>> d(n,vector<int>(m,2e9)); 
        d[0][0]=0; 
        priority_queue<T,vector<T>,greater<T>> pq; pq.push({0,{0,0}}); 
        int x[4]={1,0,-1,0},y[4]={0,1,0,-1}; 
        while (!pq.empty()) {
            auto r=pq.top(); pq.pop();
            int t=r.fi,cx=r.se.fi,cy=r.se.se; 
            if (d[cx][cy]<t) continue; 
            for (int i = 0; i < 4; i++) {
                int nx=cx+x[i],ny=cy+y[i]; 
                if (~nx&&nx<n&&~ny&&ny<m) {
                    int nt=max(t,g[nx][ny])+1+(cx+cy)%2; 
                    if (nt<d[nx][ny]) {
                        d[nx][ny]=nt; 
                        pq.push({nt,{nx,ny}}); 
                    }
                }
            }
        }
        return d[n-1][m-1];
    }
};",1441316390
4dalols,4dalols,70,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int t=0,i=1;
        for (auto r:s) {
            t+=i*(r-'0');
            i=-i;
        }
        return t==0;
    }
};",1441318720
4dalols,4dalols,70,3637,cpp,"class Solution {
public:
    const int MX = 100;
    long long F[101], Fi[101], mod=1e9+7;
     
    long long pw(long long b, long long e) {
    	int x=1;
    	while (e) {
    		if (e%2) x=x*b%mod; 
    		b=b*b%mod; 
    		e/=2; 
    	}
    	return x;
    }
     
    long long nCk(int n, int k) {
        if (k>n||k<0) return 0;
        return F[n]*Fi[k]%mod*Fi[n-k]%mod;
    }
     
    void initC() {
    	F[0]=1;
    	for (int i = 1; i <= MX; i++) F[i]=F[i-1]*i%mod;
        Fi[MX]=pw(F[MX],mod-2);
    	for (int i = MX; i; i--) Fi[i-1]=Fi[i]*i%mod;
    }
     
    int countBalancedPermutations(string s) {
        int n= s.size(); 
        initC();
        int t=0;
        map<int,int> m; 
        for (auto r:s) {
            m[r-'0']++;
            t+=r-'0'; 
        }
        if (t%2) return 0;
        vector<vector<long long>> dp(n+1,vector<long long>(t+1)); dp[0][0]=1; 
        int x=0;
        for (auto [a,b]:m) {
            x+=b;
        vector<vector<long long>> dp2(n+1,vector<long long>(t+1));
            // cout << a << "" "" << b << endl; 
            for (int i = 0; i <= b; i++) {
                for (int j = n; j>=i; j--) {
                    for (int k=t;k>=a*i;k--) {
                        (dp2[j][k]+=dp[j-i][k-a*i]*nCk(j,i)%mod*nCk(x-j,b-i))%=mod;
                    }
                }
            }
            dp=dp2;
        // for (auto r:dp) {
        //     for (int j:r) cout << j << "" ""; cout << ""\n"";
        // } cout << ""\n"";
        }
        return dp[(n+1)/2][t/2]; 
    }
};",1441307470
Brijesh Siwach,Dhongee,71,3627,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 1 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};",1441337879
Brijesh Siwach,Dhongee,71,3628,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:
    int minTimeToReach(vector<vector<int>> a) {
        int n = a.size(), m = a[0].size();
        const ll inf = 1e18;
        int dx[] = {1,-1,0,0};
        int dy[] = {0,0,1,-1};

        priority_queue<array<ll,4>, vector<array<ll,4>>, greater<array<ll,4>>> pq;
        vector<vector<vector<ll>>> dis(n, vector<vector<ll>> (m, vector<ll> (2, inf)));
        
        pq.push({0,0,0,0});

        while(!pq.empty()) {
            auto [d, i, j, mv] = pq.top();
            pq.pop();
            if(dis[i][j][mv] <= d) continue;
            dis[i][j][mv] = d;

            for(int k = 0; k < 4; k++){
                int ni = i + dx[k];
                int nj = j + dy[k];
                if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                int nmv = (mv+1)%2;
                int t = (mv ? 2 : 1);
                if(a[ni][nj] >= d) {
                    if(dis[ni][nj][nmv] > a[ni][nj]+t) {
                // dbg(ni,nj);
                        // dis[ni][nj][nmv] = a[ni][nj]+t;
                        pq.push({a[ni][nj]+t, ni, nj, nmv});
                    }
                }
                else {
                    if(dis[ni][nj][nmv] > d+t) {
                        // dis[ni][nj][nmv] = d+t;
                        pq.push({d+t, ni, nj, nmv});
                    }
                }
            }
        }
        // dbg(dis);

        ll ans = min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
        return ans;
    }
};
",1441336728
Brijesh Siwach,Dhongee,71,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int s1 = 0,s2=0;
        for(int i = 0 ; i < n; i++){
            if(i%2) s1+=(s[i]-'0');
            else s2+=(s[i]-'0');
        }
        return s1==s2;
    }
};",1441339150
Brijesh Siwach,Dhongee,71,3637,cpp,"typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef pair<ll,ll> pl;
typedef vector<pl> vpl;
 
#define all(x) x.begin(), x.end()
#define nl cout<<""\n""
#define ar  array
#define PRECISION 9
#define fast_IO ios_base::sync_with_stdio(false),cin.tie(NULL),cout.tie(NULL)
#define clock() cerr << ""Time elapsed: "" << 1.0 * clock() / CLOCKS_PER_SEC << "" s.\n""
// #define size(x) (int)x.size()
#define pb push_back
#define fr(i,j,k) for(int i=j;i<k;i++)
#define rf(i,j,k) for(int i=k-1;i>j;i--)

mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
// const ll p = uniform_int_distribution<ll>(0, mod - 1)(rng);

#ifdef LOCAL
#include ""../Library/debug.h""
#else 
#define dbg(...) ""SMILE""
#endif

//#define STACK_INCREASE


class Solution {
public:

    ll binpow(ll a,ll b,const int mod){
        ll res=1;
        while(b>0) {
            if(b&1) res=res*a%mod;
            b>>=1;
            a=a*a%mod;
        }
        return res;
    }

    int countBalancedPermutations(string s) {
        int n = s.size();
        const int mod=1e9+7;
        vector<ll> fact(n+1,1);
        vector<ll> inv(n+1);
        for(int i = 1; i <= n; i++){
            fact[i] = fact[i-1] * i % mod;
        }
        for(int i = 0; i <= n; i++){
            inv[i] = binpow(fact[i], mod-2, mod);
        }   

        auto mul = [&](ll x,ll y)->ll{
            return (x%mod * y%mod)%mod;
        };
        auto add = [&](ll x,ll y)->ll{
            return (x%mod + y%mod)%mod;
        };

        vector<ll>f(10);
        int sum = 0;
        for(auto x: s) {
            f[x-'0']++;
            sum += (x-'0');
        }
        const int M = 8e2;
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (n+1, vector<ll> (M, -1)));

        function<ll(int,int,int)>go=[&](int pos,int ot, int ost) -> ll{
            if(pos==10) {
                if(ot != (n+1)/2) return 0;
                if(ost != sum - ost) return 0;
                return mul(fact[ot], fact[n-ot]);
            }

            if(dp[pos][ot][ost] == -1) {
                ll ans = 0;
                for(int i = 0; i <= f[pos]; i++){
                    ll val = mul(inv[i], inv[f[pos]-i]);

                    ans = add(ans, mul(go(pos+1,ot+i,ost+i*pos),val));
                }
                dp[pos][ot][ost]=ans;
            }
            return dp[pos][ot][ost];
        };

        ll ans = go(0, 0, 0);

        return ans;

    }
};
",1441315427
Rastsislau Matusevich,rastsislau,72,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int move_time = max(t, moveTime[new_x][new_y]) + 1;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441301173
Rastsislau Matusevich,rastsislau,72,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        set <pair <int, pair <int, int> > > q;
        vector<vector<bool>>used(n, vector <bool>(m,false));
        q.insert(make_pair(0, make_pair(0,0)));
        vector <int> d(2,-1);
        d[1] = 1;
        while (!q.empty())
        {
            auto cur = *q.begin();
            q.erase(q.begin());
            int x = cur.second.first;
            int y = cur.second.second;
            int t = cur.first;
            if (used[x][y] == true)
            {
                continue;
            }
            used[x][y] = true;
            if (x == n - 1 && y == m-1)
            {
                return cur.first;
            }
            for (int dx = -1; dx <= 1; dx ++)
                {
                    for (int dy = -1; dy <= 1; dy++)
                    {
                        if (dy * dx != 0)
                        {
                            continue;
                        }
                        int new_x = x + dx, new_y = y+ dy;
                        if (new_x < 0 || new_y < 0 || new_x >= n || new_y >= m)
                        {
                            continue;
                        }
                        int cost = (x + y) % 2 + 1;
                        int move_time = max(t, moveTime[new_x][new_y]) + cost;
                        //cout << new_x << "" "" << new_y << "" : "" << move_time << endl;
                        q.insert(make_pair(move_time, make_pair(new_x, new_y)));
                    }
                }
        }
        return -1;
    }
    
};",1441305087
Rastsislau Matusevich,rastsislau,72,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector <int> sum(2,0);
        int i=0;
        for (auto x: num)
            {
                sum[i%2]+=(x-'0');
                i++;
            }
        return sum[0] == sum[1];
    }
};",1441281746
Rastsislau Matusevich,rastsislau,72,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10**9 + 7
        counts = [0] * 10
        total_sum = 0
    
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total_sum += d
    
        if total_sum % 2 != 0:
            return 0
    
        n_even = (n + 1) // 2 
        n_odd = n // 2 
    
        max_s = n_even * 9
    
        max_fact = n + 1
        fact = [1] * (max_fact)
        inv_fact = [1] * (max_fact)
        for i in range(1, max_fact):
            fact[i] = (fact[i - 1] * i) % MOD
        inv_fact[max_fact - 1] = pow(fact[max_fact - 1], MOD - 2, MOD)
        for i in range(max_fact - 2, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD
    
        comb_cache = {}
        def nCk(n, k):
            if k < 0 or k > n:
                return 0
            return (fact[n] * inv_fact[k] % MOD) * inv_fact[n - k] % MOD
    
        dp = [ [0] * (n_even + 1) for _ in range(total_sum // 2 + 1) ]
        dp[0][0] = 1
    
        for d in range(10):
            c_d = counts[d]
            if c_d == 0:
                continue
            dp_new = [row[:] for row in dp]
            for c in range(1, c_d + 1):
                comb_cd_c = nCk(c_d, c)
                delta_s = c * d
                for s in range(total_sum // 2 - delta_s + 1):
                    for k in range(n_even - c +1):
                        dp_new[s + delta_s][k + c] = (dp_new[s + delta_s][k + c] + dp[s][k] * comb_cd_c) % MOD
            dp = dp_new
    
        total_ways = dp[total_sum // 2][n_even]
        if total_ways == 0:
            return 0
    
        numerator = (total_ways * fact[n_even] % MOD) * fact[n_odd] % MOD
        denom = 1
        for c in counts:
            denom = (denom * fact[c]) % MOD
    
        answer = numerator * pow(denom, MOD - 2, MOD) % MOD
        return answer
        ",1441332810
PyIsTheBestLang,PyIsTheBestLang,76,3627,python3,"
def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        dis = [[math.inf] * n for _ in range(m)]
        dis[0][0] = 0
        stack = [(0, 0, 0)]
        while stack:
            d, i, j = heappop(stack)
            
            if dis[i][j] < d:
                continue
            
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0<=a+i<m and 0<=b+j<n:
                    dj = max(d + 1, moveTime[i+a][j+b]+1)
                    if dj < dis[a+i][b+j]:
                        dis[a+i][b+j] = dj
                        heappush(stack, (dj, a+i, j+b))
        ans = dis[-1][-1]
        return ans ",1441302684
PyIsTheBestLang,PyIsTheBestLang,76,3628,python3,"
def max(a, b):
    return a if a > b else b




class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        k = 2
        dis = [[[math.inf] * k for _ in range(n)] for _ in range(m)]
        dis[0][0][0] = 0
        stack = [(0, 0, 0, 0)]
        while stack:
            d, s, i, j = heappop(stack)

            if dis[i][j][s] < d:
                continue
   
            for a, b in [(0, -1), (0, 1), (1, 0), (-1, 0)]:
                if 0 <= a + i < m and 0 <= b + j < n:
                    if s == 0:
                        dj = max(d+s+1, moveTime[i + a][j + b]+1)
                    else:
                        dj = max(d+ s + 1, moveTime[i + a][j + b]+2)  
                        
                    if dj < dis[a + i][b + j][(s+1)%2]:
                        dis[a + i][b + j][(s+1)%2] = dj
                        heappush(stack, (dj, (s+1)%2, a + i, j + b))
        ans = min(dis[-1][-1])
        return ans ",1441309881
PyIsTheBestLang,PyIsTheBestLang,76,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        return sum(int(num[i]) for i in range(1, n, 2)) ==  sum(int(num[i]) for i in range(0, n, 2))",1441302566
PyIsTheBestLang,PyIsTheBestLang,76,3637,python3,"import math
from functools import lru_cache
from itertools import accumulate


# from sortedcontainers import SortedList
# sys.set_int_max_str_digits(0)  # for big number in leet code


def max(a, b):
    return a if a > b else b


def min(a, b):
    return a if a < b else b


mod = 10 ** 9 + 7


class Combinatorics:
    def __init__(self, n, mod):
        assert mod > n
        self.n = n + 10
        self.mod = mod

        self.perm = [1]
        self.rev = [1]
        self.inv = [0]
        self.fault = [0]

        self.build_perm()
        self.build_rev()
        self.build_inv()
        self.build_fault()
        return

    def build_perm(self):
        self.perm = [1] * (self.n + 1)  # (i!) % mod
        for i in range(1, self.n + 1):
            self.perm[i] = self.perm[i - 1] * i % self.mod
        return

    def build_rev(self):
        self.rev = [1] * (self.n + 1)  # pow(i!, -1, mod)
        self.rev[-1] = pow(self.perm[-1], -1, self.mod)  # GcdLike().mod_reverse(self.perm[-1], self.mod)
        for i in range(self.n - 1, 0, -1):
            self.rev[i] = (self.rev[i + 1] * (i + 1) % self.mod)  # pow(i!, -1, mod)
        return

    def build_inv(self):
        self.inv = [0] * (self.n + 1)  # pow(i, -1, mod)
        self.inv[1] = 1
        for i in range(2, self.n + 1):
            self.inv[i] = (self.mod - self.mod // i) * self.inv[self.mod % i] % self.mod
        return

    def build_fault(self):
        self.fault = [0] * (self.n + 1)  # fault permutation
        self.fault[0] = 1
        self.fault[2] = 1
        for i in range(3, self.n + 1):
            self.fault[i] = (i - 1) * (self.fault[i - 1] + self.fault[i - 2])
            self.fault[i] %= self.mod
        return

    def comb(self, a, b):
        if a < b:
            return 0
        res = self.perm[a] * self.rev[b] * self.rev[a - b]  # comb(a, b) % mod = (a!/(b!(a-b)!)) % mod
        return res % self.mod

    def factorial(self, a):
        res = self.perm[a]  # (a!) % mod
        return res % self.mod

    def inverse(self, n):
        res = self.perm[n - 1] * self.rev[n] % self.mod  # pow(n, -1, mod)
        return res

    def catalan(self, n):
        res = (self.comb(2 * n, n) - self.comb(2 * n, n - 1)) % self.mod
        return res


cb = Combinatorics(200, mod)


class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        @lru_cache(None)
        def dfs(i, k, pre):
            if k > odd or (m - odd) > even:
                return 0
            if i == 10:
                return pre == 0
            
            
            res = 0
            rest_odd = odd-k
            rest_even = post[-1] - post[i]-rest_odd
            for xx in range(cnt[i] + 1):
                res += dfs(i + 1, k + xx, pre + xx * i - (cnt[i] - xx) * i)*cb.comb(rest_odd, xx)*cb.comb(rest_even, cnt[i]-xx)
            return res % mod

        num = sorted(num)
        m = len(num)
  
        cnt = [0] * 10
        odd = m // 2 + m % 2
        even = m - odd
        for x in num:
            cnt[int(x)] += 1
        post = list(accumulate(cnt, initial=0))
        ans = dfs(0, 0, 0)
        return ans
",1441320219
Xiong_Jiangkai,xlyy,77,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y = q[0]
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n and visited[x_new][y_new] == -1:
                    t_max = max(t, moveTime[x_new][y_new]) + 1
                    visited[x_new][y_new] = t_max
                    heapq.heappush(q, (t_max, x_new, y_new))
        return visited[-1][-1] ",1441316739
Xiong_Jiangkai,xlyy,77,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        q = [(0, 0, 0, 1)]
        visited = [[-1] * n for _ in range(m)]
        while q:
            t, x, y, dt = q[0]
            dt_new = 2 if dt == 1 else 1
            heapq.heappop(q)
            for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)):
                x_new = x + dx
                y_new = y + dy
                if 0 <= x_new < m and 0 <= y_new < n:
                    t_max = max(t, moveTime[x_new][y_new])
                    if (visited[x_new][y_new] == -1 or visited[x_new][y_new] > t_max + dt):
                        visited[x_new][y_new] = t_max + dt
                        heapq.heappush(q, (t_max + dt, x_new, y_new, dt_new))
        return visited[-1][-1] ",1441313622
Xiong_Jiangkai,xlyy,77,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        n = len(num)
        sum1 = sum2 = 0
        for i in range(0, n, 2):
            sum1 += int(num[i])
        for i in range(1, n, 2):
            sum2 += int(num[i])
        return sum1 == sum2",1441281965
Xiong_Jiangkai,xlyy,77,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = int(1e9)+ 7
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
    
        counts = [0] * 10
        total = 0
        for ch in num:
            d = int(ch)
            counts[d] += 1
            total += d
    
        if total %2 != 0:
            return 0
        S = total // 2
    
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] *i % MOD
    
        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


        
        dp_prev = [[0] * (n_even + 1) for _ in range(S + 1)]
        dp_prev[0][0] = 1
        for d in range(10):
            c_d = counts[d]
            if c_d ==0:
                dp_curr = [row[:] for row in dp_prev]
            else:
                dp_curr = [[0] * (n_even + 1) for _ in range(S + 1)]
                k_min = max(0, c_d - n_odd)
                for s in range(S + 1):
                    for c in range(n_even + 1):
                        val = dp_prev[s][c]
                        if val == 0:
                            continue
                        for k in range(k_min, min(c_d, n_even - c) + 1):
                            new_s = s + d * k
                            if new_s > S:
                                continue
                            new_c = c + k
                            if new_c > n_even:
                                continue
                            add_val = val * inv_fact[k] % MOD
                            add_val = add_val * inv_fact[c_d - k] % MOD
                            dp_curr[new_s][new_c] = (dp_curr[new_s][new_c] + add_val) % MOD
                dp_prev = dp_curr
    
        dp_final = dp_prev[S][n_even]
        res = fact[n_even] * fact[n_odd] % MOD
        res = res * dp_final % MOD
        return res",1441334143
Meet Brahmbhatt,MeetBrahmbhatt,78,3627,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 1;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334615
Meet Brahmbhatt,MeetBrahmbhatt,78,3628,cpp,"const int inf = 2e9;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int odd_cost = 1;
        int even_cost = 2;
        
        int n = (int) v.size();
        int m = (int) v[0].size();
        
        vector<vector<int>> dp(n, vector<int>(m, inf));
        dp[0][0] = 0;
        
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;
        Q.push({0, 0});
        
        auto in = [&] (int x, int y) {
            return 0 <= x and x < n and 0 <= y and y < m;  
        };
        
        while (!Q.empty()) { 
            auto [time, coordinate] = Q.top();
            int x = coordinate / m;
            int y = coordinate % m;
            Q.pop();
            if (dp[x][y] < time) {
                continue;
            }
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    int nx = x + dx;
                    int ny = y + dy;
                    int turn_cost = (nx + ny) & 1 ? odd_cost : even_cost;
                    
                    if (abs(dx + dy) == 1 and in(nx, ny)) {
                        int new_time = max(time, v[nx][ny]) + turn_cost;
                        if (dp[nx][ny] > new_time) {
                            dp[nx][ny] = new_time;
                            Q.push({new_time, nx * m + ny});
                        }
                    }
                }
            }
        }
 
        return dp[n - 1][m - 1];
    }
};",1441334276
Meet Brahmbhatt,MeetBrahmbhatt,78,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < (int) s.size(); i++) {
            sum += (s[i] - '0') * (i & 1 ? -1 : 1);
        }
        return !sum;
    }
};",1441322261
Meet Brahmbhatt,MeetBrahmbhatt,78,3637,cpp,"constexpr int32_t MOD = 1e9 + 7;
// constexpr int32_t MOD = 998244353;

struct Mint {
    int val;
    Mint(long long v = 0) {
        if (v < 0) {
            v = v % MOD + MOD;
        }
        if (v >= MOD) {
            v %= MOD;
        }
        val = v;
    }
    static int mod_inv(int a, int m = MOD) {
        int g = m, r = a, x = 0, y = 1;
        while (r != 0) {
            int q = g / r;
            g %= r; swap(g, r);
            x -= q * y; swap(x, y);
        }
        return x < 0 ? x + m : x;
    }
    explicit operator int() const {
        return val;
    }
    Mint& operator+=(const Mint &other) {
        val += other.val;
        if (val >= MOD) val -= MOD;
        return *this;
    }
    Mint& operator-=(const Mint &other) {
        val -= other.val;
        if (val < 0) val += MOD;
        return *this;
    }
    typedef unsigned long long ull;
    ull fast_mod(ull a, ull b, ull M = MOD) {
        long long ret = a * b - M * ull(1.L / M * a * b);
        return ret + M * (ret < 0) - M * (ret >= (long long)M);
    }
    Mint& operator*=(const Mint &other) {
        val = fast_mod((ull) val, other.val);
        return *this;
    }
    Mint& operator/=(const Mint &other) {
        return *this *= other.inv();
    }
    friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }
    friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }
    friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }
    friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }
    Mint& operator++() {
        val = val == MOD - 1 ? 0 : val + 1;
        return *this;
    }
    Mint& operator--() {
        val = val == 0 ? MOD - 1 : val - 1;
        return *this;
    }
    Mint operator++(int32_t) { Mint before = *this; ++*this; return before; }
    Mint operator--(int32_t) { Mint before = *this; --*this; return before; }
    Mint operator-() const {
        return val == 0 ? 0 : MOD - val;
    }
    bool operator==(const Mint &other) const { return val == other.val; }
    bool operator!=(const Mint &other) const { return val != other.val; }
    Mint inv() const {
        return mod_inv(val);
    }
    Mint pow(long long p) const {
        assert(p >= 0);
        Mint a = *this, result = 1;

        while (p > 0) {
            if (p & 1)
                result *= a;

            a *= a;
            p >>= 1;
        }
        return result;
    }
    friend ostream& operator<<(ostream &stream, const Mint &m) {
        return stream << m.val;
    }
    friend istream& operator >> (istream &stream, Mint &m) {
        return stream >> m.val;
    }
};

const int32_t N = 100;
bool done = false;
Mint FAC[N + 1], INV[N + 1];

void calc() {
    if (done) {
        return;
    }
    done = true;
    FAC[0] = 1;
    for (int i = 1; i <= N; i++) {
        FAC[i] = (FAC[i - 1] * i);
    }
    INV[N] = INV[N].mod_inv(FAC[N].val, MOD);
    for (int i = N - 1; i >= 0; i--) {
        INV[i] = (INV[i + 1] * (i + 1));
    }
}
Mint ncr(int n, int r) {
    if (r < 0) return 0;
    if (n < r) return 0;
    if (r == 0) return 1;
    Mint a = FAC[n] * INV[r] * INV[n - r];
    return a;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        calc();
        int n = (int) s.size();
        
        vector<int> freq(10);
        for (auto i : s) {
            freq[i - '0']++;
        }
        
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += freq[i] * i;
        }
        
        if (sum & 1) {
            return 0;
        }
        
        sum /= 2;
        vector<vector<Mint>> dp((n / 2) + 1, vector<Mint>(sum + 1));
        dp[0][0] = 1;
        
        for (int i = 0; i < 10; i++) {
            vector<vector<Mint>> ndp(n / 2 + 1, vector<Mint>(sum + 1));
            for (int prev_take = 0; prev_take <= n / 2; prev_take++) {
                for (int take = 0; take <= freq[i] && prev_take + take <= n / 2; take++) {
                    for (int prev_sum = 0; prev_sum + take * i <= sum; prev_sum++) {
                        int new_sum = prev_sum + take * i;
                        int new_take = prev_take + take;
                        ndp[new_take][new_sum] += dp[prev_take][prev_sum] * INV[take] * INV[freq[i] - take];
                    }
                }
            }
            
            dp = ndp;
        }
        
        Mint ans = dp[n / 2][sum] * FAC[n / 2] * FAC[(n + 1) / 2];
        return ans.val;
    }
};",1441321938
Dylan Smith,DylanSmith,79,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + 1;
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441293304
Dylan Smith,DylanSmith,79,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int N = (int)moveTime.size(), M = (int)moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, INT_MAX));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> pq;
        pq.push({0, {0, 0}});
        vector vis(N, vector<bool>(M, 0));
        vector<int> x = {0, 1, 0, -1}, y = {1, 0, -1, 0};
        while (!pq.empty()) {
            int r = pq.top().second.first, c = pq.top().second.second; pq.pop();
            if (vis[r][c]) continue;
            vis[r][c] = 1;
            for (int k = 0; k < 4; k++) {
                int r2 = r + x[k], c2 = c + y[k];
                if (r2 >= 0 && r2 < N && c2 >= 0 && c2 < M) {
                    int n = max(dist[r][c], moveTime[r2][c2]) + ((r + c) % 2 == 0 ? 1 : 2);
                    if (n < dist[r2][c2]) {
                        dist[r2][c2] = n;
                        pq.push({-dist[r2][c2], {r2, c2}});
                    }
                }
            }
        }
        return dist[N - 1][M - 1];
    }
};",1441294311
Dylan Smith,DylanSmith,79,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0, o = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2 == 0) {
                e += num[i] - '0';
            } else {
                o += num[i] - '0';
            }
        }
        return e == o;
    }
};",1441281042
Dylan Smith,DylanSmith,79,3637,cpp,"typedef long long ll;

#define pb push_back
#define sz(x) (int)x.size()
#define all(x) begin(x),end(x)
#define lb(x,y) lower_bound(all(x),y)-begin(x)

int mod = 1000000007;

ll exGCD(ll a, ll b, ll &x, ll &y) {
    if (a == 0) { x = 0; y = 1; return b; }
    ll g = exGCD(b % a, a, x, y);
    ll t = x; x = y - b / a * x; y = t;
    return g;
}

int mInv(int n) {
    ll x, y, g = exGCD(n, mod, x, y);
    if (g != 1) return 0;
    return (x % mod + mod) % mod;
}

vector<int> factArr = {1}, factInvArr = {1};
int fact(int n) {
    while (sz(factArr) <= n)
        factArr.pb((int)((ll)factArr[sz(factArr) - 1] * sz(factArr) % mod));
    return factArr[n];
}

int factInv(int n) {
    fact(n);
    while (sz(factInvArr) <= n)
        factInvArr.pb(mInv(factArr[sz(factInvArr)]));
    return factInvArr[n];
}

int choose(int n, int k) {
    if (k < 0 || k > n) return 0;
    return (int)((ll)fact(n) * factInv(k) % mod * factInv(n - k) % mod);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int sum = 0;
        for (char c : num) sum += c - '0';
        if (sum % 2 == 1) return 0;
        vector<vector<ll>> dp((int)num.size() / 2 + 1, vector<ll>(sum / 2 + 1, 0)), nxt = dp;
        dp[0][0] = 1;
        vector<int> freq(10, 0);
        for (char c : num) freq[c - '0']++;
        int pre = 0;
        for (int k = 0; k < 10; k++) {
            for (int i = 0; i <= num.size() / 2; i++) fill(all(nxt[i]), 0);
            for (int l = 0; l <= freq[k]; l++) {
                for (int i = 0; i + l <= (int)num.size() / 2; i++) {
                    int n = (ll)choose(i + l, l) * choose(pre - i + freq[k] - l, freq[k] - l) % mod;
                    for (int j = 0; j + k * l <= sum / 2; j++) {
                        nxt[i + l][j + k * l] += (ll)dp[i][j] * n % mod;
                    }
                }
            }
            for (int i = 0; i <= num.size() / 2; i++) {
                for (int j = 0; j <= sum / 2; j++) {
                    nxt[i][j] %= mod;
                }
            }
            pre += freq[k];
            swap(dp, nxt);
        }
        return dp[(int)num.size() / 2][sum / 2];
    }
};",1441327844
Liwei Cai,cai_lw,80,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m);
        pq.push({0,0,0});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=it.i*m+it.j;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it2.t,moveTime[it2.i][it2.j])+1;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441295706
Liwei Cai,cai_lw,80,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        struct Item{
            int t,i,j;
            bool p;
            bool operator<(const Item& rhs)const{
                return t>rhs.t;
            }
        };
        priority_queue<Item> pq;
        int n=moveTime.size(),m=moveTime[0].size();
        vector<bool> vis(n*m*2);
        pq.push({0,0,0,false});
        while(!pq.empty()){
            auto it=pq.top();
            pq.pop();
            if(it.i==n-1&&it.j==m-1)
                return it.t;
            int idx=(it.i*m+it.j)*2+it.p;
            if(vis[idx])
                continue;
            else
                vis[idx]=true;
            const int dx[4]{1,0,-1,0};
            const int dy[4]{0,1,0,-1};
            for(int d=0;d<4;d++){
                auto it2=it;
                it2.i+=dx[d];
                it2.j+=dy[d];
                if(it2.i<0||it2.i>=n||it2.j<0||it2.j>=m)
                    continue;
                it2.t=max(it.t,moveTime[it2.i][it2.j])+(it.p?2:1);
                it2.p=!it.p;
                pq.push(it2);
            }
        }
        return -1;
    }
};",1441297773
Liwei Cai,cai_lw,80,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s[2]{0,0};
        for(int i=0;i<num.size();i++)
            s[i%2]+=num[i]-'0';
        return s[0]==s[1];
    }
};",1441280960
Liwei Cai,cai_lw,80,3637,cpp,"class Solution {
    static constexpr int P=1'000'000'007;
    struct State{
        int n1,n2,step,diff;
        bool operator<(const State& rhs)const{
            return tuple(n1,n2,step,diff)<tuple(rhs.n1,rhs.n2,rhs.step,rhs.diff);
        }
    };
    int solve(const State& st,const int (&cnt)[10],const int (&rem)[10],const vector<vector<int>>& binom,map<State,int>& mem){
        if(st.step==10)
            return st.diff==0;
        if(abs(st.diff)>rem[st.step])
            return 0;
        auto [it,inserted]=mem.emplace(st,0);
        if(!inserted)
            return it->second;
        int& ans=it->second;
        for(int c1=0;c1<=cnt[st.step];c1++){
            int c2=cnt[st.step]-c1;
            if(c1>st.n1||c2>st.n2)
                continue;
            int coef=1ll*binom[st.n1][c1]*binom[st.n2][c2]%P;
            State nxt=st;
            nxt.n1-=c1;
            nxt.n2-=c2;
            nxt.step++;
            nxt.diff+=st.step*(c2-c1);
            ans+=1ll*coef*solve(nxt,cnt,rem,binom,mem)%P;
            if(ans>=P)
                ans-=P;
        }
        return ans;
    }
public:
    int countBalancedPermutations(string num) {
        int cnt[10]{};
        for(char c:num)
            cnt[c-'0']++;
        int rem[10];
        rem[9]=cnt[9]*9;
        for(int i=8;i>=0;i--)
            rem[i]=rem[i+1]+cnt[i]*i;
        int n=num.size();
        int n1=n/2,n2=n-n1;
        vector<vector<int>> binom(n2+1,vector<int>(n2+1));
        for(int i=0;i<=n2;i++){
            binom[i][0]=binom[i][i]=1;
            for(int j=1;j<i;j++){
                binom[i][j]=binom[i-1][j-1]+binom[i-1][j];
                if(binom[i][j]>=P)
                    binom[i][j]-=P;
            }
        }
        map<State,int> mem;
        return solve(State{n1,n2,0,0},cnt,rem,binom,mem);
    }
};",1441335423
ocavue,ocavue,81,3627,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        result = [[MAX_TIME] * n for _ in range(m)]

        result[0][0] = 0

        heap = [(0, 0, 0)]

        while heap:
            time, i, j = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    new_time = start_time + 1
                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        heapq.heappush(heap, (new_time, ii, jj))

        return result[m - 1][n - 1]
 ",1441296531
ocavue,ocavue,81,3628,python3,"from typing import List
import heapq

MAX_TIME = 10**9 + 1000 * 1000


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        # print(""m"", m, ""n"", n)
        result1 = [[MAX_TIME] * n for _ in range(m)]
        result2 = [[MAX_TIME] * n for _ in range(m)]

        result2[0][0] = 0

        heap = [(0, 0, 0, 1)]

        while heap:
            time, i, j, next_move = heapq.heappop(heap)
            for ii, jj in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]:
                if 0 <= ii < m and 0 <= jj < n:
                    start_time = max(time, moveTime[ii][jj])
                    # assert next_move in [1, 2]
                    new_time = start_time + next_move

                    result = result1 if next_move == 1 else result2

                    if new_time < result[ii][jj]:
                        result[ii][jj] = new_time
                        # print(f""result {ii} {jj} {new_time} -> {(next_move) % 2 + 1}"")
                        heapq.heappush(heap, (new_time, ii, jj, (next_move) % 2 + 1))

        # print(""result1"", result1)
        # print(""result2"", result2)

        return min(result1[m - 1][n - 1], result2[m - 1][n - 1])

 ",1441316045
ocavue,ocavue,81,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = 0
        o = 0
        for i, char in enumerate(num):
            dig = int(char)
            if i % 2 == 0:
                e += dig 
            else:
                o += dig 
        return e == o",1441281980
ocavue,ocavue,81,3637,python3,"from functools import cache
import math

MOD = 10**9 + 7


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        total_sum = sum(int(c) for c in num)
        if total_sum % 2 != 0:
            return 0

        counter = [0] * 10
        for c in num:
            d = int(c)
            counter[d] += 1

        assert sum(counter) == len(num)

        n = len(num)
        e = n // 2
        o = n - e

        @cache
        def dp(i: int, e_available: int, o_available: int, diff: int) -> int:
            if i == 10:
                assert e_available == 0 and o_available == 0, f""e_available: {e_available}, o_available: {o_available}""
                return 1 if diff == 0 else 0

            total_result = 0
            for e_pick in range(0, e_available + 1):
                o_pick = counter[i] - e_pick
                if 0 <= e_pick <= e_available and 0 <= o_pick <= o_available:
                    result = 1
                    result *= math.comb(e_available, e_pick)
                    result %= MOD
                    result *= math.comb(o_available, o_pick)
                    result %= MOD
                    result *= dp(i + 1, e_available - e_pick, o_available - o_pick, diff + (o_pick - e_pick) * i)
                    result %= MOD
                    total_result += result
            return total_result % MOD

        return dp(0, e, o, 0)

 ",1441342495
nemokwy,nemokwy,82,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        ret = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0))
        ret[0][0] = 0
        while h:
            t, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m and ret[u][v] > max(moveTime[u][v]+1, t+1):
                    ret[u][v] = max(moveTime[u][v]+1, t+1)
                    heappush(h, (ret[u][v], u, v))
        return ret[-1][-1]",1441292753
nemokwy,nemokwy,82,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m  = len(moveTime), len(moveTime[0])
        r0 = [[inf] * m for _ in range(n)]
        r1 = [[inf] * m for _ in range(n)]
        h = []
        heappush(h, (0, 0, 0, 0))
        r0[0][0] = 0
        while h:
            t, p, x, y = heappop(h)
            for u, v in [(x-1,y), (x+1,y), (x,y-1), (x, y+1)]:
                if 0 <= u < n and 0 <= v < m:
                    if p == 0:
                        if r1[u][v] > max(moveTime[u][v]+1, t+1):
                            r1[u][v] = max(moveTime[u][v]+1, t+1)
                            heappush(h, (r1[u][v], 1, u, v))
                    else:
                        if r0[u][v] > max(moveTime[u][v]+2, t+2):
                            r0[u][v] = max(moveTime[u][v]+2, t+2)
                            heappush(h, (r0[u][v], 0, u, v))
        if r0[-1][-1] == inf:
            return r1[-1][-1]
        if r1[-1][-1] == inf:
            return r0[-1][-1]
        return max(r0[-1][-1], r1[-1][-1])",1441309614
nemokwy,nemokwy,82,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a, b = 0, 0
        for i,c in enumerate(num):
            if i & 1:
                a += int(c)
            else:
                b += int(c)
        return a == b",1441281344
nemokwy,nemokwy,82,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        ret = 0
        d = [0] * 10
        s = 0
        for i, c in enumerate(num):
            d[int(c)] += 1
            s += int(c)
        if s & 1:
            return 0
        v = s // 2
        @lru_cache(None)
        def C(n, m):
            a = 1
            for i in range(m):
                a = a * (n - i) * pow(i + 1, MOD - 2, MOD) % MOD
            return a

        @lru_cache(None)
        def chk(tp, tq, p, q, t):
            if t == 0:
                if tp or tq:
                    return 0
                return 1
            ret = 0
            for i in range(d[t]+1):
                if tp < i * t or tq < (d[t]-i) * t:
                    continue
                ret += C(p, i) * C(q, d[t]-i) * chk(tp - i * t, tq - (d[t]-i) * t, p - i, q - (d[t]-i), t - 1) % MOD
            # print(tp, tq, p, q, t, ret)
            return ret % MOD
        return chk(v, s - v, len(num) // 2,len(num) - len(num) // 2, 9)",1441336421
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0):0}
        h = [(0,0,0)]
        while h:
            c,x,y = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and (nx,ny) not in dist:
                    dist[nx,ny] = max(1 + moveTime[nx][ny], 1 + c)
                    heapq.heappush(h, (dist[nx,ny], nx, ny))
                ",1441290546
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[0])
        dist = {(0,0,0):0}
        h = [(0,0,0,0)]
        while h:
            c,x,y,p = heapq.heappop(h)
            if (x,y) == (R-1, C-1):
                return c
            if dist[(x,y,p)] != c:
                continue
            for dx, dy in pairwise([1,0,-1,0,1]):
                nx, ny = x+dx, y+dy
                if 0 <= nx < R and 0 <= ny < C and dist.get((nx,ny,1-p), inf) > p + 1 + max(moveTime[nx][ny], c):
                    dist[nx,ny,1-p] = p + 1 + max(moveTime[nx][ny], c)
                    heapq.heappush(h, (dist[nx,ny,1-p], nx, ny, 1-p))
                ",1441294236
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ret = 0
        for i in range(len(num)):
            x = int(num[i])
            if i % 2:
                ret += x
            else:
                ret -= x
        return ret == 0",1441280896
twitch_tv_qiqi_impact,twitch_tv_qiqi_impact,84,3637,python3,"MOD = 10**9+7

@cache
def comb(x, y):
    if y == 0 or y == x:
        return 1
    return (comb(x-1, y-1) + comb(x-1, y)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        SM = 0
        l = [0] * 10
        tot = [0] * 10
        tc = [0] * 10
        for x in num:
            l[int(x)] += 1
            SM += int(x)
        if SM % 2:
            return 0
        for i in range(10):
            tot[i] = (0 if i == 0 else tot[i-1]) + l[i] * i
            tc[i] = (0 if i == 0 else tc[i-1]) + l[i]
        # print(tot)
        # print(tc)
        # print(l)
        
        @cache
        def dp(idx, ct, sm):
            # print(idx, ct, sm)
            if idx == -1:
                # print(idx, ct, sm)
                return int(ct == 0 and sm == 0)
            ct2 = tc[idx] - ct
            sm2 = tot[idx] - sm
            # print(idx, ct, sm, ct2, sm2)
            ret = 0
            for t in range(l[idx] + 1):
                # print(t, l[idx] - t > ct2, sm > (idx) * t, sm2 > (idx) * (l[idx] - t))
                if t > ct or l[idx] - t > ct2 or sm < (idx) * t or sm2 < (idx) * (l[idx] - t):
                    continue
                v = dp(idx-1, ct - t, sm - (idx) * t)
                ret += comb(ct, t) * comb(ct2, l[idx] - t) * v % MOD
                ret %= MOD
                # print(idx, ct, sm, ret)
            return ret

        return dp(9, (len(num)+1)//2, SM//2)
                
                ",1441343521
thedude7181,thedude7181,85,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, row, col = heappop(q)
            if (row, col) in vis:
                continue
            vis.add((row, col))
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1, moveTime[nrow][ncol] + 1), nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441297537
thedude7181,thedude7181,85,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        q = [(0, 0, 0, 0)]
        rows = len(moveTime)
        cols = len(moveTime[0])
        vis = set()
        while True:
            time, movecost, row, col = heappop(q)
            if (row, col, movecost) in vis:
                continue
            vis.add((row, col, movecost))
            new_movecost = (movecost + 1) % 2 
            if row == rows - 1 and col == cols - 1:
                return time
            for nrow, ncol in four_dirs(row, col, rows, cols):
                heappush(q, (max(time + 1 + movecost, moveTime[nrow][ncol] + 1 + movecost), new_movecost, nrow, ncol))

                
                
def four_dirs(x, y, rows, cols):
    for nx, ny in [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]:
        if 0 <= nx < rows and 0 <= ny < cols:
            yield (nx, ny)
    return ",1441305265
thedude7181,thedude7181,85,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0 
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return odd == even",1441287722
thedude7181,thedude7181,85,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def helper(d, s, ecnt, ocnt):
            if s < 0:
                return 0
            if ecnt < 0:
                return 0
            if ocnt < 0:
                return 0
            if d > 9:
                return s == 0
            res = 0
            for i in range(digit_cnts[d] + 1):
                res += comb(ecnt, i) * helper(d + 1, s - (d * i), ecnt - i, ocnt - (digit_cnts[d] - i)) * comb(ocnt, digit_cnts[d] - i)
            return res % mod

        target_cnt = len(num) // 2
        mod = 1_000_000_007
        num = [int(n) for n in num]
        sum_ = sum(num)
        if sum_ % 2 != 0:
            return 0
        target_s = sum_ // 2
        digit_cnts = Counter(num)
        res = helper(0, target_s, (len(num) + 1) // 2, len(num) // 2)
        helper.cache_clear()
        return res",1441343532
Ethan,Ethan038,86,3627,cpp,"
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    int minTimeToReach(vector<vi>& mvtm) {
        return [](vector<vi>& mvtm) -> int {
            int n = mvtm.size();
            int m = mvtm[0].size();
            
            vector<vll> dis(n, vll(m, LLONG_MAX));
            dis[0][0] = 0;
            
            priority_queue<pair<ll, pi>, 
                          vector<pair<long long, pair<int, int>>>, 
                          greater<>> pq;
            pq.push({0, {0, 0}});
            
            vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
            
            while (!pq.empty()) {
                auto [currtm, cor] = pq.top();
                auto [x, y] = cor;
                pq.pop();
                
                if (currtm > dis[x][y]) continue;
                
                for (auto [dx, dy] : dirs) {
                    int nex = x + dx;
                    int ny = y + dy;
                    
                    if (nex >= 0 && nex < n && ny >= 0 && ny < m) {
                        long long waitTime = max(0LL, mvtm[nex][ny] - currtm);
                        long long ntm = currtm + waitTime + 1;
                        
                        if (ntm < dis[nex][ny]) {
                            dis[nex][ny] = ntm;
                            pq.push({ntm, {nex, ny}});
                        }
                    }
                }
            }
            
            return dis[n-1][m-1];
        }(mvtm);
    }
};",1441292430
Ethan,Ethan038,86,3628,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;
int a[N]; 
bool c[N]; 

class Solution {
public:
   int minTimeToReach(vector<vi>& mt) {
       int n = mt.size();
       int m = mt[0].size();
       
       vector<vll> ans(n, vll(m, LLONG_MAX));
       ans[0][0] = 0;
       
       priority_queue<pair<ll, vi>, vector<pair<ll, vi>>, greater<>> pq;
       pq.push({0, {0, 0, 0}});
       
       auto chk = mt;
       
       vector<pi> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
       
       auto isValid = [&](int x, int y) -> bool {
           return x >= 0 && x < n && y >= 0 && y < m;
       };
       
       auto nxtmv = [](int mvtyp) -> int {
           return 1 - mvtyp; 
       };
       
       auto gcst = [](int mvtyp) -> int {
           return (mvtyp == 0) ? 1 : 2;
       };
       
       auto getm = [](long long xrrtm, int tartime, int mvcst) -> long long {
           return max((long long)tartime, xrrtm) + mvcst;
       };
       
       while(!pq.empty()) {
           auto [time, pos] = pq.top();
           auto x = pos[0], y = pos[1], mvtyp = pos[2];
           pq.pop();
           
           if(time > ans[x][y]) continue;
           
           for(auto [dx, dy] : dirs) {
               int nx = x + dx;
               int ny = y + dy;
               
               if(isValid(nx, ny)) {
                   int mvcst = gcst(mvtyp);
                   ll ntm = getm(time, chk[nx][ny], mvcst);
                   
                   if(ntm < ans[nx][ny]) {
                       ans[nx][ny] = ntm;
                       pq.push({ntm, {nx, ny, nxtmv(mvtyp)}});
                   }
               }
           }
       }
       
       return ans[n-1][m-1];
   }
};
",1441302877
Ethan,Ethan038,86,3636,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5;

class Solution {
public:
    bool isBalanced(string num) {
        return [](string num) -> bool {
            int evenSum = 0, oddSum = 0;
            rep(i, 0, num.length()) {
                (i % 2 == 0) ? evenSum += num[i] - '0' : oddSum += num[i] - '0';
            }
            return evenSum == oddSum;
        }(num);
    }
};",1441288482
Ethan,Ethan038,86,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define pb push_back
#define vi vector<int>
#define vll vector<ll>
#define pi pair<int,int> 
#define vs vector<string>
#define vpii vector<pair<int, int>>
#define all(v) v.begin(), v.end()
#define rall(v) v.rbegin(), v.rend()
#define rep(i, a, n) for (int i = a; i < n; ++i)
#define p(a) cout << a << ""\n"";
#define YES cout << ""YES\n"";
#define NO cout << ""NO\n"";
#define fastread() (ios_base::sync_with_stdio(false), cin.tie(NULL));
const ll mod = 1e9 + 7;
const int N = 1e5 + 5; 
using namespace std;

class Solution { 
public: 
   const int MOD = 1e9 + 7;

   ll countBalancedPermutations(string num) {
       auto solv4 = [](ll x, ll y, ll mod) -> ll {
           ll res = 1;
           x %= mod;
           while(y > 0) {
               if(y & 1) res = res * x % mod;  x = x * x % mod;   y >>= 1;
           }
           return res;
       };
       
       auto solv2 = [&](vll& fc, vll& kp, int maxN) {
           fc.resize(maxN + 1, 1);
           rep(i,1,maxN+1) fc[i] = fc[i-1] * i % MOD;
           kp.resize(maxN + 1, 1);
           kp[maxN] = solv4(fc[maxN], MOD - 2, MOD);
           for(int i = maxN-1; i >= 0; --i) kp[i] = kp[i+1] * (i+1) % MOD; };auto km = num; auto sp = num;
       
       auto solv3 = [](const string& s) -> pair<array<int,10>, ll> {
           array<int,10> cnt{};
           ll sum = 0;
           for(char c : s) {
               cnt[c-'0']++;
               sum += (c-'0');
           }
           return {cnt, sum};
       };
       
       int L = num.length();
       auto [cnts, tsum] = solv3(num);
       
       if(tsum % 2) return 0;
       
       ll smevn = tsum / 2;
       int k = (L + 1) / 2;
       
       vll fc, kp;
       solv2(fc, kp, L);
       
       auto solvdp = [&](int d, const vector<vll>& pdp, int cntd) -> vector<vll> {
           vector<vll> tmdp(k + 1, vll(smevn + 1, 0));
           rep(c,0,k+1) {
               rep(s,0,smevn+1) {
                   if(pdp[c][s] == 0) continue;
                   int maxA = min(cntd, k - c);
                   rep(aD,0,maxA+1) {
                       ll nec = c + aD;   ll nws = s + (ll)d * aD;    if(nws > smevn) continue;
                       tmdp[nec][nws] = (tmdp[nec][nws] + 
                           pdp[c][s] * kp[aD] % MOD *   kp[cntd - aD] % MOD) % MOD;
                   }
               }
           }
           return tmdp;
       };

       vector<vll> pdp(k + 1, vll(smevn + 1, 0));  pdp[0][0] = 1;
       
       rep(d,0,10) {
           pdp = solvdp(d, pdp, cnts[d]);
       }
       
       ll vlid = pdp[k][smevn];
       ll anas = fc[k] * fc[L - k] % MOD;
       anas = anas * vlid % MOD;
       
       return (int)anas;
   }
};
",1441343539
Only My Railgun,Quar,89,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0)] # t, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1
                    yield tt, rr, cc
        
        while heap:
            t, ir, ic = heappop(heap)
            
            for tt, rr, cc in get_neighbor(t, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]

            ",1441293619
Only My Railgun,Quar,89,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        nrow, ncol = len(moveTime), len(moveTime[0])
        
        heap = [(0, 0, 0, 0)] # t, additional_time, ir, ic
        
        seen = {(0, 0): 0}
        
        def get_neighbor(t, dt, ir, ic):
            for rr, cc in ((ir - 1, ic), (ir + 1, ic), (ir, ic - 1), (ir, ic + 1)):
                if 0 <= rr < nrow and 0 <= cc < ncol:
                    tt = max(t, moveTime[rr][cc]) + 1 + dt
                    yield tt, 1 - dt, rr, cc
        
        while heap:
            t, d, ir, ic = heappop(heap)
            
            for tt, dd, rr, cc in get_neighbor(t, d, ir, ic):
                if tt < seen.get((rr, cc), inf) and tt < seen.get((nrow - 1, ncol - 1), inf):
                    seen[(rr, cc)] = tt
                    heappush(heap, (tt, dd, rr, cc))
        
        return seen[(nrow - 1, ncol - 1)]
",1441296911
Only My Railgun,Quar,89,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = str(num)
        even = sum(int(s[i]) for i in range(0, len(s), 2))
        odd = sum(int(s[i]) for i in range(1, len(s), 2))
        return even == odd
",1441281831
Only My Railgun,Quar,89,3637,python3,"from math import comb
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        cnt = [0] * 10
        for c in num:
            cnt[int(c)] += 1
            
        total_sum = sum(x * c for x, c in enumerate(cnt))
        
        if total_sum % 2 == 1:
            return 0
        
        target_sum = total_sum // 2
        
        MODULO = 10**9 + 7
        
        @cache
        def dp(i, rem_even, rem_odd, rem_even_sum):
            if rem_even == 0:
                if rem_even_sum != 0:
                    return 0
                ret = 1
                for j in range(i, 10):
                    ret = ret * comb(rem_odd, cnt[j]) % MODULO
                    rem_odd -= cnt[j]
                return ret
            
            if rem_even_sum > 0 and rem_even == 0:
                return 0
            
            if 0 < rem_even_sum < i:
                return 0
            
            ret = 0
            max_even_take = cnt[i] if i == 0 else min(cnt[i], rem_even_sum // i)
            max_even_take = min(max_even_take, rem_even)
            
            for even_take in range(0, max_even_take + 1):
                odd_take = cnt[i] - even_take
                if odd_take > rem_odd:
                    continue
                coeff = (comb(rem_even, even_take) % MODULO) * (comb(rem_odd, odd_take) % MODULO) % MODULO
                rest = dp(i + 1, rem_even - even_take, rem_odd - odd_take, rem_even_sum - i * even_take)
                ret += coeff * rest % MODULO
            
            return ret % MODULO
        
        n_odd = len(num) // 2
        n_even = len(num) - n_odd
        
        return dp(0, n_even, n_odd, target_sum)
                
            
                
        ",1441338510
carlostagosaku,carlostagosaku,90,3627,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 1
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441300648
carlostagosaku,carlostagosaku,90,3628,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

INF = (1<<60)
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        dp = moveTime
        H = len(moveTime)
        W = len(moveTime[0])
        def nb(x,y):
            tmp = []
            if x+1<H:
                tmp.append((x+1,y))
            if x-1>=0:
                tmp.append((x-1,y))
            if y+1<W:
                tmp.append((x,y+1))
            if y-1>=0:
                tmp.append((x,y-1))
            return tmp
        
        N = H*W

        h = []
        s = 0
        dist = [INF]*(2*N)
        dist[0] = 0
        heappush(h,(0,s))
        while h:
            nw,_v = heappop(h)
            if dist[_v]!=nw:
                continue
            flg,v = divmod(_v,N)
            x,y = divmod(v,W)
            for ix,iy in nb(x,y):
                iv = W*ix + iy + N*(1-flg)
                if flg==0:
                    ic = 1
                else:
                    ic = 2
                nc = ic + max(nw,moveTime[ix][iy])
                if nc < dist[iv]:
                    dist[iv] = nc
                    heappush(h,(nc,iv))
        if (H+W)%2==1:
            return dist[-1]
        else:
            return dist[-1-N]
        # return min(dist[-1],dist[-1-N])",1441299342
carlostagosaku,carlostagosaku,90,3636,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

class Solution:
    def isBalanced(self, num: str) -> bool:
        X = list(num)
        X = [int(x) for x in X]
        if sum(x for x in X[1::2])==sum(x for x in X[0::2]):
            return True
        else:
            return False  ",1441302147
carlostagosaku,carlostagosaku,90,3637,python3,"# import pypyjit
# pypyjit.set_param('max_unroll_recursion=-1')

from collections import *
from functools import *
from heapq import *
from itertools import *
import sys, math,random
# input = sys.stdin.buffer.readline
# sys.setrecursionlimit(10**6)

def cle(a, D):
    """"""
    Counts the number of elements in D that are less than or equal to a.

    Parameters:
    a (int): The value to compare against.
    D (list): A sorted list of integers.

    Returns:
    int: The count of elements in D that are less than or equal to a.
    """"""
    y = len(D) - 1
    x = 0
    if D[x] > a:
        return 0

    if D[y] <= a:
        return y + 1

    while y - x > 1:
        mid = (y + x) // 2
        if D[mid] <= a:
            x = mid
        else:
            y = mid
    return y
class cs_2d:
    """"""
    2D cumulative sum class.
    """"""

    def __init__(self, x):
        """"""
        Initializes the 2D cumulative sum array.

        Parameters:
        x (list of list of int): A 2D list of integers.
        """"""
        n = len(x)
        m = len(x[0])
        self.n = n
        self.m = m

        tmp = [0] * ((n + 1) * (m + 1))
        for i in range(n):
            for j in range(m):
                tmp[m * (i + 1) + j + 1] = (
                    tmp[m * (i + 1) + j] + tmp[m * i + j + 1] - tmp[m * i + j] + x[i][j]
                )

        self.S = tmp

    def query(self, ix, jx, iy, jy):
        """"""
        Queries the sum of the submatrix from (ix, iy) to (jx, jy).

        Parameters:
        ix (int): Starting row index.
        jx (int): Ending row index.
        iy (int): Starting column index.
        jy (int): Ending column index.

        Returns:
        int: The sum of the submatrix.
        """"""
        return (
            self.S[self.m * jx + jy]
            - self.S[self.m * jx + iy]
            - self.S[self.m * ix + jy]
            + self.S[self.m * ix + iy]
        )
class prime_factorize:
    """"""
    Class for prime factorization and related operations.
    """"""

    def __init__(self, M=10**6):
        """"""
        Initializes the sieve for prime factorization.

        Parameters:
        M (int): The maximum number to factorize.
        """"""
        self.sieve = [-1] * (M + 1)
        self.sieve[1] = 1
        self.p = [False] * (M + 1)
        self.mu = [1] * (M + 1)

        for i in range(2, M + 1):
            if self.sieve[i] == -1:
                self.p[i] = True

                i2 = i**2
                for j in range(i2, M + 1, i2):
                    self.mu[j] = 0

                for j in range(i, M + 1, i):
                    self.sieve[j] = i
                    self.mu[j] *= -1

    def factors(self, x):
        """"""
        Returns the prime factors of x.

        Parameters:
        x (int): The number to factorize.

        Returns:
        list: A list of prime factors of x.
        """"""
        tmp = []
        while self.sieve[x] != x:
            tmp.append(self.sieve[x])
            x //= self.sieve[x]
        tmp.append(self.sieve[x])
        return tmp

    def divisors(self, x):
        """"""
        Returns all divisors of x.

        Parameters:
        x (int): The number to find divisors for.

        Returns:
        list: A sorted list of all divisors of x.
        """"""
        C = Counter(self.factors(x))
        tmp = []
        for p in product(*[[pow(k, i) for i in range(v + 1)] for k, v in C.items()]):
            res = 1
            for pp in p:
                res *= pp
            tmp.append(res)
        tmp.sort()
        return tmp

    def is_prime(self, x):
        """"""
        Checks if x is a prime number.

        Parameters:
        x (int): The number to check.

        Returns:
        bool: True if x is prime, False otherwise.
        """"""
        return self.p[x]

    def mobius(self, x):
        """"""
        Returns the Möbius function value of x.

        Parameters:
        x (int): The number to find the Möbius function value for.

        Returns:
        int: The Möbius function value of x.
        """"""
        return self.mu[x]
class combination:
    """"""
    Class for computing combinations (nCr) modulo p.
    """"""

    def __init__(self, N, p):
        """"""
        Initializes the combination class.

        Parameters:
        N (int): The maximum value of n.
        p (int): The modulus.
        """"""
        self.fact = [1, 1]  # fact[n] = (n! mod p)
        self.factinv = [1, 1]  # factinv[n] = ((n!)^(-1) mod p)
        self.inv = [0, 1]  # factinv calculation
        self.p = p

        for i in range(2, N + 1):
            self.fact.append((self.fact[-1] * i) % p)
            self.inv.append((-self.inv[p % i] * (p // i)) % p)
            self.factinv.append((self.factinv[-1] * self.inv[-1]) % p)

    def cmb(self, n, r):
        """"""
        Computes the combination (nCr) modulo p.

        Parameters:
        n (int): The total number of items.
        r (int): The number of items to choose.

        Returns:
        int: The value of nCr modulo p.
        """"""
        if (r < 0) or (n < r):
            return 0
        r = min(r, n - r)
        return self.fact[n] * self.factinv[r] * self.factinv[n - r] % self.p
def md(n):
    """"""
    Returns all divisors of n.

    Parameters:
    n (int): The number to find divisors for.

    Returns:
    list: A sorted list of all divisors of n.
    """"""
    lower_divisors, upper_divisors = [], []
    i = 1
    while i * i <= n:
        if n % i == 0:
            lower_divisors.append(i)
            if i != n // i:
                upper_divisors.append(n // i)
        i += 1
    return lower_divisors + upper_divisors[::-1]
class DSU:
    """"""
    Disjoint Set Union (Union-Find) class.
    """"""

    def __init__(self, n):
        """"""
        Initializes the DSU.

        Parameters:
        n (int): The number of elements.
        """"""
        self._n = n
        self.parent_or_size = [-1] * n
        self.member = [[i] for i in range(n)]
        self._max = [i for i in range(n)]
        self._min = [i for i in range(n)]

    def merge(self, a, b):
        """"""
        Merges the sets containing a and b.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        int: The leader of the merged set.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        x, y = self.leader(a), self.leader(b)
        if x == y:
            return x
        if -self.parent_or_size[x] < -self.parent_or_size[y]:
            x, y = y, x
        self.parent_or_size[x] += self.parent_or_size[y]
        self._max[x] = max(self._max[x],self._max[y])
        self._min[x] = min(self._min[x],self._min[y])
        for tmp in self.member[y]:
            self.member[x].append(tmp)
        self.parent_or_size[y] = x
        return x
    def get_max(self,x):
        return self._max[self.leader(x)]
    def get_min(self,x):
        return self._min[self.leader(x)]

    def members(self, a):
        """"""
        Returns the members of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        list: A list of members in the set containing a.
        """"""
        return self.member[self.leader(a)]

    def same(self, a, b):
        """"""
        Checks if a and b are in the same set.

        Parameters:
        a (int): An element in the first set.
        b (int): An element in the second set.

        Returns:
        bool: True if a and b are in the same set, False otherwise.
        """"""
        assert 0 <= a < self._n
        assert 0 <= b < self._n
        return self.leader(a) == self.leader(b)

    def leader(self, a):
        """"""
        Finds the leader of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The leader of the set containing a.
        """"""
        assert 0 <= a < self._n
        if self.parent_or_size[a] < 0:
            return a
        self.parent_or_size[a] = self.leader(self.parent_or_size[a])
        return self.parent_or_size[a]

    def size(self, a):
        """"""
        Returns the size of the set containing a.

        Parameters:
        a (int): An element in the set.

        Returns:
        int: The size of the set containing a.
        """"""
        assert 0 <= a < self._n
        return -self.parent_or_size[self.leader(a)]

    def groups(self):
        """"""
        Returns all sets as a list of lists.

        Returns:
        list: A list of lists, where each list contains the members of a set.
        """"""
        leader_buf = [self.leader(i) for i in range(self._n)]
        result = [[] for _ in range(self._n)]
        for i in range(self._n):
            result[leader_buf[i]].append(i)
        return [r for r in result if r != []]
class SegTree:
    """"""
    Segment Tree class.
    """"""

    def __init__(self, init_val, segfunc, ide_ele):
        """"""
        Initializes the Segment Tree.

        Parameters:
        init_val (list): The initial values for the leaves of the tree.
        segfunc (function): The function to use for segment operations.
        ide_ele (any): The identity element for the segment function.
        """"""
        n = len(init_val)
        self.segfunc = segfunc
        self.ide_ele = ide_ele
        self.num = 1 << (n - 1).bit_length()
        self.tree = [ide_ele] * 2 * self.num
        # Set the initial values to the leaves
        for i in range(n):
            self.tree[self.num + i] = init_val[i]
        # Build the tree
        for i in range(self.num - 1, 0, -1):
            self.tree[i] = segfunc(self.tree[2 * i], self.tree[2 * i + 1])

    def update(self, k, x):
        """"""
        Updates the k-th value to x.

        Parameters:
        k (int): The index to update (0-indexed).
        x (any): The new value.
        """"""
        k += self.num
        self.tree[k] = x
        while k > 1:
            tk = k >> 1
            self.tree[tk] = self.segfunc(self.tree[tk << 1], self.tree[(tk << 1) + 1])
            k >>= 1

    def get(self, x):
        return self.tree[x + self.num]

    def query(self, l, r):
        """"""
        Queries the segment function result for the range [l, r).

        Parameters:
        l (int): The start index (0-indexed).
        r (int): The end index (0-indexed).

        Returns:
        any: The result of the segment function for the range [l, r).
        """"""
        res_l = self.ide_ele
        res_r = self.ide_ele

        l += self.num
        r += self.num
        while l < r:
            if l & 1:
                res_l = self.segfunc(res_l, self.tree[l])
                l += 1
            if r & 1:
                res_r = self.segfunc(self.tree[r - 1], res_r)
            l >>= 1
            r >>= 1
        res = self.segfunc(res_l, res_r)
        return res
class RSQandRAQ():
    """"""区間加算、区間取得クエリをそれぞれO(logN)で答える
    add: 区間[l, r)にvalを加える
    query: 区間[l, r)の和を求める
    l, rは0-indexed
    """"""

    def __init__(self, n, mod=None):
        self.n = n
        self.bit0 = [0] * (n + 1)
        self.bit1 = [0] * (n + 1)
        self.mod = mod
    def _add(self, bit, i, val):
        i = i + 1
        while i <= self.n:
            if self.mod is None:
                bit[i] += val
            else:
                bit[i] = (bit[i]+val)%self.mod
            i += i & -i

    def _get(self, bit, i):
        s = 0
        while i > 0:
            if self.mod is None:
                s += bit[i]
            else:
                s = (s + bit[i])%self.mod
            i-= i & -i
        return s

    def add(self, l, r, val):
        """"""区間[l, r)にvalを加える""""""
        self._add(self.bit0, l, -val * l)
        self._add(self.bit0, r,  val * r)
        self._add(self.bit1, l,  val)
        self._add(self.bit1, r, -val)

    def query(self, l, r):
        """"""区間[l, r)の和を求める""""""
        _res = (self._get(self.bit0, r) + r * self._get(self.bit1, r)
            - self._get(self.bit0, l) - l * self._get(self.bit1, l) )
        if self.mod is None:
            return _res
        else:
            return _res%self.mod
class Dinic:
    def __init__(self, n):
        self.n = n
        self.links = [[] for _ in range(n)]
        self.depth = None
        self.progress = None
 
    def add_link(self, _from, to, cap):
        self.links[_from].append([cap, to, len(self.links[to])])
        self.links[to].append([0, _from, len(self.links[_from]) - 1])
 
    def bfs(self, s):
        depth = [-1] * self.n
        depth[s] = 0
        q = deque([s])
        while q:
            v = q.popleft()
            for cap, to, rev in self.links[v]:
                if cap > 0 and depth[to] < 0:
                    depth[to] = depth[v] + 1
                    q.append(to)
        self.depth = depth
 
    def dfs(self, v, t, flow):
        if v == t:
            return flow
        links_v = self.links[v]
        for i in range(self.progress[v], len(links_v)):
            self.progress[v] = i
            cap, to, rev = link = links_v[i]
            if cap == 0 or self.depth[v] >= self.depth[to]:
                continue
            d = self.dfs(to, t, min(flow, cap))
            if d == 0:
                continue
            link[0] -= d
            self.links[to][rev][0] += d
            return d
        return 0
 
    def max_flow(self, s, t):
        flow = 0
        while True:
            self.bfs(s)
            if self.depth[t] < 0:
                return flow
            self.progress = [0] * self.n
            current_flow = self.dfs(s, t, float('inf'))
            while current_flow > 0:
                flow += current_flow
                current_flow = self.dfs(s, t, float('inf'))

mod = 10**9 + 7
CC = combination(10**6,mod)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        
        S = list(num)
        S = [int(x) for x in S]
        W = sum(S)
        if W%2==1:
            return 0
        n = len(S)
        target = W//2
        m = n//2
        dp = [[0]*(target+2) for _ in range(m+1)]
        dp[0][0] = 1
        for s in S:
            for i in range(target,-1,-1):
                for j in range(m-1,-1,-1):
                    dp[j+1][min(i+s,target+1)] = (
                        dp[j+1][min(i+s,target+1)]
                        + dp[j][i]
                    )%mod
        ans = 1
        C = Counter(S)
        
        ans = dp[m][target]*CC.fact[m]*CC.fact[n-m]%mod
        # print(dp,C)
        for v in C.values():
            ans = (ans * CC.factinv[v])%mod

        return ans",1441325130
aqxa2k,aqxa2k,91,3627,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<int>> d(n, vector<int>(m, -1)); 
        d[0][0] = 0; 

        set<array<int, 3>> st; 
        st.insert({d[0][0], 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny] == -1) {
                        d[nx][ny] = max(t + 1, a[nx][ny] + 1); 
                        st.insert({d[nx][ny], nx, ny}); 
                    }
                }
            }
        }

        return d[n - 1][m - 1]; 
        
    }
};",1441296110
aqxa2k,aqxa2k,91,3628,cpp,"const int dx[4]{0, 1, 0, -1}, dy[4]{1, 0, -1, 0}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size(); 

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2000000000))); 
        d[0][0][0] = 0; 

        set<array<int, 4>> st; 
        st.insert({0, 0, 0, 0}); 
        while (st.size()) {
            auto c = *st.begin(); 
            st.erase(c); 
            int x = c[1], y = c[2], t = c[0], z = c[3]; 
            
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i]; 
                int ny = y + dy[i]; 
                if (0 <= nx && nx < n && 0 <= ny && ny < m) {
                    if (d[nx][ny][z ^ 1] == 2000000000) {
                        d[nx][ny][z ^ 1] = max(t + 1 + z, a[nx][ny] + 1 + z); 
                        st.insert({d[nx][ny][z ^ 1], nx, ny, z ^ 1}); 
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]); 
        
    }
};",1441300647
aqxa2k,aqxa2k,91,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> c(2, 0); 
        for (int i = 0; i < num.size(); ++i) {
            c[i % 2] += (num[i] - '0'); 
        }
        return c[0] == c[1]; 
    }
};",1441281197
aqxa2k,aqxa2k,91,3637,cpp,"template <typename T>
T inverse(T a, T m) {
	T u = 0, v = 1;
	while (a != 0) {
		T t = m / a;
		m -= t * a; swap(a, m);
		u -= t * v; swap(u, v);
	}
	assert(m == 1);
	return u;
}

template<class T>
T power(T a, long long b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

template <typename T>
class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {

    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));

        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
            long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
            value = normalize(value * rhs.value - q * mod());
            return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
            value = normalize(value * rhs.value);
            return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
};
template <typename T> bool operator>(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value > rhs.value; }
template <typename T, typename U> bool operator>(const Modular<T>& lhs, U rhs) { return lhs > Modular<T>(rhs); }
template <typename T, typename U> bool operator>(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) > rhs; }

template <typename T> bool operator>=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value >= rhs.value; }
template <typename T, typename U> bool operator>=(const Modular<T>& lhs, U rhs) { return lhs >= Modular<T>(rhs); }
template <typename T, typename U> bool operator>=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) >= rhs; }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
template <typename T, typename U> bool operator<(const Modular<T>& lhs, U rhs) { return lhs < Modular<T>(rhs); }
template <typename T, typename U> bool operator<(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) < rhs; }

template <typename T> bool operator<=(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value <= rhs.value; }
template <typename T, typename U> bool operator<=(const Modular<T>& lhs, U rhs) { return lhs <= Modular<T>(rhs); }
template <typename T, typename U> bool operator<=(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) <= rhs; }

template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/

constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string ss) {
        vector<int> a; 
        for (char c: ss) a.push_back(c - '0'); 

        int s = accumulate(a.begin(), a.end(), 0); 
        if (s % 2) return 0; 

        int n = a.size(); 
        vector<int> f(10, 0); 
        for (int i = 0; i < n; ++i) f[a[i]]++; 

        s /= 2;  
        
        vector<vector<Mint>> dp(n + 1, vector<Mint>(s + 1, Mint(0))); 
        dp[0][0] = 1; 

        int hv = 0; 
        for (int v = 0; v < 10; ++v) {
            vector<vector<Mint>> dp2(n + 1, vector<Mint>(s + 1, Mint(0))); 
            
            for (int c = 0; c <= f[v]; ++c) {
                for (int i = 0; i + c <= n; ++i) {
                    for (int j = 0; j + (c * v) <= s; ++j) {
                        dp2[i + c][j + (c * v)] += dp[i][j] * C(i + c, c) * C(hv - i + f[v] - c, f[v] - c); 
                    }
                }
            }

            hv += f[v]; 
            dp = dp2; 
        }

        int ans = (int)dp[n / 2][s]; 
        return ans; 
        // return (dp[n / 2][s]) % md; 
    }
};",1441333231
user5860c,user5860c,92,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 1;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441345728
user5860c,user5860c,92,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

ll best[888][888][2];
struct cel {
    int x, y,  b;
};
int dx[] = {-1,1,0,0};
int dy[] = {0,0,-1,1};

struct ComparePair {
  bool operator()(const pair<long long, cel>& a, const pair<long long, cel>& b) {
    return a.first > b.first;  // Modify this to use 'cel' fields if needed
  }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        priority_queue<pair<ll, cel>, vector<pair<ll, cel>>, ComparePair> pq;
        int N = v.size();
        int M = v[0].size();
        FOR(i, N) {
            FOR(j, M) {
                FOR(b, 2) {
                    best[i][j][b] = -1;
                }
            }
        }
        best[0][0][0] = 0;
        pq.push({0, {0,0,0}});
        while(sz(pq)) {
            auto xc = pq.top(); pq.pop();
            auto el = xc.sc;
            //cout << el.x << "" "" << el.y  << "" "" << el.b << endl;
            if (best[el.x][el.y][el.b] != xc.fs) continue;
            FOR(k, 4) {
                int cr = (el.b == 0) ? 1 : 2;
                int nx = el.x + dx[k];
                int ny = el.y + dy[k];
                int nb = el.b ^ 1;
                if (nx < 0 || ny < 0 || nx >= N || ny >= M) continue;
                ll nc = max(best[el.x][el.y][el.b], 1LL*v[nx][ny])  + cr;
                //cout << nx << "" "" << ny << "" "" << nb << "" "" << nc << endl;
                if (best[nx][ny][nb] == -1) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                } else if (best[nx][ny][nb] > nc) {
                    best[nx][ny][nb] = nc;
                    pq.push({nc, {nx,ny,nb}});
                }
            }
        }
        ll ret = best[N-1][M-1][0];
        if (ret == -1) ret = best[N-1][M-1][1];
        else if (best[N-1][M-1][1] != -1) ret = min(ret, best[N-1][M-1][1]);
        return ret;
    }
};",1441344214
user5860c,user5860c,92,3636,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';
class Solution {
public:
    bool isBalanced(string v) {
        int o1 = 0;
        int o2 = 0;
        FOR(i, sz(v)) {
            if (i%2) {
                o1 += v[i] - '0';
            } else {
                o2 += v[i] - '0';
            }
        }
        return o1 == o2;
    }
};",1441346769
user5860c,user5860c,92,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<double, double> pdd;
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define rep(i, from, to) for (int i = from; i < (to); ++i)
#define all(x) x.begin(), x.end()
#define sz(x) (int)(x).size()
#define FOR(i, to) for (int i = 0; i < (to); ++i)
typedef vector<vector<int> > vvi;
typedef vector<ll> vll;
typedef vector<vll> vvll;
typedef vector<pair<int, int> > vpi;
typedef pair<ll,ll> pll;
typedef vector<string> vs;
const char en = '\n';

#define MOD 1000000007

template<int MODX>
struct ModInt {
  unsigned x;
  ModInt() : x(0) { }
  ModInt(signed sig) : x(((sig%MODX)+MODX)%MODX) {  }
  ModInt(signed long long sig) : x(((sig%MODX)+MODX)%MODX) { }
  int get() const { return (int)x; }
  ModInt pow(ll p) { ModInt res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  ModInt &operator+=(ModInt that) { if ((x += that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator-=(ModInt that) { if ((x += MODX - that.x) >= MODX) x -= MODX; return *this; }
  ModInt &operator*=(ModInt that) { x = (unsigned long long)x * that.x % MODX; if (x < 0) x += MODX; return *this; }
  ModInt &operator/=(ModInt that) { return (*this) *= that.pow(MODX - 2); }
 
  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }
  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }
  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }
  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }
  bool operator<(ModInt that) const { return x < that.x; }
  friend ostream& operator<<(ostream &os, ModInt a) { os << a.x; return os; }
};
typedef ModInt<MOD> mint;


// N ~ 10^6
class Combinations {
public:
  vector<mint> inv, fact, ifact;

  Combinations(int N) {
    inv.resize(N+10), fact.resize(N+10), ifact.resize(N+10);
    inv[1] = fact[0] = fact[1] = ifact[0] = ifact[1] = 1;
    for(int i=2;i<=N;++i) {
      inv[i] = inv[MOD%i] * (MOD - MOD/i);
      fact[i] = fact[i-1]*i;
      ifact[i] = ifact[i-1]*inv[i];
    }
  }
  // a > b
  mint comb(ll a, ll b) {
    if(a < b) return mint(0);
    return fact[a] * ifact[b] * ifact[a-b];
  }
};

Combinations comb(1000);

mint best[11][82*10][82];

class Solution {
public:
    int countBalancedPermutations(string v) {
        int sum = 0;
        vi cnt(10);
        for (auto x : v) {
            sum += (x-'0');
            cnt[x-'0']++;
        }
        if (sum%2) return 0;
        for (int i=0;i<=10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    best[i][s][k] = 0;
                }
            }
        }
        best[0][0][0] = 1;
        int placed = 0;
        for (int i=0;i<10;++i) {
            for (int k=0;k<sz(v);++k) {
                for (int s = 0;s <= sum/2; ++s) {
                    for (int j=0;j<=cnt[i] && s + j * i <= sum/2;++j) {
                        if (best[i][s][k].x == 0) continue;
                        //cout << i << "" "" << k << "" "" << j << "" "" << s << "" "" << endl;
                        //cout << i+1 << "" "" << s + j * (i) << "" "" << k + j << endl;
                        best[i+1][s + j * (i)][k+j] += 
                            best[i][s][k] * ( comb.comb(k+j,j) * comb.comb(placed-k+cnt[i]-j, cnt[i]-j));
                        //cout << best[i][s][k] * ( comb.comb(k+j,j) + comb.comb(placed-k+cnt[i]-j, cnt[i]-j)) << endl;
                    }
                }
            }
            placed += cnt[i];
        }
        mint ret = best[10][sum/2][(sz(v)+1)/2];
        return ret.x;
    }
};",1441318305
Abhishek Choudhary,theabbie,94,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441294424
Abhishek Choudhary,theabbie,94,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        dist = [[float('inf')] * n for _ in range(m)]
        dist[0][0] = 0
        heap = [(0, 0, 0, True)]
        while heap:
            d, i, j, even = heapq.heappop(heap)
            if (i, j) == (m - 1, n - 1):
                return d
            cost = 1 if even else 2
            for x, y in [(i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)]:
                if 0 <= x < m and 0 <= y < n and max(d, moveTime[x][y]) + cost < dist[x][y]:
                    dist[x][y] = max(d, moveTime[x][y]) + cost
                    heapq.heappush(heap, (dist[x][y], x, y, not even))",1441293690
Abhishek Choudhary,theabbie,94,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = [0, 0]
        for i in range(len(num)):
            s[i % 2] += int(num[i])
        return s[0] == s[1]",1441295519
Abhishek Choudhary,theabbie,94,3637,python3,"M = 10 ** 9 + 7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        f = [1] * (n + 1)
        rf = [1] * (n + 1)
        for i in range(1, n + 1):
            f[i] = i * f[i - 1]
            f[i] %= M
            rf[i] = pow(f[i], M - 2, M)
        ctr = [0] * 10
        s = 0
        for c in num:
            s += int(c)
            ctr[int(c)] += 1
        if s & 1:
            return 0
        cache = [[[-1] * ((s // 2) + 1) for _ in range(n + 1)] for _ in range(10)]
        def dp(d, l, rem):
            if d > 9:
                return int(l == 0 and rem == 0)
            if cache[d][l][rem] != -1:
                return cache[d][l][rem]
            res = 0
            for take in range(ctr[d] + 1):
                if take > l or d * take > rem:
                    continue
                res += rf[take] * rf[ctr[d] - take] * dp(d + 1, l - take, rem - d * take)
                res %= M
            cache[d][l][rem] = res
            return res
        return (f[n // 2] * f[n - (n // 2)] * dp(0, n // 2, s // 2)) % M",1441348952
furuyarei,furuyarei,95,3627,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0)]
        dist = {(0, 0): 0}
        while q:
            d, x, y = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny) not in dist or max(d, a[nx][ny]) + 1 < dist[(nx, ny)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + 1, nx, ny))
                        dist[(nx, ny)] = max(d, a[nx][ny]) + 1
        return dist[(m - 1, n - 1)]
        ",1441293432
furuyarei,furuyarei,95,3628,python3,"class Solution:
    def minTimeToReach(self, a: List[List[int]]) -> int:
        m, n = len(a), len(a[0])
        q = [(0, 0, 0, 1)]
        dist = {(0, 0, 1): 0}
        while q:
            d, x, y, cost = heapq.heappop(q)
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < m and 0 <= ny < n:
                    if (nx, ny, 3 - cost) not in dist or max(d, a[nx][ny]) + cost < dist[(nx, ny, 3 - cost)]:
                        heapq.heappush(q, (max(d, a[nx][ny]) + cost, nx, ny, 3 - cost))
                        dist[(nx, ny, 3 - cost)] = max(d, a[nx][ny]) + cost
        return min(dist.get((m - 1, n - 1, 1), inf), dist.get((m - 1, n - 1, 2), inf))",1441297122
furuyarei,furuyarei,95,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        p = q = 0
        for i, ch in enumerate(num):
            if i % 2 == 0:
                p += int(ch)
            else:
                q += int(ch)
        return p == q",1441286385
furuyarei,furuyarei,95,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        
        @cache
        def C(n, k):
            if n < k:
                return 0
            if k == 0:
                return 1
            return (C(n - 1, k - 1) + C(n - 1, k)) % MOD

        @cache
        def S2(n, k):
            # print(n + k - 1, k - 1)
            return C(n + k - 1, k - 1)

        c = Counter(int(d) for d in num)
        # print(c)
        
        @cache
        def f(x, p1, p2, diff):
            if x == 10:
                return int(p1 == p2 == diff == 0)

            alloc = c.get(x, 0)
            ans = 0
            for q1 in range(alloc + 1):
                q2 = alloc - q1
                if q1 > p1 or q2 > p2:
                    continue
                coef = S2(q1, p1 - q1 + 1) * S2(q2, p2 - q2 + 1) % MOD
                ans += coef * f(x + 1, p1 - q1, p2 - q2, diff + (q1 - q2) * x) % MOD
            #     print(f""coef = {q1} {p1 - q1 + 1} {q2} {p2 - q2 + 1} = {S2(q1, p1 - q1 + 1)} {S2(q2, p2 - q2 + 1)}"")
            #     print(f""from = {x + 1} {p1 - q1} {p2 - q2} {diff + (q1 - q2) * x}"")
            # print(f""{x} {p1} {p2} {diff} = {ans}"")
            return ans % MOD

        l = len(num)
        ans = f(0, (l + 1) // 2, l // 2, 0)
        C.cache_clear()
        S2.cache_clear()
        f.cache_clear()
        return ans",1441349069
Nicholas,nicholask_17,97,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
using pii=pair <int,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m];
        bool visited[n][m];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                dist[i][j]=2e9;
                visited[i][j]=0;
            }
        }
        priority_queue <pair <int,pii>,vector <pair <int,pii> >,greater <pair <int,pii> > > pq;
        dist[0][0]=0; pq.push({0,{0,0}});
        while (!pq.empty()){
            pair <int,pii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first][tp.second.second]) continue;
            visited[tp.second.first][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first+dx[dir],ny=tp.second.second+dy[dir];
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny]) continue;
                if (max(tp.first,moveTime[nx][ny])+1<dist[nx][ny]){
                    dist[nx][ny]=max(tp.first,moveTime[nx][ny])+1;
                    pq.push({dist[nx][ny],{nx,ny}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441298407
Nicholas,nicholask_17,97,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using pii=pair <int,int>;
        using tii=pair <pii,int>;
        const int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};
        int n=moveTime.size(),m=moveTime[0].size();
        int dist[n][m][2];
        bool visited[n][m][2];
        for (int i=0; i<n; i++){
            for (int j=0; j<m; j++){
                for (int k=0; k<2; k++){
                    dist[i][j][k]=2e9;
                    visited[i][j][k]=0;
                }
            }
        }
        priority_queue <pair <int,tii>,vector <pair <int,tii> >,greater <pair <int,tii> > > pq;
        dist[0][0][0]=0; pq.push({0,{{0,0},0}});
        while (!pq.empty()){
            pair <int,tii> tp=pq.top(); pq.pop();
            if (visited[tp.second.first.first][tp.second.first.second][tp.second.second]) continue;
            visited[tp.second.first.first][tp.second.first.second][tp.second.second]=1;
            for (int dir=0; dir<4; dir++){
                int nx=tp.second.first.first+dx[dir],ny=tp.second.first.second+dy[dir],nz=1-tp.second.second;
                if (nx<0||nx>=n||ny<0||ny>=m) continue;
                if (visited[nx][ny][nz]) continue;
                if (max(tp.first,moveTime[nx][ny])+(nz==1?1:2)<dist[nx][ny][nz]){
                    dist[nx][ny][nz]=max(tp.first,moveTime[nx][ny])+(nz==1?1:2);
                    pq.push({dist[nx][ny][nz],{{nx,ny},nz}});
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441303421
Nicholas,nicholask_17,97,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0,sum2=0;
        for (int i=0; i<num.size(); i++){
            if (i%2==0) sum1+=num[i]-'0';
            else sum2+=num[i]-'0';
        }
        return sum1==sum2;
    }
};",1441281077
Nicholas,nicholask_17,97,3637,cpp,"class Solution {
public:
    const long long mod=1e9+7LL;
    long long f[100],inv[100],finv[100];
    void init(){
        f[0]=f[1]=inv[0]=inv[1]=finv[0]=finv[1]=1;
        for (int i=2; i<100; i++){
            f[i]=f[i-1]*i%mod;
            inv[i]=inv[mod%i]*(mod-mod/i)%mod;
            finv[i]=finv[i-1]*inv[i]%mod;
        }
    }
    long long ncr(int n,int r){
        if (n<r||r<0) return 0;
        return f[n]*finv[n-r]%mod*finv[r]%mod;
    }
    int countBalancedPermutations(string num) {
        init();
        int n=num.size();
        int sum=0;
        for (char i:num) sum+=i-'0';
        if (sum%2) return 0;
        int cnt[10];
        for (int i=0; i<10; i++) cnt[i]=0;
        for (char i:num) cnt[(i-'0')]++;
        int dp[11][41][1500];
        for (int i=0; i<11; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++) dp[i][j][k]=0;
            }
        }
        dp[0][0][750]=1;
        int done=0;
        for (int i=0; i<10; i++){
            for (int j=0; j<41; j++){
                for (int k=0; k<1500; k++){
                    if (!dp[i][j][k]) continue;
                    for (int l=0; l<=cnt[i]&&j+l<41; l++){
                        long long way=ncr((n+1)/2-j,l)*ncr(n/2-(done-j),cnt[i]-l)%mod;
                        if (k+i*l-(cnt[i]-l)*i>=0&&k+i*l-(cnt[i]-l)*i<1500){
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]+=way*dp[i][j][k]%mod;
                            dp[i+1][j+l][k+i*l-(cnt[i]-l)*i]%=mod;
                        }
                    }
                }
            }
            done+=cnt[i];
        }
        int ans=0;
        for (int i=0; i<41; i++) ans=(ans+dp[10][i][750])%mod;
        return ans;
    }
};",1441322955
Dhruv Pasricha,pasricha_dhruv,99,3627,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441317612
Dhruv Pasricha,pasricha_dhruv,99,3628,cpp,"int dp[1000][1000][3];
int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
#define vi vector<int>
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {

        int n = a.size(), m = a[0].size();
        
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < m; ++j)
            {
                dp[i][j][1] = INT_MAX;
                dp[i][j][2] = INT_MAX;
            }
        }

        priority_queue<vi, vector<vi>, greater<vi>> pq;
        dp[0][0][2] = 0;
        pq.push({0, 2,  0, 0});
        
        while(pq.size())
        {
            auto cur = pq.top();
            pq.pop();

            int d = cur[0], h = cur[1], x = cur[2], y = cur[3];

            if(dp[x][y][h] != d) continue;
            
            for(int i = 0; i < 4; ++i)
            {
                int x_ = x + dx[i], y_ = y + dy[i];
                int h_ = h == 1 ? 2 : 1;
                
                if(x_ < 0 or x_ >= n or y_ < 0 or y_ >= m) continue;
            
                if(max(a[x_][y_], d) + h_ < dp[x_][y_][h_])
                {
                    dp[x_][y_][h_] = max(a[x_][y_], d) + h_;
                    pq.push({dp[x_][y_][h_], h_, x_, y_});
                }
            }
        }
        
        return min(dp[n - 1][m - 1][1], dp[n - 1][m - 1][2]);
    }
};",1441316521
Dhruv Pasricha,pasricha_dhruv,99,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i = 0; i < n; ++i)
        {
            num[i] -= '0';
            if(i % 2 == 0) sum1 += num[i];
            else sum2 += num[i];
        }
        return sum1 == sum2;
    }
};",1441281493
Dhruv Pasricha,pasricha_dhruv,99,3637,cpp,"#define int long long

const int N = 1e2 + 10, MOD = 1e9 + 7, mod = 1e9 + 7;
 
int fact[N + 1], invFact[N + 1];
 
// x^n % MOD
int power(int x, int n)
{
    if(n == 0)
    {
        return 1;
    }
 
    if(n % 2 == 0)
    {
        int ans = power(x, n / 2);
        ans = (ans * ans) % MOD;
        return ans;
    }
 
    return (x * power(x, n - 1)) % MOD;
}
 
// mod inverse
int modInverse(int x)
{
    return power(x, MOD - 2);
}
 
void pre()
{
    fact[0] = 1;
    for(int i = 1; i <= N; ++i)
    {
        fact[i] = (i * fact[i - 1]) % MOD;
    }
 
    for(int i = 0; i <= N; ++i)
    {
        invFact[i] = modInverse(fact[i]);
    }
}
 
int Binomial(int n, int r)
{
    if(r > n or n < 0 or r < 0) return 0;

    int ans = fact[n];
    ans *= invFact[n - r];
    ans %= MOD;
    ans *= invFact[r];
    ans %= MOD;
    return ans;
}
 
int freq[10], dp[10][42][410];

int solve(int cur, int remOddPlaces, int remEvenPlaces, int remOddSum, int remEvenSum)
{
    if(remOddPlaces < 0 or remEvenPlaces < 0 or remOddSum < 0 or remEvenSum < 0)
        return 0;
    
    if(cur == -1)
    {
        return 1;
    }

    if(dp[cur][remOddPlaces][remOddSum] != -1) return dp[cur][remOddPlaces][remOddSum]; 

    int ans = 0;
    for(int even = 0; even <= freq[cur]; ++even)
    {
        int odd = freq[cur] - even;

        int curAns = (Binomial(remOddPlaces, odd) * Binomial(remEvenPlaces, even)) % mod;
        curAns *= solve(cur - 1, remOddPlaces - odd, remEvenPlaces - even, remOddSum - odd * cur, remEvenSum - even * cur);
        curAns %= mod;

        ans += curAns;
        ans %= mod;
    }

    return dp[cur][remOddPlaces][remOddSum] = ans;
}

class Solution {
public:
    int countBalancedPermutations(string num) {

        pre();
        memset(freq, 0, sizeof(freq));
        memset(dp, -1, sizeof(dp));
    
        int sum = 0;
        for(auto it : num)
        {
            sum += it - '0';
            freq[it - '0']++;
        }
    
        if(sum % 2 == 1)
        {
            return 0;
        }

        int n = num.size();

        return solve(9, (n + 1) / 2, n / 2, sum / 2, sum / 2);
    }
};

#undef int",1441343833
Behrooz Sepehry,sepehry,100,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj

        node0 = (0, 0)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))

        return visited_dist[(n - 1, m - 1)]
",1441295828
Behrooz Sepehry,sepehry,100,3628,python3,"
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        def nei(node):
            i, j, odd = node
            for di, dj in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                ii = i + di
                jj = j + dj
                if 0 <= ii < n and 0 <= jj < m:
                    yield ii, jj, not odd

        node0 = (0, 0, True)

        q = [(0, node0)]
        visited_dist = {}

        while q:
            dist, node = heapq.heappop(q)
            if node not in visited_dist:
                visited_dist[node] = dist
                for node2 in nei(node):
                    if node2 not in visited_dist:
                        heapq.heappush(q, (node2[2] + max(dist + 1, 1 + moveTime[node2[0]][node2[1]]), node2))
        sol = float('inf')

        if (n - 1, m - 1, False) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, False)])
        if (n - 1, m - 1, True) in visited_dist:
            sol = min(sol, visited_dist[(n - 1, m - 1, True)])

        return sol
",1441311181
Behrooz Sepehry,sepehry,100,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(c) for c in num[::2]) == sum(int(c) for c in num[1::2])
",1441281738
Behrooz Sepehry,sepehry,100,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        cc = collections.Counter(num)
        F = [cc[str(ii)] for ii in range(10)]

        mod = ((10 ** 9) + 7)

        @functools.lru_cache(None)
        def dp(d, rem_odd, rem_even, balance):
            if d == -1:
                return rem_odd == 0 and rem_even == 0 and balance == 0
            f = F[d]
            min_f_odd = max(0, f - rem_even)
            max_f_odd = min(rem_odd, f)
            vvv = 0
            for f_odd in range(min_f_odd, max_f_odd + 1):
                f_even = f - f_odd
                vvv += ((math.comb(rem_odd, f_odd) % mod) * (math.comb(rem_even, f_even) % mod) * dp(d - 1,
                                                                                                     rem_odd - f_odd,
                                                                                                     rem_even - f_even,
                                                                                                     balance + (
                                                                                                                 f_odd - f_even) * d)) % mod
                vvv %= mod

            return vvv

        n2 = n // 2
        sol = dp(9, n2, n - n2, 0)
        dp.cache_clear()
        return sol % mod
",1441343869
Aryan470,Aryan470,102,3627,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, i, j = heapq.heappop(q)
            if i == n-1 and j == m-1:
                return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                # check the time at which we can reach this guy
                this_reach = max(curr_time + 1, moveTime[u][v] + 1)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, u, v))
    
                ",1441291107
Aryan470,Aryan470,102,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # can we do dijkstra?
        reach_time = {}
        n, m = len(moveTime), len(moveTime[0])
        
        q = [(0, True, 0, 0)]
        reach_time[(0, 0)] = 0
        while q:
            curr_time, first_move, i, j = heapq.heappop(q)
            # if i == n-1 and j == m-1:
                # return curr_time
            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                u, v = i + di, j + dj
                if u >= n or u < 0 or v >= m or v < 0:
                    continue

                delta_time = 1 if first_move else 2
                # check the time at which we can reach this guy
                this_reach = max(curr_time + delta_time, moveTime[u][v] + delta_time)
                if (u,v) not in reach_time or this_reach < reach_time[(u, v)]:
                    reach_time[(u, v)] = this_reach
                    heapq.heappush(q, (this_reach, not first_move, u, v))
        
        return reach_time[(n-1,m-1)]
    
                ",1441294437
Aryan470,Aryan470,102,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            dig = int(num[i])
            if i % 2 == 0:
                es += dig
            else:
                os += dig
        return es == os",1441280972
Aryan470,Aryan470,102,3637,python3,"from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # sum of digs has to be 2k
        # how many ways can we choose n//2 digs with sum k
        # then how many ways can we permute those
        sum_digs = sum(int(c) for c in num)
        if sum_digs % 2 != 0:
            return 0
        
        target_sum = sum_digs // 2
        num_to_choose = len(num) // 2
        # first n digits with sum k
        # choose z digits with sum k
        # sum can be up to 80 * 9 and num digs can be up to 80
        # dp[i][k] = num sets of i digits with sum k

        max_sum = target_sum
        dp = [[0 for j in range(max_sum+1)] for i in range(num_to_choose + 1)]
        dp[0][0] = 1

        for i in range(len(num)):
            dig = int(num[i])
            for num_dig in range(num_to_choose, 0, -1):
                for k in range(dig, max_sum+1):
                    if k - dig >= 0:
                        dp[num_dig][k] += dp[num_dig - 1][k - dig]
        num_partitions = dp[num_to_choose][target_sum]
        # if 2 * num_to_choose == len(num):
            # num_partitions //= 2
        # print(dp)
        # print(num_partitions)
        # now given this, for each partition we can make some permutations
        # how many ways can we permute num_to_choose numbers * (n - num_to_choose) // (num 0! * num 1! * num 2!)
        def fact(x):
            prod = 1
            for u in range(2,x+1):
                prod *= u
            return prod
            
        ans = num_partitions * fact(num_to_choose) * fact(len(num) - num_to_choose)
        # print(ans)
        digcnt = Counter(int(c) for c in num)
        for dig, cnt in digcnt.items():
            if cnt > 1:
                ans //= fact(cnt)
        return ans % (10**9 + 7)",1441338715
Remineva,Remineva,103,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                if 0 <= di < m and 0 <= dj < n:
                    new = max(t, moveTime[di][dj]) + 1
                    if new < time[di][dj]:
                        time[di][dj] = new
                        heappush(h, (new, di, dj))

",1441301058
Remineva,Remineva,103,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        h = [(0, 0, 0, True)]
        m = len(moveTime)
        n = len(moveTime[0])
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0

        while h:
            t, i, j, flag = heappop(h)
            if i == m - 1 and j == n - 1:
                return t
            if t > time[i][j]:
                continue
            if flag:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 1
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, False))
            else:
                for di, dj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:
                    if 0 <= di < m and 0 <= dj < n:
                        new = max(t, moveTime[di][dj]) + 2
                        if new < time[di][dj]:
                            time[di][dj] = new
                            heappush(h, (new, di, dj, True))
",1441309971
Remineva,Remineva,103,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        flag = True
        for c in num:
            if flag:
                s += int(c)
            else:
                s -= int(c)
            flag = not flag
        return s == 0",1441280982
Remineva,Remineva,103,3637,python3,"M = 10 ** 9 + 7
def ncr(n, r, p):
    num = den = 1 
    for i in range(r):
        num = (num * (n - i)) % p
        den = (den * (i + 1)) % p
    return (num * pow(den, p - 2, p)) % p
m = 100 + 1
fac = [1] * m
for i in range(2, m):
    fac[i] = fac[i-1] * i % M

inv = [1] * m
inv[-1] = pow(fac[-1], M - 2, M)
for i in range(m - 2, 1, -1):
    inv[i] = inv[i+1] * (i + 1) % M
    
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        s = 0
        cnt = [0] * 10
        for c in num:
            curr = int(c)
            s += curr
            cnt[curr] += 1
        if s & 1:
            return 0
        s //= 2
        n = len(num)
        m = (n + 1) // 2
        
        dp = [[0] * (s + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        for digit in range(10):
            temp = cnt[digit]
            if temp == 0:
                continue
            
            for i in range(m, -1, -1):
                for j in range(s, -1, -1):
                    if dp[i][j] == 0:
                        continue
                    for di in range(1, min(temp, m - i) + 1):
                        dj = di * digit
                        if j + dj > s:
                            break
                        dp[i + di][j + dj] += dp[i][j] * ncr(temp, di, M)
                        dp[i + di][j + dj] %= M
        res = dp[-1][-1]
        f = 1
        for digit in range(10):
            f = f * fac[cnt[digit]] % M
        inv_f = pow(f, M - 2, M)
        
        res *= fac[m] * fac[n - m]
        res %= M
        res *= inv_f
        res %= M
        return res

        ",1441345758
M Kawa,mkawa222,107,3627,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            nd=max(d+1,mt[ni][nj]+1)
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441297946
M Kawa,mkawa222,107,3628,python3,"from heapq import *
inf=10**16

def dijkstra(mt, root=0):
    h,w=len(mt),len(mt[0])
    n = h*w
    dist = [inf]*n
    dist[root] = 0
    hp = [(0, root)]
    while hp:
        d, u = heappop(hp)
        if d > dist[u]: continue
        i,j=divmod(u,w)
        for di, dj in dij:
            ni, nj = i+di, j+dj
            if ni < 0 or nj < 0 or ni >= h or nj >= w: continue
            v=ni*w+nj
            cost=((i^j)&1)+1
            nd=max(d,mt[ni][nj])+cost
            if dist[v] <= nd: continue
            dist[v] = nd
            heappush(hp, (nd, v))
    return dist[-1]
dij = [(0, 1), (-1, 0), (0, -1), (1, 0)]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        return dijkstra(moveTime)
",1441315942
M Kawa,mkawa222,107,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s=0
        p=1
        for c in num:
            s+=int(c)*p
            p=-p
        return s==0

",1441285811
M Kawa,mkawa222,107,3637,python3,"def nCr(com_n, com_r):
    if com_r < 0: return 0
    if com_n < com_r: return 0
    return fac[com_n]*ifac[com_r]%md*ifac[com_n-com_r]%md

md = 10**9+7
n_max = 200
fac = [1]
for i in range(1, n_max+1): fac.append(fac[-1]*i%md)
ifac = [1]*(n_max+1)
ifac[n_max] = pow(fac[n_max], md-2, md)
for i in range(n_max-1, 1, -1): ifac[i] = ifac[i+1]*(i+1)%md

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        aa = list(map(int, num))
        s = sum(aa)
        if s & 1: return 0
        s >>= 1
        n = len(aa)
        m = n//2
        em = n-m
        cnt = [0]*10
        for a in aa: cnt[a] += 1
        dp = [[0]*(s+1) for _ in range(m+1)]
        dp[0][0] = 1
        si = sj = 0
        for a in range(10):
            if cnt[a] == 0: continue
            ndp = [[0]*(s+1) for _ in range(m+1)]
            for i in range(m+1)[::-1]:
                ei = si-i
                for j in range(s+1):
                    pre = dp[i][j]
                    if pre == 0: continue
                    ej = sj-j
                    for c in range(cnt[a]+1):
                        ec = cnt[a]-c
                        if i+c > m or ei+ec > em or j+a*c > s or ej+a*ec > s: continue
                        ndp[i+c][j+a*c] += pre*nCr(m-i, c)%md*nCr(em-ei, ec)%md
                        ndp[i+c][j+a*c] %= md
            dp = ndp
            si += cnt[a]
            sj += cnt[a]*a
        return dp[-1][-1]%md
",1441353918
PankajGhodla,PankajGhodla,108,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c))

        return -1",1441291398
PankajGhodla,PankajGhodla,108,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 0)]
        dic = defaultdict(lambda : inf)
        n = len(moveTime)
        m = len(moveTime[0])
        while heap:
            time, r, c, move = heappop(heap)
            if r == n-1 and c == m-1:
                return time
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                new_r, new_c = r+dr, c+dc
                if 0<=new_r<n and 0<=new_c<m:
                    if dic[(new_r, new_c)] > max(time, moveTime[new_r][new_c]) + move + 1:
                        new_t = max(time, moveTime[new_r][new_c]) + move + 1
                        dic[(new_r, new_c)] = new_t
                        heappush(heap, (new_t, new_r, new_c, (move+1)%2 ))

        return -1",1441293810
PankajGhodla,PankajGhodla,108,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even = odd = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281353
PankajGhodla,PankajGhodla,108,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10**9 + 7
        counter = Counter()
        
        totalSum = 0
        for digit in num: 
            totalSum += int(digit)
            counter[int(digit)] += 1
        prefix = [0]*10
        prefix[0] = counter[0]
        for i in range(1, 10):
            prefix[i] = prefix[i-1] + counter[i] 
        # print(prefix)
        n = len(num)
        @cache
        def solve(digit, count, total):
            # print(digit, count, total)
            if digit == 10:
                # print(digit, count, total)
                return (count == n//2) and total*2 == totalSum
            ans = solve(digit+1, count, total) * math.comb(prefix[digit] - count, counter[digit])
            # print(math.comb(prefix[digit], counter[digit]), (prefix[digit], counter[digit]), digit)
            for i in range(counter[digit]):
                remaining = prefix[digit] - (count + i + 1)
                ans += solve(digit+1, count+i+1, total + digit*(i+1)) * math.comb(count+i+1, i+1) * math.comb(remaining, counter[digit] - (i+1))
                # print(math.comb(remaining, counter[digit] - (i+1)), math.comb(count+i+1, i+1), (count+i+1, i+1))
            return ans % MOD
        return solve(0, 0, 0)
            
            
            ",1441347745
cm_fast,cm_fast,109,3627,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441297393
cm_fast,cm_fast,109,3628,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &arr)
    {
        int n = arr.size();
        int m = arr[0].size();
        const ll INF = 1e18;
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
       priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, std::greater<tuple<long long, int, int, int>>> pq;
        dist[0][0][0] = 0;
        pq.emplace(0, 0, 0, 0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        int ans=-1;
        while (!pq.empty())
        {
            auto [val, x, y, turn] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1)
            {
                return val;
            }

            if (val > dist[x][y][turn])
            {
                continue;
            }

            for (int j = 0; j < 4; j++)
            {
                int nx = x + dx[j];
                int ny = y + dy[j];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                {
                    continue;
                }
                int next_turn = 1 - turn;
                int steps = 1;
                if (turn)
                {
                    steps++;
                }
                ll start_time = max((ll)val, (ll)arr[nx][ny]);
                ll new_time = start_time + steps;
                if (new_time < dist[nx][ny][next_turn])
                {
                    dist[nx][ny][next_turn] = new_time;
                    pq.emplace(new_time, nx, ny, next_turn);
                }
            }
        }
        return ans;
    }
};
",1441296687
cm_fast,cm_fast,109,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1=0;
        int sum2=0;
        for(int i=0;i<(int)(num.size());i++)
        {
            if(i%2)
            {
                sum1+=(int)(num[i]-'0');
            }
            else
                
            {
                sum2+=(int)(num[i]-'0');
            }
            
        }
        return (sum1==sum2);
    }
};",1441282765
cm_fast,cm_fast,109,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
const int MAX_N = 80; // Maximum possible n as per constraints

ll gcd_custom(ll a, ll b)
{
    if (b == 0)
        return a;
    return gcd_custom(b, a % b);
}

ll add(ll x, ll y)
{
    x += y;
    while (x >= MOD)
        x -= MOD;
    while (x < 0)
        x += MOD;
    return x;
}

ll mul(ll x, ll y)
{
    return (x * y) % MOD;
}

ll binpow(ll x, ll y)
{
    ll z = 1;
    while (y)
    {
        if (y & 1)
        {
            z = mul(z, x);
        }
        x = mul(x, x);
        y >>= 1;
    }
    return z;
}

ll inv(ll x)
{
    return binpow(x, MOD - 2);
}

ll divide(ll x, ll y)
{
    return mul(x, inv(y));
}

ll fact_arr[81];
ll inv_fact_arr[81];

void precalc()
{
    fact_arr[0] = 1;
    for (ll i = 1; i <= 80; i++)
    {
        fact_arr[i] = mul(fact_arr[i - 1], i);
    }
    // Precompute inverse factorials
    inv_fact_arr[80] = divide(1, fact_arr[80]);
    for (ll i = 79; i >= 0; i--)
    {
        inv_fact_arr[i] = mul(inv_fact_arr[i + 1], i + 1);
    }
}

ll C(ll n, ll k)
{
    if (k > n || k < 0)
        return 0;
    return mul(fact_arr[n], mul(inv_fact_arr[k], inv_fact_arr[n - k]));
}

class Solution
{
public:
    
    ll memo_table[11][81][801]; 

    Solution()
    {
        for(int i=0;i<11;i++)
        {
            for(int j=0;j<81;j++)
            {
                 for(int k=0;k<801;k++)
                 {
                     memo_table[i][j][k] = -1;
                 }
            }
                
                    
        }
            
    }

    ll helper(int digit, int remaining_count, ll remaining_sum, const vector<ll> &original_freq)
    {
        if (remaining_count == 0 && remaining_sum == 0)
            return 1;
        if (digit > 9 || remaining_count < 0 || remaining_sum < 0)
            return 0;
        if (memo_table[digit][remaining_count][remaining_sum] != -1)
            return memo_table[digit][remaining_count][remaining_sum];
        ll total = 0;
        for (ll k = 0; k <= original_freq[digit] && k <= remaining_count && (ll)digit * k <= remaining_sum; k++)
        {
            total = add(total, mul(C(original_freq[digit], k), helper(digit + 1, remaining_count - k, remaining_sum - (ll)digit * k, original_freq)));
            total %= MOD;
        }
        return memo_table[digit][remaining_count][remaining_sum] = total;
    }

    ll countBalancedPermutations(string s)
    {
        precalc();
        ll n = s.size();
        if (n < 2)
            return 0;
        vector<ll> original_freq(10, 0);
        ll total_sum = 0;
        for (char c : s)
        {
            original_freq[c - '0']++;
            total_sum += (ll)(c - '0');
        }
        if (total_sum % 2 != 0)
            return 0;
        ll sum_p = total_sum / 2;
        int p = (n + 1) / 2;
        int q = n / 2;
        memset(memo_table, -1, sizeof(memo_table));
        ll ways = helper(0, p, sum_p, original_freq);
        if (ways == 0)
            return 0;
        ll fact_p = fact_arr[p];
        ll fact_q = fact_arr[q];
        ll denom = 1;
        for (int d = 0; d <= 9; d++)
        {
            denom = mul(denom, fact_arr[original_freq[d]]);
        }
        ll numerator = mul(mul(ways, fact_p), fact_q);
        ll denom_inv = inv(denom);
        ll result = mul(numerator, denom_inv);
        return result;
    }
};
",1441347789
Anupam Shah,user9218i,110,3627,cpp,"class Solution {
public:
    typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    vector<ll> dijkstra(vector<vector<pair<ll, ll>>> &G, ll v)
    {
        vector<ll> ans(G.size(), INF);
        ans[v] = 0;
        priority_queue<pair<ll, ll>> que;
        que.push({0, v});
        while (!que.empty())
        {
            auto [x, u] = que.top();
            que.pop();
            if (-x > ans[u])
                continue;
            for (auto [v, w] : G[u])
                if (ans[u] + w < ans[v])
                    ans[v] = ans[u] + w, que.push({-ans[v], v});
        }
        return ans;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        
        priority_queue<pair<ll, pair<ll,ll>>> que;
        que.push({0, {0, 0}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, ux = it.second.first, uy = it.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, {xx,yy}});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441301349
Anupam Shah,user9218i,110,3628,cpp,"class Solution {
public:
        typedef long long ll;
    const ll INF = (1LL << 62) - 1;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<ll, pair<ll, pair<ll, ll>>>> que;
        que.push({0, {1, {0, 0}}});
        
        const ll n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<ll>> ans(n, vector<ll> (m, INF));
        ans[0][0] = 0;
        
        ll xd[4] = {-1, 1, 0, 0};   ll yd[4] = {0, 0, 1, -1};
        while (!que.empty())
        {
            auto it = que.top();
            ll x = it.first, p = it.second.first, ux = it.second.second.first, uy = it.second.second.second;
            //cout << x << "" ""<< ux << "" ""<< uy << endl;
            
            que.pop();
            if (-x > ans[ux][uy])
                continue;
            
            for(int i = 0; i < 4; i ++) {
                ll xx = ux + xd[i], yy = uy + yd[i];
                if(xx >= 0 and xx < n and yy >= 0 and yy < m) {
                    
                    ll mini = ans[ux][uy];
                    if(moveTime[xx][yy] > mini) mini = moveTime[xx][yy];
                    
                    ll tme = mini + p;
                    ll np = 1;
                    
                    if(p == 1)  np = 2;  
                    else np = 1;
                    
                    if(tme < ans[xx][yy])
                        ans[xx][yy] = tme, que.push({-tme, { np, {xx,yy} }});
                }
            }
        }
        return ans[n-1][m-1];
    }
};",1441310479
Anupam Shah,user9218i,110,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int o = 0, e = 0;
        for(int i = 0; i < num.length(); i ++)
            if(i % 2)   o += num[i] - '0';
            else e += num[i] - '0';
        return o == e;
    }
};",1441281198
Anupam Shah,user9218i,110,3637,cpp,"class Solution {
public:
    typedef long long ll;
    ll MOD = 1000000007;
    
    ll power(ll a, ll b, ll m) {
        ll ans = 1;
        while(b) {
            if(b & 1)
                ans = (ans * a) % m;
            b /= 2;
            a = (a * a) % m;
        }
        return ans;
    }
    
    ll go(ll ind, ll tk, ll csum, ll& sum, ll& req, ll& n, vector<ll>& f, vector<ll>& ff, vector<ll>& iff, vector<vector<vector<ll>>>& dp) {
        //cout << ind << "" "" << ind << "" ""<< tk << "" ""<< csum << endl;
        if(ind == 10) {
            if(tk == req and csum == sum) {
                //cout << ""YY"" << endl;
                return (ff[req] * ff[n-req]) % MOD;
            }
            return 0;
        }
        if(tk > req)    return 0;
        if(csum > sum)    return 0;
        
        if(dp[ind][tk][csum] != -1)     return dp[ind][tk][csum];
        
        ll ans = 0;
        for(ll i = 0; i <= f[ind]; i ++) {
            if(tk + i <= req and (csum + ( i * ind )) <= sum) {
                ll curr = (iff[i] * iff[f[ind] - i]) % MOD; 
                ans += curr * go(ind + 1, tk + i, csum + (i*ind), sum, req, n, f, ff, iff, dp);
                ans %= MOD;
            }
        }
        
        return dp[ind][tk][csum] = ans;
    }
    int countBalancedPermutations(string num) {
        ll sum = 0;
        vector<ll> f(10, 0);
        for(auto it : num) {
            //cout << it-'0' << endl;
            sum += (it - '0');
            f[it - '0'] ++;
        }
        if(sum % 2)     return 0;
        sum /= 2;
        
        vector<ll> ff(100, 1);
        vector<ll> iff(100, 1);
        
        for(int i = 0; i < 100; i ++)  {
            if(i)   ff[i] = ff[i-1] * i;
            ff[i] %= MOD;
            
            iff[i] = power(ff[i], MOD-2, MOD);
        }
        
        ll n = num.length();
        ll req = n/2;
        
        //cout << sum << "" -> "" << req << endl;
        
        vector<vector<vector<ll>>> dp(10, vector<vector<ll>> (req+1, vector<ll> (sum+1, -1)));
        
        ll ans = go(0, 0, 0, sum, req, n, f, ff, iff, dp);
        return ans%MOD;
    }
};",1441354520
user5976fh,user5976fh,111,3627,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,3>> q;
        q.push({0,0,0});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + 1, moveTime[newB][newC] + 1);
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC});
                        }
                }
            }
            
        }
        return -1;
    }
};",1441293815
user5976fh,user5976fh,111,3628,cpp,"class Solution {
public:
    vector<int> dx = {1,-1,0,0};
    vector<int> dy = {0,0,-1,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // current time, coordinates
        // time is negative
        priority_queue<array<int,4>> q;
        q.push({0,0,0,1});
        vector<vector<int>> maxD(moveTime.size(), vector<int>(moveTime[0].size(), INT_MAX));
        vector<vector<int>> maxD2 = maxD;
        // let q[3] represent if move takes 1 or move takes 2
        while (!q.empty()){
            // if goal return true;
            auto [a,b,c,d] = q.top();
            q.pop();
            if (b == moveTime.size() - 1 && c == moveTime[0].size() - 1){
                return -a;
            }
            for (int i = 0; i < dx.size(); ++i){
                int newB = b + dx[i];
                int newC = c + dy[i];
                
                if (newB >= 0 && newB < moveTime.size() &&
                    newC >= 0 && newC < moveTime[0].size()){
                        int newT = max(-a + d, moveTime[newB][newC] + d);
                    // based on D check which table to use
                    if (d == 1){
                        if (newT < maxD[newB][newC]){
                            maxD[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                    else{
                        if (newT < maxD2[newB][newC]){
                            maxD2[newB][newC] = newT;
                            q.push({-newT, newB, newC, d == 2 ? 1 : 2});
                        }
                    }
                        
                }
            }
            
        }
        return -1;
    }
};",1441297442
user5976fh,user5976fh,111,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); ++i){
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
            
        }

        return sum == 0;
    }
};",1441281034
user5976fh,user5976fh,111,3637,cpp,"class Solution {
public:
    long long mod = 1e9 + 7;

    long long powerMod(long long x, long long y, long long modVal) {
        long long res = 1;
        x %= modVal;
        while (y > 0) {
            if (y & 1) res = res * x % modVal;
            x = x * x % modVal;
            y >>= 1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size();
        int freq[10] = {0};
        long long totalSum = 0;

        for (char c : num) {
            freq[c - '0']++;
            totalSum += (c - '0');
        }

        if (totalSum % 2 != 0) return 0;
        long long sumEven = totalSum / 2;
        int halfN = (n + 1) / 2;
        int maxLimit = 160;

        vector<long long> fact(maxLimit + 1, 1);
        for (int i = 1; i <= maxLimit; i++) fact[i] = fact[i - 1] * i % mod;

        vector<long long> invFact(maxLimit + 1, 1);
        invFact[maxLimit] = powerMod(fact[maxLimit], mod - 2, mod);
        for (int i = maxLimit - 1; i >= 0; i--) invFact[i] = invFact[i + 1] * (i + 1) % mod;

        vector<vector<long long>> comb(10, vector<long long>());
        for (int d = 0; d < 10; d++) {
            comb[d].resize(freq[d] + 1, 0);
            for (int x = 0; x <= freq[d]; x++) {
                comb[d][x] = (fact[freq[d]] * invFact[x] % mod) * invFact[freq[d] - x] % mod;
            }
        }

        long long productFreqFact = 1;
        for (int d = 0; d < 10; d++) {
            productFreqFact = productFreqFact * fact[freq[d]] % mod;
        }

        vector<vector<long long>> dpPrev(sumEven + 1, vector<long long>(halfN + 1, 0));
        dpPrev[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            vector<vector<long long>> dpNext(sumEven + 1, vector<long long>(halfN + 1, 0));
            for (long long s = 0; s <= sumEven; s++) {
                for (int c = 0; c <= halfN; c++) {
                    if (dpPrev[s][c] == 0) continue;
                    for (int x = 0; x <= freq[d]; x++) {
                        if (s + (long long)x * d > sumEven) break;
                        if (c + x > halfN) continue;
                        dpNext[s + x * d][c + x] = (dpNext[s + x * d][c + x] + dpPrev[s][c] * comb[d][x]) % mod;
                    }
                }
            }
            dpPrev = dpNext;
        }

        long long F = dpPrev[sumEven][halfN];
        long long invProductFreqFact = powerMod(productFreqFact, mod - 2, mod);
        long long totalPerms = fact[n] * invProductFreqFact % mod;
        long long answer = F * fact[halfN] % mod;
        answer = answer * fact[n - halfN] % mod;
        answer = answer * invProductFreqFact % mod;

        return (int)answer;
    }
};",1441356070
Harttle,harttle,112,3627,javascript,"/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(Infinity))
    while (heap.size()) {
        const [t, x, y] = heap.pop()
        if (dist[x][y] !== Infinity) continue
        dist[x][y] = t
        for (const [nx, ny] of [[x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]]) {
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny] !== Infinity) continue
            const nt = Math.max(t + 1, moveTime[nx][ny] + 1)
            heap.push([nt, nx, ny])
        }
    }
    return dist[N - 1][M - 1]
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441297717
Harttle,harttle,112,3628,javascript,"const diffs = [0, 1, 0, -1, 0]
/**
 * @param {number[][]} moveTime
 * @return {number}
 */
var minTimeToReach = function(moveTime) {
    const N = moveTime.length, M = moveTime[0].length
    const heap = new Heap([[0, 0, 0, 0]], (l, r) => l[0] - r[0])
    const dist = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    const saw = Array(N).fill(0).map(x => Array(M).fill(0).map(x => [Infinity, Infinity]))
    while (heap.size()) {
        const [t, x, y, alt] = heap.pop()
        if (dist[x][y][alt] !== Infinity) continue
        dist[x][y][alt] = t
        const nalt = 1 - alt
        for (let i = 0; i < 4; i++) {
            const nx = x + diffs[i], ny = y + diffs[i + 1]
            if (nx < 0 || ny < 0 || nx >= N || ny >= M || dist[nx][ny][nalt] !== Infinity) continue
            const nt = Math.max(t + 1 + alt, moveTime[nx][ny] + 1 + alt)
            if (nt < saw[nx][ny][nalt]) {
                saw[nx][ny][nalt] = nt
                heap.push([nt, nx, ny, nalt])
            }
        }
    }
    return Math.min(...dist[N - 1][M - 1])
};
/*
 * Template from contest.js
 * Github: https://github.com/harttle/contest.js
 * Website: https://harttle.land/contest.js/
 */
// src/heap.ts
var Heap = class {
  constructor(data = [], compare = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    if (typeof data === ""function"") {
      compare = data;
      data = [];
    }
    this.data = [null, ...data];
    this.lt = (i, j) => compare(this.data[i], this.data[j]) < 0;
    for (let i = this.size(); i > 0; i--)
      this.heapify(i);
  }
  size() {
    return this.data.length - 1;
  }
  push(v) {
    this.data.push(v);
    let i = this.size();
    while (i >> 1 !== 0 && this.lt(i, i >> 1))
      this.swap(i, i >>= 1);
  }
  pop() {
    this.swap(1, this.size());
    const top = this.data.pop();
    this.heapify(1);
    return top;
  }
  top() {
    return this.data[1];
  }
  heapify(i) {
    while (true) {
      let min = i;
      const [l, r, n] = [i * 2, i * 2 + 1, this.data.length];
      if (l < n && this.lt(l, min))
        min = l;
      if (r < n && this.lt(r, min))
        min = r;
      if (min !== i) {
        this.swap(i, min);
        i = min;
      } else
        break;
    }
  }
  clear() {
    this.data = [null];
  }
  swap(i, j) {
    const d = this.data;
    [d[i], d[j]] = [d[j], d[i]];
  }
};
var RemovableHeap = class {
  constructor(data = [], cmp) {
    this.heap = new Heap(data, cmp);
    this.counts = new Map();
    this._size = 0;
    for (let i = 1; i < this.heap.data.length; i++) {
      this.count(this.heap.data[i], 1);
    }
  }
  size() {
    return this._size;
  }
  top() {
    this._normalize();
    return this.heap.top();
  }
  pop() {
    this._normalize();
    if (this.heap.size() < 1)
      return void 0;
    const top = this.heap.pop();
    this.count(top, -1);
    return top;
  }
  push(num) {
    this.count(num, 1);
    this.heap.push(num);
  }
  remove(num) {
    if (Number(this.counts.get(num)) > 0) {
      this.count(num, -1);
    }
  }
  has(value) {
    return this.counts.get(value) > 0;
  }
  count(num, diff = 1) {
    var _a;
    const count = (_a = this.counts.get(num)) != null ? _a : 0;
    this.counts.set(num, count + diff);
    this._size += diff;
  }
  _normalize() {
    while (this.heap.size() && !this.counts.get(this.heap.top())) {
      this.heap.pop();
    }
  }
};
var RemovableDoubleHeap = class {
  constructor(data = [], cmp = (lhs, rhs) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0) {
    this.min = new RemovableHeap(data, cmp);
    this.max = new RemovableHeap(data, (lhs, rhs) => -cmp(lhs, rhs));
  }
  popMin() {
    const min = this.min.pop();
    this.max.remove(min);
    return min;
  }
  popMax() {
    const max = this.max.pop();
    this.min.remove(max);
    return max;
  }
  remove(num) {
    this.min.remove(num);
    this.max.remove(num);
  }
  size() {
    return this.min.size();
  }
  push(num) {
    this.min.push(num);
    this.max.push(num);
  }
};
var PriorityQueue = class extends RemovableHeap {
  offer(value) {
    return this.push(value);
  }
  poll() {
    return this.pop();
  }
  peek() {
    return this.top();
  }
};",1441315111
Harttle,harttle,112,3636,javascript,"/**
 * @param {string} num
 * @return {boolean}
 */
var isBalanced = function(nums) {
    const sums = [0, 0]
    for (let i = 0; i < nums.length; i++) sums[i % 2] += +nums[i]
    // console.log(sums)
    return sums[0] === sums[1]
};",1441284175
Harttle,harttle,112,3637,javascript,"const MOD = 1e9 + 7
var MODn = BigInt(MOD);
var _Ann = [1n];
/**
 * @param {string} num
 * @return {number}
 */
var countBalancedPermutations = function(num) {
    const digits = [...num].map(x => +x)
    const N = digits.length
    const EVEN = Math.ceil(N / 2)
    const ODD = N - EVEN
    const sum = digits.reduce((sum, d) => sum + d, 0)
    if (sum % 2) return 0
    const counts = Array(10).fill(0)
    for (const d of digits) counts[d]++
    const halfSum = sum / 2
    const memo = new Map()
    const comb = dfs(halfSum, 0, ODD)
    let ans = prod(comb, factorial(EVEN), factorial(ODD))
    // console.log('comb', comb, `fact(${EVEN})`, factorial(EVEN), `fact(${ODD})`, factorial(ODD))
    for (const count of counts) {
        if (count < 2) continue
        const fact = factorial(count)
        ans = prod(ans, modInverse(fact))
    }
    return ans
    function dfs(sum, begin, count) {
        if (sum < 0 || count < 0) return 0
        if (begin === N) return sum === 0 && count === 0 ? 1 : 0
        const key = sum * 10000 + begin * 100 + count
        if (memo.has(key)) return memo.get(key)
        let ans = 0
        ans += dfs(sum - digits[begin], begin + 1, count - 1)
        ans += dfs(sum, begin + 1, count)
        ans %= MOD
        memo.set(key, ans)
        return ans
    }
};
function prod(a, ...args) {
    if (!args.length) return a
    const prev = prod(...args)
    return Number(BigInt(a) * BigInt(prev) % MODn)
}
// src/euclidean.ts
function gcdExtended(a, b) {
  if (b === 0)
    return [a, 1, 0];
  const [gcd, x1, y1] = gcdExtended(b, a % b);
  return [gcd, y1, x1 - Math.floor(a / b) * y1];
}
function modInverse(a, M = MOD) {
  const [gcd, x] = gcdExtended(a, M);
  if (gcd !== 1)
    throw new Error(""inverse not exist"");
  return (x % M + M) % M;
}

// src/binomial.ts
function factorial(N) {
  const Nn = BigInt(N);
  for (let n = BigInt(_Ann.length); n <= Nn; n++)
    _Ann.push(_Ann[_Ann.length - 1] * n % MODn);
  return Number(_Ann[Number(N)]);
}
function factorialSeq(N) {
  factorial(N);
  return _Ann.slice(0, N + 1).map((x) => Number(x));
}
function pascalsTriangle(N) {
  const C = [[1n]];
  for (let n = 1; n <= N; ++n) {
    C.push(Array(n + 1));
    C[n][0] = C[n][n] = 1n;
    for (let k = 1; k < n; ++k) {
      C[n][k] = (C[n - 1][k - 1] + C[n - 1][k]) % MODn;
    }
  }
  for (let n = 0; n <= N; n++)
    for (let k = 0; k <= n; k++)
      C[n][k] = Number(C[n][k]);
  return C;
}
function combination(n, k) {
  const deno = modMultiply(factorial(k), factorial(n - k));
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function arrangement(n, k) {
  const deno = factorial(n - k);
  return modMultiply(factorial(n), modInverse(deno, MOD));
}
function modMultiply(a, b) {
  return Number(BigInt(a) * BigInt(b) % MODn);
}",1441343449
Dhruva N L,dhruva05,113,3627,cpp,"class Solution {
public:
     int n, m;
    const long long INF = 1e18;
    vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    
    void initArrival(vector<vector<long long>>& arr) {
        for (int i = 0; i < n; i++) {
            fill(arr[i].begin(), arr[i].end(), INF);
        }
        arr[0][0] = 0;
    }
    
    bool isValid(int x, int y) {
        return x >= 0 && x < n && y >= 0 && y < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return 0;
        m = moveTime[0].size();
        vector<vector<long long>> arr(n, vector<long long>(m));
        initArrival(arr);
        
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        while (!pq.empty()) {
            auto [curTime, x, y] = pq.top();
            pq.pop();
            
            if (x == n - 1 && y == m - 1) return (int)curTime;
            if (curTime > arr[x][y]) continue;

            for (auto &[dx, dy] : dirs) {
                int nx = x + dx, ny = y + dy;
                if (isValid(nx, ny)) {
                    long long newTime = max(curTime, (long long)moveTime[nx][ny]) + 1;
                    if (newTime < arr[nx][ny]) {
                        arr[nx][ny] = newTime;
                        pq.emplace(newTime, nx, ny);
                    }
                }
            }
        }
        return -1;
    }
};",1441318569
Dhruva N L,dhruva05,113,3628,cpp,"class Solution {
    typedef long long ll;
    const ll INF = 1e18;
    
    int n, m;

    int encode(int i, int j, int parity) {
        return (i * m + j) * 2 + parity;
    }

    tuple<int, int, int> decode(int id) {
        int p = id % 2;
        int temp = id / 2;
        int j = temp % m;
        int i = temp / m;
        return {i, j, p};
    }

    void updateTime(priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> &pq,
                    vector<vector<vector<ll>>> &arrTimes, int i, int j, int p, ll arr) {
        if (arr < arrTimes[i][j][p]) {
            arrTimes[i][j][p] = arr;
            pq.push({arr, encode(i, j, p)});
        }
    }

public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size();
        if (n == 0) return -1;
        m = moveTime[0].size();
        if (m == 0) return -1;

        vector<vector<vector<ll>>> arrTimes(n, vector<vector<ll>>(m, vector<ll>(2, INF)));
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;

        arrTimes[0][0][0] = 0;
        pq.push({0, encode(0, 0, 0)});
        
        vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!pq.empty()) {
            auto [currTime, id] = pq.top(); pq.pop();
            auto [i, j, p] = decode(id);
            
            if (i == n - 1 && j == m - 1) return (int)currTime;
            if (currTime > arrTimes[i][j][p]) continue;

            for (auto &[di, dj] : dirs) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    ll moveDur = (p == 0) ? 1 : 2;
                    ll startTime = max(currTime, (ll)moveTime[ni][nj]);
                    ll arr = startTime + moveDur;
                    int np = 1 - p;
                    updateTime(pq, arrTimes, ni, nj, np, arr);
                }
            }
        }
        
        return -1;
    }
};",1441335644
Dhruva N L,dhruva05,113,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;

        for (int i = 0; i < num.length(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0)
                es += d;
            else
                os += d;
        }

        return es == os;
    }
};",1441291195
Dhruva N L,dhruva05,113,3637,java,"class Solution {
    private static final int MOD = 1_000_000_007;

    private long powerMod(long x, long y, long mod) {
        long res = 1;
        x %= mod;
        while (y > 0) {
            if ((y & 1) == 1) {
                res = res * x % mod;
            }
            x = x * x % mod;
            y >>= 1;
        }
        return res;
    }

    private void computeFactAndInvFact(long[] fact, long[] invFact, int maxN) {
        fact[0] = 1;
        for (int i = 1; i <= maxN; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[maxN] = powerMod(fact[maxN], MOD - 2, MOD);
        for (int i = maxN - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    private long calculateDigitCountsAndSum(String num, int[] digitCount) {
        long totalSum = 0;
        for (char ch : num.toCharArray()) {
            digitCount[ch - '0']++;
            totalSum += (ch - '0');
        }
        return totalSum;
    }

    private long[][] initializeDpArray(int halfLen, int halfSum) {
        long[][] dp = new long[halfLen + 1][halfSum + 1];
        dp[0][0] = 1;
        return dp;
    }

    private long processDp(int halfLen, int halfSum, int[] digitCount, long[] invFact, long[][] dp) {
        for (int d = 0; d < 10; d++) {
            int countD = digitCount[d];
            long[][] tempDp = new long[halfLen + 1][halfSum + 1];

            for (int c = 0; c <= halfLen; c++) {
                for (int s = 0; s <= halfSum; s++) {
                    if (dp[c][s] == 0) continue;
                    int maxA = Math.min(countD, halfLen - c);

                    for (int aD = 0; aD <= maxA; aD++) {
                        int newC = c + aD;
                        long newS = s + (long) d * aD;
                        if (newS > halfSum) continue;
                        tempDp[newC][(int) newS] = (tempDp[newC][(int) newS] + dp[c][s] * invFact[aD] % MOD * invFact[countD - aD] % MOD) % MOD;
                    }
                }
            }
            dp = tempDp;
        }
        return dp[halfLen][halfSum];
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] digitCount = new int[10];
        long totalSum = calculateDigitCountsAndSum(num, digitCount);

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int halfLen = (n + 1) / 2;

        long[] fact = new long[n + 1];
        long[] invFact = new long[n + 1];
        computeFactAndInvFact(fact, invFact, n);

        long[][] dp = initializeDpArray(halfLen, (int) halfSum);
        long validAssignments = processDp(halfLen, (int) halfSum, digitCount, invFact, dp);

        long answer = fact[halfLen] * fact[n - halfLen] % MOD;
        answer = answer * validAssignments % MOD;

        return (int) answer;
    }
}",1441356821
rarelytested,rarelytested,114,3627,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = 1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441356900
rarelytested,rarelytested,114,3628,cpp,"class Solution {
public:
    struct Node {
        int x, y, time;
        Node(int x, int y, int time) {
            this->x = x;
            this->y = y;
            this->time = time;
        }
        bool operator<(const Node& other) const {
            return time > other.time;
        }
    };
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<Node> pq;
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        pq.push(Node(0, 0, 0));
        dist[0][0] = 0;
        int dx[] = {-1, 0, 1, 0};
        int dy[] = {0, 1, 0, -1};
        while (!pq.empty()) {
            Node node = pq.top();
            int x = node.x;
            int y = node.y;
            int time = node.time;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            visited[x][y] = true;
            if (x == n - 1 && y == m - 1) {
                return time;
            }
            for (int i = 0; i < 4; i++) {
                int xt = x + dx[i];
                int yt = y + dy[i];
                if (xt >= 0 && xt < n && yt >= 0 && yt < m) {
                    int w = (x+y)%2+1;
                    if (max(time, moveTime[xt][yt]) + w < dist[xt][yt]) {
                        dist[xt][yt] = max(time, moveTime[xt][yt]) + w;
                        pq.push(Node(xt, yt, dist[xt][yt]));
                    }
                }
            }
        }
        return -1;
    }
};",1441355901
rarelytested,rarelytested,114,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s0 = 0, s1 = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s0 += num[i] - '0';
            } else {
                s1 += num[i] - '0';
            }
        }
        return s0 == s1;
    }
};",1441282560
rarelytested,rarelytested,114,3637,cpp,"class Solution {
   public:
#define MOD 1000000007
    long long C[100][100];
    void init() {
        C[0][0] = 1;
        for (int i = 1; i < 100; i++) {
            C[i][0] = 1;
            for (int j = 1; j <= i; j++) {
                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
            }
        }
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        vector<int> cnt(10, 0);
        for (int i = 0; i < num.size(); i++) {
            sum += num[i] - '0';
            cnt[num[i] - '0']++;
        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        init();

        int n0 = (num.size() + 1) / 2;
        int n1 = num.size() - n0;
        vector<vector<vector<long long>>> dp(
            10,
            vector<vector<long long>>(sum + 1, vector<long long>(n0 + 1, 0)));
        int tot = 0;
        for (int i = 0; i < 10; i++) {
            if (i == 0) {
                for (int j = 0; j <= cnt[i]; j++) {
                    if (j > n0) {
                        break;
                    }
                    dp[i][0][j] = C[n0][j] * C[n1][cnt[i] - j] % MOD;
                }
                tot += cnt[i];
                continue;
            }
            for (int j = 0; j <= sum; j++) {
                for (int k = 0; k <= n0; k++) {
                    if (dp[i - 1][j][k] == 0) {
                        continue;
                    }
                    for (int l = 0; l <= cnt[i]; l++) {
                        if (j + l * i > sum || k + l > n0) {
                            break;
                        }
                        if (n1 - (tot-k) < 0) {
                            continue;
                        }
                        if (tot < k) {
                            continue;
                        }
                        // if (i == 3) {
                        //     std::cout << i << "" "" << j << "" "" << k << "" "" << l
                        //               << "" "" << dp[i - 1][j][k] << "" ""
                        //               << C[n0 - k][l] << "" ""
                        //               << C[n1 - (tot-k)][cnt[i] - l]
                        //               << std::endl;
                        // }
                        dp[i][j + l * i][k + l] +=
                            dp[i - 1][j][k] * C[n0 - k][l] % MOD *
                            C[n1 - (tot-k)][cnt[i] - l] % MOD;
                        dp[i][j + l * i][k + l] %= MOD;
                    }
                }
            }
            tot += cnt[i];
        }
        // std::cout << dp[2][3][2] << std::endl;
        return dp[9][sum][n0];
    }
};",1441338543
Yucheng Dai,Rainingcity,115,3627,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(0, make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [d, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + 1;
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(-nt, make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441293574
Yucheng Dai,Rainingcity,115,3628,cpp,"const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
inline bool valid(int x, int y, int n, int m) {
    return 0 <= x && x < n && 0 <= y && y < m;
}
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>, pair<int,int>>> pq{};
        int n = moveTime.size(), m = moveTime[0].size();
        pq.push(make_pair(make_pair(0, 1), make_pair(0, 0)));
        vector<vector<int>> dist(n, vector<int>(m, -1));
        dist[0][0] = 0;
        while(!pq.empty()) {
            auto [dd, xy] = pq.top();
            pq.pop();
            auto [x, y] = xy;
            auto [d, step] = dd;
            if (x == n - 1 && y == m - 1) break;
            if (dist[x][y] != -d) continue;
            for(int c = 0; c < 4; c++) {
                int nx = x + dx[c], ny = y + dy[c];
                if (!valid(nx, ny, n, m)) continue;
                int nt = max(dist[x][y], moveTime[nx][ny]) + (step ? 1 : 2);
                if (dist[nx][ny] == -1 || dist[nx][ny] > nt) {
                    dist[nx][ny] = nt;
                    pq.push(make_pair(make_pair(-nt, !step), make_pair(nx, ny)));
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441297044
Yucheng Dai,Rainingcity,115,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < num.length(); i++) {
            if (i & 1) {
                r += num[i] - '0';
            } else {
                l += num[i] - '0';
            }
        }
        return l == r;
    }
};",1441281589
Yucheng Dai,Rainingcity,115,3637,cpp,"typedef long long ll;
const ll MOD = 1000000007;
vector<ll> buildFact(ll n) {
    vector<ll> fact(n + 1, 0);
    fact[0] = fact[1] = 1;
    for(ll i = 2; i <= n; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
    }
    return fact;
}
vector<vector<ll>> buildC(ll n) {
    vector<vector<ll>> C(n + 1, vector<ll>(n + 1, 0));
    C[0][0] = C[1][0] = C[1][1] = 1;
    for(ll i = 2; i <= n; i++) {
        C[i][0] = C[i][i] = 1;
        for(ll j = 1; j < i; j++) {
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
        }
    }
    return C;
}
ll gcdExtended(ll a, ll b, ll& x, ll& y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    ll d = gcdExtended(b % a, a, x, y);
    ll t = x;
    x = y - (b / a) * x;
    y = t;
    return d;
}
ll modInverse(ll a) {
    ll x, y;
    ll g = gcdExtended(a, MOD, x, y);
    return (x % MOD + MOD) % MOD;
}
vector<ll> buildInv(vector<ll>& l) {
    vector<ll> res{};
    for(ll x: l) {
        res.push_back(modInverse(x));
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        int sum = 0;
        int cnt[10];
        memset(cnt, 0, sizeof(cnt));
        for(char c: num) {
            sum += c - '0';
            cnt[c - '0']++;
        }
        if (sum & 1) return 0;
        vector<vector<ll>> C = buildC(n);
        vector<ll> fact = buildFact(n);
        vector<ll> factInv = buildInv(fact);
        int m = (n + 1) / 2;
        sum /= 2;
        // cur_digit, left #digit, left sum
        vector<vector<vector<ll>>> dp(11, vector<vector<ll>>(m + 1, vector<ll>(sum + 1, 0)));
        dp[0][0][0] = 1;
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= m; j++) {
                for(int k = 0; k <= sum; k++) {
                    for(int t = 0; t <= cnt[i] && t <= j && i * t <= k; t++) {
                        dp[i + 1][j][k] = (dp[i + 1][j][k] + ((dp[i][j - t][k - i * t] * factInv[t]) % MOD) * factInv[cnt[i] - t]) % MOD;
                        // cout << i << "" "" << j << "" "" << k << "" "" << dp[i + 1][j][k] << endl;
                    }
                }
            }
        }
        return (((dp[10][m][sum] * fact[m]) % MOD) * fact[n - m]) % MOD;
    }
};",1441357030
Shashwat Tripathi,Fkaiser7,117,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,
            greater<pair<int,pair<int,int>>>>pq;
        pq.push({0,{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({t1,{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({t1,{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({t1,{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({t1,{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441296836
Shashwat Tripathi,Fkaiser7,117,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size();
        int m=v[0].size();
        priority_queue<pair<pair<int,int>,pair<int,int>>,vector<pair<pair<int,int>,pair<int,int>>>,
            greater<pair<pair<int,int>,pair<int,int>>>>pq;
        pq.push({{0,0},{0,0}});
        vector<vector<int>>dist(n,vector<int>(m,2*1e9));
        vector<vector<int>>vis(n,vector<int>(m));
        dist[0][0]=0;
        while(pq.size()){
            auto it=pq.top();
            pq.pop();
            int t=it.first.first;
            int turn=it.first.second;
            int i=it.second.first;
            int j=it.second.second;
            if(vis[i][j]){
                continue;
            }
            vis[i][j]++;
            if(i-1>=0){
                int t1=t+turn+1;
                if(t<=v[i-1][j]){
                    t1=v[i-1][j]+turn+1;
                }
                if(dist[i-1][j]>t1){
                    dist[i-1][j]=t1;
                    pq.push({{t1,1-turn},{i-1,j}});
                }
            }
            if(j-1>=0){
                int t1=t+1+turn;
                if(t<=v[i][j-1]){
                    t1=v[i][j-1]+1+turn;
                }
                if(dist[i][j-1]>t1){
                    dist[i][j-1]=t1;
                    pq.push({{t1,1-turn},{i,j-1}});
                }
            }
            if(i+1<n){
                int t1=t+1+turn;
                if(t<=v[i+1][j]){
                    t1=v[i+1][j]+1+turn;
                }
                if(dist[i+1][j]>t1){
                    dist[i+1][j]=t1;
                    pq.push({{t1,1-turn},{i+1,j}});
                }
            }
            if(j+1<m){
                int t1=t+1+turn;
                if(t<=v[i][j+1]){
                    t1=v[i][j+1]+1+turn;
                }
                if(dist[i][j+1]>t1){
                    dist[i][j+1]=t1;
                    pq.push({{t1,1-turn},{i,j+1}});
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441304766
Shashwat Tripathi,Fkaiser7,117,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int a=0,b=0;
        for(int i=0;i<n;i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        return a==b;
    }
};",1441281257
Shashwat Tripathi,Fkaiser7,117,3637,cpp,"#define lli long long
lli mod=1e9+7;
vector<lli>fact(81);
void calc(){
    lli p=1;
    fact[0]=fact[1]=1;
    for(lli i=2;i<=80;i++){
        p=(p%mod*i%mod)%mod;
        fact[i]=p;
    }
}
long long power(long long i, int j) { return j ? j & 1 ? power(i * i % mod, j >> 1) * i % mod : power(i * i % mod, j >> 1) : 1; }
lli comb(lli n,lli r){
    lli t=fact[n];
    lli t1=(fact[r]%mod*fact[n-r]%mod)%mod;
    t1=power(t1,mod-2);
    t=(t%mod*t1%mod)%mod;
    return t;
}
class Solution {
public:
    lli fuc(lli i,lli o,lli sum,vector<lli>&freq,vector<vector<vector<lli>>>&dp
,lli &n){
        if(i==10){
            if(sum==0){
                return 1;
            }
            return 0;
        }
        if(dp[i][o][sum]!=-1){
            return dp[i][o][sum];
        }
        lli o1=n/2;
        if(n%2){
            o1++;
        }
        lli e=0;
        if(i!=0){
            e=freq[i-1]-o1+o;
        }
        e=n/2-e;
        lli t=freq[i];
        if(i!=0){
            t-=freq[i-1];
        }
        //cout<<i<<"" ""<<o<<"" ""<<e<<"" ""<<t<<"" ""<<sum<<endl;
        //cout<<i<<"" ""<<o<<"" ""<<e<<endl;
        lli ans=0;
            for(lli j=0;j<=t;j++){
                if(t-j>e||j>o||j*i>sum){
                    continue;
                }
                lli ans1=(comb(o,j)%mod*comb(e,t-j)%mod)%mod;
                ans1=(ans1%mod*fuc(i+1,o-j,sum-j*i,freq,dp,n)%mod)%mod;
                ans+=ans1;
                ans%=mod;
            }
        //cout<<i<<"" ""<<o<<"" ""<<t<<"" ""<<sum<<"" ""<<ans<<endl;
        return dp[i][o][sum]=ans;
    }
    int countBalancedPermutations(string num) {
        calc();
        //cout<<comb(4,2)<<endl;
        lli n=num.length();
        lli o=n/2,e=n/2;
        if(n%2){
            o++;
        }
        vector<lli>freq(10);
        lli sum=0;
        for(lli i=0;i<n;i++){
            freq[num[i]-'0']++;
            sum+=num[i]-'0';
        }
        if(sum%2){
            return 0;
        }
        vector<vector<vector<lli>>>dp(10,vector<vector<lli>>(n+1,
        vector<lli>(sum/2+1,-1)));
        vector<lli>freq1(10);
        for(lli i=0;i<10;i++){
            if(i==0){
                freq1[i]=freq[i];
            }
            else{
                freq1[i]=freq1[i-1]+freq[i];
            }
        }
        //cout<<sum<<endl;
        return (int)(fuc(0,o,sum/2,freq1,dp,n));
    }
};",1441358541
lilPeep,stupidRR,118,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<int>> dp(n,vector<int>(m,2e9));
        dp[0][0]=0;
        
        set< array<int,3> > dij;
        dij.insert( {0,0,0} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y]=*dij.begin();
            dij.erase( dij.begin() );
            
            cout << X << "" "" << Y << "" "" << tim << endl;
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim+1,ar[x][y]+1);
                    if( dp[x][y] > reach )
                    {
                        dij.erase( {dp[x][y],x,y} );
                        dp[x][y]=reach;
                        dij.insert( {dp[x][y],x,y} );
                    }
                }
            }
        }
        cout << endl;
        return dp[n-1][m-1];
    }
};",1441298381
lilPeep,stupidRR,118,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& ar) {
        int n=ar.size();
        int m=ar[0].size();
        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(2,2e9)));
        dp[0][0][1]=0;
        
        set< array<int,4> > dij;
        dij.insert( {0,0,0,1} );
            
        int dx[]={1,-1,0,0};
        int dy[]={0,0,1,-1};
        while( !dij.empty() )
        {
            auto [tim,X,Y,type]=*dij.begin();
            dij.erase( dij.begin() );
            
            for(int i=0;i<4;i++)
            {
                int x=X+dx[i];
                int y=Y+dy[i];
                if(x>=0 && x<n && y>=0 && y<m)
                {
                    int reach=std::max(tim,ar[x][y])+2-type%2;
                    if( dp[x][y][1-type] > reach )
                    {
                        dij.erase( {dp[x][y][1-type],x,y,1-type} );
                        dp[x][y][1-type]=reach;
                        dij.insert( {dp[x][y][1-type],x,y,1-type} );
                    }
                }
            }
        }
        return std::min(dp[n-1][m-1][0],dp[n-1][m-1][1]);
    }
};",1441303245
lilPeep,stupidRR,118,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum=0;
        for(int i=0;i<num.size();i++)
        {
            if(i%2)
                sum+=(num[i]-'0');
            else
                sum=sum-(num[i]-'0');
        }
        return !sum;
    }
};",1441282957
lilPeep,stupidRR,118,3637,cpp,"typedef long long ll;
class Solution {
    ll factorial[101];
    ll inverse[101];
       
    ll binpow(ll base,ll ex)
    {
        if(ex<0)
          return 0ll;
        ll ans=1;
        while(ex>0)
        {
            if(ex%2==1)
                    ans=(ans*base)%mod;
            base=(base*base)%mod;
            ex=ex/2;
        }
        return ans;
    }
     
    void pre()
    {
       factorial[0]=1;
       inverse[0]=1;
       for(int i=1;i<=100;i++)
           factorial[i]=(factorial[i-1]*i)%mod;
       
       inverse[100]=binpow(factorial[100],mod-2);
       for(int i=99;i>=0;i--)
          inverse[i]=(inverse[i+1]*(i+1ll))%mod;
    }
     
    ll nCr(int n , int r)
    {
        if(n<0 || r<0 || n<r)
                return 0;
        ll ans=1;
        ans=factorial[n];
        ans=(ans*inverse[n-r])%mod;
        ans=(ans*inverse[r])%mod;
        return ans;
    }
    const int mod=1e9+7;
public:
    int countBalancedPermutations(string num) {
        int n=num.size();
        pre();
        int odd=(n)/2;

        vector<int> freq(10);
        for(auto ele : num)
            freq[ele-'0']++;

        vector<vector<long long>> dp(odd+1,vector<long long>(1001,0));
        dp[ odd ][ 500 ]=1ll;
        int placedTillNow=0;
        int even=n-odd;

        for(int i=0;i<10;i++) // 10* 41*41*1000 = 16000*2000 
        {
            int val=freq[i];
            if(val==0)
                continue;

            vector<vector<long long>> ndp(odd+1,vector<long long>(1001,0));

            for(int oddHave=0;oddHave<=odd;oddHave++)
            {
                for(int j=oddHave;j<=odd;j++)
                {

                    int oddUsed=j-oddHave;
                    if(oddUsed>val)
                        break;
                    int evenUsed=val-oddUsed;
                    
                    int oddPlacedTillNow=odd-j;
                    int evenPlaced=placedTillNow-oddPlacedTillNow;

                    if(evenPlaced+evenUsed > even)
                        continue;
                    
                    int delta=oddUsed*i-evenUsed*i;

                    for(int sum=0;sum<=1000;sum++)
                    {
                        if(sum+delta <=1000 && sum+delta>=0 && dp[j][sum])
                            ndp[oddHave][sum+delta]=(ndp[oddHave][sum+delta]+ dp[j][sum]* ((nCr(odd-oddPlacedTillNow,oddUsed)*nCr(even-evenPlaced,evenUsed))%mod) )%mod;
                    }
                }
            }
            placedTillNow+=val;
            swap(dp,ndp);
        }

        return dp[0][500];
    }
};

",1441339362
Srujan_Teja_Rayella,Srujan_code_code,119,3627,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        int[][] distance = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(distance[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        priorityQueue.offer(new int[]{0, 0, 0}); // {time, row, col}
        distance[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!priorityQueue.isEmpty()) {
            int[] current = priorityQueue.poll();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > distance[currentRow][currentCol]) continue;

            for (int[] direction : directions) {
                int newRow = currentRow + direction[0];
                int newCol = currentCol + direction[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int newTime = Math.max(currentTime, moveTime[newRow][newCol]) + 1;

                    if (newTime < distance[newRow][newCol]) {
                        distance[newRow][newCol] = newTime;
                        priorityQueue.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }

        return distance[rows - 1][cols - 1];
    }
}


",1441321285
Srujan_Teja_Rayella,Srujan_code_code,119,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] dp = new int[n][m][2];
        for (int[][] arr : dp) {
            for (int[] subArr : arr) {
                Arrays.fill(subArr, Integer.MAX_VALUE);
            }
        }
        dp[0][0][0] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int time = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];

            if (time > dp[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);

                    if (newTime < dp[newRow][newCol][1 - parity]) {
                        dp[newRow][newCol][1 - parity] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol, 1 - parity});
                    }
                }
            }
        }

        return Math.min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
}



",1441326648
Srujan_Teja_Rayella,Srujan_code_code,119,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumEvenPositions = 0;
        int sumOddPositions = 0;
        
        for (int index = 0; index < num.length(); index++) {
            int digitValue = num.charAt(index) - '0'; 
            
            if (index % 2 == 0) {
                sumEvenPositions += digitValue; 
            } else {
                sumOddPositions += digitValue; 
            }
        }
        
        return sumEvenPositions == sumOddPositions;
    }
}
",1441297850
Srujan_Teja_Rayella,Srujan_code_code,119,3637,java,"class Solution {
    private static final int MOD = 1000000007;

    public int countBalancedPermutations(String num) {
        int length = num.length();
        long totalSum = 0;
        int[] counts = new int[10];

        for (char digit : num.toCharArray()) {
            int d = digit - '0';
            totalSum += d;
            counts[d]++;
        }

        if (totalSum % 2 != 0) {
            return 0;
        }

        long halfSum = totalSum / 2;
        int m = (length + 1) / 2;
        long[] factorial = new long[length + 1];
        long[] invFactorial = new long[length + 1];
        factorial[0] = 1;

        for (int i = 1; i <= length; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        invFactorial[length] = modInverse(factorial[length], MOD);

        for (int i = length - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        long[][] dp = new long[m + 1][(int) (halfSum + 1)];
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (counts[d] == 0) {
                continue;
            }

            for (int k = m; k >= 0; k--) {
                for (int s = (int) halfSum; s >= 0; s--) {
                    if (dp[k][s] == 0) {
                        continue;
                    }

                    for (int t = 1; t <= counts[d]; t++) {
                        if (k + t > m || s + d * t > halfSum) {
                            break;
                        }
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(counts[d], t, factorial, invFactorial, MOD)) % MOD;
                    }
                }
            }
        }

        long w = dp[m][(int) halfSum];
        long result = factorial[m] * factorial[length - m] % MOD;

        for (int d = 0; d < 10; d++) {
            result = result * invFactorial[counts[d]] % MOD;
        }

        result = result * w % MOD;
        return (int) result;
    }

    private long modInverse(long a, int m) {
        long result = 1;
        long base = a;
        int p = m - 2;

        while (p > 0) {
            if ((p & 1) == 1) {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        return result;
    }

    private long comb(int n, int k, long[] factorial, long[] invFactorial, int m) {
        if (k > n) {
            return 0;
        }
        return factorial[n] * invFactorial[k] % m * invFactorial[n - k] % m;
    }
}

",1441353506
sveng101,sveng101,120,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0))]
        while heap:
            t, pos = heapq.heappop(heap)
            if pos in seen: continue
            seen.add(pos)
            for pos2 in move(pos):
                if pos2 in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1
                if pos2 == target:
                    return t2
                heapq.heappush(heap, (t2, pos2))
        return -1",1441300706
sveng101,sveng101,120,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        shape = (len(moveTime), len(moveTime[0]))
        def move(pos: Tuple[int, int]) -> Generator[Tuple[int, int], None, None]:
            if pos[0] > 0: yield (pos[0] - 1, pos[1])
            if pos[0] < shape[0] - 1: yield (pos[0] + 1, pos[1])
            if pos[1] > 0: yield (pos[0], pos[1] - 1)
            if pos[1] < shape[1] - 1: yield (pos[0], pos[1] + 1)

        target = (shape[0] - 1, shape[1] - 1)
        seen = set()
        heap = [(0, (0, 0), False)]
        while heap:
            t, pos, even = heapq.heappop(heap)
            #print(pos, even, t)
            if (pos, even) in seen: continue
            elif pos == target:
                return t
            seen.add((pos, even))
            for pos2 in move(pos):
                if (pos2, not even) in seen: continue
                t2 = max(t, moveTime[pos2[0]][pos2[1]]) + 1 + even
                heapq.heappush(heap, (t2, pos2, not even))
        return -1",1441308855
sveng101,sveng101,120,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res = 0
        n = len(num)
        for i in range(0, n, 2):
            res += int(num[i])
        for i in range(1, n, 2):
            res -= int(num[i])
        return not res
        """"""
        while num:
            num, d = divmod(num, 10)
            res += d if d & 1 else -d
        return not res
        """"""",1441289145
sveng101,sveng101,120,3637,python3,"import math
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        md = 10 ** 9 + 7

        n = len(num)
        
        cnts = {}
        tot = 0
        for d in num:
            d2 = int(d)
            cnts[d2] = cnts.get(d2, 0) + 1
            tot += d2
        if tot & 1: return 0
        tot_target = tot >> 1
        res = 0
        cnts2 = sorted([(y, x) for x, y in cnts.items()])
        m = len(cnts2)
        cnt_target = n >> 1
        #print(cnts2)
        memo = {}
        def backtrack(idx: int, cnt_rem: int=cnt_target, tot_rem: int=tot_target) -> int:
            f_tot, num = cnts2[idx]
            if idx == m - 1:
                f = cnt_rem
                if f > f_tot or f * num != tot_rem: return 0
                return (math.factorial(cnt_target) * math.factorial(n - cnt_target)) // (math.factorial(f) * math.factorial(f_tot - f))
            args = (idx, cnt_rem, tot_rem)
            if args in memo.keys(): return memo[args]
            res = 0
            cnt_rem2 = cnt_rem
            tot_rem2 = tot_rem
            for f in range(min(f_tot, cnt_rem) + 1):
                res += backtrack(idx + 1, cnt_rem=cnt_rem2, tot_rem=tot_rem2) // (math.factorial(f) * math.factorial(f_tot - f))
                cnt_rem2 -= 1
                tot_rem2 -= num
                if tot_rem2 < 0: break
            memo[args] = res
            return res
        res =(backtrack(0)) % md
        #print(memo)
        return res",1441359877
Pankaj Ananda Bhosale,pankaj_777,121,3627,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dist(n, vector<ll> (m, inf));
        dist[0][0] = 0;
        priority_queue<array<ll, 3>, vector<array<ll, 3>>, greater<array<ll, 3>>> pq;
        pq.push({0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 : moveTime[nrow][ncol] + 1);
                    if (dist[nrow][ncol] > ntime) {
                        dist[nrow][ncol] = ntime;
                        pq.push({ntime, nrow, ncol});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441315132
Pankaj Ananda Bhosale,pankaj_777,121,3628,cpp,"#define ll long long int
const ll inf = 1e12;
int delRow[4] = {-1, 0, +1, 0};
int delCol[4] = {0, +1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        ll dist[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }
        
        dist[0][0][0] = 0;
        priority_queue<array<ll, 4>, vector<array<ll, 4>>, greater<array<ll, 4>>> pq;
        pq.push({0, 0, 0, 0});
        
        while (pq.size()) {
            ll row = pq.top()[1], col = pq.top()[2], time = pq.top()[0], parity = pq.top()[3];
            pq.pop();
            
            if (row == n - 1 and col == m - 1) return time;
            
            for (int i = 0; i < 4; i++) {
                ll nrow = row + delRow[i], ncol = col + delCol[i];
                if (nrow >= 0 and nrow < n and ncol >= 0 and ncol < m) {
                    ll ntime = (time >= moveTime[nrow][ncol] ? time + 1 + parity : moveTime[nrow][ncol] + 1 + parity);
                    if (dist[nrow][ncol][1 - parity] > ntime) {
                        dist[nrow][ncol][1 - parity] = ntime;
                        pq.push({ntime, nrow, ncol, 1 - parity});
                    }
                }
            }
        }
        
        return -1;
    }
};",1441320881
Pankaj Ananda Bhosale,pankaj_777,121,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int cntEven = 0, cntOdd = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2) cntEven += num[i] - '0';
            else cntOdd += num[i] - '0';
        }
        
        return cntOdd == cntEven;
    }
};",1441281857
Pankaj Ananda Bhosale,pankaj_777,121,3637,cpp,"#define ll long long int
const int mod = 1e9 + 7;

int mulm(ll a, ll b) {
    return (a * b) % mod;
}

int addm(ll a, ll b) {
    return (a + b) % mod;
}

ll powr(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = mulm(res, a);
        a = mulm(a, a);
        b = b >> 1;
    }
    return res;
}

ll inv(ll x) {
    if (x <= 1) return 1;
    return powr(x, mod - 2);
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        
        int tot_sum = 0;
        vector<int> cnt(10, 0), fact(n + 1, 1);
        for (int i = 0; i < n; i++) {
            tot_sum += (num[i] - '0');
            cnt[num[i] - '0']++;
        }
        
        if (tot_sum % 2) return 0;
        
        for (int i = 2; i <= n; i++) {
            fact[i] = mulm(i, fact[i - 1]);
        }
        
        vector<vector<vector<int>>> dp(10, vector<vector<int>> (400, vector<int> (n + 1, -1)));
        auto fun = [&] (int idx, int sum_even, int cntEven, auto&& fun) -> int {
            if (idx == 10) {
                return (sum_even == tot_sum / 2 and cntEven == n / 2) * mulm(fact[n / 2], fact[(n + 1) / 2]);
            }
            
            if (dp[idx][sum_even][cntEven] != -1) return dp[idx][sum_even][cntEven];
            
            int res = 0;
            for (int c = 0; c <= cnt[idx]; c++) {
                res = addm(res, mulm(fun(idx + 1, sum_even + c * idx, cntEven + c, fun), mulm(inv(fact[c]), inv(fact[cnt[idx] - c]))));
            }

            return dp[idx][sum_even][cntEven] = res;
        };
        
        return fun(0, 0, 0, fun);
    }
};",1441359987
i_will_beat_my_iq,i_will_beat_my_iq,122,3627,cpp,"class Solution {
public:
#define ll long long
void f1(int x, int y, int curr_t, vector<vector<int>>& t, vector<vector<int>>& d, 
                           priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>>& q,
                           int dirs[][2], ll r, ll c) {
        ll i = 0;
        while (i < 4) {
            int nx = x + dirs[i][0], ny = y + dirs[i][1];
            if (f2(nx, ny, r, c)) {
                int new_t = f3(curr_t, t[nx][ny]);
                if (new_t < d[nx][ny]) {
                    d[nx][ny] = new_t;
                    q.push({new_t, {nx, ny}});
                }
            }
            i++;
        }
    }

    bool f2(int x, int y, ll r, ll c) {
        return x >= 0 && x < r && y >= 0 && y < c;
    }

    int f3(int curr_t, int move_t) {
        return max(curr_t, move_t) + 1;
    }
    int minTimeToReach(vector<vector<int>>& t) {
        ll r = t.size();
        ll c = t[0].size();
        vector<vector<int>> d(r, vector<int>(c, INT32_MAX));
        d[0][0] = 0;

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> q;
        q.push({0, {0, 0}});

        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        while (!q.empty()) {
            auto [curr_t, pos] = q.top();
            int x = pos.first, y = pos.second;
            q.pop();

            if (x == r - 1 && y == c - 1) return curr_t;
            if (curr_t > d[x][y]) continue;

            f1(x, y, curr_t, t, d, q, dirs, r, c);
        }
        return -1;
    }
};",1441314147
i_will_beat_my_iq,i_will_beat_my_iq,122,3628,cpp,"class Solution {
public:
struct S {
    long long a;
    int b;
    int c;
    int d;
    bool operator<(const S& o) const {
        return a > o.a;
    }
};

 priority_queue<S> f1() {
        priority_queue<S> a;
        return a;
    }

    vector<pair<int, int>> f2() {
        vector<pair<int, int>> a = { {1,0}, {-1,0}, {0,1}, {0,-1} };
        return a;
    }

    S f3(priority_queue<S>& a) {
        S b = a.top();
        a.pop();
        return b;
    }

    bool f4(int a, int b, int c, int d) {
        return (a >= 0 && a < c && b >= 0 && b < d);
    }

    int f5(int a) {
        return (a == 0) ? 1 : 2;
    }

    long long f6(long long a, vector<vector<int>>& b, int c, int d) {
        return max(a, (long long)b[c][d]);
    }

    S f7(long long a, int b, int c, int d) {
        S e;
        e.a = a;
        e.b = b;
        e.c = c;
        e.d = d;
        return e;
    }
    int minTimeToReach(vector<vector<int>>& a) {
        vector<vector<int>> b = a;
        int c = b.size();
        if(c == 0) return -1;
        int d = b[0].size();
        if(d == 0) return -1;
        long long e = 1000000000000000000;
        vector<vector<long long>> f(c, vector<long long>(d, e));
        vector<vector<long long>> g(c, vector<long long>(d, e));
        priority_queue<S> h = f1();
        S i;
        i.a = 0;
        i.b = 0;
        i.c = 0;
        i.d = 0;
        f[0][0] = 0;
        h.push(i);
        vector<pair<int, int>> j = f2();
        while(!h.empty()) {
            S k = f3(h);
            if(k.b == c-1 && k.c == d-1){
                return (int)k.a;
            }
            if((k.d == 0 && k.a > f[k.b][k.c]) || 
               (k.d == 1 && k.a > g[k.b][k.c])) {
                continue;
            }
            for(int l = 0; l < j.size(); l++) {
                pair<int, int> m = j[l];
                int n = k.b + m.first;
                int o = k.c + m.second;
                if(!f4(n, o, c, d)) continue;
                int p = f5(k.d);
                long long q = f6(k.a, b, n, o);
                long long r = q + p;
                int s = 1 - k.d;
                if(s == 0){
                    if(r < f[n][o]){
                        f[n][o] = r;
                        S t = f7(r, n, o, s);
                        h.push(t);
                    }
                }
                else{
                    if(r < g[n][o]){
                        g[n][o] = r;
                        S u = f7(r, n, o, s);
                        h.push(u);
                    }
                }
            }
        }
        return -1;
    }
};",1441342852
i_will_beat_my_iq,i_will_beat_my_iq,122,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int se = 0, so = 0, i = 0;
        while (i < s.size()) {
            int d = s[i] - '0';
            (i % 2 == 0) ? se += d : so += d;
            i++;
        }
        return se == so;
    }
};",1441308665
i_will_beat_my_iq,i_will_beat_my_iq,122,3637,cpp,"class Solution {
public:
typedef long long ll;
static const int mx = 80;
ll mod_val = 1000000007;
ll f[mx + 1], inv_f[mx + 1];

ll f1(ll x, ll y, ll mod) {
    ll r = 1;
    x %= mod;
    while (y > 0) {
        if (y & 1) {
            r = r * x % mod;
        }
        x = x * x % mod;
        y >>= 1;
    }
    return r;
}
void f2() {
    f[0] = 1;
    for (int i = 1; i <= mx; i++) {
        f[i] = f[i - 1] * i % mod_val;
    }
    inv_f[mx] = f1(f[mx], mod_val - 2, mod_val);
    for (int i = mx - 1; i >= 0; i--) {
        inv_f[i] = inv_f[i + 1] * (i + 1) % mod_val;
    }
}
void f4(string &s, int freq[]) {
        for (char c : s) {
            freq[c - '0']++;
        }
    }

    ll f5(int freq[]) {
        ll total = 0;
        for (int d = 0; d <= 9; d++) {
            total += (ll)d * freq[d];
        }
        return total;
    }

    void f6(int freq[], ll grp_size, ll half, vector<vector<ll>> &dp_prev, vector<vector<ll>> &dp_curr) {
        for (int d = 0; d <= 9; d++) {
            for (int j = 0; j <= grp_size; j++) {
                fill(dp_curr[j].begin(), dp_curr[j].end(), 0LL);
            }

            for (int j = 0; j <= grp_size; j++) {
                for (int k = 0; k <= half; k++) {
                    if (dp_prev[j][k] == 0) continue;
                    f8(dp_curr, dp_prev, freq[d], j, k, d, grp_size, half);
                }
            }
            swap(dp_prev, dp_curr);
        }
    }

    ll f7(int freq[]) {
        ll denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * inv_f[freq[d]] % mod_val;
        }
        return denom;
    }

    void f8(vector<vector<ll>> &dp_curr, vector<vector<ll>> &dp_prev, int freq_d, int j, int k, int d, int grp_size, ll half) {
        for (int c = 0; c <= freq_d && j + c <= grp_size && k + c * d <= half; c++) {
            ll comb = f[freq_d] * inv_f[c] % mod_val * inv_f[freq_d - c] % mod_val;
            dp_curr[j + c][k + c * d] = (dp_curr[j + c][k + c * d] + dp_prev[j][k] * comb) % mod_val;
        }
    }
    int countBalancedPermutations(string s) {
        bool init = false;
        if (!init) {
            f2();
            init = true;
        }

        int freq[10] = {0};
        f4(s, freq);

        ll total = f5(freq);

        if (total % 2 != 0) return 0;

        ll half = total / 2;
        ll grp_size = (s.size() + 1) / 2;
        ll odd_grp_size = s.size() - grp_size;

        vector<vector<ll>> dp_prev(grp_size + 1, vector<ll>(half + 1, 0));
        vector<vector<ll>> dp_curr(grp_size + 1, vector<ll>(half + 1, 0));
        dp_prev[0][0] = 1;

        f6(freq, grp_size, half, dp_prev, dp_curr);

        ll total_comb = dp_prev[grp_size][half];
        ll denom = f7(freq);

        ll res = f[grp_size] * f[odd_grp_size] % mod_val;
        res = (res * total_comb) % mod_val;
        res = (res * denom) % mod_val;

        return res;
    }
};",1441353944
virinci,virinci,124,3627,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307496
virinci,virinci,124,3628,cpp,"static const int _ = []() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	return 0;
}();

#ifndef dbg
#define dbg(...)
#endif

template <typename T>
using MinPQ = priority_queue<T, vector<T>, greater<T>>;

class Solution {
public:
	int minTimeToReach(vector<vector<int>>& moveTime) {
		auto n = ssize(moveTime), m = ssize(moveTime[0]);

		using i64 = long long;
		// time, next_incr, i, j
		MinPQ<tuple<i64, int, int, int>> pq;
		pq.emplace(0, 1, 0, 0);

		constexpr i64 inf = 1e18;
		vector min_t(n, vector(m, inf));
		min_t[0][0] = 0;

		while (!pq.empty()) {
			auto [t, incr, i, j] = pq.top();
			pq.pop();
			for (auto [di, dj] : array{
					 pair{-1,  0},
					 pair{ 1,  0},
					 pair{ 0, -1},
					 pair{ 0, +1},
            }) {
				auto ni = i + di, nj = j + dj;
				if (ni < 0 || ni >= n || nj < 0 || nj >= m)
					continue;

				auto t_reach = max(t, 1LL * moveTime[ni][nj]) + incr;
				if (t_reach < min_t[ni][nj]) {
					pq.emplace(t_reach, 3 - incr, ni, nj);
					min_t[ni][nj] = t_reach;
				}
			}
		}

		return min_t[n - 1][m - 1];
	}
};",1441307148
virinci,virinci,124,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281046
virinci,virinci,124,3637,python3,"from collections import Counter

M = 10**9 + 7

fact = [1] * 81
for x in range(1, len(fact)):
    fact[x] = (fact[x - 1] * x) % M


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digit_sum = sum(map(int, num))
        if digit_sum % 2:
            return 0

        n, m = len(num), digit_sum // 2 + 1

        dp = [[0] * (m + 1) for _ in range(n + 1)]
        dp[0][0] = 1

        for d in map(int, num):
            for i in range(n, 0, -1):
                for j in range(m, d - 1, -1):
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % M

        even_count = (n + 1) // 2
        ways = dp[even_count][digit_sum // 2]

        counter = Counter(num)
        inv = 1
        for c in counter.values():
            inv *= pow(fact[c], -1, M)
            inv %= M

        return ways * fact[even_count] * fact[n - even_count] * inv % M",1441342013
Samadeep,rbssmtkr,125,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        int n = moveTime.size();
        int m = moveTime[0].size();

        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>,
                       greater<>>
            pq;

        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));

        pq.push({0, 0, 0});
        dist[0][0] = 0;

        while (!pq.empty()) {

            auto [time, x, y] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (time > dist[x][y])
                continue;

            for (auto& [dx, dy] : directions) {
                int nx = x + dx, ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int wait_time = max(0, moveTime[nx][ny] - time);
                    int new_time = time + 1 + wait_time;

                    if (new_time < dist[nx][ny]) {
                        dist[nx][ny] = new_time;
                        pq.push({new_time, nx, ny});
                    }
                }
            }
        }

        return -1;
    }
};",1441296109
Samadeep,rbssmtkr,125,3628,cpp,"int64_t dist1[850][850], dist0[850][850];
const int64_t INF = 1e18;
class Solution {
public:
    struct node_state {
    int64_t time;
        int x, y;    
        bool parity;
        bool operator<(const node_state& other) const {
            return time > other.time;
        }
    };

    Solution() {

        for (int i = 0; i <= 800; i++) {
            for (int j = 0; j <= 800; j++) {
                dist1[i][j] = INF;
                dist0[i][j] = INF;
            }
        }
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        auto inside = [&](int x, int y) {
            return !(x < 0 || x >= n || y < 0 || y >= m);
        };

        auto cmp = [](const node_state a, const node_state b) {
            return a.time > b.time;
        };

        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<node_state> pq;
        dist0[0][0] = 0;

        pq.push(node_state{0, 0, 0, false});

        while (!pq.empty()) {

            auto [curr_time,x, y, parity] = pq.top();
            pq.pop();

            if ((curr_time > dist0[x][y] && !parity) ||
                (curr_time > dist1[x][y]) && parity) {
                continue;
            }

            for (auto [dx, dy] : directions) {
                int nx = x + dx;
                int ny = y + dy;

                if (!inside(nx, ny))
                    continue;

                int64_t start = max(curr_time, (int64_t)moveTime[nx][ny]);
                int dur = (parity) ? 2 : 1;
                int64_t arrival_time = start + dur;

                bool next = !parity;

                if (next == 0 and arrival_time < dist0[nx][ny]) {
                    dist0[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                } else if (arrival_time < dist1[nx][ny]) {
                    dist1[nx][ny] = arrival_time;
                    pq.push(node_state{arrival_time, nx, ny, next});
                }
            }
        }

        int64_t answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return static_cast<int>(answer);
    }
};",1441340411
Samadeep,rbssmtkr,125,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for( int i = 0 ; i < num.size(); i++ ){
            if( i&1 ) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }

        return sum == 0;
    }
};",1441286169
Samadeep,rbssmtkr,125,3637,cpp,"
const int64_t mod = 1e9 + 7;
int64_t inv(int64_t i) {if (i == 1) return 1; return (mod - ((mod / i) * inv(mod % i)) % mod) % mod;}
int64_t mod_mul(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a * b) % mod) + mod) % mod;}
int64_t mod_add(int64_t a, int64_t b) {a = a % mod; b = b % mod; return (((a + b) % mod) + mod) % mod;}
int64_t gcd(int64_t a, int64_t b) { if (b == 0) return a; return gcd(b, a % b);}
int64_t ceil_div(int64_t a, int64_t b) {return a % b == 0 ? a / b : a / b + 1;}


const int SIZE = 200;
const int MOD = 1e9 + 7;
int64_t mypow(int64_t x, int64_t y) {
    x %= MOD;
    int64_t res = 1 % MOD;
    while (y) {
        if (y & 1)
            res = res * x % MOD;
        y >>= 1;
        x = x * x % MOD;
    }
    return res;
}

int64_t power(int64_t base, int64_t exp, int64_t mod) {
    int64_t res = 1;
    base %= mod;
    while (exp > 0) {
        if (exp & 1)
            res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

int64_t fac[SIZE];
int64_t inv_fac[SIZE];
void pre() {
    fac[0] = 1;
    for (int i = 1; i < SIZE; i++) {
        fac[i] = fac[i - 1] * i % MOD;
    }
    inv_fac[SIZE - 1] = mypow(fac[SIZE - 1], MOD - 2);
    for (int i = SIZE - 2; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD;
    }
}

int64_t NCR(int64_t n, int64_t m) {
    if (m < 0 || m > n) {
        return 0;
    }
    return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;
}

bool precompute = false;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if (not precompute) {
            pre();
            precompute = true;
        }

        int N = num.size();
        int E = (N + 1) / 2;
        int O = N / 2;

        int64_t cnt[10] = {0};
        for (char ch : num) {
            cnt[ch - '0']++;
        }

        int64_t total_sum = 0;
        for (int64_t d = 0; d < 10; d++) {
            total_sum += d * cnt[d];
        }

        if (total_sum % 2 != 0)
            return 0;

        const int64_t TARGET = total_sum / 2;

        vector<vector<int64_t>> dp(E + 1,
                                     vector<int64_t>(TARGET + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (!cnt[d])
                continue;
            
            for (int t = E; t >= 0; t--) {
                for (int64_t s = TARGET; s >= 0; s--) {
                    if (!dp[t][s])
                        continue;
                    
                    for (int k = 1; k <= cnt[d] && t + k <= E &&
                                    s + (int64_t)d * k <= TARGET;
                         k++) {
                        dp[t + k][s + (int64_t)d * k] =
                            mod_add(dp[t + k][s + (int64_t)d * k] , dp[t][s] * NCR(cnt[d], k));
                    }
                }
            }
        }

        int64_t prod_ans = 1;
        for (int d = 0; d < 10; d++) {
            prod_ans = mod_mul(prod_ans , fac[cnt[d]]);
        }

        int64_t answer = dp[E][TARGET] * fac[E] % MOD;
        answer = answer * fac[O] % MOD;
        return (int)mod_mul(answer , power(prod_ans, MOD - 2, MOD));
    }
};",1441361820
Huzaifa Khilawala,RedHeadphone,127,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+1,(nx,ny)))
                    visited.add((nx,ny))",1441295652
Huzaifa Khilawala,RedHeadphone,127,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime), len(moveTime[0])
        heap = [(0,1,(0,0))]
        visited = set()
        visited.add((0,0))

        while heap:
            time,addi, (x,y) = heappop(heap)
            if x==n-1 and y==m-1:
                return time
            
            for nx,ny in ((x+1,y),(x-1,y),(x,y+1),(x,y-1)):
                if 0<=nx<n and 0<=ny<m and (nx,ny) not in visited:
                    heappush(heap,(max(time,moveTime[nx][ny])+addi,1 if addi==2 else 2,(nx,ny)))
                    visited.add((nx,ny))",1441299635
Huzaifa Khilawala,RedHeadphone,127,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        ev = 0
        for i in range(0,len(num),2):
            ev += int(num[i])
        od = 0
        for i in range(1,len(num),2):
            od += int(num[i])
        return ev == od",1441281765
Huzaifa Khilawala,RedHeadphone,127,3637,python3,"
MOD = 10**9 + 7

class Combinatorics:
    def __init__(self, pre_compute_limit=0):
        self.fact = [1] * pre_compute_limit
        self.invfact = [1] * pre_compute_limit
        for i in range(1, pre_compute_limit):
            self.fact[i] = (self.fact[i - 1] * i) % MOD
            self.invfact[i] = (self.invfact[i - 1] * pow(i, MOD - 2, MOD)) % MOD

    def ncr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[r] * self.invfact[n - r]) % MOD

    def npr(self, n, r):
        if n < r or r < 0:
            return 0
        return (self.fact[n] * self.invfact[n - r]) % MOD

    def ncr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = den = 1
        for i in range(r):
            num = (num * (n - i)) % MOD
            den = (den * (i + 1)) % MOD
        return (num * pow(den, MOD - 2, MOD)) % MOD

    def npr_without_memo(self, n, r):
        if n < r or r < 0:
            return 0
        num = 1
        for i in range(n, n - r, -1):
            num = (num * i) % MOD
        return num

comb = Combinatorics(100)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(num)
        num = [int(i) for i in num]

        summ = sum(num)
        if summ%2 != 0:
            return 0
        
        target = summ//2
        n = len(num)
        length_req = n//2

        inv_mul = True if n-length_req == length_req else False

        combi = (comb.fact[length_req]*comb.fact[n-length_req])%MOD

        c = Counter(num)

        @cache
        def dp(i, curr, length):
            if curr > target:
                return 0
            
            if i==10:
                if curr==target and length==length_req:
                    return combi
                else:
                    return 0
            
            ans = 0
            for j in range(c[i]+1):
                ans+= dp(i+1, curr+i*j, length+j)*comb.invfact[j]*comb.invfact[c[i]-j]
                ans%= MOD
            return ans

        ans = dp(0,0,0)
        return ans",1441351613
Saijayavinoth T V S,saijayavinoth,128,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0))]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+1
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny)))
        # print(T)
        return -1",1441295122
Saijayavinoth T V S,saijayavinoth,128,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, (0,0), True)]
        ROWS, COLS = len(moveTime), len(moveTime[0])
        def safe(x,y):
            return 0<=x<ROWS and 0<=y<COLS
        target = (ROWS-1, COLS-1)
        T = {(0,0):0}
        while heap:
            time, cell, step = heappop(heap)
            x,y = cell
            if cell == target:
                # print(T)
                return time
            for dx, dy in [(0,1), (1,0), (-1,0), (0,-1)]:
                nx = x + dx
                ny = y + dy
                if not safe(nx, ny):
                    continue
                ntime = max(moveTime[nx][ny], time)+(1 if step else 2)
                if ntime < T.get((nx, ny), inf):
                    T[(nx, ny)] = ntime
                    heappush(heap, (ntime, (nx, ny), not step))
        # print(T)
        return -1",1441297746
Saijayavinoth T V S,saijayavinoth,128,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        x = 0
        flag = True
        for ch in num:
            ch = int(ch)
            if flag: ch *= -1
            x += ch
            flag = not flag
        return x == 0",1441282486
Saijayavinoth T V S,saijayavinoth,128,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = list(map(int, list(num)))
        count = Counter(nums)
        nums = list(set(nums))
        nums.sort()
        MOD = 10**9+7
        n = len(num)
        O = n//2
        E = n-O
        @cache
        def ncr(n, r):
            if n == 0 and r == 0:
                return 1
            if n == 0:
                return 0
            return ncr(n-1,r) + ncr(n-1,r-1)
        @cache
        def solve(ind, evenPos, oddPos, x):
            if ind == len(nums):
                return 1 if x == 0 else 0
            num = nums[ind]
            ans = 0
            for even in range(count[num]+1):
                if even > evenPos:
                    break
                odd = count[num] - even
                if odd > oddPos: continue
                ans += ncr(evenPos, even) * ncr(oddPos, odd) * solve(ind+1, evenPos-even, oddPos-odd, x+(even-odd)*num)
                ans %= MOD
            return ans
        return solve(0, E, O, 0)
        ",1441364426
MvKaio,MvKaio,129,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, (long long)(1e11)));
        dist[0][0] = 0;
        
        using T = pair<long long, pair<int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, pair(0, 0));
        
        vector vis(n, vector(m, false));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = v.first;
            int j = v.second;
            if (vis[i][j]) continue;
            vis[i][j] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1] > dist[i][j] + 1) {
                    dist[i1][j1] = dist[i][j] + 1;
                    dist[i1][j1] = max<long long>(dist[i1][j1], g[i1][j1] + 1);
                    q.emplace(dist[i1][j1], pair(i1, j1));
                }
            }
        }
        
        

        return dist[n - 1][m - 1];
    }
};",1441303773
MvKaio,MvKaio,129,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = g.size(), m = g[0].size();
        
        vector<pair<int, int>> mv = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
        };
        
        vector dist(n, vector(m, vector(2, (long long)(1e11))));
        dist[0][0][0] = 0;
        
        using T = pair<long long, tuple<int, int, int>>;
        priority_queue<T, vector<T>, greater<T>> q;
        q.emplace(0, make_tuple(0, 0, 0));
        
        vector vis(n, vector(m, vector(2, false)));

        while (q.size()) {
            auto [d, v] = q.top(); q.pop();
            int i = get<0>(v);
            int j = get<1>(v);
            int x = get<2>(v);
            if (vis[i][j][x]) continue;
            vis[i][j][x] = 1;
            for (auto [i1, j1] : mv) {
                i1 += i, j1 += j;
                if (i1 < 0 || i1 >= n) continue;
                if (j1 < 0 || j1 >= m) continue;
                if (dist[i1][j1][!x] > dist[i][j][x] + 1 + x) {
                    dist[i1][j1][!x] = dist[i][j][x] + 1 + x;
                    dist[i1][j1][!x] = max<long long>(dist[i1][j1][!x], g[i1][j1] + 1 + x);
                    q.emplace(dist[i1][j1][1-x], make_tuple(i1, j1, 1 - x));
                }
            }
        }
        
        

        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441309686
MvKaio,MvKaio,129,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2) s += num[i] - '0';
            else s -= num[i] - '0';
        }
        return s == 0;
    }
};",1441281184
MvKaio,MvKaio,129,3637,cpp,"const int MOD = 1e9 + 7;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();
        vector<int> v(n);
        for (int i = 0; i < n; i++)
            v[i] = s[i] - '0';
        
        vector cnt(10, 0);
        for (int i : v) cnt[i]++;
        
        int S = accumulate(v.begin(), v.end(), 0);
        if (S % 2) return 0;
        
        auto add = [&] (long long& a, long long b) {
            a += b;
            if (a >= MOD) a -= MOD;
        };
        
        vector fact(n + 1, 1ll);
        for (int i = 2; i <= n; i++)
            fact[i] = i * fact[i - 1] % MOD;
        
        auto fexp = [&] (long long a, long long b) {
            long long ans = 1;
            while (b) {
                if (b & 1) ans = ans * a % MOD;
                a = a * a % MOD;
                b /= 2;
            }
            return ans;
        };
        
        vector ifact(n + 1, 1ll);
        for (int i = 0; i <= n; i++)
            ifact[i] = fexp(fact[i], MOD - 2);
        
        vector dp(11, vector(n + 1, vector(S + 1, 0LL)));
        dp[0][0][0] = fact[n/2] * fact[(n+1)/2] % MOD;
        for (int d = 0; d < 10; d++) {
            for (int i = 0; i <= n; i++) {
                for (int s = 0; s <= S; s++) {
                    for (int qt = 0; qt <= cnt[d]; qt++) if (s + qt * d <= S && i + qt <= n) {
                        add(dp[d + 1][i + qt][s + qt * d], 
                            dp[d][i][s] 
                            * ifact[qt] % MOD
                            * ifact[cnt[d] - qt] % MOD
                       );
                    }
                }
            }
        }

        
        //cout << dp[10][n/2][S/2] << endl;
        return dp[10][n/2][S/2];
    }
};",1441338870
Arnab Mondal,arnab_97,131,3627,java," class Solution {
     public int minTimeToReach(int[][] moveTime) {
         int n = moveTime.length;
         int m = moveTime[0].length;
         int[][] dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
         int[][] minArrive = new int[n][m];
         for(int[] row : minArrive){
             Arrays.fill(row, Integer.MAX_VALUE);
         }
         minArrive[0][0] = 0;
         PriorityQueue<Cell> pq = new PriorityQueue<>();
         pq.offer(new Cell(0, 0, 0));
         while(!pq.isEmpty()){
             Cell current = pq.poll();
             int r = current.row;
             int c = current.col;
             int t = current.time;
             if(r == n-1 && c == m-1){
                 return t;
             }
             if(t > minArrive[r][c]){
                 continue;
             }
             for(int[] dir : dirs){
                 int nr = r + dir[0];
                 int nc = c + dir[1];
                 if(nr >=0 && nr < n && nc >=0 && nc < m){
                     int arriveTime = Math.max(t, moveTime[nr][nc]) +1;
                     if(arriveTime < minArrive[nr][nc]){
                         minArrive[nr][nc] = arriveTime;
                         pq.offer(new Cell(nr, nc, arriveTime));
                     }
                 }
             }
         }
         return -1;
     }

     class Cell implements Comparable<Cell>{
         int row;
         int col;
         int time;
         Cell(int row, int col, int time){
             this.row = row;
             this.col = col;
             this.time = time;
         }
         public int compareTo(Cell other){
             return Integer.compare(this.time, other.time);
         }
     }
 }",1441294066
Arnab Mondal,arnab_97,131,3628,java,"
class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        long INF = Long.MAX_VALUE;
        long[][][] dist = new long[n][m][2];
        for(int i=0;i<n;i++) {
            for(int j=0; j<m; j++) {
                dist[i][j][0] = INF;
                dist[i][j][1] = INF;
            }
        }
        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> Long.compare(a.time, b.time));
        dist[0][0][0] = 0;
        pq.add(new State(0, 0, 0, 0));
        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};
        while(!pq.isEmpty()) {
            State current = pq.poll();
            if(current.x == n-1 && current.y == m-1){
                return (int)current.time;
            }
            if(current.time > dist[current.x][current.y][current.p]){
                continue;
            }
            for(int[] dir : directions){
                int nx = current.x + dir[0];
                int ny = current.y + dir[1];
                if(nx >=0 && nx <n && ny >=0 && ny <m){
                    long start_move_time = Math.max(current.time, (long)moveTime[nx][ny]);
                    long move_duration = current.p == 0 ? 1 : 2;
                    long arrival_time = start_move_time + move_duration;
                    int next_p = 1 - current.p;
                    if(arrival_time < dist[nx][ny][next_p]){
                        dist[nx][ny][next_p] = arrival_time;
                        pq.add(new State(nx, ny, next_p, arrival_time));
                    }
                }
            }
        }
        return -1;
    }
    class State {
        int x, y, p;
        long time;
        State(int x, int y, int p, long time){
            this.x = x;
            this.y = y;
            this.p = p;
            this.time = time;
        }
    }
}
",1441293520
Arnab Mondal,arnab_97,131,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';

            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}",1441283689
Arnab Mondal,arnab_97,131,3637,java,"class Solution {
    static final int MOD = 1_000_000_007;

     public int countBalancedPermutations(String num) {
         int[] freq = new int[10];
         int N = num.length();
         long sumTotal = 0;
         for(char c : num.toCharArray()) {
             freq[c - '0']++;
             sumTotal += (c - '0');
         }
         if(sumTotal % 2 != 0) return 0;
         long sumTarget = sumTotal / 2;
         int half1 = (N + 1) / 2;
         int half2 = N / 2;

         long[] fact = new long[N + 1];
         fact[0] = 1;
         for(int i=1;i<=N;i++) {
             fact[i] = fact[i-1] * i % MOD;
         }

         long[] invFact = new long[N +1];
         invFact[N] = powMod(fact[N], MOD-2);
         for(int i=N-1;i>=0;i--){
             invFact[i] = invFact[i+1] * (i+1) % MOD;
         }

         
         long[][] dp = new long[half1 +1][(int)(sumTarget) +1];
         dp[0][0] = 1;

         for(int d=0; d<=9; d++) {
             int f = freq[d];
             if(f ==0) continue;
             long[][] next = new long[half1 +1][(int)(sumTarget) +1];
             for(int j=0; j<=half1; j++) {
                 for(int k=0; k<=sumTarget; k++) {
                     if(dp[j][k] ==0) continue;
                     for(int c=0; c<=f; c++) {
                         if(j + c > half1) break;
                         long newSum = k + (long)d * c;
                         if(newSum > sumTarget) break;
                         next[j + c][(int)newSum] = (next[j + c][(int)newSum] + dp[j][k] * invFact[c] % MOD * invFact[f - c] % MOD ) % MOD;
                     }
             }}
             dp = next;
         }

         if(sumTotal %2 !=0){
             return 0;
         }

         if(half1 <0 || half1 >N || sumTarget <0){
             return 0;
         }

         long dpVal = dp[half1][(int)sumTarget];
         if(dpVal ==0){
             return 0;
         }

         long answer = fact[half1] * fact[half2] % MOD;
         answer = answer * dpVal % MOD;
         return (int)answer;
     }

     long powMod(long a, long b){
         long res =1;
         a %= MOD;
         while(b >0){
             if( (b&1) !=0){
                 res = res * a % MOD;
             }
             a = a * a % MOD;
             b >>=1;
         }
         return res;
    }
}",1441359079
Nutty Professor,varkatkl,132,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        BIG = 1 << 30
        best = [[BIG] * W for _ in range(H)]
        bfs = collections.deque()
        def visit(y, x, t):
            if best[y][x] > t and (t > moveTime[y][x] or (y == 0 and x == 0)):
                best[y][x] = t
                bfs.append((y, x))

        visit(0, 0, 0)
        while bfs:
            y, x = bfs.popleft()
            t_cur = best[y][x]
            for dy, dx in ADJACENT:
                y2, x2 = y + dy, x + dx
                if y2 >= 0 and x2 >= 0 and y2 < H and x2 < W:
                    t_move = max(moveTime[y2][x2], t_cur)
                    visit(y2, x2, t_move + 1)

        return best[H - 1][W - 1]
",1441295956
Nutty Professor,varkatkl,132,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        H = len(moveTime)
        W = len(moveTime[0])

        ADJACENT = [(1, 0), (0, 1), (-1, 0), (0, -1)] 
        BIG = 1 << 30

        best = [[[BIG, BIG] for _ in range(W)] for _ in range(H)]
        bfs = []
        def visit(y, x, par, t):
            if best[y][x][par] > t:
                best[y][x][par] = t
                heapq.heappush(bfs, (t, y, x, par))

        visit(0, 0, 0, 0)

        while bfs:
            t_cur, y, x, par = heapq.heappop(bfs)
            if y == H - 1 and x == W - 1:
                return t_cur
            for dy, dx in ADJACENT:
                y2, x2, par2 = y + dy, x + dx, 1 - par
                if y2 < 0 or x2 < 0 or y2 >= H or x2 >= W:
                    continue
                t_start = max(t_cur, moveTime[y2][x2])
                visit(y2, x2, par2, t_start + par + 1)

        return min(best[H - 1][W - 1])
",1441309476
Nutty Professor,varkatkl,132,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e, o = 0, 0
        for i, d in enumerate(num):
            if i % 2 == 0:
                e += int(d)
            else:
                o += int(d)
        return e == o
",1441282473
Nutty Professor,varkatkl,132,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = (10 ** 9) + 7
        counts = [0] * 10
        total = 0
        N = len(num)
        for d in num:
            counts[int(d)] += 1
            total += int(d)

        if total % 2 != 0:
            return 0

        inv_fact = [1] * 81
        fact = 1
        for i in range(2, 81):
            fact = fact * i % MOD
            inv_fact[i] = pow(fact, MOD - 2, MOD)

        @functools.lru_cache(maxsize=None)
        def f(i, odds_used, osum):
            if i == 10:
                if odds_used != N // 2 or osum * 2 != total:
                    return 0
                return 1

            ret = 0
            for ei in range(counts[i] + 1):
                oi = counts[i] - ei
                ret += inv_fact[ei] * inv_fact[oi] * f(i + 1, oi + odds_used, oi * i + osum) % MOD
                ret %= MOD
            return ret

        ret = f(0, 0, 0)
        ret *= pow(inv_fact[(N + 1) // 2], MOD - 2, MOD) * pow(inv_fact[N // 2], MOD - 2, MOD)
        ret %= MOD
        return ret
",1441359390
Yatin Kwatra,yatin_kwatra,134,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

int vis[55][55];

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:

	// bool possible(int k, vvii &v) {
	// 	fo(i, 0, n - 1) {
	// 		fo(j, 0, m - 1) vis[i][j] = 1e9;
	// 	}
	// 	queue<ar<int, 2>> q;

	// 	q.push({0, 0});
	// 	vis[0][0] = 1;

	// 	while (sz(q)) {
	// 		auto t = q.front();
	// 		q.pop();

	// 		int a = t[0], b = t[1];

	// 		fo(dir, 0, 3) {
	// 			int x = a + dx[dir];
	// 			int y = b + dy[dir];

	// 			if (valid(x, y, k, vis[a][b])) {
	// 				vis[x][y] = max(v[x][y], vis[a][b] + 1);
	// 				q.push({x, y});
	// 			}
	// 		}
	// 	}

	// 	return vis[n - 1][m - 1];

	// }

	int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vvii dp(n, vii(m, INT_MAX));

		set<ar<int, 3>> s;
		s.insert({0, 0, 0});
		dp[0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[1] + dx[dir];
				int y = t[2] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1, t[0] + 1);
				if (spend < dp[x][y]) {
					auto it = s.find({dp[x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[x][y] = spend;
					s.insert({dp[x][y], x, y});
				}
			}
		}

		return dp[n - 1][m - 1];
	}
};


















",1441306051
Yatin Kwatra,yatin_kwatra,134,3628,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

int n, m;

int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

bool valid(int x, int y) {
	return (x >= 0 and x < n and y >= 0 and y < m);
}

class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& v) {
		n = sz(v);
		m = sz(v[0]);

		vector<vector<vector<int>>>  dp(2, vvii(n, vii(m, INT_MAX)));

		set<ar<int, 4>> s;
		s.insert({0, 0, 0, 0});
		dp[0][0][0] = 0;

		while (sz(s)) {
			auto t = *(s.begin());
			s.erase(t);

			fo(dir, 0, 3) {
				int x = t[2] + dx[dir];
				int y = t[3] + dy[dir];

				if (!valid(x, y)) continue;
				int spend = max(v[x][y] + 1 + t[0], t[1] + 1 + t[0]);
				if (spend < dp[!t[0]][x][y]) {
					auto it = s.find({dp[!t[0]][x][y], x, y});
					if (it != s.end()) s.erase(t);
					dp[!t[0]][x][y] = spend;
					s.insert({!t[0], dp[!t[0]][x][y], x, y});
				}
			}
		}

		return min(dp[0][n - 1][m - 1], dp[1][n - 1][m - 1]);
	}
};


















",1441315344
Yatin Kwatra,yatin_kwatra,134,3636,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */


class Solution {
public:
	bool isBalanced(string s) {
		int n = sz(s);
		int a[2] = {0};
		fo(i, 0, n - 1) {
			a[i % 2] += s[i] - '0';
		}
		return a[0] == a[1];
	}
};




















",1441281153
Yatin Kwatra,yatin_kwatra,134,3637,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define ll                      long long
#define ar                      array
// #define int                     ll
#define sz(v)                   (int)(v.size())
#define FIO                     ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define ld                      long double
#define ull                     unsigned long long
#define endl                    ""\n""
#define fo(i,a,b)               for(int i = a; i<=b ; i++)
#define rfo(i,a,b)              for(int i = a; i>=b ; i--)
#define vii                     vector<int>
#define pq                      priority_queue
#define uomii                   unordered_map<int,int,best_hash>
#define all(v)                  v.begin(),v.end()
#define mp                      make_pair
#define pb                      push_back
#define pob                     pop_back
#define ff                      first
#define ss                      second
#define pii                     pair<int,int>
#define mii                     map<int,int>
#define vvii                    vector<vii>
#define mod                     1000000007
#define inf                     5e18
#define pi                      3.1415926535897932384626433832795
#define cz(x)                   63 - __builtin_clzll(x)



using namespace std;
using namespace __gnu_pbds;
template<class T> using oset =  tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;


// https://codeforces.com/blog/entry/68809

void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << ','; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i : x) cout << (f++ ? "","" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define pr(x...) cout << ""["" << #x << ""] = [""; _print(x)
#else
#define pr(x...)
#endif

// https://codeforces.com/blog/entry/62393

struct best_hash {
	static uint64_t splitmix64(uint64_t x) {

		x += 0x9e3779b97f4a7c15;
		x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
		x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
		return x ^ (x >> 31);
	}

	size_t operator()(uint64_t x) const {
		static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
		return splitmix64(x + FIXED_RANDOM);
	}
};


/* ------------------------------- REAL CODING STARTS NOW --------------------------- */

const int N = 81;
ll f[N];

ll addmod(ll a, ll b) {
	a %= mod;
	b %= mod;
	return (a + b) % mod;
}

ll submod(ll a, ll b) {
	a %= mod;
	b %= mod;
	a -= b;
	return (a % mod + mod) % mod;
}

ll mulmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return (a * b) % mod;
}

ll power(ll n, ll p) {
	ll res = 1;
	while (p) {
		if (p & 1) res = mulmod(res, n);
		n = mulmod(n, n);
		p /= 2;
	}
	return res;
}

ll divmod(ll a, ll b) {
	a %= mod;
	b %= mod;

	return mulmod(a, power(b, mod - 2));
}

ll nCr(ll n, ll r) {
	if (n < r) return 0;
	ll num = f[n];
	ll deno = mulmod(f[r], f[n - r]);
	return divmod(num, deno);
}


int cnt[10];

int dp[10][42][802], sum;

class Solution {
public:

	int gino(int pos, int odd, int even, int dx) {
		if (pos == 10) {
			return (dx == 0);
		}
		int &ans = dp[pos][odd][sum + dx];
		if (ans != -1) return ans;
		ans = 0;

		fo(placeAtOdd, 0, min(odd, cnt[pos])) {
			int atOdd = placeAtOdd;
			int atEven = cnt[pos] - placeAtOdd;
			if (atEven > even) continue;

			int updDx = dx + atOdd * pos - atEven * pos;

			ans = addmod(ans, mulmod(mulmod(nCr(odd, atOdd), nCr(even, atEven)), gino(pos + 1, odd - atOdd, even - atEven,  updDx)));

			// pr(pos, atOdd, atEven, odd, even,  updDx, ans);
		}

		// pr(pos, odd, even, dx, ans);

		return ans;
	}

	int countBalancedPermutations(string s) {
		if (!f[0]) {
			f[0] = 1;
			fo(i, 1, N - 1) {
				f[i] = mulmod(f[i - 1], i);
			}
		}

		fo(i, 0, 9) {
			cnt[i] = 0;
		}
		for (auto &i : s) cnt[i - '0']++;
		int n = sz(s);

		sum = 0;
		sort(all(s));
		reverse(all(s));
		fo(i, 0, ((n + 1) / 2) - 1) sum += s[i] - '0';

		fo(i, 0, 9) {
			fo(j, 0, (n + 1) / 2) {
				fo(k, 0, 2 * sum) dp[i][j][k] = -1;
			}
		}


		return gino(0, (n + 1) / 2, n / 2, 0);
	}
};





















",1441359762
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3627,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        using Triple = tuple<int64_t,int,int>;
        PQ(Triple, greater) pq;
        pq.emplace(0, 0, 0);
        vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        vector<vector<bool>> vis(R, vector<bool>(C, false));
        dp[0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x] = pq.top(); pq.pop();
            if(vis[y][x]) continue;
            vis[y][x] = true;
            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1, 
                    1ll * stat[ny][nx] + 1
                );
                if(next_time >= dp[ny][nx])
                    continue;
                dp[ny][nx] = next_time;
                pq.emplace(next_time, ny, nx);
            }
        }

        return dp[R - 1][C - 1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441360335
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3628,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

const int nax = 751;
int64_t dp[nax][nax][2];
bool vis[nax][nax][2];

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& stat) {
        const int R = stat.size();
        const int C = stat[0].size();
        const int64_t INF = 1ll << 50;
        //triple -> dist, y, x

        // vector<vector<int64_t>> dp(R, vector<int64_t>(C, INF));
        //dp[row][col][flag] = best
        //min(...dp[R - 1][C - 1])
        for(int row = 0; row < R; row++)
            for(int col = 0; col < C; col++)
                for(int flag = 0; flag <= 1; flag++)
                    dp[row][col][flag] = INF, vis[row][col][flag] = false;

        using Quad = tuple<int64_t,int,int,int>;
        PQ(Quad, greater) pq;
        pq.emplace(0, 0, 0, 0);
        dp[0][0][0] = 0;
        while(!pq.empty()){
            auto [cur_time, y, x, flag] = pq.top(); pq.pop();
            if(vis[y][x][flag]) continue;
            vis[y][x][flag] = true;

            for(int i = 0; i <= 3; i++){
                const int ny = y + dy[i];
                const int nx = x + dx[i];
                if(ny < 0 || nx < 0 || ny >= R || nx >= C)
                    continue;
                const int64_t next_time = max(
                    cur_time + 1 + flag, 
                    1ll * stat[ny][nx] + 1 + flag
                );
                if(next_time >= dp[ny][nx][flag ^ 1])
                    continue;
                dp[ny][nx][flag ^ 1] = next_time;
                pq.emplace(next_time, ny, nx, flag ^ 1);
            }
        }

        return min(dp[R - 1][C - 1][0], dp[R - 1][C - 1][1]);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441367413
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3636,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

class Solution {
public:
    bool isBalanced(string num) {
        int ans[2] = {0, 0};
        const int n = num.size();
        for(int i = 0; i < n; i++)
            ans[i % 2] += num[i] - '0';

        return ans[0] == ans[1];
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441346394
Lock_My_Cock_Out_SUKI,Lock_My_Cock_Out_SUKI,136,3637,cpp,"#include <bits/stdc++.h> 

// #define MAIN_ACTIVE
// #define IO_ON_FILE

using namespace std;
#define int64_t wadwafesfesfes21321300242142104210321
using int64_t = long long;
using pii = pair<int,int>;
using pil = pair<int,int64_t>;
using pli = pair<int64_t,int>;
using pll = pair<int64_t,int64_t>;
// #define DISABLE_SANITIZER __attribute__((no_sanitize(""address"", ""thread"")))
#define umap unordered_map
#define uset unordered_set
#define all(x) x.begin(), x.end()
#define allr(x) x.rbegin(), x.rend()
#define emp_back emplace_back
#define bitcount(x) __builtin_popcount((x))
#define PQ(x, y) priority_queue<x, vector<x>, y<x>>
// #define PQD(x, y) priority_queue<x, vector<x>, decltype(y)>
#define print(x) cout << ""[ "" << #x << "" ]: "" << x << ""\n"";
#define printc(x) cout << ""[ "" << #x << "" ]: ["", show(all(x), "", "", false), cout << ""]\n"";
#define e_ cout << ""\n"";
template <typename F, typename S> ostream& operator << (ostream& os, const pair<F, S>& duo) { return os << ""("" << duo.first << "", "" << duo.second << "")""; }
template <typename Iter> void show(Iter begin, Iter end, const char* sep = "" "", bool is_end = true) { for(Iter it = begin; it != end; it++) cout << (it != begin ? sep : """") << *it; if(is_end) cout << ""\n""; }
template<typename T, typename Cmp = less<T>> void get_unique(vector<T>& arr, Cmp compare = Cmp()){ sort(all(arr), compare); arr.erase(unique(all(arr)), arr.end()); }
mt19937_64 _GEN(chrono::high_resolution_clock::now().time_since_epoch().count());
template <typename T>
T mrand(T begin, T end) {
    if constexpr (is_integral<T>::value){ uniform_int_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); } 
    else if constexpr (is_floating_point<T>::value) { uniform_real_distribution<T> _UNI_DIST(begin, end); return _UNI_DIST(_GEN); }
}
int fastIO = []{ ios_base::sync_with_stdio(false); cin.tie(NULL); return 0; }();
//0down, 1right, 2up, 3left, 4upleft, 5downright, 6upright, 7downleft, 8stay
constexpr int dx[9] = {0, 1, 0, -1, -1, 1, 1, -1, 0};
constexpr int dy[9] = {1, 0, -1, 0, -1, 1, -1, 1, 0};

template <typename T>
void mmax(T& me, const T& other) {
    me = max(me, other);
}

template <typename T>
void mmin(T& me, const T& other) {
    me = min(me, other);
}

template <typename T>
string mbin(T val, int8_t want_sign = 1) {
    const string sign = (want_sign) ? (val < 0 ? ""-"" : ""+"") : """";
    if(!val) return sign + ""0"";
    val = abs(val);
    string ans;
    while(val){
        ans.push_back('0' + (val & 1));
        val >>= 1;
    }
    return sign + string(allr(ans));
}

template <uint64_t mod = 1'000'000'007>
struct Mint {
    uint64_t val;
    Mint() : val(0) {}
    Mint(int64_t _val) {
        _val %= mod;
        if (_val < 0) _val += mod;
        val = _val;
    }
    Mint& operator += (const Mint& other){ val += other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator -= (const Mint& other){ val += mod - other.val; if(val >= mod) val -= mod; return *this; }
    Mint& operator *= (const Mint& other){ val = (uint64_t)val * other.val % mod; return *this; }
    Mint& operator /= (const Mint& other){ return *this *= other.inv(); }
    Mint operator + (const Mint& other) const { return Mint(*this) += other; }
    Mint operator - (const Mint& other) const { return Mint(*this) -= other; }
    Mint operator * (const Mint& other) const { return Mint(*this) *= other; }
    Mint operator / (const Mint& other) const { return Mint(*this) /= other; }
    Mint pwr(int64_t expo) const {
        Mint res = 1;
        Mint cur = *this;
        while(expo){
            if(expo & 1) res *= cur;
            cur *= cur; expo >>= 1;
        }
        return res;
    }
    Mint inv() const { return pwr(mod - 2); }
    friend ostream& operator << (ostream& os, const Mint& m) { os << m.val; return os; }
    bool operator == (const Mint& other) const { return val == other.val; }
};

constexpr uint64_t MODS[] = {
    1'000'000'007,       // 1e9 + 7
    1'000'000'009,       // 1e9 + 9
    1'000'000'003,       // 1e9 + 3
    1'000'000'019,       // 1e9 + 19
    1'000'000'037,       // 1e9 + 37
    1'000'000'061,       // 1e9 + 61
    1'000'000'077,       // 1e9 + 77
    1'000'000'123,       // 1e9 + 123
    5'330'004'01, 
    7'356'327'91, 
    7'765'314'19,
    7'970'034'13
};

using mint = Mint<MODS[0]>;
mint fact[100];
mint ifact[100];
int dp[10][42][42][730];
int vfreq[10];
int even_max;
int odd_max;
//729 is the max
//370(offset) is the 0

int init = []{
    fact[0] = 1;
    ifact[0] = 1;
    for(int i = 1; i < 100; i++){
        fact[i] = fact[i - 1] * i;
        ifact[i] = fact[i].inv();
    }
    return 0;
}();

mint ncr(int take, int has) {
    assert(take <= has);
    assert(take >= 0 && has >= 0);
    return fact[has] * ifact[take] * ifact[has - take];
}

int dfs(int val, int even, int odd, int sum) {
    if(val < 0)
        return sum == 370 && even == even_max && odd == odd_max;
    if(dp[val][even][odd][sum] != -1)
        return dp[val][even][odd][sum];

    const int left_slot = even_max - even;
    const int right_slot = odd_max - odd;
    mint got = 0;
    for(int left = 0; left <= vfreq[val]; left++){
        if(left_slot < left) continue;
        const int right = vfreq[val] - left;
        if(right_slot < right) continue;
        const int next_sum = sum + (left * val) - (right * val);
        if(next_sum < 0 || next_sum > 729) 
            continue;
        got += 
        ncr(left, left_slot) * 
        ncr(right, right_slot) * 
        dfs(val - 1, even + left, odd + right, next_sum);
    }

    return dp[val][even][odd][sum] = got.val;
}

class Solution {
public:
    int countBalancedPermutations(string s) {
        const int n = s.size();
        even_max = n / 2 + (n & 1);
        odd_max = n / 2;
        for(int i = 0; i <= 9; i++)
            for(int even = 0; even <= even_max; even++)
                for(int odd = 0; odd <= odd_max; odd++)
                    for(int sum = 0; sum < 730; sum++)
                        dp[i][even][odd][sum] = -1;

        fill(vfreq, vfreq + 10, 0);
        for(auto ch : s)
            vfreq[ch - '0']++;

        return dfs(9, 0, 0, 370);
    }
};

#ifdef MAIN_ACTIVE

void solve() {

}

int main() {

#ifdef IO_ON_FILE
    const string FILENAME = ""user"";
    freopen((FILENAME + "".in"").c_str(), ""r"", stdin);
    freopen((FILENAME + "".out"").c_str(), ""w"", stdout);
#endif

    int test_count = 1;
    // cin >> test_count;
    while(test_count--)
        solve();

    return EXIT_SUCCESS;
}
#endif      
",1441343915
VILLANOVA_ECON,VILLANOVA_ECON,138,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0))
            best_dist = [[math.inf]*(M) for _ in range(N)]
            best_dist[0][0] = 0
            while heap_list:
                dist, i,j = heapq.heappop(heap_list)
                if dist == best_dist[i][j]:
                    best_dist[i][j] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+1,moveTime[a][b]+1)
                        if new_max < best_dist[a][b]:
                            best_dist[a][b] = new_max
                            heapq.heappush(heap_list,(new_max,a,b))
            return best_dist[-1][-1]
        
        return djikstra(graph)",1441294489
VILLANOVA_ECON,VILLANOVA_ECON,138,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        
        N,M = len(moveTime),len(moveTime[0])
        
        
        graph = collections.defaultdict(list)
        
        directions = [(1,0),(-1,0),(0,1),(0,-1)]
        for i in range(len(moveTime)):
            for j in range(len(moveTime[0])):
                for dx,dy in directions:
                    a,b = i+dx,j+dy
                    if 0 <= a < N and 0 <= b < M:
                        graph[(i,j)].append((a,b))
        
        
                
        
        
        def djikstra(graph):
            heap_list = []
            heap_list.append((0,0,0,0))
            best_dist = [[[math.inf]*2 for _ in range(M)] for _ in range(N)]
            best_dist[0][0][0] = 0
            while heap_list:
                dist, seq,i,j = heapq.heappop(heap_list)
                jump_cost = 1 if seq == 0 else 2
                if dist == best_dist[i][j][seq]:
                    best_dist[i][j][seq] = dist
                    for a,b in graph[(i,j)]:
                        new_max = max(dist+jump_cost,moveTime[a][b]+jump_cost)
                        if new_max < best_dist[a][b][seq^1]:
                            best_dist[a][b][seq^1] = new_max
                            heapq.heappush(heap_list,(new_max,seq^1,a,b))
            return min(best_dist[-1][-1])
        
        return djikstra(graph)",1441299087
VILLANOVA_ECON,VILLANOVA_ECON,138,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        dp = [0,0]
        
        for i in range(len(list(num))):
            x = int(num[i])
            dp[i%2] += x
        return dp[0] == dp[1]",1441281131
VILLANOVA_ECON,VILLANOVA_ECON,138,3637,python3,"# class Solution:
#     def countBalancedPermutations(self, num: str) -> int:
#         def check(num):
#             dp = [0,0]  
#             for i in range(len(list(num))):
#                 x = int(num[i])
#                 dp[i%2] += x
#             return dp[0] == dp[1]

#         def brute(arr):
#             seen = set()
#             for zeb in itertools.permutations(arr):
#                 if check(list(zeb)):
#                     seen.add("""".join(list(zeb)))
#             return len(seen)
        
#         return brute(num)
    
    
MOD = 10 ** 9 + 7
MX = 1000

fac = [1] * MX
for i in range(1, MX):
    fac[i] = fac[i-1] * i % MOD
ifac = [pow(fac[MX - 1], MOD-2, MOD)] * MX
for i in range(MX - 1, 0, -1):
    ifac[i-1] = ifac[i] * i % MOD




class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        modulo = 10**9 + 7

        total_sum = sum([int(x) for x in num])
        
        target_count = len(num)//2
        
        remain_count = len(num)-target_count
        

        if total_sum%2 != 0:
            return 0
        
        target_sum = total_sum//2

        digit_len = len(list(num))//2
        

                    
                    
        num_count = [0]*10
        
        for x in num:
            num_count[int(x)] += 1
            
            
        ans = 0
        
        
        dp = [[0]*(target_sum+1) for _ in range(target_count+1)]
        dp[0][0] = 1

        for i in range(len(num_count)):
            
            new_dp = [[0]*(target_sum+1) for _ in range(target_count+1)] #[0]*(target_sum+1)
            for x in range(num_count[i]+1):
                take = x
                remain = num_count[i]-take
                new_take_sum = x * i
                #print(i,take,remain,new_take_sum)
                for j in range(len(dp)-1,-1,-1):
                    if j-take < 0:
                        break
                    for z in range(len(dp[0])-1,-1,-1):
                        if z-new_take_sum < 0:
                            break
                        if dp[j-take][z-new_take_sum] >= 0:
                            new_dp[j][z] += dp[j-take][z-new_take_sum] * ifac[take] * ifac[remain]
                            if new_dp[j][z] >= modulo:
                                new_dp[j][z] %= modulo
            

                        
            dp = list([list(row) for row in new_dp]) #[0]*(target_sum+1)

        return (dp[-1][-1] * fac[target_count]  * fac[len(num)-target_count]     )%modulo
                    
        
        
        
        
        

                    
            
",1441367947
parthDOOM,parthDOOM,139,3627,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
#define ptpll priority_queue<tuple<ll,ll,ll>, vector<tuple<ll,ll,ll>>, greater<tuple<ll,ll,ll>>>

class Solution {
public:
   int minTimeToReach(vector<vector<int>>& mt) {
       ll n = sz(mt);
       if(n == 0) rt 0;
       ll m = sz(mt[0]);
       
       vl dx = {-1, 1, 0, 0};
       vl dy = {0, 0, -1, 1};
       
       vlll0(arr, n, m);
       
       arr[0][0] = 0;
       
       ptpll pq;
       pq.emplace(0ll, 0ll, 0ll);
       
       while(!pq.empty()){
           auto [ct, x, y] = pq.top();
           pq.pop();
           
           if(x == n-1 && y == m-1){
               rt (int)ct;
           }
           if(ct > arr[x][y]) cnt;
           rep(i, 0, 4){
               ll nx = x + dx[i],ny = y + dy[i];
               if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                   ll nt = max(ct, (ll)mt[nx][ny]) + 1;
                   if(nt < arr[nx][ny]) {
                       arr[nx][ny] = nt;
                       pq.emplace(nt, nx, ny); 
                   }
               }
           }
       }
       rt -1;
   }
};
 ",1441319399
parthDOOM,parthDOOM,139,3628,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,INF));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = sz(moveTime),m = sz(moveTime[0]); 
        vl dx = {0, 0, 1, -1},dy = {1, -1, 0, 0};
        vlll0(dist, n, m);
        vlll0(moves, n, m); 
        priority_queue<pair<ll, pair<pll, ll>>, 
                      vector<pair<ll, pair<pll, ll>>>, 
                      greater<pair<ll, pair<pll, ll>>>> pq;
        
        dist[0][0] = 0;
        moves[0][0] = 0;
        pq.push({0, {{0, 0}, 0}});
        
        while(!pq.empty()) {
            ll currTime = pq.top().fst;
            ll x = pq.top().sec.fst.fst,y = pq.top().sec.fst.sec;
            ll moveCount = pq.top().sec.sec;
            pq.pop();
            if(currTime > dist[x][y]) cnt;
            rep(i, 0, 4) {
                ll newX = x + dx[i],newY = y + dy[i];
                if(newX >= 0 && newX < n && newY >= 0 && newY < m) {
                    ll waitTime = max(0ll, moveTime[newX][newY] - currTime);
                    ll moveTime = (moveCount % 2 == 0) ? 1 : 2;
                    ll newTime = currTime + waitTime + moveTime;
                    if(newTime < dist[newX][newY]) {
                        dist[newX][newY] = newTime;
                        moves[newX][newY] = moveCount + 1;
                        pq.push({newTime, {{newX, newY}, moveCount + 1}});
                    }
                }
            }
        }
        rt dist[n-1][m-1];        
    }
};",1441299919
parthDOOM,parthDOOM,139,3636,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return

class Solution {
public:
    bool isBalanced(string num) {
        ll ctE = 0,ctO = 0;
        rep(i, 0, sz(num)){
            if(!(i%2)) ctE += (num[i] - '0');
            else ctO += (num[i] - '0');
        }
        rt ctE == ctO;        
    }
};",1441285157
parthDOOM,parthDOOM,139,3637,cpp,"#define ll long long
#define modulo (1000000000+7)
#define rep(i,a,b) for(ll i=a;i<b;i++)
#define per(i,a,b) for(ll i=a;i>b;i--)
#define loop(x,a) for(auto &x:a)
#define vll(v,n) vector<ll> v(n);
#define vll0(v,n) vector<ll> v(n,0);
#define vllk(v,n,k) vector<ll> v(n,k);
#define vlll vector<vector<ll>>
#define vl vector<ll>
#define vlll0(v,n,m) vector<vector<ll>> v(n,vector<ll>(m,0));
#define qll queue<ll>
#define dqll deque<ll>
#define stll set<ll>
#define mpll map<ll,ll>
#define pqll priority_queue<ll>
#define pqvll priority_queue<ll,vector<ll>,greater<ll>>
#define pll pair<ll,ll>
#define vb vector<bool>
#define ump unordered_map
#define ust unordered_set
#define mst(x,a) memset(x,a,sizeof(x)) 
#define rd(x) ll x;cin>>x;
#define rds(x) cin>>x;
#define pt(x) cout<<x;
#define nl cout<<endl;
#define yes pt(""YES"") nl
#define no pt(""NO"") nl
#define rdvec(v,n) rep(i,0,n){rds(v[i])}
#define rdmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){rds(a[i][j])}}
#define INF LLONG_MAX
#define NINF LLONG_MIN
#define pb push_back
#define pob pop_back
#define pof pop_front
#define emp emplace
#define emb emplace_back
#define emf emplace_front
#define lb lower_bound
#define ub upper_bound
#define bk back()
#define sz(x) (ll)x.size()
#define ist insert
#define mkp(x, y) make_pair(x, y)
#define mkt(x, y, z) make_tuple(x, y, z)
#define all(v) v.begin(),v.end()
#define allr(v) v.rbegin(),v.rend()
#define fst first
#define sec second
#define acc(a) accumulate(all(a),0ll)
#define maxi(a) *max_element(all(a))
#define mini(a) *min_element(all(a))
#define sortr(a) sort(allr(a))
#define bitcnt(x) __builtin_popcountll(x)
#define ispow2(x) (!(x & (x-1)) && x)
#define lsb(x) (x & -x)
#define msb(x) (63 - __builtin_clzll(x))
#define clz(x) __builtin_clzll(x)
#define ctz(x) __builtin_ctzll(x)
#define dis(x1,y1,x2,y2) sqrt(sq(x1-x2) + sq(y1-y2))
#define ptvec(a) for(auto &x:a) {cout<<x<<"" "";} nl;
#define ptmat(a,n,m) for(int i=0;i<n;i++){for(int j=0;j<m;j++){cout<<a[i][j]<<"" "";}nl}
#define cnt continue;
#define brk break;
#define rt return
class Solution {
public:
    int countBalancedPermutations(string s) {
        ll n = sz(s),e = (n+1)>>1,o = n>>1,sum = 0;
        vll0(ct,10)
        loop(c,s) ct[c-'0']++;
        rep(d,0,10) sum += d * ct[d];
        if(sum&1) rt 0;
        sum >>= 1;
        const ll mx = 80;
        vll(f,mx+1)
        f[0] = 1;
        rep(i,1,mx+1) f[i] = f[i-1]*i%modulo;
        vll(inv,mx+1)
        inv[mx] = [&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(f[mx],modulo-2);
        per(i,mx-1,-1) inv[i] = inv[i+1]*(i+1)%modulo;
        auto C = [&](ll n,ll k) -> ll{
            if(k > n) rt 0;
            rt f[n]*inv[k]%modulo*inv[n-k]%modulo;
        };
        vlll dp(e+1,vl(sum+1,0));
        dp[0][0] = 1;
        rep(d,0,10){
            if(!ct[d]) cnt;
            per(t,e,-1){
                per(s,sum,-1){
                    if(!dp[t][s]) cnt;
                    rep(k,1,ct[d] + 1){
                        if(!(t+k <= e) || !(s+d*k <= sum)) brk;
                        ll ns = s+d*k;
                        dp[t+k][ns] = (dp[t+k][ns]+dp[t][s]*C(ct[d],k))%modulo;
                    }
                }
            }
        }
        ll ans = dp[e][sum],pf = 1;
        rep(d, 0, 10) pf = pf*f[ct[d]]%modulo;
        ans = ans*f[e]%modulo;ans = ans*f[o]%modulo;
        ans = ans*[&](ll b,ll ex){
            ll r = 1;
            while(ex){
                if(ex&1) r = r*b%modulo;
                b = b*b%modulo;
                ex >>= 1;
            }
            rt r;
        }(pf,modulo-2)%modulo;
        rt (int)ans;
    }
};",1441355501
wei zhang,l1l2,141,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;


class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> time(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.emplace(moveTime[0][0], make_pair(0, 0));
        time[0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0},{1,0},{0,-1},{0,1}};

        while (!pq.empty()) {
            auto [t, p] = pq.top(); pq.pop();
            int i = p.first, j = p.second;
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    
                    int nt = max({t, moveTime[i][j], moveTime[ni][nj]}) + 1;
                    if (nt < time[ni][nj]) {
                        time[ni][nj] = nt;
                        pq.emplace(nt, make_pair(ni, nj));
                    }
                }
            }
        }
        return -1;
    }
};
",1441349376
wei zhang,l1l2,141,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        moveTime[0][0] = 0;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<vector<int>>> time(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(moveTime[0][0], 0, 0, 0);
        time[0][0][0] = moveTime[0][0];
        vector<pair<int, int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};

        while (!pq.empty()) {
            auto [t, i, j, k] = pq.top(); pq.pop();
            if (i == n - 1 && j == m - 1) return t;
            if (t > time[i][j][k]) continue;

            for (auto& d : dirs) {
                int ni = i + d.first, nj = j + d.second;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int c = (k == 0) ? 1 : 2;
                    int t_start = max({t, moveTime[i][j], moveTime[ni][nj]});
                    int arrival_time = t_start + c;
                    int nk = 1 - k;
                    if (arrival_time < time[ni][nj][nk]) {
                        time[ni][nj][nk] = arrival_time;
                        pq.emplace(arrival_time, ni, nj, nk);
                    }
                }
            }
        }
        return -1;
    }
};
",1441355653
wei zhang,l1l2,141,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        long long se = 0;
        long long so = 0;

        for(int i = 0; i < num.size(); i += 2) {
            se += (num[i] - '0');
        }

        for(int i = 1; i < num.size(); i += 2) {
            so += (num[i] - '0');
        }

        return se == so;
    }
};",1441287354
wei zhang,l1l2,141,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int MOD = 1000000007;

ll power_mod(ll a, ll b, ll mod_val){
    ll res=1;a%=mod_val;
    while(b>0){
        if(b&1) res=res*a%mod_val;
        a=a*a%mod_val; b>>=1;
    }
    return res;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int f[10] = {0};
        ll total =0;
        for(char c: num) {f[c-'0']++; total += (c-'0');}
        if(total%2) return 0;
        ll tgt = total/2;
        int ne = (n+1)/2, no = n/2;
        vector<ll> fact(n+1,1), invf(n+1,1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1]*i%MOD;
        invf[n] = power_mod(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--) invf[i] = invf[i+1]*(i+1)%MOD;
        vector<vector<ll>> dp(ne+1, vector<ll>(tgt+1,0));
        dp[0][0]=1;
        for(int d=0;d<10;d++) {
            if(f[d]==0) continue;
            vector<vector<ll>> ndp(ne+1, vector<ll>(tgt+1,0));
            for(int k=0;k<=ne;k++) {
                for(ll s=0;s<=tgt;s++) {
                    if(dp[k][s]==0) continue;
                    for(int c=0;c<=min(f[d], ne -k);c++) {
                        ll ns = s + (ll)c*d;
                        if(ns > tgt) continue;
                        ll comb = fact[f[d]] * invf[c] % MOD;
                        comb = comb * invf[f[d]-c] % MOD;
                        ndp[k+c][ns] = (ndp[k+c][ns] + dp[k][s]*comb)%MOD;
                    }
                }
            }
            dp = move(ndp);
        }
        ll sa = dp[ne][tgt];
        ll ipf =1;
        for(int d=0;d<10;d++) if(f[d]>0) ipf = ipf * invf[f[d]] % MOD;
        ll fe = fact[ne], fo = fact[no];
        ll ans = fe * fo % MOD;
        ans = ans * sa % MOD;
        ans = ans * ipf % MOD;
        return ans;
    }
};
",1441307596
delphih,delphih,142,3627,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0
        que = [(0, 0, 0)]  # d, r, c
        while que:
            d, r, c = heappop(que)
            if d != D[r][c][0]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                d2 = max(d, A[r2][c2]) + 1
                if d2 < D[r2][c2][0]:
                    D[r2][c2][0] = d2
                    heappush(que, (d2, r2, c2))
        # print(D)
        return D[-1][-1][0]",1441294936
delphih,delphih,142,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        m, n = len(A), len(A[0])
        D = [[[inf, inf] for _ in range(n)] for _ in range(m)]
        D[0][0][0] = 0 # (next 1, next 2)
        que = [(0, 0, 0, 0)]  # d, r, c, t
        while que:
            d, r, c, t = heappop(que)
            if d != D[r][c][t]: continue
            for r2, c2 in ((r-1, c), (r+1, c), (r, c-1), (r, c+1)):
                if not (0<=r2<m and 0<=c2<n): continue
                t2 = 1 - t
                d2 = max(d, A[r2][c2]) + t + 1
                if d2 < D[r2][c2][t2]:
                    D[r2][c2][t2] = d2
                    heappush(que, (d2, r2, c2, t2))
        # print(D)
        return min(D[-1][-1])",1441296845
delphih,delphih,142,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = sum(int(c) for c in num[::2])
        s2 = sum(int(c) for c in num[1::2])
        return s1 == s2",1441281691
delphih,delphih,142,3637,python3,"M = 10**9+7

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        n_even = (n + 1) // 2
        n_odd = n // 2
        tot = sum(int(d) for d in num)
        if tot % 2 != 0: return 0
            
        freq = Counter(num)
        
        dp = [[Counter() for _ in range(n_odd+1)] for _ in range(n_even+1)]  # dp[even][odd][even - odd]
        dp[0][0][0] = 1
        cur = 0
        for d, cnt in freq.items():
            d = int(d)
            for i0 in range(cur-n_odd, min(cur, n_even)+1):
                i1 = cur - i0
                # if i1 > n_odd: continue
                # print(i0, i1)
                for diff0, ways0 in dp[i0][i1].items():
                    for j0 in range(cnt+1):
                        j1 = cnt - j0
                        if i0+j0 > n_even or i1+j1 > n_odd: continue
                        diff = diff0 + (j0-j1) * d
                        ways = ways0 * comb(i0+j0, j0) * comb(i1+j1, j1) % M
                        dp[i0+j0][i1+j1][diff] = (dp[i0+j0][i1+j1][diff] + ways) % M
            cur += cnt
        return dp[n_even][n_odd][0]",1441356652
Syed Ali Aatif,mafailure,143,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; 
        pq.push(make_pair(0,0)); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<int>> d(n, vector<int>(m,inf)); 
        d[0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second;
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y]>max(moveTime[x][y]+1, _d+1)) {
                    d[x][y] = max(moveTime[x][y]+1, _d+1); 
                    pq.push(make_pair(d[x][y], x*m+y)); 
                }
            }
        }
        return d[n-1][m-1]; 
    }
};",1441297641
Syed Ali Aatif,mafailure,143,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq; 
        pq.push(make_pair(0,make_pair(0,0))); 
        int n = moveTime.size(); 
        int m = moveTime.front().size(); 
        const int inf = 2e9; 
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m,vector<int>(2,inf))); 
        d[0][0][0] = 0; 
        auto isPossible = [&](int i,int j) {
            return (i>=0 && i<n && j>=0 && j<m); 
        };
        vector<int> dx = {0,1,-1,0}, dy = {1,0,0,-1}; 
        while(pq.size()){
            auto _d = pq.top().first;
            auto u = pq.top().second.first;
            auto _ = pq.top().second.second; 
            pq.pop(); 
            int i = u/m; 
            int j = u%m; 
            for(int k=0;k<4;k++){
                int x = dx[k]+i; 
                int y = dy[k]+j; 
                if(!isPossible(x,y)) continue; 
                if(d[x][y][1-_]>max(moveTime[x][y], _d)+1+_) {
                    d[x][y][1-_] = max(moveTime[x][y], _d)+1+_; 
                    pq.push(make_pair(d[x][y][1-_], make_pair(x*m+y,1-_))); 
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]); 
    }
};",1441302882
Syed Ali Aatif,mafailure,143,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int> cnt(2); 
        for(int i=0;i<num.size();i++){
            cnt[i%2]+=num[i]-'0'; 
        }
        return cnt.front() == cnt.back(); 
    }
};",1441285747
Syed Ali Aatif,mafailure,143,3637,cpp,"const int mod = 1e9+7; 
class Solution {
public:
#define int long long 
    int add (int a,int b ) { return (a+b)%mod;}
    int mul (int a,int b) {return a*b%mod;}
    int sub(int a,int b) { return (a-b+mod)%mod;}
    int power(int a,int b,int mod) {
        if(b==0)return 1; 
        int u = power(a,b>>1,mod); 
        u = mul(u,u);
        if(b%2)u = mul(u,a); 
        return u; 
    }


    int32_t countBalancedPermutations(string num) {
        int dp[num.size()+1][9*num.size()+1];
        memset(dp,0,sizeof(dp)); 
        vector<int> cnt(10);
        for(auto it:num)cnt[it-'0']++; 
        vector<int> fact(81);
        fact[0] = 1; 
        for(int i=1;i<fact.size();i++)fact[i] = mul(i,fact[i-1]); 
        vector<int> ifact(81,1); 
        ifact[80] = power(fact[80], mod-2, mod); 
        for(int i=79;i>=0;i--)ifact[i]=mul(i+1, ifact[i+1]); 
        int tot = 0; 
        for(auto it:num)tot+=it-'0'; 
        if(tot%2)return 0; 
        auto getAns = [&](vector<int> & c,int t) {
            int dp[11][81][81*9]; 
            memset(dp,0,sizeof(dp)); 
            dp[0][0][0] = 1; 
            for(int i=0;i<10;i++){
                for(int j=0;j<=t;j++){
                    for(int p = 0;p<81*9;p++){
                    if(dp[i][j][p] == 0)continue; 
                    for(int k=0;k<=c[i] && k+j<=t;k++){
                         //cout<<i<<"" ""<<j<<"" ""<<p<<"" ""<<k<<"" ""<<t<<endl; 
                        dp[i+1][j+k][p+k*i] = add(dp[i+1][j+k][p+k*i], mul(dp[i][j][p], mul(ifact[k], ifact[c[i]-k])));
                    }
                    }
                }
            }
            return dp[10][t][tot/2]; 
        };
        int n = num.size();
        int o = (n+1)/2;
        int e = n-o; 
        int ans = mul(mul(fact[o], fact[e]), getAns(cnt, o)); 
    
        return ans;
    }

#undef int
};",1441350773
Shubham Maheshwari,sm_27,144,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0))]
        visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+1,(x,y)))
                        visited.add((x,y))
                        
                        
            ",1441298499
Shubham Maheshwari,sm_27,144,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        curr = 0
        heap = [(0,(0,0),0)]
        times = [[[float(""inf""), float(""inf"")] for _ in range(m)] for _ in range(n)]
        # visited = set([(0,0)])
        directions = [[1,0],[-1,0],[0,1],[0,-1]]
        while heap:
            # print(heap)
            time,node,move = heapq.heappop(heap)
            if curr < time:
                curr = time
            if node == (n-1,m-1):
                return curr
            # visited.add(node)
            for dx,dy in directions:
                if 0<=node[0] + dx<n and 0<= node[1] + dy<m:
                    x = node[0] + dx
                    y = node[1] + dy
                    if max(curr,moveTime[x][y]) + move < times[x][y][(move+1)%2]:
                    # if (node[0] + dx, node[1] + dy) not in visited:
                        heapq.heappush(heap,(max(curr,moveTime[x][y])+move+1,(x,y),(move+1)%2))
                        times[x][y][(move+1)%2] = max(curr,moveTime[x][y]) + move                        
                        
            ",1441313266
Shubham Maheshwari,sm_27,144,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(n):
            if i&1:
                odd += int(num[i])
            else:
                even += int(num[i])
        return odd == even",1441281409
Shubham Maheshwari,sm_27,144,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        def C(n,r):
            return math.comb(n,r)
        n = len(num)
        nums = dict()
        for i in range(10):
            nums[i] = 0
        s = 0
        for c in num:
            nums[int(c)] += 1
            s += int(c)
        if s %2 != 0:
            return 0
        odd = n//2
        if n&1:
            odd += 1
        MOD = 10**9+7
        @lru_cache(None)
        def dfs(num, odd,even, rem):
            nonlocal MOD
            # print(num,odd,even,rem)
            if rem == 0 and num == 10:
                if odd == 0 and even == 0:
                    return 1
                return 0
            if num >= 10:
                return 0
            if odd < 0 or even < 0:
                return 0
            if rem < 0:
                return 0
            ans = 0
            for count in range(nums[num]+1):
                # we select count num in odd side
                if rem < count*num and count <= odd and nums[num]-count <= even:
                    continue
                # count in odd and nums[num]-count in even
                facts = (C(odd,count)*C(even,nums[num]-count))% MOD
                ans += (dfs(num+1,odd-count,even-nums[num]+count,rem-count*num) * facts)
                ans %= MOD
            # if num == 1:
                # print(ans)
            return ans
            
            
        return dfs(0,odd,n-odd,s//2)
            ",1441363442
Umesh Kumar,icosa,145,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<ii, vector<ii>, greater<ii>> pq;
        pq.push({0, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] == inf){
                        dp[ni][nj] = 1 + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441299654
Umesh Kumar,icosa,145,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define ll long long
        typedef vector<ll> vi;
        typedef vector<vi> vvi;
        typedef pair<ll, ll> ii;
        typedef tuple<ll, ll, ll> iii;

        int n = moveTime.size(), m = moveTime[0].size();

        const ll inf = 1e15;
        vvi dp(n, vi(m, inf));
        dp[0][0] = 0;

        priority_queue<iii, vector<iii>, greater<iii>> pq;
        pq.push({0, 1, 0});

        ii nbrs[] = {
            {0,1}, {0, -1}, {1, 0}, {-1, 0}
        };

        while(!pq.empty()){
            auto [t, mt, u] = pq.top();
            pq.pop();

            int i = u/m, j=u%m;

            if(dp[i][j] < t) continue;
            
            for(auto &[di, dj]: nbrs){
                int ni = i+di, nj = j + dj;
                if(ni >= 0 && nj >= 0 && ni < n && nj < m){
                    int v = ni * m + nj;
                    if(dp[ni][nj] > mt + max(t, (ll)moveTime[ni][nj])){
                        dp[ni][nj] = mt + max(t, (ll)moveTime[ni][nj]);
                        pq.push({dp[ni][nj], mt == 1? 2: 1, v});
                    }
                }
            }
        }

        return dp[n-1][m-1];
    }
};",1441309882
Umesh Kumar,icosa,145,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i=0; i<num.size(); i++){
            (i & 1 ? odd: even) += (num[i] - '0');
        }
        return even == odd;
    }
};",1441311751
Umesh Kumar,icosa,145,3637,cpp,"#include <bits/stdc++.h>
#define ll long long
#define FOR(i, l, r) for (ll i = l; i < r; i++)
#define For(i, r, l) for (ll i = r - 1; i >= l; i--)
#define sz(x) x.size()
#define all(x) x.begin(), x.end()
#define pb push_back
#define eb emplace_back
#define ITER(itr, x) for (auto &itr : x)
#define LSOne(S) ((S) & (-S))

using namespace std;
#define debug(args...)                                                         \
  {                                                                            \
    string _s = #args;                                                         \
    replace(_s.begin(), _s.end(), ',', ' ');                                   \
    stringstream _ss(_s);                                                      \
    istream_iterator<string> _it(_ss);                                         \
    err(_it, args);                                                            \
  }
template <typename... Args>
void err(istream_iterator<string> it, Args... args) {
  ((cerr << *it << "" = "" << args << "" "", it++), ...);
  cerr << endl;
}

typedef pair<int, int> ii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vll;
typedef vector<ii> vii;
typedef vector<vi> vvi;
typedef vector<vll> vvll;

/**
 * Description: modular arithmetic operations
 * Source:
 * KACTL
 * https://codeforces.com/blog/entry/63903
 * https://codeforces.com/contest/1261/submission/65632855 (tourist)
 * https://codeforces.com/contest/1264/submission/66344993 (ksun)
 * also see https://github.com/ecnerwala/cp-book/blob/master/src/modnum.hpp
 * (ecnerwal) Verification: https://open.kattis.com/problems/modulararithmetic
 */

template <int MOD, int RT> struct mint {
  static const int mod = MOD;
  static constexpr mint rt() { return RT; } // primitive root for FFT
  int v;
  explicit operator int() const {
    return v;
  } // explicit -> don't silently convert to int
  mint() : v(0) {}
  mint(ll _v) {
    v = int((-MOD < _v && _v < MOD) ? _v : _v % MOD);
    if (v < 0)
      v += MOD;
  }
  bool operator==(const mint &o) const { return v == o.v; }
  friend bool operator!=(const mint &a, const mint &b) { return !(a == b); }
  friend bool operator<(const mint &a, const mint &b) { return a.v < b.v; }
  friend void re(mint &a) {
    ll x;
    cin >> x;
    a = mint(x);
  }
  // friend str ts(mint a) { return ts(a.v); }

  mint &operator+=(const mint &o) {
    if ((v += o.v) >= MOD)
      v -= MOD;
    return *this;
  }
  mint &operator-=(const mint &o) {
    if ((v -= o.v) < 0)
      v += MOD;
    return *this;
  }
  mint &operator*=(const mint &o) {
    v = int((ll)v * o.v % MOD);
    return *this;
  }
  mint &operator/=(const mint &o) { return (*this) *= inv(o); }
  friend mint pow(mint a, ll p) {
    mint ans = 1;
    assert(p >= 0);
    for (; p; p /= 2, a *= a)
      if (p & 1)
        ans *= a;
    return ans;
  }
  friend mint inv(const mint &a) {
    assert(a.v != 0);
    return pow(a, MOD - 2);
  }

  mint operator-() const { return mint(-v); }
  mint &operator++() { return *this += 1; }
  mint &operator--() { return *this -= 1; }
  friend mint operator+(mint a, const mint &b) { return a += b; }
  friend mint operator-(mint a, const mint &b) { return a -= b; }
  friend mint operator*(mint a, const mint &b) { return a *= b; }
  friend mint operator/(mint a, const mint &b) { return a /= b; }
};

const ll MOD = 1e9 + 7;
using mi = mint<MOD, 5>; // 5 is primitive root for both common mods
using vmi = vector<mi>;
using pmi = pair<mi, mi>;
using vpmi = vector<pmi>;

vector<vmi> scmb; // small combinations
void genComb(int SZ) {
  scmb.assign(SZ, vmi(SZ));
  scmb[0][0] = 1;
  FOR(i, 1, SZ)
  FOR(j, 0, i + 1) scmb[i][j] = scmb[i - 1][j] + (j ? scmb[i - 1][j - 1] : 0);
}

/**
 * Description: pre-compute factorial mod inverses,
 * assumes MOD$ is prime and SZ < MOD$.
 * Time: O(SZ)
 * Source: KACTL
 * Verification: https://dmoj.ca/problem/tle17c4p5
 */

vmi invs, fac, ifac;
void genFac(int SZ) {
  invs.resize(SZ), fac.resize(SZ), ifac.resize(SZ);
  invs[1] = fac[0] = ifac[0] = 1;
  FOR(i, 2, SZ) invs[i] = mi(-(ll)MOD / i * (int)invs[MOD % i]);
  FOR(i, 1, SZ) fac[i] = fac[i - 1] * i, ifac[i] = ifac[i - 1] * invs[i];
}
mi comb(int a, int b) {
  if (a < b || b < 0)
    return 0;
  return fac[a] * ifac[b] * ifac[a - b];
}

const int MAX_E = 41;
const int MAX_SE = MAX_E * 9;
mi dp[11][MAX_E][MAX_SE]; // count even, sum even

class Solution {
public:
  int countBalancedPermutations(string num) {
    genFac(1001);
    vi count(10, 0);
    for (auto c : num)
      count[c - '0']++;

    memset(dp, 0, sizeof(dp));
    dp[0][0][0] = 1;

    int n = num.size(), digs = 0, sum_digs = 0;
    for (int i = 0; i < 10; i++) {
      for (int e = 0; e < min(MAX_E, digs + 1); e++) {
        int odd = digs - e;
        for (int c = 0; c <= min(count[i], MAX_E - e - 1); c++) {
          for (int se = 0; se < min(sum_digs + 1, MAX_SE - c * i); se++) {
            int sum_odd = sum_digs - se;
            // put c in even places
            dp[i + 1][c + e][se + c * i] +=
                (dp[i][e][se] * comb((n + 1) / 2 - e, c) *
                 comb(n - (n + 1) / 2 - odd, count[i] - c));
          }
        }
      }

      digs += count[i];
      sum_digs += count[i] * i;
    }

    mi ans = 0;
    ans += dp[10][(n + 1) / 2][sum_digs / 2];

    if (sum_digs & 1)
      return 0;
    return (int)ans;
  }
};",1441363622
g129512,g129512,146,3627,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,1)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=1
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359512
g129512,g129512,146,3628,python3,"class Solution:
    def minTimeToReach(self, ar: List[List[int]]) -> int:
        m,n=len(ar),len(ar[0])
        q=[(0,0,0,2)]
        vis=[[False]*n for _ in range(m)]
        while q!=[]:
            t,x,y,nt=heapq.heappop(q)
            if vis[x][y]:
                continue
            vis[x][y]=True
            if x==m-1 and y==n-1:
                return t
            for dx,dy in (1,0),(-1,0),(0,1),(0,-1):
                xx,yy=dx+x,dy+y
                if 0<=xx<m and 0<=yy<n and not vis[xx][yy]:
                    nnt=(1 if nt==2 else 2)
                    heapq.heappush(q, (max(t,ar[xx][yy])+nnt, xx,yy, nnt))
            
                    
        
        ",1441359413
g129512,g129512,146,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n=len(num)
        s1=sum(int(num[i]) for i in range(n) if i%2==0)
        s2=sum(int(num[i]) for i in range(n) if i%2==1)
        return s1==s2
        ",1441359720
g129512,g129512,146,3637,python3,"from functools import cache
from typing import Counter

class Comb:
    def __init__(self, n, mod) -> None:
        p,pi=[0]*(n+1),[0]*(n+1)
        self.p,self.pi=p,pi
        self.mod=mod
        p[0]=1
        pi[0]=1
        for i in range(1,n+1):
            p[i]=p[i-1]*i%mod
        pi[n]=pow(p[n],mod-2,mod)
        for i in range(n-1,0,-1):
            pi[i]=pi[i+1]*(i+1)%mod
    
    def comb(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[r]*self.pi[n-r]%self.mod
    
    def perm(self,n,r):
        if n<r:return 0
        return self.p[n]*self.pi[n-r]%self.mod

M=10**9+7
comb=Comb(80, M)

@cache
def cb(n,k):
    return comb.comb(n,k)

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n=len(num)
        s=sum(int(v) for v in num)
        if s%2==1:return 0
        ct=Counter(num)
        dp=[[0]*361 for _ in range(41)]
        dp[0][0]=1
        prec=0
        for kk,v in ct.items():
            kk=int(kk)
            ndp=[[0]*361 for _ in range(41)]
            for i in range(n//2+1):
                for j in range(s//2+1):
                    for k in range(v+1):
                        if i+k>n//2 or j+k*kk>s//2:break
                        ndp[i+k][j+k*kk]+=dp[i][j]*cb(i+k,k)*cb(prec-i+v-k,v-k)
                        ndp[i+k][j+k*kk]%=M
            dp=ndp
            prec+=v
        return dp[n//2][s//2]",1441363810
Rahul Gupta,guts_berserker718,147,3627,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0}); 
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 1) : time + (k == 0 ? 1 : 1);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301916
Rahul Gupta,guts_berserker718,147,3628,cpp,"class Solution {
public:
    int dr[4] = {-1, 0, 1, 0};
    int dc[4] = {0, 1, 0, -1};
    
    int minTimeToReach(vector<vector<int>>& move) {
        int rows = move.size(), cols = move[0].size();
        vector<vector<vector<bool>>> visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false)));
        
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});  
        visited[0][0][0] = true;
        
        while (!pq.empty()) {
            auto it = pq.top();
            pq.pop();
            
            int time = it[0], i = it[1], j = it[2], k = it[3];
            if (i == rows - 1 && j == cols - 1) return time;
            
            for (int o = 0; o < 4; o++) {
                int n_r = i + dr[o], n_c = j + dc[o];
                if (n_r >= 0 && n_c >= 0 && n_r < rows && n_c < cols) {
                    int new_time = (move[n_r][n_c] >= time) ? move[n_r][n_c] + (k == 0 ? 1 : 2) : time + (k == 0 ? 1 : 2);
                    int new_k = !k;

                    if (!visited[n_r][n_c][new_k]) {
                        visited[n_r][n_c][new_k] = true;
                        pq.push({new_time, n_r, n_c, new_k});
                    }
                }
            }
        }
        
        return -1;
    }
};
",1441301323
Rahul Gupta,guts_berserker718,147,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0,b=0;
        for(int i=0;i<num.length();i++){
            if(i%2==0){
                a+=(num[i]-'0');
            }else b+=(num[i]-'0');
        }
    return a==b;
    }

};",1441281567
Rahul Gupta,guts_berserker718,147,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

class Solution {
public:
    ll nCr(int n, int r, const vector<ll>& fact, const vector<ll>& invFact) {
        if (r > n) return 0;
        return fact[n]* invFact[n - r] % MOD * invFact[r] % MOD ;
    }
    ll modPow(ll base, ll exp) {
        ll res = 1;
        while (exp) {
            if (exp & 1) res = res * base % MOD;
            base = base * base % MOD;
            exp >>= 1;
        }
        return res;
    }
    

    
    int countBalancedPermutations(string num) {
        int i = 0;
        int len = num.size();
         int half2 = len / 2;
        int half1 = (len + 1) / 2;
       
        
        vector<int> freq(12, 0);
       
        
        ll sum = 0;
       
        
        
        
        vector<ll>invFact(len + 5, 1), fact(len + 5, 1);
        i = 1;
        while (i <= len) {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        i=0;
        while (i < len) {
            freq[num[i] - '0']++;
            i++;
        }
        invFact[len] = modPow(fact[len], MOD - 2);
        i = len - 1;
        while (i >= 0) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
            i--;
        }
        
        i = 0;
        while (i < 10) {
            sum += 1LL * i * freq[i];
            i++;
        }
        if (sum % 2 != 0) return 0;
        ll target = sum / 2;

        
        

       vector<vector<ll>> dp(target + 5, vector<ll>(half1 + 5, 0));
dp[0][0] = 1;

int d = 0;
while (d < 10) {
    // if(freq[d]==0)continue;
    if (freq[d] != 0) {
        int j = half1;
        while (j >= 0) {
            int k = target;
            while (k >= 0) {
                if (dp[k][j] != 0) {
                    int c = 1;
                    while (c <= min(freq[d], half1 - j)) {
                        if (k + d * c > target) break;
                        ll ways = nCr(freq[d], c, fact, invFact);
                        dp[k + d * c][j + c] = (dp[k + d * c][j + c] % MOD + dp[k][j] * ways) % MOD;
                        c++;
                    }
                }
                k--;
            }
            j--;
        }
    }
    d++;
}

ll dpVal = dp[target][half1];
if (dpVal == 0) return 0;


ll factProd = 1;
d = 0;
while (d < 10) {
    factProd = (fact[freq[d]] % MOD * factProd % MOD) % MOD;
    d++;
}
ll result = (dpVal * fact[half1] % MOD * fact[half2] % MOD) % MOD;
result = result * modPow(factProd, MOD - 2) % MOD;
return result % MOD;

    }
};
",1441357919
xpycc,xpycc,148,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        pq.emplace(0, 0, 0);
        mt[0][0] = -1;
        while (!pq.empty()) {
            auto [t, x, y] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d];
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (mt[nx][ny] < 0) continue;
                const int nt = max(t + 1, mt[nx][ny] + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny);
                mt[nx][ny] = -1;
            }
        }
        return -1;
    }
};",1441305505
xpycc,xpycc,148,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        const int n = mt.size(), m = mt[0].size();
        priority_queue<tuple<int, int16_t, int16_t, int16_t>> pq;
        constexpr int dx[] = { 0, 1, 0,-1};
        constexpr int dy[] = { 1, 0,-1, 0};
        vector<int8_t> mem(n * m * 2);
        auto vis = [&](int x, int y, int b) -> int8_t& {
            return mem[x * m * 2 + y * 2 + b];
        };
        pq.emplace(0, 0, 0, 0);
        vis(0, 0, 0) = true;
        while (!pq.empty()) {
            auto [t, x, y, b] = pq.top(); pq.pop();
            t = -t;
            // printf(""%d %d %d\n"", t, x, y, b);
            for (int d = 0; d < 4; ++d) {
                const int nx = x + dx[d], ny = y + dy[d], nb = !b;
                // printf(""%d %d\n"", nx, ny);
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if (vis(nx, ny, nb)) continue;
                const int nt = max(t + b + 1, mt[nx][ny] + b + 1);
                // printf(""%d %d %d\n"", nt, nx, ny);
                if (nx == n - 1 && ny == m - 1) return nt;
                pq.emplace(-nt, nx, ny, nb);
                vis(nx, ny, nb) = true;
            }
        }
        return -1;
    }
};",1441317271
xpycc,xpycc,148,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int diff = 0, f = 1;
        for (char c : num) {
            diff += f * (c - '0');
            f = -f;
        }
        return diff == 0;
    }
};",1441282241
xpycc,xpycc,148,3637,cpp,"class Solution {
    static constexpr int mod = 1'000'000'007;
    static int inv(int x) {
        int p = mod - 2;
        int a = 1;
        while (p > 0) {
            if (p & 1) a = a * 1LL * x % mod;
            p >>= 1;
            x = x * 1LL * x % mod;
        }
        return a;
    }
public:
    int countBalancedPermutations(string num) {
        const int n = num.size(), h = n / 2,
                  S = accumulate(num.begin(), num.end(), 0, [](int x, char c) {
                        return x + c - '0';
                    }),
                  H = S / 2;
        if (S % 2 != 0) return 0;
        vector<vector<int>> f(h + 1, vector<int>(H + 1));
        f[0][0] = 1;
        for (int i = 0; i < n; ++i) {
            for (int j = h; j >= 0; --j)
                for (int k = H; k >= 0; --k) {
                    int x = num[i] - '0';
                    f[j][k] = (f[j][k] * (i + 1LL - j)) % mod; 
                    if (j > 0 && k - x >= 0)
                        f[j][k] = (f[j][k] + f[j - 1][k - x] * 1LL * j) % mod;
                }
        }
        int count[10] = {};
        for (char c : num) count[c - '0']++;
        vector<int> fact(n + 1);
        fact[0] = 1;
        for (int i = 1; i <= n; ++i)
            fact[i] = (fact[i - 1] * 1LL * i) % mod;
        int ans = f[h][H];
        for (int i = 0; i < 10; ++i)
            ans = (ans * 1LL * inv(fact[count[i]])) % mod;
        return ans;
    }
};",1441359032
BHISHMADEV GHOSH,bhishma_v2,150,3627,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][] minTime = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                minTime[i][j] = Integer.MAX_VALUE;
            }
        }
        minTime[0][0] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0});

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];

            if (curR == n - 1 && curC == m - 1) {
                return time;
            }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + 1;
                    if (newTime < minTime[rr][cc]) {
                        minTime[rr][cc] = newTime;
                        q.offer(new int[]{rr, cc, newTime});
                    }
                }
            }
        }

        return -1;
    }
}
",1441315131
BHISHMADEV GHOSH,bhishma_v2,150,3628,java,"import java.util.PriorityQueue;

class Solution {
    int[] d = {0, 1, 0, -1, 0};

    public int minTimeToReach(int[][] moveTime) {
        return getMin(moveTime);
    }

    int getMin(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] minTime = new int[n][m][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                for(int k = 0; k <= 1; k++){
                minTime[i][j][k] = Integer.MAX_VALUE;
                }
            }
        }
        minTime[0][0][0] = 0;
        minTime[0][0][1] = 0;

        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[2], b[2]));
        q.offer(new int[]{0, 0, 0,0});
        

        while (!q.isEmpty()) {
            int[] t = q.poll();
            int curR = t[0];
            int curC = t[1];
            int time = t[2];
            int k = t[3];

            // if (curR == n - 1 && curC == m - 1) {
            //     return time;
            // }

            for (int i = 0; i < 4; i++) {
                int rr = curR + d[i];
                int cc = curC + d[i + 1];

                if (rr >= 0 && cc >= 0 && rr < n && cc < m) {
                    int newTime = Math.max(time, moveTime[rr][cc]) + (k == 0 ? 1 : 2);
                    if (newTime < minTime[rr][cc][k]) {
                        minTime[rr][cc][k] = newTime;
                        q.offer(new int[]{rr, cc, newTime, k == 0 ? 1 : 0});
                    }
                }
            }
        }

        return Math.min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
}
",1441321903
BHISHMADEV GHOSH,bhishma_v2,150,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int sum1 = 0, sum2 = 0;

        for(int i = 0; i < n; i++){
            if(i % 2 == 0)sum1 += (num.charAt(i) - '0');
            else sum2 += (num.charAt(i) - '0');
        }

        return sum1 == sum2;
    }
}",1441282941
BHISHMADEV GHOSH,bhishma_v2,150,3637,java,"import java.util.*;

class Solution {
    int mod = (int) 1e9 + 7;
    long[][][] dp;
    Map<Integer, Integer> freqMap = new HashMap<>();

    long fact(int n) {
        long res = 1;
        for (int i = 1; i <= n; i++) {
            res = (res * i) % mod;
        }
        return res;
    }

    long modInverse(long a, int mod) {
        long res = 1;
        long power = mod - 2;
        while (power > 0) {
            if ((power & 1) != 0) {
                res = (res * a) % mod;
            }
            a = (a * a) % mod;
            power >>= 1;
        }
        return res;
    }

    public int countBalancedPermutations(String num) {
        int sum = 0;
        List<Integer> cur = new ArrayList<>();
        int n = num.length();

        for (char c : num.toCharArray()) {
            int digit = c - '0';
            sum += digit;
            cur.add(digit);
            freqMap.put(digit, freqMap.getOrDefault(digit, 0) + 1);
        }

        if (sum % 2 != 0)
            return 0;

        int odd = n / 2, even = (n + 1) / 2, target = sum / 2;
        dp = new long[n][even + 1][target + 1];

        for (long[][] rr : dp) {
            for (long[] r : rr) Arrays.fill(r, -1);
        }

        long ways = getWays(0, cur, even, target);

        for (int f : freqMap.values()) {
            ways = (ways * modInverse(fact(f), mod)) % mod;
        }

        long factEven = fact(even);
        long factOdd = fact(odd);

        return (int) ((ways * factEven % mod) * factOdd % mod);
    }

    long getWays(int ind, List<Integer> cur, int n, int target) {
        if (n < 0 || target < 0) return 0;
        if (ind == cur.size()) return (n == 0 && target == 0) ? 1 : 0;

        if (dp[ind][n][target] != -1) return dp[ind][n][target];

        long take = 0, notTake = 0;

        if (cur.get(ind) <= target) {
            take = getWays(ind + 1, cur, n - 1, target - cur.get(ind));
        }

        notTake = getWays(ind + 1, cur, n, target);

        return dp[ind][n][target] = (take + notTake) % mod;
    }
}
",1441365713
Abhishek Srivastava,Abhi_Srivastava,151,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        queue<pair<int, int>> q;
        dist[0][0] = 0;
        q.push({0, 0});
        while (!q.empty()) {
            int x = q.front().first, y = q.front().second;
            q.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 1) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 1;
                        q.push({x + i, y + j});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441298457
Abhishek Srivastava,Abhi_Srivastava,151,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> dist(n, vector<int>(m, 2e9));
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        while (!pq.empty()) {
            int dst = pq.top().first, x = pq.top().second.first, y = pq.top().second.second;
            pq.pop();
            for (int i = -1; i < 2; i++)
                for (int j = -1; j < 2; j++)
                    if (abs(i) + abs(j) == 1 && min(x + i, y + j) >= 0 && x + i < n && y + j < m && dist[x + i][y + j] > max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2)) {
                        dist[x + i][y + j] = max(dist[x][y], moveTime[x + i][y + j]) + 2 - ((x + i + y + j) % 2);
                        pq.push({dist[x + i][y + j], {x + i, y + j}});
                    }               
        }
        return dist[n - 1][m - 1];
    }
};",1441311456
Abhishek Srivastava,Abhi_Srivastava,151,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2)
                sum += num[i] - '0';
            else
                sum -= num[i] - '0';
        }
        return !sum;
    }
};",1441281587
Abhishek Srivastava,Abhi_Srivastava,151,3637,cpp,"const int mod = 1e9 + 7;
long long fact[81], inv_fact[81];
long long binpow(long long a, int b) {
    long long res = 1;
    while (b) {
        if (b % 2)
            (res *= a) %= mod;
        (a *= a) %= mod;
        b /= 2;
    }
    return res;
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if (!fact[0]) {
            fact[0] = 1;
            for (int i = 1; i < 81; i++)
                fact[i] = (fact[i - 1] * i) % mod;
            inv_fact[80] = binpow(fact[80], mod - 2);
            for (int i = 79; i >= 0; i--)
                inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % mod;
        }
        int dig = num.size() / 2, sum = 0;
        int freq[10] = {};
        for (char x : num) {
            sum += x - '0';
            freq[x - '0']++;
        }
        if (sum % 2)
            return 0;
        sum /= 2;
        vector<vector<int>> dp(dig + 1, vector<int>(sum + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i <= 9; i++) {
            vector<vector<int>> ndp(dig + 1, vector<int>(sum + 1, 0));
            for (int j = 0; j <= freq[i]; j++)
                for (int k = j; k <= dig; k++)
                    for (int l = i * j; l <= sum; l++)
                        (ndp[k][l] += dp[k - j][l - i * j] * inv_fact[j] % mod * inv_fact[freq[i] - j] % mod) %= mod;
            swap(dp, ndp);
        }
        return dp[dig][sum] * fact[dig] % mod * fact[num.size() - dig] % mod;
    }
};",1441353464
avienn_x,avienn_x,152,3627,cpp,"class Solution {
public:
    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<long long>> dist(n, vector<long long>(m, INT_MAX));
        dist[0][0] = 0;
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            long long t = curr[0];
            long long i = curr[1];
            long long j = curr[2];
            if (i == n-1 && j == m-1)
                return t;
            if (t > dist[i][j])
                continue;
            for (auto &d : dirs) {
                long long ni = i + d.first;
                long long nj = j + d.second;
                if(!chck(ni, nj, n, m))
                    continue;
                int sr = max(t, 1ll * mt[ni][nj]);
                if (sr + 1 < dist[ni][nj]) {
                    dist[ni][nj] = sr + 1;
                    pq.push({sr + 1, ni, nj});
                }
            }
        }
        return INT_MAX;
    }
};",1441304877
avienn_x,avienn_x,152,3628,cpp,"class Solution {
public:

    bool chck(int i, int j, int n, int m){
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    vector<pair<int, int>> dirs = { {-1,0}, {1,0}, {0,-1}, {0,1} };
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<vector<long long>>> dist(n, vector<vector<long long>>(m, vector<long long>(2, INT_MAX)));
        dist[0][0][0] = 0;
        priority_queue<vector<int>, vector<vector<int>>, std::greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int t = curr[0];
            int i = curr[1];
            int j = curr[2];
            int p = curr[3];
            if (i == n-1 && j == m-1 || t > dist[i][j][p])
                continue;
            for (auto &d : dirs) {
                int ni = i + d.first;
                int nj = j + d.second;
                if(!chck(ni, nj, n, m))
                        continue;
                int sr = max(t, mt[ni][nj]);
                int mv = (p == 0) ? 1 : 2;
                int nxt = sr + mv;
                int np = 1 - p;
                if (nxt < dist[ni][nj][np]){
                        dist[ni][nj][np] = nxt;
                        pq.push({nxt, ni, nj, np});
                }

            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441316491
avienn_x,avienn_x,152,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int a = 0, b= 0 ;
        for(int i = 0; i < n; i++){
            if(i % 2)
                a += num[i] - '0';
            else
                b += num[i] - '0';
        }
        return a == b;
    }
};",1441305980
avienn_x,avienn_x,152,3637,cpp,"
const int N = 2e5 + 5;
const int MOD = 1e9 + 7;
const int MAXN = 105; 
const int MAXS = 1100;
typedef long long ll;

ll dp[MAXN][MAXS];
ll f[MAXN], invf[MAXN];
int fr[10];

class Solution {
private:
    ll mpow(ll b, ll p) {
        ll r = 1;
        b %= MOD;
        while (p > 0) {
            if (p & 1) r = (r * b) % MOD;
            b = (b * b) % MOD;
            p >>= 1;
        }
        return r;
    }
    
    void precalc(int sz) {
        f[0] = 1;
        for (int i = 1; i <= sz; i++) {
            f[i] = (f[i-1] * i) % MOD;
        }
        invf[sz] = mpow(f[sz], MOD-2);
        for (int i = sz-1; i >= 0; i--) {
            invf[i] = (invf[i+1] * (i+1)) % MOD;
        }
    }
    
    ll ncr(int n, int r) {
        if (r > n) return 0;
        return (((f[n] * invf[r]) % MOD) * invf[n-r]) % MOD;
    }

public:
    int countBalancedPermutations(string s) {
        int n = s.length();
        int m = (n + 1) / 2;
        int h = n / 2;
        ll sm = 0;
        memset(fr, 0, sizeof(fr));
        for (char c : s){
        	fr[c-'0']++;
        	sm += (c - '0');
        }
        if (sm % 2) return 0;
        ll t = sm / 2;
        precalc(n);
        memset(dp, 0, sizeof(dp));
        dp[0][0] = 1;
   			
        for (int d = 0; d < 10; d++) {
            if (!fr[d]) continue;
            ll available = fr[d];
            for (int cs = t; cs >= 0; cs--) {
                for (int p = m; p >= 0; p--) {
                    if (!dp[p][cs])
                        continue;

                    ll val = dp[p][cs];
                    ll rem = m - p;

                    for (int c = 1; c <= available && c <= rem; c++) {
                        if (cs + 1LL * d * c > t) break;

                        ll cmb = f[fr[d]];
                        (cmb *= invf[c]) %= MOD;
                        (cmb *= invf[fr[d] - c]) %= MOD;

                        (dp[p + c][cs + d * c] += val * cmb) %= MOD;
                    }
                }
            }
        }

        if (!dp[m][t]) return 0;
        
        ll ff = 1;
        for (int d = 0; d < 10; d++) {
            ff = (ff * f[fr[d]]) % MOD;
        }
        
        ll iff = mpow(ff, MOD-2);
        ll ans = dp[m][t];
        ans = (ans * f[m]) % MOD;
        ans = (ans * f[h]) % MOD;
        ans = (ans * iff) % MOD;
        
        return ans;
    }
};",1441366231
ABHAY GUPTA,abhayg_07,153,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<int,3>,vector<array<int,3>>,greater<array<int,3>>> pq;
        pq.push({0,0,0});
        vector<vector<int>> dis(n,vector<int>(m,INT_MAX));
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0] = 0;
        while(!pq.empty()){
            array<int,3> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy] > max( a[0] , moveTime[newx][newy] ) + 1 ){
                    dis[newx][newy] = max( a[0] , moveTime[newx][newy] ) + 1;
                    pq.push({dis[newx][newy],newx,newy});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441306123
ABHAY GUPTA,abhayg_07,153,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        moveTime[0][0] = 0;
        priority_queue<array<long long,4>,vector<array<long long,4>>,greater<array<long long,4>>> pq;
        pq.push({0,0,0,0});
        long long dis[n][m][2];
        for( int i = 0 ; i < n ; i++ ){
            for( int j = 0 ; j < m ; j++ ){
                for( int k = 0 ; k < 2 ; k++ ){
                    dis[i][j][k] = 1e15;
                }
            }
        }
        vector<int> dx = {-1,0,0,1};
        vector<int> dy = {0,-1,1,0};
        dis[0][0][0] = 0;
        while(!pq.empty()){
            array<long long,4> a = pq.top();
            pq.pop();
            if( dis[a[1]][a[2]][a[3]] < a[0] ) continue;
            for( int i = 0 ; i < 4 ; i++ ){
                int newx = a[1] + dx[i] , newy = a[2] + dy[i];
                if( newx < 0 || newx >= n || newy < 0 || newy >= m ) continue;
                if( dis[newx][newy][a[3]^1] > max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1 ){
                    dis[newx][newy][a[3]^1] = max( a[0] , (long long)moveTime[newx][newy] ) + a[3] + 1;
                    pq.push({dis[newx][newy][a[3]^1],newx,newy,a[3]^1});
                }
            }
        }
        return min(dis[n-1][m-1][0],dis[n-1][m-1][1]);
    }
};",1441314055
ABHAY GUPTA,abhayg_07,153,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int e = 0 , o = 0;
        for( int i = 0 ; i < num.size() ; i++ ){
            if(i&1) o += num[i] - '0';
            else e += num[i] - '0';
        }
        return e == o;
    }
};",1441282354
ABHAY GUPTA,abhayg_07,153,3637,cpp,"class Solution {
public:
    const long long mod = 1e9 + 7;
    vector<long long> fact , ifact;

    long long expo(long long a, long long b, long long m)
    {
        long long res = 1;
        while (b > 0)
        {
            if (b & 1)
                res = (res * a) % m;
            a = (a * a) % m;
            b = b >> 1;
        }
        return res % m;
    }

    long long modinv(long long a, long long m) { return expo(a, m - 2, m) % m; } // m is prime

    long long dp[10][162][1500];
    // // center is 750
    int cnt[10];

    void init(long long  n){
        fact.resize(n);
        ifact.resize(n);
        fact[0]=1;
        for( int i = 1 ; i < n ; i++ ) fact[i]=(fact[i-1]%mod*i)%mod;
        ifact[n-1]=modinv(fact[n-1],mod)%mod;
        for(int i=n-2 ; i>=1 ; i--){
            ifact[i]=(ifact[i+1]%mod*(i+1))%mod;
        }
        ifact[0]=1;
    }

    long long recursion( int d , int c , int diff ){
        if( d == -1 && c== 80 && diff == 750 ) return 1;
        else if( d == -1 ) return 0;
        if( dp[d][c][diff] != -1 )return dp[d][c][diff];
        long long ways = 0;
        for( int i = 0 ; i <= cnt[d] ; i++ ){
            // this much d is given to 1
            int newc = c + i - ( cnt[d] - i );
            int newdiff = diff + i * d - ( cnt[d] - i ) * d;
            int D = ( ifact[i]%mod * ifact[cnt[d]-i]%mod )%mod;
            ways = ( ways%mod + ( recursion( d - 1 , newc , newdiff )%mod * D%mod )%mod )%mod;
        }
        return dp[d][c][diff] = ways;
    }

    int countBalancedPermutations(string num) {
        init(10000);
        
        for( int i = 0 ; i < 10 ; i++ ){
            for( int j = 0 ; j < 162 ; j++ ){
                    for( int l = 0 ; l < 1500 ; l++ ){
                        dp[i][j][l] = -1;
                    }
            }
        }
        for( int i = 0 ; i < 10 ; i++ ){
            cnt[i] = 0;
        }
        for( auto i : num ){
            int d = i - '0';
            cnt[d]++;
        }
        int n = num.size();
        long long ways = recursion( 9 , 80 + (n&1) , 750 );
        ways = ( ways * fact[(n+1)/2]%mod )%mod;
        ways = ( ways * fact[n/2]%mod )%mod;
        return ways;
    }
};",1441354161
Yuanbin Cheng,cybsbbbb,154,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[float('inf')] * n for _ in range(m)]
        distance[0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y = heapq.heappop(queue)
            if distance[cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y = cur_x + dx, cur_y + dy
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1, cur_dis + 1)
                    if distance[nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y))

        return distance[-1][-1]

        ",1441303445
Yuanbin Cheng,cybsbbbb,154,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])

        distance = [[[float('inf')] * n for _ in range(m)] for _ in range(2)]
        distance[0][0][0] = 0
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        queue = [(0, 0, 0, 0)]
        while queue:
            cur_dis, cur_x, cur_y, cur_step = heapq.heappop(queue)
            if distance[cur_step][cur_x][cur_y] != cur_dis:
                continue
            for dx, dy in directions:
                nxt_x, nxt_y, nxt_step = cur_x + dx, cur_y + dy, (cur_step + 1) % 2
                if 0 <= nxt_x < m and 0 <= nxt_y < n:
                    nxt_dis = max(moveTime[nxt_x][nxt_y] + 1 + cur_step, cur_dis + 1 + cur_step)
                    if distance[nxt_step][nxt_x][nxt_y] > nxt_dis:
                        distance[nxt_step][nxt_x][nxt_y] = nxt_dis
                        heapq.heappush(queue, (nxt_dis, nxt_x, nxt_y, nxt_step))

        return min(distance[0][-1][-1], distance[1][-1][-1])
        ",1441309705
Yuanbin Cheng,cybsbbbb,154,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        odd = 0
        even = 0
        for i in range(0, n, 2):
            even += int(num[i])
        for i in range(1, n, 2):
            odd += int(num[i])
        return odd == even
        ",1441284061
Yuanbin Cheng,cybsbbbb,154,3637,python3,"MOD = 10 ** 9 + 7
MAXN = 80
fac = [1] * MAXN
inv_fac = [1] * MAXN
for i in range(1, MAXN):
    fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN - 1] = pow(fac[MAXN - 1], -1, MOD)
for i in range(MAXN - 2, -1, -1):
    inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD

def combination(n, k):
    return (fac[n] * inv_fac[k] % MOD) * inv_fac[n - k] % MOD


class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        
        cnt = [0] * 10
        tot = 0
        for i in range(n):
            ni = int(num[i])
            cnt[ni] += 1
            tot += ni
        if tot % 2 == 1:
            return 0

        tot_half = tot // 2
        n_even = n // 2 + n % 2
        n_odd = n // 2

        @cache
        def dp(even_v, odd_v, even_c, odd_c, d):
            if even_c < 0 or odd_c < 0:
                return 0
            
            if d == 0:
                if even_v or odd_v:
                    return 0
                else:
                    return 1
            res = 0
            d_cnt = cnt[d]
            for i in range(d_cnt + 1):
                if even_v < i * d or odd_v < (d_cnt - i) * d:
                    continue
                # print(even_c, odd_c)
                res += comb(even_c, i) * comb(odd_c, d_cnt - i) * dp(even_v - i * d, odd_v - (d_cnt - i) * d, even_c - i, odd_c - (d_cnt - i), d - 1) % MOD
            # print(even_v, odd_v, even_c, odd_c, d, res)
            return res % MOD

        return dp(tot_half, tot_half, n_even, n_odd, 9)
            


        

        
        ",1441360555
Matt,mattagar6,155,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int lo = 0, hi = 1e9 + 1;
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> d(n, vector<int>(m, 1e9+n+m+1000));
        d[0][0] = 0;

        set<tuple<int,int,int>> s;
        s.insert({0,0,0});

        auto go = [&](int r, int c, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;

            int min_time_to_him = moveTime[nr][nc];
            int his_dis = max(dis, min_time_to_him) + 1;
            if(his_dis < d[nr][nc]) {
                s.erase({d[nr][nc], nr, nc});
                d[nr][nc] = his_dis;
                s.insert({d[nr][nc], nr, nc});
            }
            
        };
        
        while(!s.empty()) {
            auto [dis, r, c] = *s.begin();
            s.erase(s.begin());

            for(int dx = -1; dx <= 1; dx++) {
                for(int dy = -1; dy <= 1; dy++) {
                    if(abs(dx) + abs(dy) == 1) {
                        go(r, c, dis, r + dx, c + dy);
                    }
                }
            }
        }
        
        return d[n-1][m-1];
    }
};",1441337323
Matt,mattagar6,155,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2,2e9)));
        d[0][0][0] = 0;
        set<tuple<int,int,int,int>> s;
        s.insert({0,0,0,0});
        // arrive at r, c with parity p
        auto go = [&](int r, int c, int p, int dis, int nr, int nc) {
            if(nr < 0 || nr == n || nc < 0 || nc == m) return;
            // we are going now for sure!
            int starting_time = max(dis, grid[nr][nc]);
            dis=starting_time;
            // go now
            for(int rep = 0; rep < 2; rep++, dis++) {
                int np = (p + 1)%2;
                if( dis + 1 + p % 2 < d[nr][nc][np] ) {
                    s.erase({d[nr][nc][np], nr, nc, np});
                    d[nr][nc][np] = dis + 1 + p % 2;
                    s.insert({d[nr][nc][np], nr, nc, np});
                }
            }
            
            
            // wait, then go
            
        };

        while(!s.empty()) {
            auto [dis, r, c, p] = *s.begin();
            s.erase(s.begin());
            for(int dx = -1; dx <= 1; ++dx) {
                for(int dy = -1; dy <= 1; ++dy) {
                    if(abs(dx)+abs(dy)!=1) continue;
                    go(r, c, p, dis, r + dx, c + dy);
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
    }
};",1441366949
Matt,mattagar6,155,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0, b = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                a += num[i] - '0';
            } else {
                b += num[i] - '0';
            }
        }
        return a == b;
    }
};",1441297104
Matt,mattagar6,155,3637,cpp,"// for each group of digits

// x o o o x x o o  o
// have N at even, M at odd


struct I {
    long long x{};
};

const int MOD = 1000*1000*1000+7;

I operator + (I a, I b) {
    return I{(a.x + b.x) % MOD};
}

I operator * (I a, I b) {
    return I {(a.x * b.x) % MOD};
}

const int N = 100;
const int M = 1000;
I choose[N][N];
I dp[11][N][M];



// number of used even squares, sum on even squares
class Solution {
public:
    int countBalancedPermutations(string num) {
        for(int i = 0; i < N; i++) {
            choose[i][0] = choose[i][i] = I{1};
            for(int j = 1; j < i; j++) {
                choose[i][j] = choose[i-1][j] + choose[i-1][j-1];
            }
        }
        for(int i = 0; i < 11; i++) for(int j = 0; j < N; j++) for(int k = 0; k < M; k++) dp[i][j][k] = I{0};

        map<int,int> count;
        for(char ch : num) count[ch - '0']++;

        int n = num.size();
        dp[0][0][0] = I{1};
        for(int d = 0; d < 10; d++) {
            int to_put = count[d];
            int sum_all = 0;
            int count_all = 0;
            for(char ch : num) {
                if(ch-'0' < d) {
                    sum_all += ch-'0';
                    count_all+=1;
                }
            }
            
            for(int even = 0; even <= (n+1)/2; even++) {
                for(int sum_even = 0; sum_even <= 9*even; sum_even++) {
                    int sum_odd = sum_all - sum_even;
                    if(sum_odd < 0) continue;
                    for(int on_even = 0; on_even <= to_put; on_even++) {
                        if(on_even + even > (n + 1) / 2) continue;
                        if(n/2-(count_all-even)<to_put-on_even) continue;//odd indices

                        dp[d+1][on_even + even][sum_even + d * on_even] =  dp[d+1][on_even + even][sum_even + d * on_even] + dp[d][even][sum_even] * choose[(n+1)/2 - even ][ on_even ] * choose[n/2-(count_all-even)][ to_put - on_even ];
                    }
                }
            }
        }
        //cout << dp[2][1][1].x << '\n'; // digit 1 is done, one even, sum 1 -> 1 x x, x x 1
       // cout << dp[2][0][0].x; // x 1 x
        int sum = 0;
        for(char c : num) sum += c - '0';
        if(sum % 2 == 1) return 0;
        return dp[10][(n+1)/2][sum/2].x;
    }
};",1441329857
harshal_02,harshal_02,156,3627,cpp,"

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});  
        vector<vector<ll>>vec(n,vector<ll>(m, INF));
        vec[0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j = upr.j;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1) {
                return b;
            }
            if (b > vec[i][j]) {
                continue;
            }
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + 1;
                    if (maxi < vec[ii][jj]) {
                        vec[ii][jj] = maxi;
                        pq.push(st{ii, jj, 0, maxi});  
                    }
                }
            }
        }
        return -1;
    }
};
",1441334267
harshal_02,harshal_02,156,3628,cpp,"#include <vector>
#include <queue>
#include <algorithm>

#define ll long long int

class Solution {
public:
    const ll INF = 1e18;

    struct st {
        int i, j, par;
        ll a;
        bool operator<(const st& other) const {
            return a > other.a;
        }
    };

    int minTimeToReach(vector<std::vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        int arr[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        priority_queue<st> pq;
        pq.push(st{0, 0, 0, 0});
        vector<std::vector<std::vector<ll>>> vec(n, std::vector<std::vector<ll>>(m, std::vector<ll>(2, INF)));
        vec[0][0][0] = 0;
        while (!pq.empty()) {
            st upr = pq.top(); 
            pq.pop();
            int i = upr.i;
            int j= upr.j;
            int p= upr.par;
            ll b = upr.a;
            if (i == n - 1 && j == m - 1){
                return b;
        }
            if (b > vec[i][j][p]){
                continue;
    }
        int tot = (p == 0) ? 1 : 2;
            for (auto& d : arr) {
                int ii = i + d[0];
                int jj = j + d[1];    
                if (ii >= 0 && ii < n && jj >= 0 && jj < m) {
                    ll maxi = max(b, (ll)moveTime[ii][jj]) + tot;
                    int np = 1 - p;
                    if (maxi < vec[ii][jj][np]) {
                        vec[ii][jj][np] = maxi;
                        pq.push(st{ii, jj, np, maxi});
                    }
                }
            }
        }
        ll ans=min(vec[n - 1][m - 1][0], vec[n - 1][m - 1][1]);
        return ans;
    }
};
",1441316511
harshal_02,harshal_02,156,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.size();
        int e=0;
        int o=0;
        for(int i=0;i<n;i++) {
            if(i%2==0){
                e+=num[i]-'0';
        }
            else{
                o+=num[i]-'0';
            }
        }
        return e==o;
    }
};",1441317691
harshal_02,harshal_02,156,3637,cpp,"#define ll long long int
const int MOD=1e9+7;
struct Solution {
    ll mathpow(ll base, ll exponent) {
        ll result=1;
        base=base%MOD;
        while(exponent>0) {
            if(exponent&1)
                result=result*base;
            result=result%MOD;
            base=base*base;
            base=base%MOD;
            exponent>>=1;
        }
        return result;
    }
    ll compute_factorial(int n) {
        ll fact=1;
        for(int i=1;i<n+1;i++){
            fact=fact*i;
            fact=fact%MOD;
        }
        return fact;
    }
    ll compute_combination(int n, int k) {
        if(k > n || k < 0) 
            return 0;
        ll comb=1;
        for(int i=1; i<=k; i++) {
            comb=comb*(n-i+1);
            comb=comb%MOD;
            ll inverse=mathpow(i, MOD-2);
            comb=comb*inverse;
            comb=comb%MOD;
        }
        return comb;
    }
    int countBalancedPermutations(string digits) {
        int n=digits.size(), digit_count[10]={0};
        for(char ch:digits) digit_count[ch-'0']++;
        ll sum=0;
        for(int i=0;i<10;i++){
        sum+=(ll)i*digit_count[i];
    }
        if(sum%2!=0) 
        return 0;
        ll target_value=sum/2;
        int half_n=(n+1)/2;
        vector<vector<vector<ll>>>dp(11, vector<vector<ll>>(half_n+1, vector<ll>(target_value+1, 0)));
        dp[0][0][0]=1;
        for(int i=0;i<10;i++) {
            for(int j=0;j<half_n+1;j++) {
                for(int k=0;k<target_value+1;k++) {
                    if(dp[i][j][k]==0) 
                    continue;
                    for(int use=0; use<=digit_count[i] && use+j<=half_n && use*i<=target_value-k; use++) {
                        ll combination=compute_combination(digit_count[i], use);
                        dp[i+1][j+use][k+use*i]=(dp[i+1][j+use][k+use*i]+dp[i][j][k]*combination)%MOD;
                    }
                }
            }
        }
        ll summ=0;
        for(int i=0;i<10;i++){
        summ+=digit_count[i];
        }
        ll target_sum=target_value;
        if(half_n<0 || half_n > n || target_value<0)
         return 0;
        ll cnt=dp[10][half_n][target_value];
        if(cnt==0) 
        return 0;
        ll fact_val=compute_factorial(n);
        ll prod_fact=1;
        for(int i=0;i<10;i++) {
            prod_fact=prod_fact*compute_factorial(digit_count[i]);
            prod_fact=prod_fact%MOD;
        }
        ll factorial_k=compute_factorial(half_n);
        ll factorial_nk=compute_factorial(n-half_n);
        ll inverse_prod_fact=mathpow(prod_fact,MOD-2);
        ll ans=cnt*factorial_k;
        ans=ans%MOD;
        ans=ans*factorial_nk;
        ans=ans%MOD;
        ans=ans*inverse_prod_fact;
        ans=ans%MOD;
        return (int)ans;
    }
};",1441373357
Rajat,log1,157,3627,cpp,"class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        
        vector<vector<long>>dist(n,vector<long>(m,N));
        priority_queue<tuple<long,int,int>,vector<tuple<long,int,int>>,greater<tuple<long,int,int>>>pq;
        
        dist[0][0]=0;
        pq.push(make_tuple(0,0,0));
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[i,j,k]=pq.top();pq.pop();
            if(j==n-1 && k==m-1)
            {
                return i;
            }
            if(dist[j][k]<i)continue;
            for(auto& it:dir)
            {
                int Nx=j+it[0],Ny=k+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long long Nz=max(i,(long)moveTime[Nx][Ny])+1;
                    if(Nz<dist[Nx][Ny])
                    {
                        dist[Nx][Ny]=Nz;
                        pq.push(make_tuple(Nz,Nx,Ny));
                    }
                }
            }
        }
        return-1;
    }
};",1441348101
Rajat,log1,157,3628,cpp,"#include<bits/stdc++.h>
using namespace std;
class Solution{
public:
    int minTimeToReach(vector<vector<int>>&moveTime){
        int n=moveTime.size(),m=moveTime[0].size();
        const long N=1e18;
        vector<vector<vector<long>>>dist(n,vector<vector<long>>(m,vector<long>(2,N)));
        priority_queue<tuple<long,int,int,int>,vector<tuple<long,int,int,int>>,greater<tuple<long,int,int,int>>>pq;
        dist[0][0][0]=0;
        pq.emplace(0,0,0,0);
        vector<array<int,2>>dir={{0,1},{1,0},{0,-1},{-1,0}};
        while(!pq.empty())
        {
            auto[ct,i,j,k]=pq.top();pq.pop();
            if(i==n-1 && j==m-1)
            {
                return(int)ct;
            }
            if(dist[i][j][k]<ct)continue;
            int cost=(k==0)?1:2;
            for(auto& it:dir)
            {
                int Nx=i+it[0],Ny=j+it[1];
                if(Nx>=0 && Nx<n && Ny>=0 && Ny<m)
                {
                    long at=max((long)ct,(long)moveTime[Nx][Ny])+(long)cost;
                    int Nz=1-k;
                    if(at<dist[Nx][Ny][Nz])
                    {
                        dist[Nx][Ny][Nz]=at;
                        pq.emplace(at,Nx,Ny,Nz);
                    }
                }
            }
        }
        return -1;
    }
};",1441310912
Rajat,log1,157,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n=num.length();
        int evenSum=0,oddSum=0;
        for(int i=0;i<n;++i)
        {
            (i&1)?oddSum+=num[i]-'0':evenSum+=num[i]-'0';
        }
        return evenSum==oddSum;
    }
};",1441281609
Rajat,log1,157,3637,cpp,"#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;

ll mod_pow(ll x,ll y)
{
    ll res=1;
    x%=MOD;
    while(y>=1)
    {
        if(y&1)res=res*x%MOD;
        x=x*x%MOD;
        y>>=1;
    }
    return res;
}
class Solution{
public:
    int countBalancedPermutations(string num){
        int n=num.size();
        int dig[10]={0};
        for(int i=0;i<n;++i)
        {
            dig[num[i]-'0']++;
        }
        ll tot=0;
        for(int d=0;d<10;++d)
        {
            tot+=(ll)d*dig[d];
        }
        if(tot%2!=0)
        {
            return 0;
        }
        ll tar=tot/2;
        int k=(n+1)/2;
        vector<vector<vector<ll>>>dp(11,vector<vector<ll>>(k+1,vector<ll>(tar+1,0)));
        dp[0][0][0]=1;
        for(int d=0;d<10;++d)
        {
            for(int c=0;c<=k;++c)
            {
                for(int s=0;s<=tar;++s)
                {
                    if(dp[d][c][s]==0)continue;
                    for(int t=0;t<=dig[d] && t+c<=k && t*d<=tar-s;++t)
                    {
                        ll res=1;
                        for(int i=1;i<=t;++i)
                        {
                            res=res*(dig[d]-i+1)%MOD;
                            ll inv=mod_pow(i,MOD-2);
                            res=res*inv%MOD;
                        }
                        int nxt=d+1,nxtc=c+t,nxts=s+t*d;
                        dp[nxt][nxtc][nxts]=(dp[nxt][nxtc][nxts]+dp[d][c][s]*res)%MOD;
                    }
                }
            }
        }
        if(k<0 || k>n || tar<0)return 0;
        ll ret=dp[10][k][tar];
        if(ret==0)return 0;
        vector<long long>ndp(n+1,1);
        for(int i=1;i<=n;++i)
        {
            ndp[i]=ndp[i-1]*i%MOD;
        }
        ll prod=1;
        for(int d=0;d<10;++d)
        {
            for(int i=1;i<=dig[d];++i)
            {
                prod=prod*i%MOD;
            }
        }
        ll pre1=ndp[k],pre2=ndp[n-k];
        ll prod_inv=mod_pow(prod,MOD-2);
        ll ans=ret*pre1%MOD;
        // for(int i=0;i<ans;++i)
        // {
        //     cout<<ndp[i]<<"" "";
        // }
        // cout<<endl;
        ans=ans*pre2%MOD;
        ans=ans*prod_inv%MOD;
        return(long long)ans;
    }
};",1441332406
chh9976,chh9976,158,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d + 1, moveTime[x-1][y] + 1)
                bfs.add((max(d + 1, moveTime[x-1][y] + 1), (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d + 1, moveTime[x][y-1] + 1)
                bfs.add((max(d + 1, moveTime[x][y-1] + 1), (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d + 1, moveTime[x+1][y] + 1)
                bfs.add((max(d + 1, moveTime[x+1][y] + 1), (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d + 1, moveTime[x][y+1] + 1)
                bfs.add((max(d + 1, moveTime[x][y+1] + 1), (x, y+1)))
                
                ",1441299328
chh9976,chh9976,158,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        bfs = SortedList()
        bfs.add((0, (0, 0)))
        been = defaultdict(lambda: 1e10)
        been[0] = 0
        while bfs:
            d, (x, y) = bfs[0]
            bfs.pop(0)
            if d > been[(x, y)]:
                continue
            if (x, y) == (n-1, m-1):
                return d
            been[(x, y)] = d
            if x and been[(x-1, y)] > max(d + 1, moveTime[x-1][y] + 1):
                if been[(x-1, y)] != 1e10:
                    bfs.remove((been[(x-1, y)], (x-1, y)))
                been[(x-1, y)] = max(d, moveTime[x-1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x-1, y)], (x-1, y)))
            if y and been[(x, y-1)] > max(d + 1, moveTime[x][y-1] + 1):
                if been[(x, y-1)] != 1e10:
                    bfs.remove((been[(x, y-1)], (x, y-1)))
                been[(x, y-1)] = max(d, moveTime[x][y-1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y-1)], (x, y-1)))
            if x != n - 1 and been[(x+1, y)] > max(d + 1, moveTime[x+1][y] + 1):
                if been[(x+1, y)] != 1e10:
                    bfs.remove((been[(x+1, y)], (x+1, y)))
                been[(x+1, y)] = max(d, moveTime[x+1][y]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x+1, y)], (x+1, y)))
            if y != m - 1 and been[(x, y+1)] > max(d + 1, moveTime[x][y+1] + 1):
                if been[(x, y+1)] != 1e10:
                    bfs.remove((been[(x, y+1)], (x, y+1)))
                been[(x, y+1)] = max(d, moveTime[x][y+1]) + 1 + (x-y+15000) % 2
                bfs.add((been[(x, y+1)], (x, y+1)))
                
        ",1441304424
chh9976,chh9976,158,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441280967
chh9976,chh9976,158,3637,cpp,"
void __print(int x) {cout << x;}
void __print(long x) {cout << x;}
void __print(long long x) {cout << x;}
void __print(unsigned x) {cout << x;}
void __print(unsigned long x) {cout << x;}
void __print(unsigned long long x) {cout << x;}
void __print(float x) {cout << x;}
void __print(double x) {cout << x;}
void __print(long double x) {cout << x;}
void __print(char x) {cout << '\'' << x << '\'';}
void __print(const char *x) {cout << '\""' << x << '\""';}
void __print(const string &x) {cout << '\""' << x << '\""';}
void __print(bool x) {cout << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {cout << '{'; __print(x.first); cout << "", ""; __print(x.second); cout << '}';}
template<typename T>
void __print(const T &x) {int f = 0; cout << '{'; for (auto &i: x) cout << (f++ ? "", "" : """"), __print(i); cout << ""}"";}
void _print() {cout << ""]\n"";}
void _println() {}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) cout << "", ""; _print(v...);}
template <typename T, typename... V>
void _println(T t, V... v) {__print(t); if (sizeof...(v)) cout << "" ""; _println(v...);}
#define dbg(x...) cout << ""\e[91m""<<__func__<<"":""<<__LINE__<<"" ["" << #x << ""] = [""; _print(x); cout << ""\e[39m"" << endl;

#define ll long long
#define vc vector
#define ints2 array<int, 2>
#define ints3 array<int, 3>
#define ints4 array<int, 4>
#define ints5 array<int, 5>
#define lls2 array<long long, 2>
#define lls3 array<long long, 3>
#define lls4 array<long long, 4>
#define lls5 array<long long, 5>
#define pb push_back
#define eb emplace_back
#define ppb pop_back
#define all(a) a.begin(), a.end()
#define rall(a) a.rbegin(), a.rend()
#define sz(a) (int(a.size()))
#define trav(b) for(auto& b:b)
#define between(x, n) (((x) < n) && ((x) >= 0))
#define between2(x, n, m) (between(x[0], n) && between(x[1], m))
#define rep(i, a, b) for(int i=(a);i<(b);i++)
#define per(i, a, b) for(int i=(a);i>(b);i--)
#define coutf(a) cout<<a<<endl; cout.flush();
#define inf 2000000000
#define infll 4000000000000000000ll
#define ee9 1000000000
#define ee18 1000000000000000000ll
#define mod17 1000000007
#define mod99 998244353
#define vcint vc<int>
#define vcll vc<ll>
#define popcount __builtin_popcount
#define SUM(a) (accumulate(all(a), 0ll))
#define MAX(a) (*max_element(all(a)))
#define MIN(a) (*min_element(all(a)))
#define SORT(a) sort(all(a))
#define UNIQ(a) a.erase(unique(all(a)), a.end())
#define ERASE(a, b) a.erase(a.find(b))
#define INSERT(a, b) a.insert(b)
#define ZERO(a) fill(all(a), 0);
#define ZERO2(a) trav(a) fill(all(a), 0);
#define INT(a) int a; cin>>a;
#define INT2(a, b) int a, b; cin>>a>>b;
#define INT3(a, b, c) int a, b, c; cin>>a>>b>>c;  
#define INT4(a, b, c, d) int a, b, c, d; cin>>a>>b>>c>>d;
#define LL(a) ll a; cin>>a;
#define LL2(a, b) ll a, b; cin>>a>>b;
#define LL3(a, b, c) ll a, b, c; cin>>a>>b>>c;
#define LL4(a, b, c, d) ll a, b, c, d; cin>>a>>b>>c>>d;
#define STR(a) string a; cin>>a;
#define VEC(a, n) vc<int> a(n); cin>>a;
#define VEC1(a, n) vc<int> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VECLL(a, n) vc<ll> a(n); cin>>a;
#define VECLL1(a, n) vc<ll> a(n); rep(i, 0, n) cin>>a[i], a[i]--;
#define VV(type, a, n, m) vc<vc<type>> a(n, vc<type>(m)); trav(a) cin>>a;
#define ADJ(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); adj[a].pb(b); adj[b].pb(a);}
#define ADJ1(adj, n, m)  vc<vc<int>> adj(n+1); rep(i, 0, m) {auto [a, b] = getints<2>(); a--, b--; adj[a].pb(b); adj[b].pb(a);}
#define ADJW(adj, n, m) vc<vc<ints2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getints<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJW1(adj, n, m) vc<vc<pair<int, int>>> adj(n+1); rep(i, 0, m) {int a, b, c; cin>>a>>b>>c; a--, b--; adj[a].pb(make_pair(b, c)); adj[b].pb(make_pair(a, c));}
#define ADJWLL(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); adj[a].pb({b, c}); adj[b].pb({a, c});}
#define ADJWLL1(adj, n, m) vc<vc<lls2>> adj(n+1); rep(i, 0, m) {auto [a, b, c] = getlls<3>(); a--, b--; adj[a].pb({b, c}); adj[b].pb({a, c});}
#define chmin(a, b) a = min(a, b)
#define trav2dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]; sajdklf < 2; sajdklf++, di = i + _2dirs[sajdklf][0], dj = j + _2dirs[sajdklf][1]) if(between(di, n) && between(dj, m))
#define trav4dir(di, dj, i, j, n, m) for(int sajdklf = 0, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]; sajdklf < 4; sajdklf++, di = i + _4dirs[sajdklf][0], dj = j + _4dirs[sajdklf][1]) if(between(di, n) && between(dj, m))


template<int MOD>
struct mint {
  unsigned x;
  mint() : x(0) { }
  mint(signed sig) : x(((sig)%MOD+MOD)%MOD) {}
  mint(signed long long sig) : x(((sig)%MOD+MOD)%MOD) { }
  int get() const { return (int)x; }
  mint pow(ll p) { mint res = 1, a = *this; while (p) { if (p & 1) res *= a; a *= a; p >>= 1; } return res; }
 
  mint &operator+=(mint that) { if ((x += that.x) >= MOD) x -= MOD; return *this; }
  mint &operator-=(mint that) { if ((x += MOD - that.x) >= MOD) x -= MOD; return *this; }
  mint &operator*=(mint that) { x = (unsigned long long)x * that.x % MOD; return *this; }
  mint &operator/=(mint that) { return (*this) *= that.pow(MOD - 2); }
 
  mint operator+(mint that) const { return mint(*this) += that; }
  mint operator-(mint that) const { return mint(*this) -= that; }
  mint operator*(mint that) const { return mint(*this) *= that; }
  mint operator/(mint that) const { return mint(*this) /= that; }
  bool operator<(mint that) const { return x < that.x; }
  
  friend mint operator+(int lhs, mint rhs) {return rhs + lhs;}
  friend mint operator-(int lhs, mint rhs) {return mint(lhs) - rhs;}
  friend mint operator*(int lhs, mint rhs) {return rhs * lhs;}
  friend mint operator/(int lhs, mint rhs) {return mint(lhs) / rhs;}

  friend ostream& operator<<(ostream &os, mint a) { os << a.x; return os; }
};
typedef mint<1000000007> mint17;
typedef mint<998244353> mint99;
vc<mint17> fact(1, 1), ifact(1, 1);
mint17 C(int a, int b){
    return fact[a] * ifact[b] * ifact[a-b];
}
class Solution {
public:
    int countBalancedPermutations(string num) {
        if(fact.size() == 1){
            rep(i, 1, 170) fact.pb(fact.back() * i), ifact.pb(ifact.back() / i);
        }
        int n = num.size();
        map<int, int> cnter;
        for(auto c:num) cnter[c-48]++;
        
        int su = 0;
        for(auto [k, v]:cnter) su += k * v;
        if(su % 2 == 1) return 0;
        int tar = su / 2;
        
        vc dp((1+n) / 2 + 1, vc<mint17>(tar+1)); dp[0][0] = 1;
        int nowcnt = 0;
        for(auto [k, v]:cnter){
            vc ndp((1+n) / 2 + 1, vc<mint17>(tar+1));
            rep(i, 0, v+1){
                rep(j, 0, tar+1) if(i * k + j <= tar) {
                    rep(kk, 0, nowcnt+1) if(i + kk <= (1+n) / 2){
                        ndp[i + kk][i * k + j] += C(i + kk, i) * C(nowcnt - kk + v - i, v - i) * dp[kk][j];
                    }
                }
            }
            nowcnt += v;
            dp = move(ndp);
        }
        return dp[(1+n)/2][tar].x;
        
    }
};",1441361211
colicon,colicon,159,3627,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[2e9]*m for _ in range(n)]
        d[0][0] = 0
        
        h = [(0, 0, 0)]
        while h:
            cd, i, j = heappop(h)

            if d[i][j] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + 1
    
                    if d[ni][nj] > nd:
                        d[ni][nj] = nd
                        heappush(h, (nd, ni, nj))

        return d[-1][-1]
            ",1441297539
colicon,colicon,159,3628,python3,"dx = [0, -1, 0, 1]
dy = [-1, 0, 1, 0]

class Solution:
    
    def minTimeToReach(self, a: List[List[int]]) -> int:
        n = len(a)
        m = len(a[0])
        
        d = [[[2e9]*2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        w = [1, 2]
        
        h = [(0, 0, 0, 0)]
        while h:
            cd, t, i, j = heappop(h)

            if d[i][j][t] != cd:
                continue
            
            for k in range(4):
                ni = i + dx[k]
                nj = j + dy[k]

                if 0 <= ni < n and 0 <= nj < m:
                    nd = max(cd, a[ni][nj]) + w[t]
    
                    if d[ni][nj][t^1] > nd:
                        d[ni][nj][t^1] = nd
                        heappush(h, (nd, t^1, ni, nj))

        return min(d[-1][-1])
            
",1441301085
colicon,colicon,159,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        b = 0

        for i, x in enumerate(num):
            if i&1:
                a += int(x)
            else:
                b += int(x)

        return a == b",1441282279
colicon,colicon,159,3637,python3,"mod = 10**9 + 7

fac = [1] * 100
for i in range(2, 100):
    fac[i] = fac[i-1] * i % mod
ifac = [0] * 100
ifac[99] = pow(fac[99], -1, mod)
for i in range(98, -1, -1):
    ifac[i] = ifac[i+1] * (i+1) % mod

def choose(n, k):
    return fac[n] * ifac[k] % mod * ifac[n-k] % mod

class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        n = len(num)

        cnt = [0] * 11
        for x in num:
            cnt[int(x)] += 1

        tot_sum = [0] * 11
        for i in range(10):
            tot_sum[i] = tot_sum[i-1] + cnt[i] * i

        tot_cnt = [0] * 11
        for i in range(10):
            tot_cnt[i] = tot_cnt[i-1] + cnt[i]

        if tot_sum[-2] & 1:
            return 0
        
        dp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]
        dp[0][0] = 1
        for d in range(10):
            for i in range(min(n//2, tot_cnt[d-1])+1):
                for j in range(tot_sum[d-1]+1):
                    for k in range(min(n//2-i, cnt[d])+1):
                        if j + k*d > tot_sum[-2]//2:
                            break
                        ri = tot_cnt[d-1] - i
                        rk = cnt[d] - k

                        ndp[i + k][j + k*d] += dp[i][j] * choose(i+k, k) % mod * choose(ri+rk, rk) % mod
                        ndp[i + k][j + k*d] %= mod
            dp = ndp
            ndp = [[0]*(tot_sum[-2]//2+1) for _ in range(n//2+1)]

        return dp[n//2][tot_sum[-2]//2]
                
            
            ",1441348954
Pranav Raj,ThunderXGod,162,3627,cpp,"#define pii pair<int, int>
vector<vector<int>> d = {{-1,0}, {1, 0}, {0, -1}, {0, 1}};
int zz;
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        
        vector<vector<long long>> a(n, vector<long long>(m, 2e18));
        
        priority_queue<pair<long long,pii>, vector<pair<long long,pii>>, greater<pair<long long,pii>>> pq;
        
        a[0][0] = 0;
        pii p = {0, 0};
        pq.push({0, p});
        long long cur = 0, tm = 0;
        while((int)pq.size()) 
        {
            auto c = pq.top();
            cur += c.first;
            int i = c.second.first, j = c.second.second;
            pq.pop();
            
            if(i == n - 1 && !zz && j == m - 1) 
            {
                int ans = cur;
                return ans;
            }
            long long st;
            if(cur <= a[i][j])
            {
                st -= st;
                st += max(1ll*cur, 1ll*moveTime[i][j]);
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = j;
                    ni += dir[0];
                    nj += dir[1];

                    if (ni > -1 && !zz && ni <= n - 1 && !zz && nj > -1 && !zz && nj <= m - 1) 
                    {
                        long long mt, at = -1;
                        mt = st;
                        at++;
                        tm += max(1ll*cur, 1ll*moveTime[ni][nj]);
                        at -= at;
                        at += tm;
                        
                        //at += max(mt, 1ll*moveTime[ni][nj]);
                        
                        if (at + 1 < a[ni][nj]) 
                        {
                            a[ni][nj] = at + 1;
                            p.first = ni;
                            p.second = nj;
                            pq.push({at + 1, p});
                        }
                        tm -= tm;
                    }
                }
            }
            cur -= cur;
        }
        
        return -1;
    }
};",1441307299
Pranav Raj,ThunderXGod,162,3628,cpp,"vector<vector<int>> d = {{-1,0}, {1,0}, {0,-1}, {0,1}};
#define vll vector<long long>
int zz;
#define liii long long, int, int, int
class Solution {
public:
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = (int)moveTime.size();
        m = (int)moveTime[0].size();
        vector<vector<vll>> a(n, vector<vll>(m, vll(2, 2e18)));
        priority_queue<tuple<liii>, vector<tuple<liii>>, greater<tuple<liii>>> pq;
        a[0][0][0] -= a[0][0][0];
        pq.push({0, 0, zz, 0});
        long long c = zz, tm = 0, at = 0;
        while((int)pq.size()) 
        {
            auto cur = pq.top();
            int i = get<1>(cur), j = 0, p = -1;
            j += get<2>(cur);
            c += get<0> (cur);
            
            pq.pop();
            
            if(i+1==n&&j+1==m) 
            {
                int ans = c;
                return ans;
            }
             
            p += get<3>(cur);
            if(c <= a[i][j][p+1]) 
            {  
                int dr = 2;
                if(!(p+1))
                    dr--;
                for(vector<int> dir: d) 
                {
                    int ni = i, nj = i + j;
                    ni+= dir[0];
                    nj += dir[1];
                    nj -= i;
        
                    if(ni > -1 && !zz&& ni <= n - 1 && !zz&& nj > -1 && nj <= m - 1) 
                    {
                        at += 1ll*dr;
                        if(!zz)
                        tm += max(1ll*c, 1ll*moveTime[ni][nj]);
                        at += tm;
                        int np = 1;
                        np-= (p+1);

                        if(at+zz < a[ni][nj][np]) 
                        {
                            a[ni][nj][np] = at;
                            if(!zz)
                            pq.push({at, ni, nj, np});
                        }
                        tm -= tm;
                        at -= at;
                    }
                }
            }
            c-=c;
        }
        
        return -1;
    }
};
",1441331247
Pranav Raj,ThunderXGod,162,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int l = 0, r = 0;
        for(int i = 0; i < (int)num.size(); i++)
        {
            if(i&1)
                l += (num[i]-'0');
            else
                r += (num[i]-'0');
        }
        return (l==r);
    }
};",1441281650
Pranav Raj,ThunderXGod,162,3637,cpp,"#define ll long long
const int M = 1e9 + 7;
ll f1(ll x, ll y, ll mv) 
{
    ll r = 1;
    x %= mv;
    while(y>=1)
    {
        if(y&1)
        {
            r*=x;
            r%=mv;
        }
        x*=x;
        x%=mv;
        y >>= 1;
    }
    return r;
}
struct Factorials 
{
    vector<ll> fc,ifc;
    Factorials(int mn, int mv)
    {
        int sz = 1;
        sz += mn;
        fc.resize(sz, 1);
        ifc=fc;
        int i = 1;
        while(i < mn + 1)
        {
            fc[i]=fc[i-1];
            fc[i]*=i;
            fc[i]%=mv;
            i++;
        }
        ifc[mn] = f1(fc[mn], mv -2, mv);
        i = -1;
        i += mn;
        while(i > -1)
        {
            ifc[i] = ifc[i+1];
            ifc[i]*=(1+i);
            ifc[i]%=mv;
            i--;
        }
    }
    ll f2(int n, int k)
    {
        if(k > n)
            return 0;
        if(k <= -1)
            return 0;
        ll ans = fc[n];
        ans *= ifc[k];
        ans %= M;
        ans *= ifc[-k+n];
        return (ans%M);
    }
};

class Solution {
public:
    int n;
    int countBalancedPermutations(string &num) 
    {
        n = (int)num.size();
        int dc[10];
        memset(dc, 0, sizeof(dc));
        ll s =0;
        for(char ch: num)
        {
            int vv=(int)(ch-'0');
            dc[vv]++;
            s+=(vv);
        }
        if(s&1) 
            return 0;
        ll ts = s;
        ts >>= 1;
        int m = 1,p=2*n,d=0,cnt = 1;
        m+=n;
        m>>=1;
        p>>=2;
        int sz = 1;
        sz += ts;
        Factorials f(n, M);
        vector<ll> vec(sz, 0);
        vector<vector<ll>> dp(m +1, vec);
        dp[0][0]++;
        while(d<10)
        {
            vector<vector<ll>> dp2 = dp;
            while(cnt < dc[d]+1)
            {
                int k = m;
                while(1)
                {
                    if(k < cnt)
                        break;
                    int s = 0;
                    s += ts;
                    while(1)
                    {
                        if(s < cnt*d)
                            break;
                        int kk = -d*cnt;
                        kk += s;
                        ll val = dp[-cnt+k][kk];
                        val*=1ll*f.f2(dc[d],cnt);
                        dp2[k][s] += val;
                        dp2[k][s] %= M;
                        s--;
                    }
                    k--;
                }
                cnt++;
            }
            cnt = 1;
            d++;
            dp = dp2;
        }
        d-=d;
        ll dm =1;
        while(d < 10)
        {
            dm *= f.fc[dc[d]];
            dm %= M;
            d++;
        }
        ll fm = 0, fp = 0;
        fm+=f.fc[m];
        fp+=f.fc[p];
        ll ans = dp[m][ts];
        ans *= fm;
        ans%=M;
        ans*=fp;
        ans%=M;
        ans*=f1(dm, M -2, M);
        ans%=M;
        int fans = ans;
        return fans;
    }
};",1441369307
TheRaven,TheRaven,163,3627,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?1:0]) {
                    PQ.add(new Pair(i2,j2,Math.max(p.d+1,moveTime[i2][j2]+1), p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441314301
TheRaven,TheRaven,163,3628,java,"class Solution {
    int [] dx = {0, -1, 0, 1};
    int [] dy = {-1, 0, 1, 0};
    public int minTimeToReach(int[][] moveTime) {
        
        PriorityQueue<Pair> PQ = new PriorityQueue<Pair>();
        PQ.add(new Pair(0,0,0,true));
        
        int goali = moveTime.length-1;
        int goalj = moveTime[0].length-1;
        boolean [][][] vis = new boolean [moveTime.length][moveTime[0].length][2];
        
        while (!PQ.isEmpty()) {
            Pair p = PQ.poll();
            //System.out.println(""@ "" + p.i + "" , "" + p.j + "" w/ depth = "" + p.d);
            if (p.i == goali && p.j == goalj) return p.d;
            if (vis[p.i][p.j][p.parity?1:0]) continue;
            vis[p.i][p.j][p.parity?1:0] = true;
            
            for (int k = 0; k<dx.length; ++k) {
                int i2 = p.i + dx[k];
                int j2 = p.j + dy[k];
                if (i2 >= 0 && j2 >= 0 && i2 < vis.length && j2 < vis[0].length && !vis[i2][j2][p.parity?0:1]) {
                    int d2 = (p.parity) ? 1 : 2;
                    PQ.add(new Pair(i2,j2,Math.max(p.d+d2,moveTime[i2][j2]+d2), !p.parity));
                }
            }
            
        }
        return -1;
    }
    static class Pair implements Comparable<Pair>{
        int i,j,d;
        boolean parity;
        
        public Pair (int ii, int jj, int dd, boolean p) {
            i = ii;j=jj;d=dd;
            this.parity = p;
        }
        public int compareTo(Pair p) {
            return d - p.d;
        }
    }
}",1441319121
TheRaven,TheRaven,163,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int eSum = 0;
        int oSum = 0;
        char [] S = num.toCharArray();
        for (int i = 0; i<S.length; ++i) {
            if (i % 2 == 0) eSum += S[i]-'0';
            else oSum += S[i]-'0';
        }
        return eSum == oSum;
        
    }
}",1441284618
TheRaven,TheRaven,163,3637,java,"class Solution {
    long [][][] dp;
    long MOD = 1000000007L;
    int [] cnt;
    long [][] choose = new long [82][82];
    int numtot;
    public int countBalancedPermutations(String num) {
        choose[0][0] = 1;
        for (int i = 1; i<choose.length; ++i) {
            choose[i][0] = choose[i-1][0];
            for (int j = 1; j<=i; ++j) {
                choose[i][j] = (choose[i-1][j] + choose[i-1][j-1]) % MOD;   
            }
        }
        //System.out.println(choose[30][30]);
        
        int sum = 0;
        cnt = new int [10];
        char [] N = num.toCharArray();
        int numtot = N.length;
        for (char c : N) cnt[c-'0']++;
        for (int i = 1; i<=9; ++i) sum += cnt[i]*i;
        if (sum % 2 == 1) return 0;
        if (sum == 0) return 1;
        
        dp = new long [10][sum/2+1][N.length/2+1];
        for (int i = 0; i<10; ++i) for (int j = 0; j<dp[0].length; ++j) Arrays.fill(dp[i][j], -1);
        int goal = sum/2;
        
        long ans = recurse(0, sum/2, N.length/2, N.length - N.length/2);
            
        return (int)(ans % MOD);
    }
    public long recurse(int dig, int goalsum, int numleft, int numother) {
        if (numleft == 0 && goalsum == 0 && numother == 0) return 1;
        if (dig > 9) return 0;
        if (goalsum == 0 && numleft > 0 && dig != 0) return 0;
        if (numother < 0) return 0;
        
        if (dp[dig][goalsum][numleft] == -1) {
            int lim = Math.min(numleft, cnt[dig]);
            long ans = 0;
            for (int i = 0,g=goalsum,j=cnt[dig]; i<=lim && g>=0 && j>=0; ++i,--j,g-=dig) {
                long tmp = recurse(dig+1, g, numleft-i, numother - j);
                tmp *= choose[numleft][i];
                tmp %= MOD;
                tmp *= choose[numother][j];
                ans += (tmp % MOD);
            }
            ans %= MOD;
            dp[dig][goalsum][numleft] = ans;
            //System.out.println(""dig = "" + dig + "" goalsum = "" + goalsum + "" numleft = "" + numleft + "" ans = "" + ans);
        }
        return dp[dig][goalsum][numleft];
    }
}",1441363064
Decision,Decision,165,3627,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[1][m][n];
        for(int i=0;i<1;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = 0;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375984
Decision,Decision,165,3628,java,"class Solution {
    final static int[][] dir = {{-1,0}, {1,0}, {0,-1}, {0,1}};
    public int minTimeToReach(int[][] mt) {
        final int m = mt.length, n = mt[0].length;
        final int[][][] dist = new int[2][m][n];
        for(int i=0;i<2;++i){
            for(int j=0;j<m;++j){
                Arrays.fill(dist[i][j], -1);
            }
        }
        final PriorityQueue<Node> que = new PriorityQueue<>();
        que.offer(new Node(0, 0, 0, 0));
        dist[0][0][0] = 0;
        while(!que.isEmpty()){
            final Node nd = que.poll();
            if(nd.d > dist[nd.st][nd.x][nd.y]){
                continue;
            }
            final int st2 = (nd.st + 1) % 2;
            for(int[] d : dir){
                int a = nd.x + d[0], b = nd.y + d[1];
                if(a < m && a >= 0 && b < n && b >= 0){
                    final int v = Math.max(mt[a][b], nd.d) + nd.st + 1;
                    if(dist[st2][a][b] < 0 || dist[st2][a][b] > v){
                        dist[st2][a][b] = v;
                        que.offer(new Node(st2, a, b, v));
                    }
                }
            }
        }
        int res = dist[0][m-1][n-1];
        if(dist[1][m-1][n-1] >= 0 && (res < 0 || res > dist[1][m-1][n-1])){
            res = dist[1][m-1][n-1];
        }
        return res;
    }
}
class Node implements Comparable<Node>{
    int st;
    int x;
    int y;
    int d;
    public Node(int a, int b, int c, int k){
        st = a;
        x = b;
        y = c;
        d = k;
    }
    public int compareTo(Node nd){
        return this.d - nd.d;
    }
}",1441375746
Decision,Decision,165,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int odd = 0, even = 0, k = 0;
        for(char ch : num.toCharArray()){
            if(k == 0){
                odd += ch - '0';
            }else{
                even += ch - '0';
            }
            k = (k+1) % 2;
        }
        return odd == even;
    }
}",1441376163
Decision,Decision,165,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        final int n = num.length(), m = 10, odd = (n+1) / 2, k = odd * (m - 1), MODE = 1000000007;
        final int even = n - odd;
        final int[] cs = new int[m];
        int sum = 0;
        long[][] dp = new long[odd+1][k+1], comb = new long[n+1][n+1];
        dp[0][0] = 1L;
        for(char ch : num.toCharArray()){
            cs[ch-'0']++;
            sum += ch - '0';
        }
        comb[0][0] = 1L;
        for(int i=1;i<=n;++i){
            comb[i][0] = comb[i][i] = 1L;
            for(int j=1;j<i;++j){
                comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % MODE;
            }
        }
        for(int i=0,cnt=0;i<m;++i){
            long[][] dp2 = new long[odd+1][k+1];
            for(int a=0;a<=cnt && a<=odd;++a){
                for(int b=0;b<=k;++b){
                    if(dp[a][b] > 0){
                        for(int c=0;c<=cs[i];++c){
                            if(c + a <= odd && cs[i]-c+(cnt-a) <= even){
                                dp2[c+a][b+i*c] += (comb[odd-a][c] * comb[even-(cnt-a)][cs[i]-c]) % MODE * dp[a][b];
                                dp2[c+a][b+i*c] = dp2[c+a][b+i*c] % MODE;
                            }
                        }
                    }
                }
            }
            cnt += cs[i];
            dp = dp2;
        }
        long res = 0;
        for(int i=0;i<=k;++i){
            if(sum-i == i){
                res = (res + dp[odd][i]) % MODE;
            }
        }
        return (int)res;
    }
}",1441375516
Piyush Kumar,kumarfeldspar,166,3627,cpp,"#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll, ll>, null_type, less<pair<ll, ll>>, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F first
#define S second
#define __builtin_popcount __builtin_popcountll
#define vvi vector<vector<int>>
#define ld long double
#define pb push_back
#define mp make_pair
#define precision(i) cout << fixed << setprecision(i)
#define vpii vector<pair<int, int>>
#define pii pair<int, int>
#define vi vector<int>
#define stoi stoll
#define all(x) x.begin(), x.end()
#define mii map<int, int>
#define pqb priority_queue<int>
#define sz(a) (ll) a.size()
#define fastio                        \
    ios_base::sync_with_stdio(false); \
    cin.tie(NULL);                    \
    cout.tie(NULL);
#define pqs priority_queue<int, vi, greater<int>>
#define rsort(a) sort(a.rbegin(), a.rend())
#define get_sum(a) accumulate(a.begin(), a.end(), 0LL)
#define get_max(a) *max_element(a.begin(), a.end())
#define get_min(a) *min_element(a.begin(), a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG);
long long rnd(long long x, long long y)
{
    return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout << x << nl
#define inf 1e18
#define ld long double
#define w(t)  \
    int t;    \
    cin >> t; \
    while (t--)
#define in(k) \
    int k;    \
    cin >> k;
#define f(i, x) for (int i = 0; i < x; i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i, a, b) for (int i = a; i < b; i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x << endl
#define dbg2(x, y) cout << #x << "" "" << x << "" "" << #y << "" "" << y << endl
#define dbg3(x, y, z) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << endl
#define dbg4(x, y, z, w) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << endl
#define dbg5(x, y, z, w, a) cout << #x << "" "" << x << "" "" << #y << "" "" << y << "" "" << #z << "" "" << z << "" "" #w << "" "" << w << "" "" << #a << "" "" << a << endl
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)         \
    cout << #x << "" => ""; \
    _print1(x);           \
    cout << ""\n"";
void _print(ll t) { cerr << t; }
void _print(int t) { cerr << t; }
void _print(string t) { cerr << t; }
void _print(char t) { cerr << t; }
void _print(ld t) { cerr << t; }
void _print(double t) { cerr << t; }
template <class T, class V>
void _print(pair<T, V> p);
template <class T>
void _print(vector<T> v);
template <class T>
void _print(set<T> v);
template <class T, class V>
void _print(map<T, V> v);
template <class T>
void _print(multiset<T> v);
template <class T, class V>
void _print(pair<T, V> p)
{
    cerr << ""{"";
    _print(p.first);
    cerr << "","";
    _print(p.second);
    cerr << ""}"";
}
template <class T>
void _print(vector<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(set<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T>
void _print(multiset<T> v)
{
    cerr << ""[ "";
    for (T i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
template <class T, class V>
void _print(map<T, V> v)
{
    cerr << ""[ "";
    for (auto i : v)
    {
        _print(i);
        cerr << "" "";
    }
    cerr << ""]"";
}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
    // shows from left
    string res;
    while (x > 0)
    {
        if (x % 2 == 0)
            res += '0';
        else
            res += '1';
        x /= 2;
    }
    reverse(all(res));
    return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX; j += i)
            {
                if (spf[j] == j)
                    spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m)
{
    a %= m;
    ll res = 1;
    while (b > 0)
    {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n, ll r)
{
    if (n < r)
        return 0;
    if (r > n - r)
        r = n - r;
    ll ans = 1;
    ll i;
    for (i = 1; i <= r; i++)
    {
        ans *= n - r + i;
        ans /= i;
    }
    return ans;
}
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lcm(ll a, ll b) { return a / __gcd(a, b) * b; }
ll MI(ll a, ll m) { return bpow(a, m - 2, m); }
void meta(int x) { cout << ""Case #"" << x << "": ""; }

class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size();
        int m = tm[0].size();
        vector<vector<ll>> dist(n, vector<ll>(m, 1e18));
        priority_queue<pair<ll, pair<int, int>>, vector<pair<long long, pair<int, int>>>, greater<pair<long long, pair<int, int>>>> pq;
        dist[0][0] = 0;
        pq.push({0, {0, 0}});
        int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.empty())
        {
            auto current = pq.top();
            pq.pop();
            long long t = current.F;
            int i = current.second.F;
            int j = current.second.S;
            if (i == n - 1 && j == m - 1)
                return t;
            if (t > dist[i][j])
                continue;
            f(k,4)
            {
                int ni = i + dx[k];
                int nj = j + dy[k];
                if (ni >= 0 && ni < n && nj >= 0 && nj < m)
                {
                    long long nt = max(t, (long long)tm[ni][nj]) + 1;
                    if (nt < dist[ni][nj])
                    {
                        dist[ni][nj] = nt;
                        pq.push({nt, {ni, nj}});
                    }
                }
            }
        }
        return -1;
    }
};",1441296485
Piyush Kumar,kumarfeldspar,166,3628,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define unewxq(s) s.resize(unewxque(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
// long long rnd(long long x, long long y)
// {
// return unewxform_int_distribution<long long>(x, y)(RNG);
// }
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
#define MAX 500007
vector<int> primes;
bool isprime[MAX];
int spf[MAX];
void sieve()
{
    f(i, MAX) spf[i] = i;
    for (ll i = 2; i < MAX ; i++)
    {
        if (spf[i] == i)
        {
            for (ll j = i * i; j < MAX ; j += i)
            {
            if(spf[j]==j)	
                spf[j] = i;
            }
        }
    }
    f(i, MAX) isprime[i] = true;
    isprime[1] = false;
    for (ll i = 2; i < MAX ; i++)
    {
        if (isprime[i])
        {
            for (ll j = i * i; j < MAX ; j += i)
                isprime[j] = false;
        }
    }

    // for (ll p = 2; p < MAX; p++)
    // 	if (isprime[p])
    // 		primes.push_back(p);
}
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
// #define int long long int
#define mod             1000000007
const int N = 4e5 + 5;


class Solution
{
public:
    int minTimeToReach(vector<vector<int>> &tm)
    {
        int n = tm.size(), m = tm[0].size();
        vector<vector<ll>> d0(n, vector<long long>(m, 1e18));
        vector<vector<ll>> d1(n, vector<long long>(m, 1e18));
        d0[0][0] = 0;
        priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty())
        {
            auto [t, i, j, p] = pq.top();
            pq.pop();

            if (i == n - 1 && j == m - 1)
                return t;

            if ((p == 0 && t > d0[i][j]) || (p == 1 && t > d1[i][j]))
                continue;

            f(k,4)
            {
                int newx = i + dx[k], newy = j + dy[k];

                if (newx >= 0 && newx < n && newy >= 0 && newy < m)
                {
                    long long temp = 2;
                    if(p==0)temp=1;
                    long long nt = max(t, (long long)tm[newx][newy]) + temp;
                    int np = 1 - p;

                    if (np == 0)
                    {
                        if (nt < d0[newx][newy])
                        {
                            d0[newx][newy] = nt;
                            // cout<<nt<<"" ""<<newx<<"" ""<<newy<<"" ""<<np<<endl;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                    else
                    {
                        if (nt < d1[newx][newy])
                        {
                            d1[newx][newy] = nt;
                            pq.push({nt, newx, newy, np});
                        }
                    }
                }
            }
        }

        return -1;
    }
};
",1441302838
Piyush Kumar,kumarfeldspar,166,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            } else {
                oddSum += num[i] - '0';
            }
        }
        
        return evenSum == oddSum;
    }
};",1441286993
Piyush Kumar,kumarfeldspar,166,3637,cpp,"#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
 using namespace std;
using namespace __gnu_pbds;
#define ll              long long
typedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;
typedef tree<ll, null_type, less_equal<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_multiset;
typedef tree<pair<ll,ll>, null_type, less<pair<ll,ll> >, rb_tree_tag, tree_order_statistics_node_update> ordered_pair_set;
/*==============================================MACROS=================================================*/
#define forder(x) find_by_order(x)
#define okey(x) order_of_key(x)
#define sqrt sqrtl
#define pok(ok) (ok) ? cout << ""YES"" << nl : cout << ""NO"" << nl;
#define nl '\n'
#define F              first
#define S              second
#define __builtin_popcount   __builtin_popcountll
#define vvi vector<vector<int>>
#define ld              long double
#define pb              push_back
#define mp              make_pair
#define precision(i) cout<<fixed<<setprecision(i)
#define vpii vector<pair<int,int>> 
#define pii             pair<int,int>
#define vi              vector<int>
#define stoi            stoll
#define all(x)     x.begin(), x.end()
#define mii             map<int,int>
#define pqb             priority_queue<int>
#define sz(a)      (ll)a.size()
#define fastio ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define pqs             priority_queue<int,vi,greater<int> >
#define rsort(a) sort(a.rbegin(),a.rend())
#define get_sum(a) accumulate(a.begin(),a.end(),0LL)
#define get_max(a) *max_element(a.begin(),a.end())
#define get_min(a) *min_element(a.begin(),a.end())
#define uniq(s) s.resize(unique(s.begin(), s.end()) - s.begin())
#define setbits(x) __builtin_popcountll(x)
mt19937 RNG(chrono::steady_clock::now().time_since_epoch().count());
#define SHUF(v) shuffle(all(v), RNG); 
long long rnd(long long x, long long y)
{
return uniform_int_distribution<long long>(x, y)(RNG);
}
// Use mt19937_64 for 64 bit random numbers
#define print(x) cout<<x<<nl
#define inf             1e18
#define ld              long double
#define w(t)            int t; cin>>t; while(t--)
#define in(k)           int k;cin>>k;
#define f(i,x)          for(int i=0;i<x;i++)
#define bfor(i, a, b) for (int i = a; i >= b; i--)
#define rep(i,a,b)      for(int i=a;i<b;i++)
#define trav(a, x) for (auto &a : x)
/*===============================================DEBUG===================================================*/
#define dbg1(x) cout << #x << "" "" << x<<endl 
#define dbg2(x,y) cout << #x << "" "" << x << "" ""  << #y << "" "" << y<<endl 
#define dbg3(x, y, z) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<<endl 
#define dbg4(x, y, z,w) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<endl 
#define dbg5(x, y, z,w,a) cout << #x << "" "" << x << "" ""  << #y << "" "" << y << "" ""  << #z << "" "" << z<< "" "" #w << "" "" << w<<"" ""  << #a << "" "" << a<<endl 
template <typename T>
void _print1(T i) { cout << i; };
template <typename x, typename... y>
void _print1(x a, y... b)
{
    _print1(a);
    if (sizeof...(b))
        cout << "", "";
    _print1(b...);
}
#define dbg(x...)                 \
    cout  << #x << "" => ""; \
    _print1(x);                   \
    cout << ""\n"";
void _print(ll t) {cerr << t;}
void _print(int t) {cerr << t;}
void _print(string t) {cerr << t;}
void _print(char t) {cerr << t;}
void _print(ld t) {cerr << t;}
void _print(double t) {cerr << t;}
template <class T, class V> void _print(pair <T, V> p);
template <class T> void _print(vector <T> v);
template <class T> void _print(set <T> v);
template <class T, class V> void _print(map <T, V> v);
template <class T> void _print(multiset <T> v);
template <class T, class V> void _print(pair <T, V> p) {cerr << ""{""; _print(p.first); cerr << "",""; _print(p.second); cerr << ""}"";}
template <class T> void _print(vector <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(set <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T> void _print(multiset <T> v) {cerr << ""[ ""; for (T i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
template <class T, class V> void _print(map <T, V> v) {cerr << ""[ ""; for (auto i : v) {_print(i); cerr << "" "";} cerr << ""]"";}
/*=============================================FUNCTIONS=================================================*/
string tobin(ll x)
{
//shows from left
 string res;
 while (x > 0)
 {
   if (x % 2 == 0)
     res += '0';
   else
     res += '1';
   x /= 2;
 }
reverse(all(res));
 return res;
}
struct custom_hash
{
    static uint64_t splitmix64(uint64_t x)
    {
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const
    {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
// #define MAX 500007
// vector<int> primes;
// bool isprime[MAX];
// int spf[MAX];
// void sieve()
// {
//     f(i, MAX) spf[i] = i;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (spf[i] == i)
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//             {
//             if(spf[j]==j)	
//                 spf[j] = i;
//             }
//         }
//     }
//     f(i, MAX) isprime[i] = true;
//     isprime[1] = false;
//     for (ll i = 2; i < MAX ; i++)
//     {
//         if (isprime[i])
//         {
//             for (ll j = i * i; j < MAX ; j += i)
//                 isprime[j] = false;
//         }
//     }

//     // for (ll p = 2; p < MAX; p++)
//     // 	if (isprime[p])
//     // 		primes.push_back(p);
// }
ll bpow(ll a, ll b, ll m) {
a %= m;
ll res = 1;
while (b > 0) {
if (b & 1)
res = res * a % m;
a = a * a % m;
b >>= 1;
}
return res;
}
ll dx[] = {0, 1, -1, 0};
ll dy[] = {1, 0, 0, -1};
ll nCr(ll n,ll r){if(n<r)return 0;if(r>n-r)r=n-r;ll ans=1;ll i;for(i=1;i<=r;i++) {ans*= n-r+i;ans/=i;}return ans;}
ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }
ll lcm(ll a,ll b){return a/__gcd(a,b)*b;}
ll MI(ll a, ll m){ return bpow(a, m - 2, m);}
void meta(int x){cout<<""Case #""<<x<<"": "";}
/*
order_of_key (val): returns the no. of values less than val
find_by_order (k): returns the iterator to kth largest element.(0-based)
memory taken by int of 1e6 is 4 mbs 
*/
#define MOD 1000000007

ll bpow(ll x, ll y)
{
    ll res = 1;
    x %= MOD;
    while (y > 0)
    {
        if (y & 1)
            res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

class Solution
{
public:
    int countBalancedPermutations(string num)
    {
        int n = num.size();
        int k = (n + 1) / 2;
        int l = n / 2;
        ll S = 0;
        int freq[10];
        memset(freq,0,sizeof(freq));
        for (char c : num)
        {
            S += (c - '0');
            freq[c - '0']++;
        }
        if (S&1)
            return 0;
        ll target = S / 2;
        int MAX = n;
        vector<ll> fact(MAX + 1, 1);
        for (int i = 1; i <= MAX; i++)
            fact[i] = fact[i - 1] * i % MOD;

        vector<ll> inv_fact(MAX + 1, 1);
        inv_fact[MAX] = bpow(fact[MAX], MOD - 2);
        for (int i = MAX - 1; i >= 0; i--)
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;

        vector<vector<ll>> old_dp(k + 1, vector<ll>(target + 1, 0));
        old_dp[0][0] = 1;
        for (int d = 0; d <= 9; d++)
        {
            vector<vector<ll>> dp_next(k + 1, vector<ll>(target + 1, 0));
            for (int c = 0; c <= k; c++)
            {
                for (int s = 0; s <= target; s++)
                {
                    if (old_dp[c][s] == 0)
                        continue;
                    for (int assign = 0; assign <= min(freq[d], k - c); assign++)
                    {
                        if (s + (ll)assign * d > target)
                            continue;
                        ll val = old_dp[c][s] * inv_fact[assign] % MOD;
                        val = val * inv_fact[freq[d] - assign] % MOD;
                        dp_next[c + assign][s + assign * d] = (dp_next[c + assign][s + assign * d] + val) % MOD;
                    }
                }
            }
            old_dp = dp_next;
        }
        ll value = old_dp[k][target];
        if (value == 0)
            return 0;
        ll ans = fact[k]*fact[l] % MOD;
        ans = ans * value % MOD;
        return (int)ans;
    }
};
",1441371265
Linh Nguyen,ll931110,168,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[55][55];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = inf;
            }
        }
        dist[0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2];
            if (-u[0] != dist[ux][uy]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i];
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = 1 + max(dist[ux][uy], moveTime[vx][vy]);

                if (dist[vx][vy] > ts) {
                    dist[vx][vy] = ts;
                    pq.push({-ts, vx, vy});
                }
            }
        }

        return dist[m - 1][n - 1];
    }
};",1441293859
Linh Nguyen,ll931110,168,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        int dist[755][755][2];
        int inf = 1e9 + 1e8;

        int dx[4] = {-1, 0, 1, 0};
        int dy[4] = {0, 1, 0, -1};

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < 2; k++) {
                    dist[i][j][k] = inf;
                }
            }
        }

        dist[0][0][0] = 0;

        priority_queue< vector<int> > pq;
        pq.push({0, 0, 0, 0});

        while (!pq.empty()) {
            auto u = pq.top();
            pq.pop();

            int ux = u[1], uy = u[2], uz = u[3];
            if (-u[0] != dist[ux][uy][uz]) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int vx = ux + dx[i], vy = uy + dy[i], vz = uz ^ 1;
                if (vx < 0 || vx >= m || vy < 0 || vy >= n) {
                    continue;
                }
                int ts = max(dist[ux][uy][uz], moveTime[vx][vy]);
                if (uz == 0) {
                    ts++;
                } else {
                    ts += 2;
                }

                if (dist[vx][vy][vz] > ts) {
                    dist[vx][vy][vz] = ts;
                    pq.push({-ts, vx, vy, vz});
                }
            }
        }

        return min(dist[m - 1][n - 1][0], dist[m - 1][n - 1][1]);
    }
};",1441296588
Linh Nguyen,ll931110,168,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int delta = 0;
        for (int i = 0; i < num.size(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0) {
                delta += d;
            } else {
                delta -= d;
            }
        }
        return (delta == 0);
    }
};",1441281045
Linh Nguyen,ll931110,168,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int even = n/2, odd = n - even;
        int maxn = 42;
        int mod = 1e9 + 7;

        int binom[maxn][maxn];
        memset(binom, 0, sizeof binom);
        binom[0][0] = 1;
        for (int i = 1; i < maxn; i++) {
            for (int j = 0; j <= i; j++) {
                binom[i][j] = binom[i - 1][j];
                if (j) {
                    binom[i][j] = (binom[i][j] + binom[i - 1][j - 1]) % mod;
                }
            }
        }

        int D = 361;
        int cur[maxn][maxn][2 * D + 1], nxt[maxn][maxn][2 * D + 1];
        
        memset(cur, 0, sizeof cur);
        cur[even][odd][D] = 1;

        int counter[10];
        memset(counter, 0, sizeof counter);
        for (auto c : num) {
            counter[c - '0']++;
        }

        vector< vector<int> > curs, nexts;
        curs.push_back({even, odd, D});

        for (int d = 0; d < 10; d++) {
            memset(nxt, 0, sizeof nxt);
            nexts.clear();
            for (auto u : curs) {
                int e = u[0], o = u[1], delta = u[2];
                for (int chosen = 0; chosen <= counter[d]; chosen++) {
                    int _e = e - chosen;
                    int _o = o - (counter[d] - chosen);
                    if (_e < 0 || _o < 0) {
                        continue;
                    }
                    int _delta = delta + chosen * d - (counter[d] - chosen) * d;
                    if (_delta < 0 || _delta >= 2 * D) {
                        continue;
                    }

                    long long ways = cur[e][o][delta];
                    ways = (ways * binom[e][chosen]) % mod;
                    ways = (ways * binom[o][counter[d] - chosen]) % mod;
                    if (!nxt[_e][_o][_delta]) {
                        nexts.push_back({_e, _o, _delta});
                    }
                    nxt[_e][_o][_delta] += ways;
                    nxt[_e][_o][_delta] %= mod;
                }
            }
            for (int e = 0; e <= even; e++) {
                for (int o = 0; o <= odd; o++) {
                    for (int d = 0; d < 2 * D; d++) {
                        cur[e][o][d] = nxt[e][o][d];
                    }
                }
            }
            curs = nexts;
        }

        return cur[0][0][D];
    }
};",1441325657
LeeetCode,user3517H,170,3627,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0))]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1
    grid[0][0] = 0
    while heap:
      t, (i, j) = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j)))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += 1
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj)))
",1441299374
LeeetCode,user3517H,170,3628,python3,"class Solution:
  def minTimeToReach(self, grid: List[List[int]]) -> int:
    m = len(grid)
    n = len(grid[0])
    heap = [(0, (0, 0), 1)]
    dij = [
      (1, 0),
      (0, -1),
      (0, 1),
      (-1, 0)
    ]
    time = [[inf] * n for i in range(m)]
    for i in range(m):
      for j in range(n):
        grid[i][j] += 1 + (i + j + 1) % 2
    grid[0][0] = 0
    while heap:
      t, (i, j), d = heappop(heap)
      if i < 0 or i >= m or j < 0 or j >= n or t >= time[i][j]:
        continue
      if t < grid[i][j]:
        heappush(heap, (grid[i][j], (i, j), d))
        continue
      if i + 1 == m and j + 1 == n:
        return t
      time[i][j] = t
      t += d
      d = 3 - d
      for di, dj in dij:
        heappush(heap, (t, (i + di, j + dj), d))
",1441312441
LeeetCode,user3517H,170,3636,python3,"class Solution:
  def isBalanced(self, num: str) -> bool:
    return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
",1441281990
LeeetCode,user3517H,170,3637,python3,"class Solution:
  def countBalancedPermutations(self, num: str) -> int:
    @cache
    def dfs(i, l, r, o, e):
      if i == 9:
        return 0 if o * 9 != l or o > cnt[9] else 1
      res = 0
      # j >= cnt[i] - r / i
      # cnt[i] - j <= e
      lo = max(0, cnt[i] - e, 0 if i == 0 else cnt[i] - r // i)
      hi = 1 + min(o, inf if i == 0 else l // i, cnt[i])
      for j in range(lo, hi):
        k = cnt[i] - j
        res = (res + dfs(i + 1, l - i * j, r - i * k, o - j, e - k) * comb(o, j) * comb(e, k)) % mod
      return res

    mod = 10 ** 9 + 7
    cnt = [0] * 10
    tot = 0
    n = len(num)
    for i in num:
      i = int(i)
      cnt[i] += 1
      tot += i
    if tot % 2 == 1:
      return 0
    return dfs(0, tot // 2, tot // 2, (n + 1) // 2, n // 2)",1441360652
yahoo010206,yahoo010206,171,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, (0, 0))]
        used = set()
        while heap[0][1]!=target:
            t, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+1, (x, y)))
        return heap[0][0]
                        
            
        ",1441300685
yahoo010206,yahoo010206,171,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        edges = defaultdict(dict)
        for r, row in enumerate(moveTime):
            for c, value in enumerate(row):
                for x, y in [(r-1, c), (r, c-1),(r+1, c),(r, c+1)]:
                    if 0<=x<m and 0<=y<n:
                        edges[(x, y)][(r, c)] = value
        target = (m-1, n-1)
        heap = [(0, 0, (0, 0))]
        used = set()
        while heap[0][2]!=target:
            t, l, coord = heapq.heappop(heap)
            if coord not in used:
                used.add(coord)
                for (x, y), _t in edges[coord].items():
                    if 0<=x<m and 0<=y<n and (x, y) not in used:
                        heapq.heappush(heap, (max(t, _t)+(2 if l&1 else 1), (l+1)%2, (x, y)))
        return heap[0][0]
                        
            
        ",1441304135
yahoo010206,yahoo010206,171,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2))== sum(int(num[i]) for i in range(1, len(num), 2))",1441281480
yahoo010206,yahoo010206,171,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits = [int(d) for d in num]
        total = sum(digits)
        if total%2:
            return 0

        modulo = 1000000007
        digits_cnts = Counter(digits)
        length1 = len(digits)>>1
        length2 = (len(digits)>>1)+(len(digits)&1)
        mem = {}
        def solve(d, value, l1, l2):
            key = (d, value, l1, l2)
            # print(d, value, l1, l2)
            if key in mem:
                return mem[key]
            if d==-1:
                # print(""**"")
                return 1 if value==0 and l2==0 else 0

            res = 0
            for cnt in range(0, min(digits_cnts[d], l1)+1):
                if (_value:=value-cnt*d)>=0:
                    if (_res:=solve(d-1, _value, l1-cnt, l2-(digits_cnts[d]-cnt)))!=0:
                        # print(""--"", _res, d, (l1, cnt), (l2, digits_cnts[d]-cnt))
                        res += _res*(
                            math.comb(l1, cnt)%modulo*
                            math.comb(l2, digits_cnts[d]-cnt)%modulo
                        )
                        
            mem[key] = res%modulo if res else 0
            return mem[key]
        return solve(9, total>>1, length1, length2)",1441367015
AxxxxxA,blackhatinside,174,3627,python3,"class Solution:
    def minTimeToReach(self, moTi, flag = 1, temp = 5, ext = 5, dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]):
        if flag: far = [[float('inf')] * len(moTi[0]) for _ in range(len(moTi))]
        if flag: pq = [(0, 0, 0)]
        if flag: far[0][0] = 0
        while pq:
            if flag: tm, rw, cl = heapq.heappop(pq)
            if tm <= far[rw][cl]:
                for i in range(len(dirs)):
                    if 0 <= rw + dirs[i][0] < len(moTi) and 0 <= cl + dirs[i][1] < len(moTi[0]):
                        if (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1) < far[rw + dirs[i][0]][cl + dirs[i][1]]:
                            if flag: far[rw + dirs[i][0]][cl + dirs[i][1]] = (max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1)
                            if flag: heapq.heappush(pq, ((max(tm, moTi[rw + dirs[i][0]][cl + dirs[i][1]]) + 1), rw + dirs[i][0], cl + dirs[i][1]))
        return temp + far[ext + (-1) - ext][ext + (-1) -ext] - temp",1441334916
AxxxxxA,blackhatinside,174,3628,python3,"import heapq

class Solution:
    def minTimeToReach(self, movt, directions = [(0, 1), (1, 0), (0, -1), (-1, 0)], flag = 1, temp = 5):
        if not movt or not movt[0]:
            return 0
        if flag: n, m = len(movt), len(movt[0])
        if flag: pq = [(0, 0, 0, 0)]
        if flag: vsit = set()
        while pq:
            if flag: curt, chk, r, c = heapq.heappop(pq)
            if r == n - 1 and c == m - 1:
                return curt
            if flag: st = (r, c, chk)
            if st not in vsit:
                if flag: vsit.add(st)
                for dx, dy in directions:
                    if 0 <= (temp + r + dx - temp) < n and 0 <= (temp + c + dy - temp) < m:
                        if flag: heapq.heappush(pq, (curt + (max(0, movt[temp + r + dx - temp][temp + c + dy - temp] - curt)) + \
                            (2 if chk else 1), not chk, temp + r + dx - temp, temp + c + dy - temp))
        return -1",1441309396
AxxxxxA,blackhatinside,174,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(len(num)) if i % 2 == 0) == sum(int(num[i]) for i in range(len(num)) if i % 2 == 1)",1441289373
AxxxxxA,blackhatinside,174,3637,python3,"class Solution:
    def countBalancedPermutations(self, num, one = 1, two = 2, flag = 1, temp = 5, MOD = int(1e9 + 7)):
        if flag: tsum = sum(int(d) for d in num)
        if flag and (tsum % two == 0):
            if flag: hp = [0] * 10
            for d in num:
                if flag: hp[int(d)] += (temp + one - temp)
            if flag: half_len = (len(num) + one) // two
            if flag: fact = [temp + one - temp] * (len(num) + one)
            for i in range(temp + one - temp, len(num) + one):
                if flag: fact[i] = (i * fact[i-one]) % MOD
            if flag: ivft = [pow(f, MOD-two, MOD) for f in fact]
            if flag: dp = [[0] * ((tsum // two) + one) for _ in range(half_len + one)]
            if flag: dp[0][0] = temp + one - temp
            for d in range(10):
                if flag and hp[d]:
                    for k in range(half_len - one, -one, -one):
                        for s in range((tsum // two) - d, -one, -one):
                            if flag and dp[k][s]:
                                for cps in range(one, min(hp[d] + one, half_len - k + one)):
                                    if flag and (s + d * cps <= (tsum // two)):
                                        if flag: dp[k + cps][s + d * cps] = (dp[k + cps][s + d * cps] + dp[k][s] * ((fact[hp[d]] * ivft[cps] % MOD * ivft[hp[d] - cps] % MOD))) % MOD
            if flag: anss = dp[-1][-1]
            if dp[-1][-1]:
                if flag: anss = (anss * fact[half_len] * fact[len(num) - half_len] % MOD * prod(ivft[f] for f in hp if f > 1)) % MOD
            return anss
        else:
            return 0

",1441380184
parallel_stream,parallel_stream,175,3627,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;

    State(int row, int col, int time) {
      this.row = row;
      this.col = col;
      this.time = time;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][] arrivalTime = new int[n][m];
    Arrays.stream(arrivalTime).forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    arrivalTime[0][0] = 0;
    PriorityQueue<State> pq = new PriorityQueue<>();
    pq.offer(new State(0, 0, 0));
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + 1;
            if (newArrivalTime < arrivalTime[newRow][newCol]) {
              arrivalTime[newRow][newCol] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441295264
parallel_stream,parallel_stream,175,3628,java,"class Solution {
  
  private static final int[][] DIRS = {
      {-1, 0}, {1, 0}, {0, -1}, {0, 1}
  };

  private static class State implements Comparable<State> {
    int row;
    int col;
    int time;
    int moveToggle;

    State(int row, int col, int time, int moveToggle) {
      this.row = row;
      this.col = col;
      this.time = time;
      this.moveToggle = moveToggle;
    }

    @Override
    public int compareTo(State other) {
      return Integer.compare(this.time, other.time);
    }
  }

  public int minTimeToReach(int[][] moveTime) {
    int n = moveTime.length;
    if (n == 0) {
      return -1;
    }
    int m = moveTime[0].length;
    if (m == 0) {
      return -1;
    }
    int[][][] arrivalTime = new int[n][m][2];
    Arrays.stream(arrivalTime)
        .flatMap(Arrays::stream)
        .forEach(row -> Arrays.fill(row, Integer.MAX_VALUE));
    PriorityQueue<State> pq = new PriorityQueue<>();
    State start = new State(0, 0, 0, 0);
    pq.offer(start);
    arrivalTime[0][0][0] = 0;
    while (!pq.isEmpty()) {
      State current = pq.poll();
      int row = current.row;
      int col = current.col;
      int currentTime = current.time;
      int moveToggle = current.moveToggle;
      if (row == n - 1 && col == m - 1) {
        return currentTime;
      }
      if (currentTime <= arrivalTime[row][col][moveToggle]) {
        Arrays.stream(DIRS).forEach(dir -> {
          int newRow = row + dir[0];
          int newCol = col + dir[1];
          if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
            int moveDuration = (moveToggle == 0) ? 1 : 2;
            int moveStartTime = Math.max(currentTime, moveTime[newRow][newCol]);
            int newArrivalTime = moveStartTime + moveDuration;
            int newMoveToggle = 1 - moveToggle;
            if (newArrivalTime < arrivalTime[newRow][newCol][newMoveToggle]) {
              arrivalTime[newRow][newCol][newMoveToggle] = newArrivalTime;
              pq.offer(new State(newRow, newCol, newArrivalTime, newMoveToggle));
            }
          }
        });
      }
    }
    return -1;
  }
}",1441374155
parallel_stream,parallel_stream,175,3636,java,"class Solution {
  public boolean isBalanced(String num) {
    int evenSum = 0;
    int oddSum = 0;
    for (int i = 0; i < num.length(); i++) {
      int digit = num.charAt(i) - '0';
      if (i % 2 == 0) {
        evenSum += digit;
      } else {
        oddSum += digit;
      }
    }
    return evenSum == oddSum;
  }
}",1441282265
parallel_stream,parallel_stream,175,3637,java,"class Solution {

  private static final int MOD = 1_000_000_007;

  private long[] fact;
  private long[] invFact;

  public int countBalancedPermutations(String num) {
    int n = num.length();
    int[] count = new int[10];
    long totalSum = 0;
    for (char c : num.toCharArray()) {
      count[c - '0']++;
      totalSum += (c - '0');
    }
    if (totalSum % 2 != 0) {
      return 0;
    }
    long target = totalSum / 2;
    int A = (n + 1) / 2;
    int B = n / 2;
    precomputeFactorials(n);
    long freqFactor = 1;
    for (int d = 0; d <= 9; d++) {
      freqFactor = (freqFactor * fact[count[d]]) % MOD;
    }
    long[][] dp = new long[A + 1][(int) target + 1];
    dp[0][0] = 1;
    for (int d = 0; d <= 9; d++) {
      if (count[d] == 0) {
        continue;
      }
      for (int k = A; k >= 0; k--) {
        for (int s = 0; s <= target; s++) {
          if (dp[k][s] != 0) {
            for (int t = 1; t <= Math.min(count[d], A - k); t++) {
              if (s + (long) t * d > target) {
                break;
              }
              long comb = (fact[count[d]] * invFact[t] % MOD) * invFact[count[d] - t] % MOD;
              dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb) % MOD;
            }
          }
        }
      }
    }
    long iff = powMod(freqFactor, MOD - 2);
    long ans = (fact[A] * fact[B]) % MOD;
    ans = (ans * dp[A][(int) target]) % MOD;
    ans = (ans * iff) % MOD;
    return (int) ans;
  }

  private void precomputeFactorials(int max) {
    fact = new long[max + 1];
    fact[0] = 1;
    for (int i = 1; i <= max; i++) {
      fact[i] = fact[i - 1] * i % MOD;
    }
    invFact = new long[max + 1];
    invFact[max] = powMod(fact[max], MOD - 2);
    for (int i = max - 1; i >= 0; i--) {
      invFact[i] = invFact[i + 1] * (i + 1) % MOD;
    }
  }

  private long powMod(long a, long b) {
    long res = 1;
    a %= MOD;
    while (b > 0) {
      if ((b & 1) != 0) {
        res = res * a % MOD;
      }
      a = a * a % MOD;
      b >>= 1;
    }
    return res;
  }
}",1441331229
Jie Hong Lin,tusov8899,176,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 0, 0)]
        ret = 0
        while pq:
            t, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

                
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + 1, moveTime[i][j] + 1)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, i, j))",1441301835
Jie Hong Lin,tusov8899,176,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = map(len, (moveTime, moveTime[0]))
        arrive = [[inf] * n for _ in range(m)]
        pq = [(0, 2, 0, 0)]
        ret = 0
        while pq:
            t, prev_cost, x, y = heapq.heappop(pq)
            if arrive[x][y] < t: continue

            if x == m - 1 and y == n - 1: return t

            next_cost = 2 if prev_cost == 1 else 1
            for i, j in (x + 1, y), (x, y + 1), (x - 1, y), (x, y - 1):
                if m > i >= 0 <= j < n:
                    eta = max(t + next_cost, moveTime[i][j] + next_cost)
                    if eta < arrive[i][j]:
                        arrive[i][j] = eta
                        heapq.heappush(pq, (eta, next_cost, i, j))",1441307944
Jie Hong Lin,tusov8899,176,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = sum(int(num[i]) for i in range(n) if i & 1)
        odd = sum(int(num[i]) for i in range(n) if i & 1 == 0)
        return odd == even",1441283976
Jie Hong Lin,tusov8899,176,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def f(on, os, en, es):
            if on == en == 0: return int(os == es)
            i = n - (on + en)
            ret = 0
            if on:
                ret = (ret + f(on - 1, os + A[i], en, es) * on)#  % MOD
            if en:
                ret = (ret + f(on, os, en - 1, es + A[i]) * en)#   % MOD

            return ret
           
        def help(a):
            ret = 1
            while a:
                ret *= a
                a -= 1
            return ret
                
        MOD = 1_000_000_007
        A = list(map(int, list(num)))
        A.sort()
        n = len(A)
        cnt = Counter(A)
        div =1
        for v in cnt.values():
            div *= help(v)
        en = n // 2
        on = en + (n & 1)
        ret = f(on, 0, en, 0)
        # print(ret, div)
        return (ret // div)  % MOD
        ",1441361636
pulkit0707chawla,pulkit0707chawla,177,3627,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<long long>>grid(n+1,vector<long long>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<long long>,vector<vector<long long>>,greater<vector<long long>>>pq;
        pq.push({0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            long long t=v[0],x=v[1],y=v[2];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k],ny=y+dy[k];
                if(nx>=0 and ny>=0 and nx<n and ny<m){
                    long long val=1+t;
                    if(val<1+mat[nx][ny]) val=1+mat[nx][ny];
                    if(grid[nx][ny]>val){
                        grid[nx][ny]=val;
                        pq.push({grid[nx][ny],nx,ny});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441328732
pulkit0707chawla,pulkit0707chawla,177,3628,cpp,"class Solution {
public:
    int dx[4]={0,-1,0,1};
    int dy[4]={-1,0,1,0};
    int minTimeToReach(vector<vector<int>>& mat) {
        int n=mat.size(),m=mat[0].size();
        vector<vector<int>>grid(n+1,vector<int>(m+1,INT_MAX));
        grid[0][0]=0;
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;
        pq.push({0,0,0,0});
        while(!pq.empty()){
            auto v=pq.top();
            pq.pop();
            int t=v[0],x=v[1],y=v[2],c=v[3];
            if(x==n-1 and y==m-1) return t;
            for(int k=0; k<4; k++){
                int nx=x+dx[k];
                int ny=y+dy[k];
                if(nx<n and ny<m and nx>=0 and ny>=0){
                    if(grid[nx][ny]>max(1+c+t,mat[nx][ny]+1+c)){
                        grid[nx][ny]=max(1+c+t,mat[nx][ny]+1+c);
                        pq.push({grid[nx][ny],nx,ny,1-c});
                    }
                }
            }
        }
        return grid[n-1][m-1];
    }
};",1441320388
pulkit0707chawla,pulkit0707chawla,177,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd=0,even=0;
        bool c=0;
        for(auto x:num){
            if(c) odd+=x-'0';
            else even+=x-'0';
            c=!c;
        }
        return odd==even;
    }
};",1441291044
pulkit0707chawla,pulkit0707chawla,177,3637,cpp,"class Solution {
public:
    int mod=1e9+7;
    int countBalancedPermutations(string num) {
        int n=num.size();
        int e=(n+1)/2,o=n/2;
        string s=num;
        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }
        long long sum = 0;
        for(int d = 0; d < 10; d++) {
            sum += (long long)d * cnt[d];
        }
        if(sum%2) return 0;
        long long target = sum / 2;
        int mx=80;
        vector<long long> factorial(mx + 1, 1);
        for(int i = 1; i <= mx; i++) {
            factorial[i] = factorial[i -1] * i % mod;
        }
        vector<long long> inv_fact(mx + 1, 1);
        inv_fact[mx] = power(factorial[mx], mod - 2, mod);
        for(int i = mx -1; i >=0; i--){
            inv_fact[i] = inv_fact[i +1] * (i +1) % mod;
        }
        auto comb = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return factorial[n] * inv_fact[k] % mod * inv_fact[n -k] % mod;
        };
        vector<vector<long long>> dp(e +1, vector<long long>(target +1, 0));
        dp[0][0] =1;

        for(int d =0; d <10; d++) {
            if(cnt[d] ==0) continue;
            for(int t = e; t >=0; t--){
                for(long long s = target; s >=0; s--){
                    if(dp[t][s] ==0) continue;
                    for(int k =1; k <= cnt[d] && t +k <= e && s + (long long)d *k <= target; k++){
                        dp[t +k][s + (long long)d *k] = (dp[t +k][s + (long long)d *k] + dp[t][s] * comb(cnt[d], k)) % mod;
                    }
                }
            }
        }

        string l = num;
        long long valid = dp[e][target];
        long long p =1;
        for(int d =0; d <10; d++) {
            p = p * factorial[cnt[d]] % mod;
        }
        long long ans= valid;
        ans = ans * factorial[e] % mod;
        ans = ans * factorial[o] % mod;
        long long inv_product = power(p, mod -2, mod);
        ans = ans * inv_product % mod;
        return (int)ans;
    }

private:
    long long power(long long base, long long exp, long long mod){
        long long res =1;
        base %= mod;
        while(exp >0){
            if(exp &1) res = res * base % mod;
            base = base * base % mod;
            exp >>=1;
        }
        return res;
    }
};",1441355524
xs_pg,xs_pg,178,3627,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny] + 1, d + 1)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12",1441291533
xs_pg,xs_pg,178,3628,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        n = len(g)
        m = len(g[0])
        
        dis = [[inf for _ in range(m)] for _ in range(n)]
        dis[0][0] = 0
        q = [[0, 0, 0]]
        while q:
            d, x, y = heappop(q)
            if dis[x][y] < d:
                continue
            if x == n-1 and y == m-1:
                return d
            for nd in [[0,1], [0,-1], [1,0], [-1,0]]:
                nx, ny = x+nd[0], y+nd[1]
                if nx < 0 or nx >= n or ny < 0 or ny >= m:
                    continue
                nt = max(g[nx][ny], d) + (1 if (nx+ny) % 2 == 1 else 2)
                if nt < dis[nx][ny]:
                    dis[nx][ny] = nt
                    heappush(q, [nt, nx, ny])
        return 10 ** 12
        ",1441294433
xs_pg,xs_pg,178,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = 0
        b = 0
        for i in range(0, n, 2):
            a += int(num[i])
            if i + 1 < n:
                b += int(num[i+1])
        return a == b
        ",1441281376
xs_pg,xs_pg,178,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num)
        t = n // 2
        
        d = defaultdict(int)
        S = 0
        for x in num:
            d[int(x)] += 1
            S += int(x)
        if S % 2 == 1:
            return 0
        
        f = [1]
        for i in range(n):
            f.append(f[-1] * (i+1) % mod)
        nf = [pow(x, mod-2, mod) for x in f]
        # print(f, nf)
        
        ks = list(d.keys())
        nk = len(ks)
        # print(ks)
        
        @cache
        def dp(index, cnt, v):
            if index >= nk:
                if cnt == t and v == S//2:
                    return f[t] * f[n-t] % mod
                return 0
            if cnt > t or v > S//2:
                return 0
            ans = 0
            c = d[ks[index]]
            for i in range(c+1):
                ans += nf[i] * nf[c-i] * dp(index+1, cnt+i, v+i*ks[index]) % mod
            return ans % mod
        
        return dp(0, 0, 0)
            ",1441380685
lawrencewxy,lawrencewxy,179,3627,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //两种写法，一种是newd = Math.abs(A[x][y] - A[x0][y0]); 这种写法，要用全局变量 res, 看上面，res = Math.max(a[2], res);当遇到终点时返回res
               // 第二种写法是 newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));， 遇到终点时直接返回 a[2] 本质上是一样的，第二种更好一些，可以在PQ里存的点少些？？
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                newd += 1;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y]});
                }

            }


        }

        return res;
    }
	   



}",1441305509
lawrencewxy,lawrencewxy,179,3628,java,"class Solution {
    public int minTimeToReach(int[][] A) {
   //public int minimumEffortPath(int[][] A) {

        int m = A.length;
        int n = A[0].length;
        int[][] dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) ->(a[2] - b[2]));

        //boolean[][] v = new boolean[m][n];

        q.offer(new int[]{0, 0, 0, 0});

        int[][] dis = new int[m][n];


        for(int i = 0; i < m; i++){
            Arrays.fill(dis[i], Integer.MAX_VALUE);
        }

        int res = Integer.MAX_VALUE;


        while(!q.isEmpty()){
            int[] a = q.poll();

            int x0 = a[0];
            int y0 = a[1];
            int step = a[3];
            //System.out.println(A[a[0]][a[1]] + "", "" + a[0] + "", ""  + a[1] + "", "" + a[2]);
            //v[x0][y0] = true;

            //System.out.println(""res = "" + res);
             //res = Math.max(a[2], res);

            if(x0 == m - 1 && y0 == n - 1){
                //return res;
                return a[2];
            }
            //res = Math.max(res, a[2]); 

            for(int[] d : dir ){


                int x = x0 + d[0];
                int y = y0 + d[1];

                if(x < 0 || x >=m || y < 0 || y >= n) continue;
                //两种写法，一种是newd = Math.abs(A[x][y] - A[x0][y0]); 这种写法，要用全局变量 res, 看上面，res = Math.max(a[2], res);当遇到终点时返回res
               // 第二种写法是 newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));， 遇到终点时直接返回 a[2] 本质上是一样的，第二种更好一些，可以在PQ里存的点少些？？
                //int newd = Math.abs(A[x][y] - A[x0][y0]);
                // int newd = Math.max(a[2], Math.abs(A[x][y] - A[x0][y0]));
                int newd = a[2];
                // if(x == m - 1 && y == n - 1){
                //     //return res;
                //     res = Math.min(res, newd);
                // }
                    
                if(newd < A[x][y]){
                    newd = A[x][y];
                }
                
                if(step%2 == 0)newd += 1;
                if(step%2 == 1)newd += 2;

                if(newd < dis[x][y]){
                    dis[x][y] = newd;
                    q.offer(new int[]{x, y, dis[x][y], step + 1});
                }

            }


        }

        return res;
    }
}",1441310354
lawrencewxy,lawrencewxy,179,3636,java,"class Solution {
    public boolean isBalanced(String A) {
        
        int a = 0;
        int b = 0;
        int n = A.length();
        int j = 0;
        for(int i = 0; i < n; i++){
            int x = A.charAt(i)- '0';
            if(i %2 == 0){
                a +=x;
            }
            else{
                b += x;
            }
            
            
            
        }
        
        return a == b;
        
    }
}",1441284898
lawrencewxy,lawrencewxy,179,3637,java,"
class Solution {
 

    int mod = (int)(1e9 + 7);
    public int countBalancedPermutations(String num) {
 
        int n = num.length();
        int[] digitCnt = new int[10];
        int sum = 0;
        for (char ch : num.toCharArray()) {
            int digit = ch - '0';
            digitCnt[digit]++;
            sum += digit;
        }

        if (sum % 2 != 0) {
            return 0;
        }

        int target = sum / 2;
        int evenPos = (n + 1) / 2;
        int oddPos = n / 2;

        long[][][] state = new long[11][target + 1][evenPos + 1];
        state[0][0][0] = 1;

        long[] f = new long[n + 1];
        long[] invF = new long[n + 1];
        f[0] = invF[0] = 1;
        for (int i = 1; i <= n; i++) {
            f[i] = f[i - 1] * i % mod;
            invF[i] = modInverse(f[i]);
        }

        long[][] combs = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            combs[i][0] = combs[i][i] = 1;
            for (int j = 1; j < i; j++) {
                combs[i][j] = (combs[i - 1][j - 1] + combs[i - 1][j]) % mod;
            }
        }

        
        //  难
        for (int d = 0; d <= 9; d++) {
            int currentCount = digitCnt[d];
            for (int s = 0; s <= target; s++) {
                for (int c = 0; c <= evenPos; c++) {
                    if (state[d][s][c] == 0) continue;

                    for (int k = 0; k <= currentCount && c + k <= evenPos && s + k * d <= target; k++) {
                        state[d + 1][s + k * d][c + k] = (state[d + 1][s + k * d][c + k] + state[d][s][c] * combs[currentCount][k]) % mod;
                    }
                }
            }
        }

        long finalCount = state[10][target][evenPos];
        if (finalCount == 0) return 0;

        long evenWays = f[evenPos];
        long oddWays = f[oddPos];

        long denom = 1;
        for (int d = 0; d <= 9; d++) {
            denom = denom * f[digitCnt[d]] % mod;
        }
        //get the final result
        long res = finalCount * evenWays % mod * oddWays % mod * modInverse(denom) % mod;
        return (int)(res);
    }

    long modInverse(long a) {
        return powMod(a, mod - 2);
    }

    // long powMod(long a, long b, int mod) {
     long powMod(long a, long b){
         long res = 1;
         
         a %= mod; // 这句话不能少，不然当a 大于 2^31 时就不对了！参看1969 Minimum Non-Zero Product of the Array Elements    
          
         while(b > 0){
             if(b%2 != 0) { // 等价于 if((b&1) == 1){
                 res = (res*a)%mod;
             }
            
             b = b/2;  // 等价于 b = b>>1;
             a = (a *a)%mod;
         }
         //System.out.println(""res = "" +res);
         return res;
     }

}",1441374842
Ritik Rathor,ritik_369,180,3627,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441356192
Ritik Rathor,ritik_369,180,3628,cpp,"int n , m ; 
bool ok(int x , int y)
{
   if(x < 0 or y < 0)return 0 ; 
   if(x >= n or y >= m)return 0 ; 
   return 1 ; 
}

template<typename T>using min_heap=priority_queue<T,vector<T>,greater<T>>;


class Solution {
public:
   int minTimeToReach(vector<vector<int>>& moveTime) 
   {
       n = moveTime.size() ;  
       m = moveTime[0].size() ;  
       int dist[n + 1][m + 1][2] , vis[n + 1][m + 1][2] ; 
      array < int , 2 > src = {0 , 0} ; 
      moveTime[0][0] = 0 ; 
      min_heap < array < int , 4 >  > pq ; 
      for(int i = 0 ; i <= n ; i += 1)
         for(int j = 0 ; j <= m ; j += 1)
         {
            dist[i][j][0] = -1 ; 
            dist[i][j][1] = -1 ; 
            vis[i][j][0] = 0 ; 
            vis[i][j][1] = 0 ; 
         }
      dist[0][0][0] = 0 ; 
      pq.push({0 , 0 , 0 , 0}) ; 
      while(pq.size() > 0)
      {
         auto [dst , x , y , b] = pq.top() ; 
         pq.pop() ; 
         if(vis[x][y][b])continue ; 
         vis[x][y][b] = 1 ; 
         vector<array < int , 2 > >childs = {{x , y + 1} , {x , y-1} , {x-1 , y} , {x + 1 , y}} ; 
         for(auto child : childs)
         {
            if(!ok(child[0] , child[1]))continue ; 
            int nw = dst + 1 + (b) ; 
            nw = max(nw , moveTime[child[0]][child[1]] + 1+b) ; 
            if(dist[child[0]][child[1]][b ^ 1] == -1 or (dist[child[0]][child[1]][b ^ 1] > nw))
            {
               dist[child[0]][child[1]][b ^ 1] = nw ; 
               pq.push({dist[child[0]][child[1]][b ^ 1] , child[0] , child[1] , b ^ 1}) ; 
            }
         }
      }
      int res = -1 ; 
      if(dist[n-1][m-1][0] != -1)
          res = dist[n-1][m-1][0] ; 

      if(dist[n-1][m-1][1] != -1)
         if(res == -1)
          res = dist[n-1][m-1][1] ; 
         else
          res = min(res , dist[n-1][m-1][1]) ; 
      
      return res; 
   }
};

",1441364305
Ritik Rathor,ritik_369,180,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    array < int , 2 > ar ; 
    ar[0] = ar[1] = 0 ; 
    int i = 0 ; 
    for(auto a : num)
       ar[(i ++ ) & 1] += a - '0' ;       
    return ar[0] == ar[1] ; 
    }
};",1441356045
Ritik Rathor,ritik_369,180,3637,cpp,"const int mod = 1e9 + 7;
string s ; 
int sm , to , n ; 
vector < int > vec , fac , ifac ; 
int dp[10][400][45] ; 
int f(int idx , int cur , int ct)
{
   if(cur > sm)return 0 ; 
   if(ct > to)return 0 ; 
   if(idx == 10)
   {
      return 1ll * (1ll * (cur == sm and ct == to) * 1ll * fac[ct] * fac[n - ct]) % mod ; 
   }
   int  & res = dp[idx][cur][ct] ; 
   if(res != -1)return res ; 
   res = 0 ; 
   for(int i = 0 ; i <= vec[idx] ; i += 1)
   {
      int h = 0 ; 
      h = 1ll * (1ll * h + 1ll * f(idx + 1 , cur + (i * idx) , ct + i)) % mod ; 
      h = 1ll * (1ll * h * ifac[i]) % mod ; 
      h = 1ll * (1ll * h * ifac[vec[idx] - i]) % mod ; 
      res = 1ll * (1ll * res + 1ll * h) % mod ; 
   }
   return res ; 
}
long long binpow(long long a, long long b, long long m) {
    a %= m;
    long long res = 1;
    while (b > 0) {
        if (b & 1)
            res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}


class Solution {
public:
    int countBalancedPermutations(string num)
    {
      if(fac.size() == 0)
      {
         fac = vector < int > (100 , 0) ; 
         ifac = vector < int > (100 , 0) ; 
         fac[0] = 1 ; 
         ifac[0] = binpow(1 , mod-2 , mod) ; 
         for(int i = 1 ; i <= 90 ; i += 1)
         {
            fac[i] = (1ll * fac[i-1] * i) % mod ; 
            ifac[i] = binpow(fac[i] , mod-2 , mod) ; 
         }
      }
      memset(dp , -1 , sizeof(dp)) ; 

      n = num.size() ; 
        vec = vector < int > (10 , 0) ; 
        sm = 0 ; 
        for(auto a : num)
        {
         vec[a - '0'] ++  ; 
         sm += a - '0' ; 
        }
        if(sm & 1)return 0 ; 
        sm /= 2 ;
        to = ((num.size() + 1) / 2) ; 
        return f(0 , 0 , 0) ; 
    }
};",1441369052
CLOWNTK,CLOWNTK,181,3627,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441355375
CLOWNTK,CLOWNTK,181,3628,cpp,"typedef long long ll;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n= a.size(), m= a[0].size();
        vector<pair<int,int>> moves= {{1,0}, {0,1}, {-1,0}, {0,-1}};
        vector<vector<ll>> dis(n, vector<ll> (m,-1));

        priority_queue<array<ll,4>> q;
        q.push({0,0,0,0});
        dis[0][0]=0;
        while(!q.empty()){
            auto p= q.top();
            q.pop();

            int tim= -p[0], turn= p[1], x= p[2], y=p[3];

            for(auto P: moves){
                int i= P.first+x, j= P.second+y;
                if(i>=0 && j>=0 && i<n && j<m){
                    int d=max(a[i][j], tim)+ turn+1;
                    if(dis[i][j]==-1 || dis[i][j]> d){
                        dis[i][j]= d;
                        q.push({-d, (turn+1)%2, i, j});
                    }
                }
            }
        }
        return dis[n-1][m-1];
        
    }
};",1441353979
CLOWNTK,CLOWNTK,181,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int tot=0;
        for(int i=0;i<num.size();i++){
            if(i%2){
                tot+= (num[i]-'0');
            }
            else{
                tot-= (num[i]-'0');
            }
        }
        if(tot==0) return 1;
        return 0;
    }
};",1441356632
CLOWNTK,CLOWNTK,181,3637,cpp,"typedef long long ll;
int M= 1e9+7;
ll inv[85], fact[85];
ll dp[85][11][850];

long long power(long long a,long long b){
    if(b<0){
        return 0;
    }
    if(b==0){
        return 1;
    }
    if(abs(a)>=M){
        a= a%M;
    }
    if(a<0){
        a+=M;
    }
    long long  z = power((a*a)%M,b>>1);
    if(b&1){
        z=(z*a)%M;
    }
    return z;
}

class Solution {
public:
    ll solve(int i, int d, int sum, vector<int> &freq, int n, int tot){
        if(sum> (tot/2)){
            return 0;
        }
        if(d> 9){
            if(i!=(n+1)/2) return 0;
            if(sum!= (tot/2)) return 0;
            return 1;
        }
        if(dp[i][d][sum]!=-1){
            return dp[i][d][sum];
        }
        
        ll ans=0;

        for(int f=0;f<=freq[d] && (i+f)<=(n+1)/2;f++){
            ll now= (solve(i+f,d+1,sum+f*d,freq,n,tot)*inv[f])%M;
            now= (now*inv[freq[d]-f])%M;
            ans= (ans+now)%M;
            if(sum+ f*d> (tot/2)) break;
        }

        return dp[i][d][sum]= ans;
        
    }
    int countBalancedPermutations(string num) {
        fact[0]= inv[0]=1;

        for(int i=1;i<=84;i++){
            fact[i]= (i*fact[i-1])%M;
            inv[i]= power(fact[i], M-2);
        }

        int n= num.size();
        vector<int> freq(10);
        int tot=0;
        for(auto x: num){
            freq[x-'0']++;
            tot+= (x-'0');
        }
 
        if(tot%2) return 0;
        for(int i=0;i<=n;i++){
            for(int j=0;j<=9;j++){
                for(int sum=0;sum<=tot;sum++){
                    dp[i][j][sum]=-1;
                }
            }
        }
        
        ll now= (fact[n/2]*fact[(n+1)/2])%M;
        return (solve(0,0,0,freq,n,tot)*now)%M;
    }
};",1441340805
a_k,a0518,182,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+1
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc))
        
                
            ",1441287203
a_k,a0518,182,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        
        h = [(0,0,0,0)]
        vis = [[False for _ in range(n)] for _ in range(m)]
        while h:
            t, r, c, x = heappop(h)
            if vis[r][c]: continue
            vis[r][c] = True
            if r == m-1 and c == n-1: return t
            
            for nr, nc in [(r+1,c),(r-1,c),(r,c+1),(r,c-1)]:
                if nr < 0 or nr >= m or nc < 0 or nc >= n: continue
                newt = t+(1 if x == 0 else 2)
                if t < moveTime[nr][nc]: newt+=moveTime[nr][nc]-t
                heappush(h, (newt,nr,nc,x^1))
        
                
            ",1441289199
a_k,a0518,182,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = b = 0
        for i in range(len(num)):
            if i%2:
                a+=int(num[i])
            else: b+=int(num[i])
        return a==b",1441280894
a_k,a0518,182,3637,python3,"from collections import Counter
from functools import cache

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9+7
        n = len(num)
        mp = Counter(num)

        tot = sum(int(d) for d in num)
        if tot % 2 != 0:  
            return 0

        fac = [1] * (n + 1)
        for i in range(1, n + 1):
            fac[i] = (fac[i - 1] * i) % mod

        def mod_inverse(v, p):
            return pow(v, p - 2, p)

        t = tot // 2

        dp = [[[0] * (n // 2 + 1) for _ in range(t + 1)] for _ in range(n + 1)]
        dp[0][0][0] = 1 

        for i in range(1, n + 1):
            digit = int(num[i - 1])
            for cur in range(t + 1):
                for cnt in range(n // 2 + 1):
                    if dp[i - 1][cur][cnt] > 0:
                        if cur + digit <= t and cnt + 1 <= n // 2:
                            dp[i][cur + digit][cnt + 1] = (dp[i][cur + digit][cnt + 1] + dp[i - 1][cur][cnt]) % mod
                        dp[i][cur][cnt] = (dp[i][cur][cnt] + dp[i - 1][cur][cnt]) % mod

        a = dp[n][t][n // 2] * fac[n // 2] % mod 
        b = fac[n - n // 2] 
        res = (a * b) % mod

        for v in mp.values():
            res = (res * mod_inverse(fac[v], mod)) % mod

        return res
",1441350922
Nat,4nIlUcEGTM,185,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        
        int[][] dist = new int[n][m];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dist[i], Integer.MAX_VALUE);
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (int[] dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
}",1441359050
Nat,4nIlUcEGTM,185,3628,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();

        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        d[0][0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0, 0});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) {
            vector<int> current = pq.top();
            pq.pop();

            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (auto dir : directions) {
                int ni = i + dir.first;
                int nj = j + dir.second;

                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
            }
        }

        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};

",1441361470
Nat,4nIlUcEGTM,185,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        # Iterate through each digit and accumulate sums based on index parity
        for i, digit in enumerate(num):
            if i % 2 == 0:  # even index
                even_sum += int(digit)
            else:           # odd index
                odd_sum += int(digit)
        
        # Check if the sums are equal
        return even_sum == odd_sum
",1441313791
Nat,4nIlUcEGTM,185,3637,rust,"impl Solution {
    const MOD: i64 = 1_000_000_007;

    pub fn count_balanced_permutations(num: String) -> i32 {
        let length = num.len();
        let total_sum: i32 = num.chars().map(|c| c.to_digit(10).unwrap() as i32).sum();

        // Count occurrences of each digit
        let mut counts = vec![0; 10];
        for digit in num.chars() {
            counts[digit.to_digit(10).unwrap() as usize] += 1;
        }

        // If the total sum is odd, it's impossible to divide it into two equal parts
        if total_sum % 2 != 0 {
            return 0;
        }

        let half_sum = total_sum / 2;
        let m = (length + 1) / 2;

        // Factorial and inverse factorial arrays
        let mut factorial = vec![1i64; length + 1];
        for i in 1..=length {
            factorial[i] = factorial[i - 1] * i as i64 % Self::MOD;
        }

        let mut inv_factorial = vec![1i64; length + 1];
        inv_factorial[length] = Self::mod_inverse(factorial[length], Self::MOD);
        for i in (0..length).rev() {
            inv_factorial[i] = inv_factorial[i + 1] * (i as i64 + 1) % Self::MOD;
        }

        // DP table for counting balanced subsets
        let mut dp = vec![vec![0i64; (half_sum + 1) as usize]; m + 1];
        dp[0][0] = 1;

        for d in 0..10 {
            if counts[d] == 0 {
                continue;
            }

            for k in (0..=m).rev() {
                for s in (0..=half_sum as usize).rev() {
                    if dp[k][s] == 0 {
                        continue;
                    }

                    for t in 1..=counts[d] {
                        if k + t > m || s + (d * t) > half_sum as usize {
                            break;
                        }
                        let new_k = k + t;
                        let new_s = s + (d * t);
                        dp[new_k][new_s] = (dp[new_k][new_s] + dp[k][s] * Self::comb(counts[d], t, &factorial, &inv_factorial, Self::MOD)) % Self::MOD;
                    }
                }
            }
        }

        let w = dp[m][half_sum as usize];
        let mut result = factorial[m] * factorial[length - m] % Self::MOD;

        for d in 0..10 {
            result = result * inv_factorial[counts[d]] % Self::MOD;
        }

        result = result * w % Self::MOD;
        result as i32
    }

    fn mod_inverse(a: i64, m: i64) -> i64 {
        let mut result = 1;
        let mut base = a;
        let mut p = m - 2;

        while p > 0 {
            if p & 1 == 1 {
                result = result * base % m;
            }
            base = base * base % m;
            p >>= 1;
        }

        result
    }

    fn comb(n: usize, k: usize, factorial: &[i64], inv_factorial: &[i64], m: i64) -> i64 {
        if k > n {
            return 0;
        }
        factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m
    }
}
",1441382752
EthanZyh,EthanZyh,186,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[int(1e10) for j in range(m)] for i in range(n)]
        f[0][0]=0
        q = [(0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y = heapq.heappop(q)
            d[(x,y)] = True
            if x==n-1 and y==m-1:
                return f[x][y]
            if x<n-1:
                t = max(f[x][y], moveTime[x+1][y])+1
                if t<f[x+1][y] and (x+1,y) not in d:
                    f[x+1][y]=t
                    heapq.heappush(q, (t,x+1,y))
            
            if x>=1:
                t = max(f[x][y], moveTime[x-1][y])+1
                if t<f[x-1][y] and (x-1,y) not in d:
                    f[x-1][y]=t
                    heapq.heappush(q, (t,x-1,y))
            
            if y<m-1:
                t = max(f[x][y], moveTime[x][y+1])+1
                if t<f[x][y+1] and (x,y+1) not in d:
                    f[x][y+1]=t
                    heapq.heappush(q, (t,x,y+1))
            
            if y>=1:
                t = max(f[x][y], moveTime[x][y-1])+1
                if t<f[x][y-1] and (x,y-1) not in d:
                    f[x][y-1]=t
                    heapq.heappush(q, (t,x,y-1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441307882
EthanZyh,EthanZyh,186,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        """"""
        :type moveTime: List[List[int]]
        :rtype: int
        """"""
        import heapq
        n = len(moveTime)
        m = len(moveTime[0])
        f = [[[int(1e10), int(1e10)] for j in range(m)] for i in range(n)]
        f[0][0][0]=0
        q = [(0,0,0,0)]
        heapq.heapify(q)
        d = {}
        while True:
            _,x,y,z = heapq.heappop(q)
            d[(x,y,z)] = True
            if x==n-1 and y==m-1:
                return f[x][y][z]
            if x<n-1:
                t = max(f[x][y][z], moveTime[x+1][y])+(z+1)
                if t<f[x+1][y][z^1] and (x+1,y,z^1) not in d:
                    f[x+1][y][z^1]=t
                    heapq.heappush(q, (t,x+1,y,z^1))
            
            if x>=1:
                t = max(f[x][y][z], moveTime[x-1][y])+(z+1)
                if t<f[x-1][y][z^1] and (x-1,y,z^1) not in d:
                    f[x-1][y][z^1]=t
                    heapq.heappush(q, (t,x-1,y,z^1))
            
            if y<m-1:
                t = max(f[x][y][z], moveTime[x][y+1])+(z+1)
                if t<f[x][y+1][z^1] and (x,y+1,z^1) not in d:
                    f[x][y+1][z^1]=t
                    heapq.heappush(q, (t,x,y+1,z^1))
            
            if y>=1:
                t = max(f[x][y][z], moveTime[x][y-1])+(z+1)
                if t<f[x][y-1][z^1] and (x,y-1,z^1) not in d:
                    f[x][y-1][z^1]=t
                    heapq.heappush(q, (t,x,y-1,z^1))
            
        # f[0][0] = 0
        # for i in range(n):
        #     for j in range(m):
        #         if i>=1:
        #             f[i][j] = min(f[i][j], max(f[i-1][j], moveTime[i][j])+1)
        #         if j>=1:
        #             f[i][j] = min(f[i][j], max(f[i][j-1], moveTime[i][j])+1)
        # return f[n-1][m-1]
                    ",1441315726
EthanZyh,EthanZyh,186,3636,python,"class Solution(object):
    def isBalanced(self, num):
        """"""
        :type num: str
        :rtype: bool
        """"""
        s = sum([int(num[i]) for i in range(len(num)) if i %2==0])
        t = sum([int(num[i]) for i in range(len(num)) if i %2==1])
        return s==t
        ",1441284111
EthanZyh,EthanZyh,186,3637,python,"class Solution(object):
    def countBalancedPermutations(self, num):
        """"""
        :type num: str
        :rtype: int
        """"""
        P = int(1e9+7)
        def Pow(a, b):
            ans = 1
            while b:
                if b%2==1:
                    ans = ans*a%P
                a = a*a%P
                b //= 2
            return ans
        ton = [0 for i in range(10)]
        n = len(num)
        num_list = [int(a) for a in num]
        S = sum(num_list)
        if S%2==1:
            return 0
        target = S//2
        for a in num:
            ton[int(a)] += 1
        N = 100
        fac = [0 for i in range(N)]
        ifac = [0 for i in range(N)]
        fac[0] = 1
        for i in range(1,N):
            fac[i]=fac[i-1]*i%P
        ifac[N-1] = Pow(fac[N-1], P-2)
        for i in range(N-2, -1, -1):
            ifac[i] = ifac[i+1] * (i+1) %P
        def C(n ,m):
            ans = (fac[n]*ifac[m]%P)*ifac[n-m]%P
            return ans
        f = [[[0 for k in range(target+1)] for j in range(n//2+1)] for i in range(11)]
        f[0][0][0] = 1
        used_pos = 0
        for i in range(10):
            for j in range(n//2+1):
                for k in range(target+1):
                    now = f[i][j][k]
                    if now==0:
                        continue
                    for l in range(ton[i]+1):
                        newK = k + l * i
                        newJ = j + l
                        if newK>target or newJ>n//2:
                            continue
                        f[i+1][newJ][newK] = (f[i+1][newJ][newK]+(now*C(n//2-j,l)%P)* \
                                              C(n-n//2-(used_pos-j),ton[i]-l))%P
            used_pos += ton[i]
        return f[10][n//2][target]
        ",1441358062
Vladislav,timetoai,189,3627,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0)]
        while h:
            t, i, j = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1
                    if (ni, nj) not in mem or mem[ni, nj] > nt:
                        mem[ni, nj] = nt
                        heappush(h, (nt, ni, nj))

        ",1441298463
Vladislav,timetoai,189,3628,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        mem = {(0, 0, 0): 0}
        n, m = map(len, (mt, mt[0]))
        h = [(0, 0, 0, 0)]
        while h:
            t, i, j, add = heappop(h)
            if i + 1 == n and j + 1 == m:
                return t
            if mem[i, j, add] < t:
                continue
            for ni, nj in ((i - 1, j), (i, j - 1), (i + 1, j), (i, j + 1)):
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(mt[ni][nj], t) + 1 + add
                    nadd = add ^ 1
                    if (ni, nj, nadd) not in mem or mem[ni, nj, nadd] > nt:
                        mem[ni, nj, nadd] = nt
                        heappush(h, (nt, ni, nj, nadd))

        ",1441302001
Vladislav,timetoai,189,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(1, len(num), 2)) == sum(int(num[i]) for i in range(0, len(num), 2))",1441280875
Vladislav,timetoai,189,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        cnt = [0] * 10
        for n in num:
            cnt[int(n)] += 1
        base = factorial(len(num) // 2) * factorial(len(num) - len(num) // 2)

        @cache
        def go(i, left, bal):
            if left == 0:
                if bal - sum(j * cnt[j] for j in range(i, 10)) == 0:
                    ret = base
                    for j in range(i, 10):
                        ret //= factorial(cnt[j])
                    return ret
                else:
                    return 0
            if i == 10:
                return 0
            if cnt[i] == 0:
                return go(i + 1, left, bal)
            res = 0
            for cur in range(0, min(left, cnt[i]) + 1):
                res += go(
                    i + 1, 
                    left - cur, 
                    bal + (2 * cur - cnt[i]) * i
                ) // factorial(cnt[i] - cur) // factorial(cur)
            return res

        return go(0, len(num) // 2, 0) % mod if sum(digit * cnt[digit] for digit in range(10)) % 2 == 0 else 0
        ",1441341525
Superultra,Superultra,191,3627,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + 1;
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441360320
Superultra,Superultra,191,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int di[] = {-1, 0, 1, 0};
const int dj[] = {0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        
        int n = A.size(), m = A[0].size();
        priority_queue<array<int, 4>, vector<array<int, 4>>, greater<array<int, 4>>> pq;

        int dist[n + 5][m + 5][2];
        memset(dist, 0x3f, sizeof(dist));

        pq.push({0, 0, 0, 0});
        dist[0][0][0] = 0;

        auto in = [&](int i, int j){
            return i >= 0 and i < n and j >= 0 and j < m;
        };

        while (pq.size()){
            auto [ds, i, j, p] = pq.top(); pq.pop();
            if (dist[i][j][p] != ds)
                continue;


            if (i == n - 1 and j == m - 1)
                return ds;
            
            for (int d = 0; d < 4; d++){
                int ni = i + di[d];
                int nj = j + dj[d];
                
                if (!in(ni, nj))
                    continue;
                // cout << ni << "" "" << nj << endl;
                
                int nd = max(ds, A[ni][nj]) + (p + 1);
                
                if (nd < dist[ni][nj][!p]){
                    dist[ni][nj][!p] = nd;
                    pq.push({nd, ni, nj, !p});
                }
            }
        }
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441359927
Superultra,Superultra,191,3636,cpp,"class Solution {
public:
    bool isBalanced(string S) {
        int e = 0, o = 0;
        for (int i = 0; i < S.size(); i++){
            if (i % 2 == 0)
                e += S[i] - '0';
            else
                o += S[i] - '0';
        }
        return e == o;
    }
};",1441361327
Superultra,Superultra,191,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define FOR(i, x, y) for (int i = x; i < y; i++)

#define ll long long

#define pb push_back
#define all(x) x.begin(), x.end()
#define sz(x) x.size()

#define pii pair<int, int>
#define f first
#define s second
#define mp make_pair

const int md = 1e9 + 7;

struct mint{
    int v;
    mint() : v(0) {}
    mint(ll v_) : v(int(v_ % md)){ if (v < 0) v += md; }
    explicit operator int() const{ return v; }
    friend std::ostream& operator << (std::ostream& out, const mint& n){ return out << int(n); }
    friend std::istream& operator >> (std::istream& in, mint& n){ ll v_; in >> v_; n = mint(v_); return in; }
 
    friend bool operator == (const mint& a, const mint& b){ return a.v == b.v; }
    friend bool operator != (const mint& a, const mint& b){ return a.v != b.v; }
    friend bool operator < (const mint& a, const mint& b){ return a.v < b.v; }
    friend bool operator <= (const mint& a, const mint& b){ return a.v <= b.v; }
    friend bool operator > (const mint& a, const mint& b){ return a.v > b.v; }
    friend bool operator >= (const mint& a, const mint& b){ return a.v >= b.v; }

    mint& operator += (const mint& o){ ((v += o.v) >= md) ? v -= md : 0; return *this; }
    mint& operator -= (const mint& o){ ((v -= o.v) < 0) ? v += md : 0; return *this; }
    mint& operator *= (const mint& o){ v = int((ll)v * o.v % md); return *this; }
    mint& operator /= (const mint& o){ return (*this) *= inv(o); }

    mint operator - () const{ return mint(-v); }
    friend mint operator + (mint a, const mint& b){ return a += b; }
    friend mint operator - (mint a, const mint& b){ return a -= b; }
    friend mint operator * (mint a, const mint& b){ return a *= b; }
    friend mint operator / (mint a, const mint& b){ return a /= b; }

    friend mint pow(mint a, ll p){ return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);	}
    friend mint inv(const mint& a){ return pow(a, md - 2); }
};

class Solution {
public:
    int countBalancedPermutations(string A) {
        vector<int> cnt(10, 0);
        int sum = 0;

        for (char c : A){
            cnt[c - '0']++;
            sum += (c - '0');
        }

        if (sum % 2){
            return 0;
        }

        int n = A.size();
        int targSz = n / 2;
        int targSum = sum / 2;

        mint dp[10][targSz + 5][targSum + 5];
        for (int i = 0; i < 10; i++)
            for (int j = 0; j <= targSz; j++)
                for (int k = 0; k <= targSum; k++)
                    dp[i][j][k] = 0;

        mint F[n + 5];
        F[0] = 1;

        for (int i = 1; i <= n; i++)
            F[i] = F[i - 1] * i;
        
        mint inv[n + 1][n + 1];
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= n; j++)
                inv[i][j] = 1 / (F[i] * F[j]);

        for (int i = 0; i < 10; i++){
            int mxSz = 0, mxSum = 0;
            for (int j = 0; j <= i; j++){
                mxSz += cnt[j];
                mxSum += cnt[j] * j;
            }
            for (int sz = 0; sz <= min(targSz, mxSz); sz++){
                for (int sum = 0; sum <= min(targSum, mxSum); sum++){
                    auto &cur = dp[i][sz][sum];
                    // Base
                    if (!i){
                        if (sum == 0 and sz <= cnt[i]){
                            cur = F[targSz] * F[n - targSz] / (F[sz] * F[(cnt[i] - sz)]);
                        }
                        // cout << i << "" "" << sz << "" "" << sum << "": "" << cur << endl;
                        // cout << F[targSz] << "" "" << 
                        continue;
                    }
                    for (int take = 0; take <= min(sz, cnt[i]) and sum - take * i >= 0; take++){
                        auto &temp = dp[i - 1][sz - take][sum - take * i];
                        cur += temp * inv[take][cnt[i] - take];
                    }
                }
            }
        }
        return dp[9][targSz][targSum].v;
    }
};
",1441341620
Reversal,ReversalGM,192,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0)]
        visited = set()
        while min_heap:
            cur_time, i, j = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j) in visited:
                continue
            visited.add((i, j))
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:
                    heapq.heappush(min_heap, (max(cur_time + 1, moveTime[new_i][new_j] + 1), new_i, new_j))
        return -1
                
                    
                    ",1441301107
Reversal,ReversalGM,192,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #djikstra
        m, n = len(moveTime), len(moveTime[0])
        min_heap = [(0, 0, 0, 1)]
        visited = set()
        while min_heap:
            cur_time, i, j, next_move_cost = heapq.heappop(min_heap)
            if (i, j) == (m - 1, n - 1):
                return cur_time
            if (i, j, next_move_cost) in visited:
                continue
            visited.add((i, j, next_move_cost))
            new_next_move_cost = 2 if next_move_cost == 1 else 1
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_i, new_j = i + dx, j + dy
                if 0 <= new_i < m and 0 <= new_j < n:
                    if new_next_move_cost == 2:
                        if (new_i, new_j, 1) not in visited and (new_i, new_j, 2) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
                    else:
                        if (new_i, new_j, 1) not in visited:
                            heapq.heappush(min_heap, (max(cur_time, moveTime[new_i][new_j]) + next_move_cost, new_i, new_j, new_next_move_cost))
        return -1
                
                    
                    ",1441313629
Reversal,ReversalGM,192,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        for idx, val in enumerate(num):
            if idx % 2 == 0:
                even_sum += int(val)
            else:
                odd_sum += int(val)
        return even_sum == odd_sum",1441282216
Reversal,ReversalGM,192,3637,python3,"class Solution:
    # even - odd
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        MOD = 10 ** 9 + 7
        required_evens = math.ceil(n / 2)
        required_odds = n - required_evens
        prev_ways = collections.Counter([(0, 0)])

        global_counter = collections.Counter([int(char) for char in num])

        picked_items = 0
        for val, val_count in global_counter.items():
            new_ways = collections.Counter()
            for (perm_sum, perm_even_count), perm_ways in prev_ways.items():
                for chosen_evens in range(val_count + 1):
                    chosen_odds = val_count - chosen_evens
                    new_perm_sum = perm_sum + ((chosen_evens - chosen_odds) * val)

                    even_spots_remaining = required_evens - perm_even_count
                    odd_spots_remaining = required_odds - (picked_items - perm_even_count)
                    
                    even_ways = math.comb(even_spots_remaining, chosen_evens) if even_spots_remaining > 0 else 1
                    odd_ways = math.comb(odd_spots_remaining, chosen_odds) if odd_spots_remaining > 0 else 1
                    if even_spots_remaining < chosen_evens:
                        break
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] += even_ways * odd_ways * perm_ways
                    new_ways[(new_perm_sum, perm_even_count + chosen_evens)] = new_ways[(new_perm_sum, perm_even_count + chosen_evens)] % MOD
                    
            picked_items += val_count
            prev_ways = new_ways
        return prev_ways[(0, required_evens)]
                
            ",1441367686
robezh765,robezh765,193,3627,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 1);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};",1441297593
robezh765,robezh765,193,3628,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;



class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = sz(moveTime), m = sz(moveTime[0]);
        vvi dis(n, vi(m, INF));
        dis[0][0] = 0;
        priority_queue<P, vector<P>, greater<P>> pque;
        pque.push({0, {0, 0}});
        pque.push({0, {0, 0}});
        auto in_bound = [&](int i, int j) {
            return i >= 0 && i < n && j >= 0 && j < m;
        };
        vi dx = {-1, 0, 1, 0}, dy = {0, -1, 0, 1};
        while(!pque.empty()) {
            auto p = pque.top(); pque.pop();
            int i = p.second.first, j = p.second.second;
            int d = p.first;
            if (dis[i][j] != d) continue;
            rep(di, 0, 4) {
                int ni = i + dx[di], nj = j + dy[di];
                if(in_bound(ni, nj)) {
                    int nxt_d = max(moveTime[ni][nj], d) + ((i + j) % 2 == 0 ? 1 : 2);
                    if(nxt_d < dis[ni][nj]) {
                        dis[ni][nj] = nxt_d;
                        pque.push({nxt_d, {ni, nj}});
                    }
                }
            }
        }
        return dis[n - 1][m - 1];
    }
};
",1441296978
robezh765,robezh765,193,3636,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;

class Solution {
public:
    bool isBalanced(string num) {
        int s = 1;
        int sum = 0;
        for (char c : num) {
            sum += s * int(c - '0');
            s *= -1;
        }
        return sum == 0;
    }
};
",1441281118
robezh765,robezh765,193,3637,cpp,"#define rep(i, a, b) for(int i = a; i < (b); ++i)
#define trav(a, x) for(auto& a : x)
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
#define subnb true
#define Lnb true
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<vvi> vvvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef pair<vi, vi> pvi;
const int mod =  (int)1e9 + 7;
const int INF = (int)2e9;
typedef pair<int, int> pii;
//typedef pair<pii, int> ppi;
typedef pair<int, pii> P;


const int MOD = (int)1e9 + 7;

struct mi {
    typedef decay<decltype(MOD)>::type T;
    /// don't silently convert to T
    T v; explicit operator T() const { return v; }
    mi() { v = 0; }
    mi(ll _v) {
        v = (-MOD < _v && _v < MOD) ? _v : _v % MOD;
        if (v < 0) v += MOD;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
//    friend void re(mi& a) { ll x; re(x); a = mi(x); }
//    friend str ts(mi a) { return ts(a.v); }

    mi& operator+=(const mi& m) {
        if ((v += m.v) >= MOD) v -= MOD;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += MOD;
        return *this; }
    mi& operator*=(const mi& m) {
        v = (ll)v*m.v%MOD; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, ll p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,MOD-2); }

    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
};


mt19937 rng(2333);
const int S = 400 * 2 + 1, M = 400;
mi rdp[2][41][S];

class Solution {
public:
    int countBalancedPermutations(string num) {
        int c0 = (sz(num) + 1) / 2, c1 = sz(num) - c0;
//        cout << sz(num) << endl;

        int nw = 1, la = 0;
        memset(rdp, 0, sizeof rdp);
//        vector<vector<vector<mi>>> dp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
        rdp[nw][0][M] = 1;
        vi cnt(10);

        int sum = 0;
        shuffle(all(num), rng);
        for (char c : num) {
            swap(nw, la);
            int x = c - '0';
            cnt[x]++;
            auto &ndp = rdp[nw];
            auto &dp = rdp[la];
            memset(rdp[nw], 0, sizeof rdp[nw]);
//            vector<vector<vector<mi>>> ndp(c0 + 1, vector<vector<mi>>(c1 + 1, vector<mi>(S)));
            rep(i, 0, c0 + 1) {
                rep(s, 0, S) {
                    if (s + x < S && i + 1 < c0 + 1) ndp[i + 1][s + x] += (i + 1) * dp[i][s];
                    if (s - x >= 0) ndp[i][s - x] += (sum - i + 1) * dp[i][s];
                }
            }
            sum += 1;

//            dp = ndp;
        }
        mi res = rdp[nw][c0][M];
//        return int(res);
        rep(i, 0, 10) {
            rep(j, 1, cnt[i] + 1) res /= j;
        }
        return int(res);
    }
};

",1441329938
Anshuman Tripathi,anshumantripathi878,194,3627,cpp,"class Solution {
public:
    int solve(vector<vector<int>>& moveTime) {
    int xxxx = moveTime.size(), yyyy = moveTime[0].size();
    vector<vector<int>> zzzz(xxxx, vector<int>(yyyy, INT_MAX));
    priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;

    zzzz[0][0] = 0;
    pq.push({0, 0, 0}); // (time, row, col)
    
    int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    
    while (!pq.empty()) {
        auto [timeNow, xx, yy] = pq.top();
        pq.pop();

        if (xx == xxxx - 1 && yy == yyyy - 1) return timeNow;
        
        for (auto& dir : directions) {
            int nx = xx + dir[0], ny = yy + dir[1];
            if (nx >= 0 && ny >= 0 && nx < xxxx && ny < yyyy) {
                int timeNext = max(timeNow + 1, moveTime[nx][ny] + 1);
                if (timeNext < zzzz[nx][ny]) {
                    zzzz[nx][ny] = timeNext;
                    pq.push({timeNext, nx, ny});
                }
            }
        }
    }
    
    return zzzz[xxxx - 1][yyyy - 1];
}

int minTimeToReach(vector<vector<int>>& moveTime) {
    return solve(moveTime);
}
};",1441308314
Anshuman Tripathi,anshumantripathi878,194,3628,python3,"import heapq
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        xxxx = len(moveTime)
        yyy = len(moveTime[0])
        
        zzzz = [[[float('inf')] * 2 for _ in range(yyy)] for _ in range(xxxx)]
        zzzz[0][0][0] = 0
        
        pq = []
        heapq.heappush(pq, (0, (0, 0, 0)))
        
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            
            if t > zzzz[i][j][p]:
                continue
            
            for di, dj in directions:
                ni = i + di
                nj = j + dj
                
                if 0 <= ni < xxxx and 0 <= nj < yyy:
                    nt = max(t, moveTime[ni][nj]) + (2 if p else 1)
                    
                    if nt < zzzz[ni][nj][1 - p]:
                        zzzz[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))
        
        return min(zzzz[xxxx - 1][yyy - 1][0], zzzz[xxxx - 1][yyy - 1][1])
",1441336487
Anshuman Tripathi,anshumantripathi878,194,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
         int evenSum = 0, oddSum = 0;
    for (int i = 0; i < num.size(); ++i) {
        if (i % 2 == 0)
            evenSum += num[i] - '0';
        else
            oddSum += num[i] - '0';
    }
    return evenSum == oddSum;
    }
};",1441287216
Anshuman Tripathi,anshumantripathi878,194,3637,cpp,"class Solution {
public:
    int MOD = 1e9 + 7;
    typedef long long ll;

    // Function to compute power modulo
    long long zzzzz(long long aaaaa, long long bbbbb, long long ccccc) {
        long long ddddd = 1;
        while (bbbbb > 0) {
            if (bbbbb % 2 == 1) {
                ddddd = (ddddd * aaaaa) % ccccc;
            }
            aaaaa = (aaaaa * aaaaa) % ccccc;
            bbbbb /= 2;
        }
        return ddddd;
    }

    void eeeee(vector<long long>& fffff, vector<long long>& ggggg, int hhhhh) {
        fffff.resize(hhhhh + 1, 1);
        for (int iiiii = 1; iiiii <= hhhhh; ++iiiii) {  // Changed `iiii` to `iiiii`
            fffff[iiiii] = fffff[iiiii - 1] * iiiii % MOD; // Use `iiiii` here
        }
        ggggg.resize(hhhhh + 1, 1);
        ggggg[hhhhh] = zzzzz(fffff[hhhhh], MOD - 2, MOD);
        for (int jjjjj = hhhhh - 1; jjjjj >= 0; --jjjjj) {
            ggggg[jjjjj] = ggggg[jjjjj + 1] * (jjjjj + 1) % MOD;
        }
    }

    // Function to compute the number of balanced permutations
    int countBalancedPermutations(string num) {
        int kkkkk = num.length();
        int lllll[10] = {0};
        ll mmmmm = 0;

        for (char nnnnn : num) {
            lllll[nnnnn - '0']++;
            mmmmm += (nnnnn - '0');
        }

        if (mmmmm % 2 != 0) {
            return 0;
        }

        ll ooooo = mmmmm / 2;
        int ppppp = (kkkkk + 1) / 2;

        vector<ll> qqqqq, rrrrr;
        eeeee(qqqqq, rrrrr, kkkkk);

        vector<vector<ll>> sssss(ppppp + 1, vector<ll>(ooooo + 1, 0));
        sssss[0][0] = 1;

        for (int ttttt = 0; ttttt < 10; ++ttttt) {
            int uuuuu = lllll[ttttt];
            vector<vector<ll>> vvvvv(ppppp + 1, vector<ll>(ooooo + 1, 0));
            for (int wwwww = 0; wwwww <= ppppp; ++wwwww) {
                for (ll xxxxx = 0; xxxxx <= ooooo; ++xxxxx) {
                    if (sssss[wwwww][xxxxx] == 0) continue;
                    int yyyyy = min(uuuuu, ppppp - wwwww);
                    for (int zzzzz = 0; zzzzz <= yyyyy; ++zzzzz) {
                        ll aaaaa = wwwww + zzzzz;
                        ll bbbbb = xxxxx + (ll)ttttt * zzzzz;
                        if (bbbbb > ooooo) continue;
                        vvvvv[aaaaa][bbbbb] = (vvvvv[aaaaa][bbbbb] + sssss[wwwww][xxxxx] * rrrrr[zzzzz] % MOD * rrrrr[uuuuu - zzzzz] % MOD) % MOD;
                    }
                }
            }
            sssss = vvvvv;
        }

        ll ccccc = sssss[ppppp][ooooo];

        ll ddddd = qqqqq[ppppp] * qqqqq[kkkkk - ppppp] % MOD;
        ddddd = ddddd * ccccc % MOD;

        return (int)ddddd;
    }
};
",1441375431
xlx2,xlx2,195,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        h = [(0, 0, 0)]
        f[0][0] = 0
        while h:
            t, i, j = heapq.heappop(h)
            if f[i][j] != t:
                continue
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + 1
                    if x < f[a][b]:
                        f[a][b] = x
                        heapq.heappush(h, (x, a, b))
        return f[-1][-1]",1441314344
xlx2,xlx2,195,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        f = [[math.inf] * n for _ in range(m)]
        vis = [[[0,0] for _ in range(n)] for _ in range(m)]
        h = [(0, 0, 0, 0)]
        f[0][0] = 0
        # vis[0][0][0] = 1
        while h:
            t, i, j, k = heapq.heappop(h)
            if vis[i][j][k]:
                continue
            vis[i][j][k] = 1
            if i == m-1 and j == n-1:
                break
            for a,b in (i-1, j), (i+1, j), (i, j-1), (i, j+1):
                if 0 <= a < m and 0 <= b < n:
                    x = max(t, moveTime[a][b]) + k+1
                    if vis[a][b][k^1] == 0:
                        if x < f[a][b]:
                            f[a][b] = x
                        heapq.heappush(h, (x, a, b, k^1))
        return f[-1][-1]",1441314113
xlx2,xlx2,195,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        s = sum(int(x) for x in num)
        s2 = sum(int(x) for x in num[::2])
        return s == 2 * s2",1441314562
xlx2,xlx2,195,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        if sum(int(x) for x in num) % 2:
            return 0

        M = 10**9 + 7
        n = len(num)
        p, q = (n+1)//2, n//2
        r = sum(int(v) for v in num) // 2
        c = [0] * 10
        for v in num:
            c[int(v)] += 1
        
        d = defaultdict(int)
        d[(0, 0, 0, 0)] = 1
        for i,v in enumerate(c):
            g = defaultdict(int)
            for j in range(v+1):
                for a,s,b,t in d:
                    if a+j <= p and b+v-j <= q and s+j*i <= r and t+(v-j)*i <= r:
                        x = d[(a,s,b,t)] * math.comb(a+j, j) * math.comb(b+v-j, v-j) % M
                        g[(a+j, s+j*i, b+v-j, t+(v-j)*i)] += x
            d = g
        
        return d[(p, r, q, r)] % M
",1441375631
Abhinav Nagar,abhinav_2696,197,3627,java,"class Solution {
    public int minTimeToReach(int[][] mt) {
        int r = mt.length;
        int c = mt[0].length;
        
        int[][] d = fn2(r, c);
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        fn3(pq, d);
        
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.isEmpty()) {
            int[] t = pq.poll();
            int ct = t[0], cr = t[1], cc = t[2];
            
            if (ct > d[cr][cc]) continue;
            
            fn4(pq, mt, d, dirs, ct, cr, cc, r, c);
        }
        
        return d[r - 1][c - 1];
    }
    void fn3(PriorityQueue<int[]> pq, int[][] d) {
        pq.offer(new int[]{0, 0, 0});
        d[0][0] = 0;
    }
    int[][] fn2(int r, int c) {
        int[][] d = new int[r][c];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                d[i][j] = Integer.MAX_VALUE;
            }
        }
        return d;
    }
    void fn4(PriorityQueue<int[]> pq, int[][] mt, int[][] d, int[][] dirs, int ct, int cr, int cc, int r, int c) {
        for (int[] dir : dirs) {
            int nr = cr + dir[0];
            int nc = cc + dir[1];
            
            if (nr >= 0 && nr < r && nc >= 0 && nc < c) {
                int nt = Math.max(ct, mt[nr][nc]) + 1;
                
                if (nt < d[nr][nc]) {
                    d[nr][nc] = nt;
                    pq.offer(new int[]{nt, nr, nc});
                }
            }
        }
    }
}",1441336597
Abhinav Nagar,abhinav_2696,197,3628,java,"class Solution {
    int fn3(int[][] mt) {
        return mt[0].length;
    }
    boolean fn6(int nr, int nc, int r, int c) {
        return nr >= 0 && nr < r && nc >= 0 && nc < c;
    }
    public int minTimeToReach(int[][] mt) {
        int r = fn2(mt), c = fn3(mt);
        int[][][] mtm = fn4(r, c);
        mtm[0][0][0] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        pq.add(new int[]{0, 0, 0, 0});
        
        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.isEmpty()) {
            int[] cur = pq.poll();
            int ct = cur[0], rw = cur[1], cl = cur[2], pr = cur[3];
            
            if (ct > mtm[rw][cl][pr]) continue;
            
            fn5(pq, dir, mt, mtm, ct, rw, cl, pr, r, c);
        }
        
        return Math.min(mtm[r - 1][c - 1][0], mtm[r - 1][c - 1][1]);
    }
    void fn5(PriorityQueue<int[]> pq, int[][] dir, int[][] mt, int[][][] mtm, int ct, int rw, int cl, int pr, int r, int c) {
        for (int[] d : dir) {
            int nr = rw + d[0], nc = cl + d[1];
            
            if (fn6(nr, nc, r, c)) {
                int nt = Math.max(ct, mt[nr][nc]) + (pr == 1 ? 2 : 1);
                
                if (nt < mtm[nr][nc][1 - pr]) {
                    mtm[nr][nc][1 - pr] = nt;
                    pq.add(new int[]{nt, nr, nc, 1 - pr});
                }
            }
        }
    }
    int fn2(int[][] mt) {
        return mt.length;
    }
    int[][][] fn4(int r, int c) {
        int[][][] mtm = new int[r][c][2];
        for (int i = 0; i < r; i++) {
            for (int j = 0; j < c; j++) {
                mtm[i][j][0] = Integer.MAX_VALUE;
                mtm[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return mtm;
    }
}",1441345445
Abhinav Nagar,abhinav_2696,197,3636,python3,"class Solution:
    def fn4(self, es, os):
        return es == os
        
    def fn3(self, i):
        return i % 2 == 0
        
    def fn2(self, c):
        return int(c) - 0
    
    def isBalanced(self, num: str) -> bool:
        es = 0
        os = 0
        for i in range(len(num)):
            d = self.fn2(num[i])
            if self.fn3(i):
                es += d
            else:
                os += d
        return self.fn4(es, os)",1441305485
Abhinav Nagar,abhinav_2696,197,3637,python3,"MOD = int(1e9 + 7)

class Solution:
    def fn3(self, dp, fq, fact, inv_fact, m, tgt):
        for d in range(10):
            if fq[d] == 0:
                continue
            for j in range(m, -1, -1):
                for k in range(tgt, -1, -1):
                    if dp[j][k] == 0:
                        continue
                    for c in range(1, min(fq[d], m - j) + 1):
                        if k + d * c > tgt:
                            break
                        cmb = fact[fq[d]] * inv_fact[c] % MOD * inv_fact[fq[d] - c] % MOD
                        dp[j + c][k + d * c] = (dp[j + c][k + d * c] + dp[j][k] * cmb) % MOD

    def fn2(self, a, b):
        res = 1
        a %= MOD
        while b > 0:
            if b & 1:
                res = res * a % MOD
            a = a * a % MOD
            b >>= 1
        return res
        
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        m = (n + 1) // 2
        l = n // 2
        fq = [0] * 10
        for c in num:
            fq[ord(c) - ord('0')] += 1
        s = sum(d * fq[d] for d in range(10))
        if s % 2 == 1:
            return 0
        tgt = s // 2
        fact = [1] * (n + 1)
        inv_fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i % MOD
        inv_fact[n] = self.fn2(fact[n], MOD - 2)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD
        dp = [[0] * (tgt + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        self.fn3(dp, fq, fact, inv_fact, m, tgt)
        dp_val = dp[m][tgt]
        if dp_val == 0:
            return 0
        ans = self.fn4(dp_val, fact, inv_fact, fq, m, l)
        return ans
    
    def fn4(self, dp_val, fact, inv_fact, fq, m, l):
        fact_m = fact[m]
        fact_l = fact[l]
        fact_fq = 1
        for d in range(10):
            fact_fq = fact_fq * fact[fq[d]] % MOD
        inv_fact_fq = self.fn2(fact_fq, MOD - 2)
        ans = dp_val * fact_m % MOD * fact_l % MOD * inv_fact_fq % MOD
        return ans
",1441388024
Orz,retired_kid,198,3627,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            Arrays.fill(dp[i], 1<<30);
        }
        dp[0][0] = 0;
        Queue<int[]> q = new LinkedList<>();
        q.add(new int[] {0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]] > Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1) {
                    dp[c[0] + dr[i]][c[1] + dc[i]] = Math.max(dp[c[0]][c[1]], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i]});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441294378
Orz,retired_kid,198,3628,java,"class Solution {
    int[] dr = new int[] {-1, 1, 0, 0}, dc = new int[] {0, 0, -1, 1};
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[1].length;
        int[][][] dp = new int[n + 1][m + 1][2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                Arrays.fill(dp[i][j], 1<<30);
            }
        }
        dp[0][0][0] = 0;
        PriorityQueue<int[]> q = new PriorityQueue<>(Comparator.comparingInt(v -> v[3]));
        q.add(new int[] {0, 0, 0, 0});
        while (!q.isEmpty()) {
            int[] c = q.poll();
            int k = c[2];
            for (int i = 0; i < 4; i++) {
                if (valid(c[0] + dr[i], c[1] + dc[i], n, m) && dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] >
                        Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k) {
                    dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1] = Math.max(dp[c[0]][c[1]][k], moveTime[c[0] + dr[i]][c[1] + dc[i]]) + 1 + k;
                    q.add(new int[] {c[0] + dr[i], c[1] + dc[i], k ^ 1, dp[c[0] + dr[i]][c[1] + dc[i]][k ^ 1]});
                }
            }
        }
        return Arrays.stream(dp[n - 1][m - 1]).min().getAsInt();
    }
    boolean valid(int i, int j, int n, int m) {
        return i>=0 && j>=0 && i<n && j<m;
    }
}",1441299893
Orz,retired_kid,198,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length(), e = 0, o = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) e+=num.charAt(i)-'0';
            else o+=num.charAt(i)-'0';
        }
        return e == o;
    }
}",1441281401
Orz,retired_kid,198,3637,java,"class Solution {
    static long[] inv, f;
    static boolean init = false;
    static int mod = (int) 1e9 + 7, MM = 10;
    Map<Integer, Integer>[][] dp;
    Map<Integer, Integer> cnt = new HashMap<>();
    public int countBalancedPermutations(String num) {
        if (!init) {
            fc();
        }
        int n = num.length();
        dp = new Map[MM][n + 1];
        for (int i = 0; i < MM; i++) {
            for (int j = 0; j < n; j++) {
                dp[i][j] = new HashMap<>();
            }
        }
        for (int i = 0; i < n; i++) {
            int v = num.charAt(i) - '0';
            cnt.put(v, cnt.getOrDefault(v, 0) + 1);
        }
        return dfs(0, n / 2, 0, n);
    }
    public int dfs(int d, int even, int s, int n) {
        // System.out.println(even + "" "" + d);
        if (d == MM) return s == 0 && even == 0 ? 1 : 0;
        else if (dp[d][even].containsKey(s)) return dp[d][even].get(s);
        long ret = 0;
        int ct = cnt.getOrDefault(d, 0);
        for (int j = 0; j <= Math.min(ct, even); j++) { // how many we put at left / right
            long p = ( C(even, j) % mod * C(n - even, (ct - j)) % mod * dfs(d + 1, even - j, s + (j * d) - (ct - j) * d, n - ct) % mod ) % mod;
            ret += p;
            ret %= mod;
        }
        dp[d][even].put(s, (int) ret);
        return (int) ret;
    }
    static void fc() {
        init = true;
        inv = new long[100]; f = new long[100];
        f[0] = inv[0] = 1;
        for (int i = 1; i < 100; i++) {
            f[i] = (f[i-1] % mod * i % mod) % mod;
            inv[i] = pow(f[i], mod-2);
        }
    }
    public static long C(int n, int r) {
        // System.out.println(n + "" "" + r);
        if (n < r) return 0;
        return (f[n] % mod * inv[r] % mod * inv[n-r] % mod) % mod;
    }
    static long pow (long x, long exp){
        if (exp==0) return 1;
        long t = pow(x, exp/2);
        t = t*t % mod;
        if (exp%2 == 0) return t;
        return t*x % mod;
    }
}",1441375957
Chuan-Chih Chou,chuan-chih,199,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0)]
        while heap:
            t, i, j = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y))
        
                    
            ",1441300467
Chuan-Chih Chou,chuan-chih,199,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        visited = [[math.inf] * m for _ in range(n)]
        visited[0][0] = 0
        heap = [(0, 0, 0, False)]
        while heap:
            t, i, j, p = heappop(heap)
            if t > visited[i][j]:
                continue
            if (i, j) == (n - 1, m - 1):
                return t
            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:
                if 0 <= x < n and 0 <= y < m and (new_t := 1 + p + max(t, moveTime[x][y])) < visited[x][y]:
                    visited[x][y] = new_t
                    heappush(heap, (new_t, x, y, not p))",1441303185
Chuan-Chih Chou,chuan-chih,199,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(d) for d in num[::2]) == sum(int(d) for d in num[1::2])",1441281012
Chuan-Chih Chou,chuan-chih,199,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10 ** 9 + 7
        n = len(num) // 2
        total, p = divmod(sum(int(d) for d in num), 2)
        if p:
            return 0
        f = [1, 1]
        for i in range(2, len(num) + 1):
            f.append(f[-1] * i % mod)
        count = [0] * 10
        for d in num:
            count[int(d)] += 1
        base = [0] * 10
        b = 1
        for i, c in enumerate(count):
            base[i] = b
            b *= (c + 1)
        
        def decode(b):
            c = []
            x = b
            for curr in reversed(base):
                d, x = divmod(x, curr)
                c.append(d)
            c.reverse()
            return c
        
        nom = f[n] * f[len(num) - n] % mod
        
        @cache
        def recur(d, used, s):
            if d == 10:
                if used != n:
                    return 0
                if s != total:
                    return 0
                return nom
            to_use = n - used
            ans = 0
            for use in range(min(to_use, count[d]) + 1):
                factor = pow(f[use], -1, mod) * pow(f[count[d] - use], -1, mod) % mod
                ans += recur(d + 1, used + use, s + use * d) * factor % mod
            # print(d, used, s, ans)
            return ans % mod
            
            
        return recur(0, 0, 0)
        
            ",1441376296
Jasper,JasperT37449,200,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
        pq.push({0, {0, 0}});
        int t, i, j;
        vector<vector<int>> time(n+1, vector<int>(m+1, 1e9));
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+1, moveTime[i+1][j]+1), {i+1, j}});
            if(j+1<=m)pq.push({max(t+1, moveTime[i][j+1]+1), {i, j+1}});
            if(i-1>=0)pq.push({max(t+1, moveTime[i-1][j]+1), {i-1, j}});
            if(j-1>=0)pq.push({max(t+1, moveTime[i][j-1]+1), {i, j-1}});
        }
        return t;
    }
};",1441313753
Jasper,JasperT37449,200,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size()-1, m = moveTime[0].size()-1;
        priority_queue<pair<int, pair<int ,pair<int, int>>>, vector<pair<int, pair<int, pair<int, int>>>>, greater<pair<int, pair<int, pair<int, int>>>>> pq;
        pq.push({0, {0, {0, 1}}});
        int t, i, j, turn;
        vector<vector<bool>> vis(n+1, vector<bool>(m+1, 0));
        while(!pq.empty()){
            t = pq.top().first, i = pq.top().second.first, j = pq.top().second.second.first, turn = pq.top().second.second.second%2;
            if(!turn)turn = 2;
            pq.pop();
            if(vis[i][j])continue;
            vis[i][j] = true;
            //cout<<""T : ""<<t<<"" ""<<i<<"" ""<<j<<endl;
            if(i==n && j==m)return t;
            if(i+1<=n)pq.push({max(t+turn, moveTime[i+1][j]+turn), {i+1, {j, turn+1}}});
            if(j+1<=m)pq.push({max(t+turn, moveTime[i][j+1]+turn), {i, {j+1, turn+1}}});
            if(i-1>=0)pq.push({max(t+turn, moveTime[i-1][j]+turn), {i-1, {j, turn+1}}});
            if(j-1>=0)pq.push({max(t+turn, moveTime[i][j-1]+turn), {i, {j-1, turn+1}}});
        }
        return t;
    }
};",1441328086
Jasper,JasperT37449,200,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd = 0, even = 0;
        for(int i = 0;i<num.size();i++){
            if(i%2==0){
                odd+=num[i]-48;
            }
            else {
                even+=num[i]-48;
            }
        }
        if(odd==even)return true;
        return false;
    }
};",1441282589
Jasper,JasperT37449,200,3637,cpp,"typedef long long ll;

class Solution {
public:
    ll power(ll a, ll b, ll mod) {
        ll res = 1;
        a %= mod;
        while(b >0){
            if(b &1){
                res = res * a % mod;
            }
            a = a *a % mod;
            b >>=1;
        }
        return res;
    }

    int countBalancedPermutations(string num) {
        int n = num.size(), cnt[10] = {0}, sum =0, mod = 1e9 + 7;
        for(char c: num){
            cnt[c - '0']++;
            sum += (c - '0');
        }
        if(sum %2 !=0)return 0;
        ll s = sum /2;
        int k = (n+1)/2;
        vector<ll> fact(n+1,1), table(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] *i % mod;
        table[n] = power(fact[n], mod-2, mod);
        for(int i=n-1;i>=0;i--) table[i] = table[i+1] * (i+1) % mod;
        vector< vector<ll> > prev(k+1, vector<ll>(s+1, 0));
        prev[0][0] =1;
        for(int d=0; d<=9; d++){
            int c_d = cnt[d];
            vector< vector<ll> > curr(k+1, vector<ll>(s+1, 0));
            for(int k_prev=0; k_prev <=k; k_prev++){
                for(int s_prev=0; s_prev <=s; s_prev++){
                    if(prev[k_prev][s_prev] ==0) continue;
                    for(int x=0; x<=c_d; x++){
                        if(k_prev +x >k) break;
                        if((ll)s_prev + (ll)d *x >s) break;
                        int new_k = k_prev +x, new_s = s_prev + d *x;
                        ll val = prev[k_prev][s_prev];
                        val = val * table[x] % mod;
                        val = val * table[c_d -x] % mod;
                        curr[new_k][new_s] = (curr[new_k][new_s] + val) % mod;
                    }
                }
            }
            prev = move(curr);
        }
        if(k >n || s > 9*80)return 0;
        ll res = fact[k];
        res = res * fact[n -k] % mod;
        res = res * prev[k][s] % mod;
        return res;
    }
};",1441376524
lu-chen-chen,lu-chen-chen,201,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t + 1, moveTime[x][y] + 1)});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441298612
lu-chen-chen,lu-chen-chen,201,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int[][] dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dis = new int[m][n];
        PriorityQueue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[2]));
        queue.add(new int[]{0, 0, 0});
        boolean[][] vis = new boolean[m][n];
        while (!queue.isEmpty()) {
            int[] remove = queue.remove();
            int i = remove[0];
            int j = remove[1];
            int t = remove[2];
            if (vis[i][j]) {
                continue;
            }
            vis[i][j] = true;
            dis[i][j] = t;
            for (int[] d : dxy) {
                int x = i + d[0];
                int y = j + d[1];
                if (x >= 0 && x < m && y >= 0 && y < n && !vis[x][y]) {
                    queue.add(new int[]{x, y, Math.max(t, moveTime[x][y]) + 1 + (x + y + 1) % 2});
                }
            }
        }
        return dis[m - 1][n - 1];
    }
}",1441305940
lu-chen-chen,lu-chen-chen,201,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int a = 0;
        int b = 0;
        char[] chars = num.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            if (i % 2 == 0) {
                a += chars[i] - '0';
            } else {
                b += chars[i] - '0';
            }
        }
        return a == b;
    }
}",1441281556
lu-chen-chen,lu-chen-chen,201,3637,java,"import java.math.BigInteger;
class Solution {
    public int countBalancedPermutations(String num) {
        long mod = (long) (1e9 + 7);
        char[] chars = num.toCharArray();
        int n = chars.length;
        int sum = 0;
        int[] cnt = new int[10];
        for (char c : chars) {
            cnt[c - '0']++;
            sum += c - '0';
        }
        if (sum % 2 == 1) {
            return 0;
        }
        Factorial fac = new Factorial(n + 5, (int) mod);
        long[][][] dp = new long[10][n / 2 + 1][sum / 2 + 1];
        for (int i = 0; i <= Math.min(cnt[0], n / 2); i++) {
            dp[0][i][0] = 1;
        }
        int curCnt = cnt[0];
        for (int i = 1; i < 10; i++) {
            curCnt += cnt[i];
            for (int j = 0; j <= n / 2; j++) {
                for (int k = 0; k <= sum / 2; k++) {
                    for (int l = 0; l <= cnt[i]; l++) {
                        int j1 = j + l;
                        int k1 = k + l * i;
                        if (j1 > n / 2 || k1 > sum / 2) {
                            break;
                        }
                        dp[i][j1][k1] += fac.comb(j1, l) * dp[i - 1][j][k] % mod * fac.comb(curCnt - j1, cnt[i] - l) % mod;
                        dp[i][j1][k1] %= mod;
                    }
                }
            }
        }
        long ans = dp[9][n / 2][sum / 2];
        return (int) ((ans + mod) % mod);
    }
}

class Factorial {
    long[] fac;
    long[] inv;
    long mod;

    public Factorial(long[] fac, long[] inv, long mod) {
        this.mod = mod;
        this.fac = fac;
        this.inv = inv;
        fac[0] = inv[0] = 1;
        int n = fac.length;
        for (int i = 1; i < n; i++) {
            fac[i] = i;
            fac[i] = (int) (fac[i] * fac[i - 1] % mod);
        }
        inv[n - 1] = BigInteger.valueOf(fac[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();
        for (int i = n - 2; i >= 1; i--) {
            inv[i] = (int) (inv[i + 1] * (i + 1) % mod);
        }
    }

    public Factorial(int limit, int mod) {
        this(new long[Math.min(limit + 1, mod)], new long[Math.min(limit + 1, mod)], mod);
    }

    public long getMod() {
        return mod;
    }

    public long fac(int n) {
        if (n >= mod) {
            return 0;
        }
        return fac[n];
    }

    public long inv(int n) {
        if (n >= mod) {
            throw new IllegalArgumentException();
        }
        return inv[n];
    }

    public long comb(int n, int m) {
        if (n < m) {
            return 0;
        }
        return fac[n] * inv[m] % mod * inv[n - m] % mod;
    }

    public long combInv(int n, int m) {
        if (n < m) {
            throw new IllegalArgumentException();
        }
        return inv[n] * fac[m] % mod * fac[n - m] % mod;
    }
}",1441364181
unnu,unnu,202,3627,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty]+1,t+1);
                    if(dis[tx][ty]>t1){
                        st.erase({dis[tx][ty],tx,ty});
                        st.insert({t1,tx,ty});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
        
    }
};",1441302269
unnu,unnu,202,3628,cpp,"class Solution {
public:
    bool f(int x,int y,int n,int m){ return (x>=0 && y>=0 && x<n && y<m);}
 
    int minTimeToReach(vector<vector<int>>& mt) {
        int n=mt.size();
        int m=mt[0].size();
        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        set<vector<int>>st;
        st.insert({0,0,0,0});
        dis[0][0]=0;
        vector<int>dx={-1,0,1,0};
        vector<int>dy={0,1,0,-1};
        while(st.size()){
            auto it=st.begin();
            auto v=(*it);st.erase(it);
            int t=v[0],x=v[1],y=v[2],z=v[3];
            for(int i=0;i<4;i++){
                int tx=x+dx[i],ty=y+dy[i];
                if(f(tx,ty,n,m)){
                    int t1=max(mt[tx][ty],t);
                    if(z%2==0) t1+=1;
                    else t1+=2;
                    if(dis[tx][ty]>t1){
                        // st.erase({dis[tx][ty],tx,ty,});
                        st.insert({t1,tx,ty,1-z});
                        dis[tx][ty]=t1;
                    }
                }
            }
            
        }
        return dis[n-1][m-1];
    }
};",1441305679
unnu,unnu,202,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int x=0;int y=0;int n=num.size();
        for(int i=0;i<n;i++){
            if(i%2) x+=(num[i]-'0');
            else y+=(num[i]-'0');
        }
        return (x==y);
    }
};",1441289924
unnu,unnu,202,3637,cpp,"#define ll long long
class Solution {
public:
    const int mod=1e9+7;
    ll dp[12][41][365];
    vector<int>freq;int p;
    vector<ll>fact,invf;

ll power(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1)
        {
            res=(res*a)%mod;
        }
        a=(a*a)%mod;
        b>>=1;
    }
    return res;
}

void precompute(int n)
{
    fact.resize(n+1);
    invf.resize(n+1);
    fact[0]=1;
    for(int i=1;i<=n;i++)
    {
        fact[i]=(fact[i-1]*i)%mod;
    }
    invf[n]=power(fact[n],mod-2);
    for(int i=n-1;i>=0;i--)
    {
        invf[i]=(invf[i+1]*(i+1))%mod;
    }
}

ll nCr(int n,int r)
{
    if(r>n)
    {
        return 0;
    }
    ll ans=(invf[r])%mod;
    ans=(ans*invf[n-r])%mod;
    return ans;
}
    ll f(int idx,int cnt,int sum,int k){
        // int n=v.size();
        // int p=n/2;
        // if(idx>=n && sum==k && cnt==p) return 1;
        // if(idx>=n || sum>k || cnt>p) return 0;
        // if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        // ll take=f(idx+1,cnt+1,sum+v[idx],k,v);
        // ll nt=f(idx+1,cnt,sum,k,v);
        // ll ans=(take+nt)%mod;
        // return dp[idx][cnt][sum]=ans;
        
        int n=freq.size();
        if(idx>=n && sum==k && cnt==p) {
          //  cout<<sum<<"" ""<<cnt<<endl;
            return 1;
        }
        if(idx>=n || sum>k || cnt>p) return 0;
        if(dp[idx][cnt][sum]!=-1) return dp[idx][cnt][sum];
        ll take=0,nt=0;ll res=0;
        for(int i=0;i<=freq[idx];i++){
            take=(f(idx+1,cnt+i,sum+(i)*idx,k)*nCr(freq[idx],(i)))%mod;
           // nt=(f(idx+1,cnt+i,sum+(i*idx),k)*nCr(freq[idx],i))%mod;
            //cout<<take<<"" ""<<nt<<"" p""<<i<<endl;
            res+=((take%mod))%mod;
            res%=mod;
            res=(res+mod)%mod;
        }
         //nt=(f(idx+1,cnt+freq[idx],sum+(freq[idx]*idx),k))%mod;
        // res+=(nt%mod);
        // res%=mod;
        // res=(res+mod)%mod;
       // cout<<idx<<"" ""<<cnt<<"" ""<<sum<<"" ""<<res<<endl;
        return dp[idx][cnt][sum]=res;
    }
    int countBalancedPermutations(string num) {
        vector<int>v;freq.resize(10,0);precompute(81);
        for(auto ch:num) v.push_back(ch-'0');
        int k=0;p=v.size()/2;
        for(auto it:v) k+=it,freq[it]++;
        if(k%2) return 0;
        memset(dp,-1,sizeof(dp));
        ll ans=(fact[p]*fact[v.size()-p])%mod;
        ll tmp=f(0,0,0,k/2)%mod;
        ll res=(ans*tmp)%mod;
        res=(res+mod)%mod;
        return res;
        
        
        // return f(0,0,0,k/2);
    }
};",1441385344
op33,op33,203,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        visited = set()
        queue = [(0, (0,0))]
        while queue:
            time, (row, col) = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    heapq.heappush(queue, (ntime, (nr, nc)))
            

        # should always return earlier",1441297937
op33,op33,203,3628,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # dijkstra/bfs kind of
        # check the soonest time that you can move and where you are
        # Mark as visited when you add a neighbor, since no future route can move there faster (including the +1 move time)
        # The queue will have at most nxm nodes inside
        # minheap/queue
        # pop a node, then find its neighbors. if a neighbor has been seen, do nothing. if it is the endpoint, return the answer. otherwise add to queue with +1 time as (time, (i,j))
        # if a neighbor has a minimum time, then check current time + 1 and compare with min time + 1 and the larger will be the time of the neighbor
        # another variable to track move parity
        visited = set()
        queue = [(0, (0,0), True)]
        while queue:
            time, (row, col), parity = heapq.heappop(queue)
            if row == len(moveTime) - 1 and col == len(moveTime[0]) - 1:
                return time

            for dr, dc in {(0,1), (1,0), (-1,0), (0,-1)}:
                nr, nc = row + dr, col + dc
                if 0 <= nr < len(moveTime) and 0 <= nc < len(moveTime[0]) and (nr, nc) not in visited:
                    visited.add((nr, nc))
                    ntime = max(time + 1, moveTime[nr][nc] + 1)
                    if not parity:
                        ntime += 1
                    heapq.heappush(queue, (ntime, (nr, nc), not parity))
            

        # should always return earlier",1441300716
op33,op33,203,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens, odds = 0, 0
        for i, char in enumerate(num):
            digit = int(char)
            if i % 2 == 0:
                evens += digit
            else:
                odds += digit
        return evens == odds",1441283006
op33,op33,203,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        # naively you can compute n! perms * n to count all
        # They must sum to sum(num) / 2 which must be even in total
        # sum(num) // 2 = S
        # how many subsets will sum to S? -> This is a known problem, N^2
        # How many permutations of each of these subsets are there as well
        # If a subset has duplicates, you need to divide by m! for each duplicate for overcounting
        # num.length is max 80 which can make it easier
        # Can manually go through each distinct subset after collecting each?
        # Or can iteratively build a count and correct for overcounting at each step?
        # What if you track each counts of each digit set, such as {7:2,9:1} -> 2
        # Or track each sum -> unique digit sets such as 21 -> {{7:3}, {8:2, 5:1}}
        # This is an option but might be too slow/memory(?)

        # count each digit and then do coin change like dp?
        # This could work since you can iteratively build the denominator at each step
        # For example, if there are 3 2s available and you choose to use 3 of them, then you eventually need to overcorrect by a factor of 3!, so you can pass that down in the dp process, no matter what is chosen later.
        # need to store num_elems so far chosen, denominator so far, index, sum so far
        # also need to store denom for the other subset
        # Forgot that num elems must match or be off by 1 at most
        # Also if sum > S at any point, early break
        # If num elems is > half at any point, only add 0 elems in future.
        # maybe set1 is evens, set2 is odds. Can have at most 1 extra for either by the end -> No only even can have more
        # maybe can reduce time using symmetry of even/odd sets?? maybe only if even digits_count
        # If odd digit count, then there will be exactly 1 extra even compared to odds
        # Do we need denom1/denom2 in the cache state? No? Can just divide on demand when receiving the output
        # 851350267
        
        MOD = 10**9 + 7

        @cache
        def factorial(n):
            if n == 0:
                return 1
            answer = 1
            for i in range(1, n + 1):
                answer *= i
            return answer

        digits = [int(char) for char in num]
        digits_count = len(digits)
        evens_digit_count = digits_count // 2
        if digits_count % 2 == 1:
            evens_digit_count += 1

        T = sum(digits)
        if T % 2 == 1:
            return 0
        
        S = T // 2

        counts = list(Counter(digits).items())
        counts = sorted(counts) # ex - [(0, 5), (1, 2), (3, 1), ... (9, 1)]

        @cache
        def count_bal_perms(idx, sum_so_far, num_elems):
            if idx == len(counts):
                if sum_so_far == S and num_elems == evens_digit_count:
                    total1 = factorial(num_elems) # should always divide cleanly
                    total2 = factorial(digits_count - num_elems)
                    return total1 * total2
                else:
                    return 0

            cur_dig, count = counts[idx]
            bal_perms = 0
            for i in range(count + 1):
                new_num_elems = num_elems + i
                new_sum = sum_so_far + i * cur_dig
                if new_num_elems > evens_digit_count or new_sum > S:
                    continue

                denom1, denom2 = factorial(i), factorial(count - i)

                bal_perms += count_bal_perms(idx + 1, new_sum, new_num_elems) // denom1 // denom2

            return bal_perms

        return count_bal_perms(0, 0, 0) % MOD
            
        ",1441379448
user9821NM,user9821NM,204,3627,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<int>>dist(n, vector<int>(m, INT_MAX));
        
        set<tuple<int,int,int>>q; q.insert({0, 0, 0}); dist[0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y] = *q.begin(); q.erase(*q.begin());
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && dist[X][Y] > max(dist[x][y] + 1, moveTime[X][Y] + 1)) {
                    q.erase({dist[X][Y], X, Y});
                    dist[X][Y] =  max(dist[x][y] + 1, moveTime[X][Y] + 1);
                    q.insert({dist[X][Y], X, Y});
                }
            }
        };
        
        return dist[n - 1][m - 1];
    }
};",1441344848
user9821NM,user9821NM,204,3628,cpp,"class Solution {
public:
    
    const int dx[4] = {0, 0, +1, -1};
    const int dy[4] = {-1, +1, 0, 0};
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        
        vector<vector<vector<int>>>dist(n, vector<vector<int>>(m, vector<int>(2, INT_MAX)));
        
        set<tuple<int,int,int,int>>q; q.insert({0, 0, 0, 0}); dist[0][0][0] = 0;
        
        while(!q.empty()) {
            auto [distance, x, y, move] = *q.begin(); q.erase(*q.begin());
            
            int cost = ((move ^ 1) ? 1 : 2);
            
            for(int i = 0; i < 4; i++) {
                int X = x + dx[i], Y = y + dy[i];
                if(X >= 0 && Y >= 0 && X < n && Y < m && 
                    dist[X][Y][move ^ 1] > max(dist[x][y][move] + cost, moveTime[X][Y] + cost)) {
                    q.erase({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                    dist[X][Y][move ^ 1] =  max(dist[x][y][move] + cost, moveTime[X][Y] + cost);
                    q.insert({dist[X][Y][move ^ 1], X, Y, (move ^ 1)});
                }
            }
        };
        
        return min(dist[n - 1][m - 1][0], dist[n - 1][m - 1][1]);
    }
};",1441351431
user9821NM,user9821NM,204,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        vector<int>sum(2);
        for(int i = 0;i < num.size(); i++) {
            sum[i % 2] += num[i] - '0';
        }
        
        return sum[0] == sum[1];
    }
};",1441326964
user9821NM,user9821NM,204,3637,cpp,"class Solution {
public:
    const int MOD = 1e9 + 7;
    
    int expo(int a, int b) {
        int res = 1;
        while(b) {
            if(b & 1) res = (1ll * res * a) % MOD;
            b >>= 1; a = (1ll * a * a) % MOD;
        }
        return res;
    }
    
    int countBalancedPermutations(string num) {
        vector<int>fr(10), fact(num.size() + 1, 1), ifact(num.size() + 1, 1); int sum = 0;
        for(auto &i : num) fr[i - '0']++, sum += (i - '0');
                
        if((sum % 2 == 1)) return 0;
        
        for(int i = 1; i <= num.size(); i++) {
            fact[i] = (1ll * i * fact[i - 1]) % MOD;
            ifact[i] = expo(fact[i], MOD - 2);
        }
                        
        vector<vector<vector<int>>>dp(10, vector<vector<int>>(num.size() / 2 + 1, vector<int>(sum + 1, -1)));
        
        int permutationsCount = (1ll * fact[num.size() / 2] * fact[(num.size() + 1) / 2]) % MOD;
        
        auto f = [&](int number, int taken, int currentSum, auto &&self) -> int {            
            if(number == 10) {
                return (currentSum == sum / 2 && taken == num.size() / 2 ? permutationsCount : 0);
            }
            
            if(dp[number][taken][currentSum] != -1) return dp[number][taken][currentSum];
            
            int ways = 0;
            
            for(int i = 0; i <= min(fr[number], (int) num.size() / 2 - taken); i++) {
                ways = (ways + (1ll * (1ll * ifact[i] * ifact[fr[number] - i]) % MOD * self(number + 1, taken + i, currentSum + i * number, self)) % MOD) % MOD;
            }
            
            return dp[number][taken][currentSum] = ways;
        };
        
        return f(0, 0, 0, f);
    }
};",1441379576
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue

                new_cost = max(c, moveTime[x][y]) + 1
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441295323
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])

        h = []
        d = [[-1] * m  for _ in range(n)]

        d[0][0] = 0
        heappush(h, (d[0][0], (0, 0)))

        vectors = [
            (-1, 0), (0, 1), (1, 0), (0, -1)
        ]

        while h:
            c, (u, v) = heappop(h)
            if d[u][v] != c:
                continue

            for vec in vectors:
                x, y = u + vec[0], v + vec[1]
                if x < 0 or x >= n or y < 0 or y >=m:
                    continue
                extra_cost = 0 if (x + y) & 1 else 1
                new_cost = max(c, moveTime[x][y]) + 1 + extra_cost
                if d[x][y] == -1 or d[x][y] > new_cost:
                    d[x][y] = new_cost
                    heappush(h, (new_cost, (x, y)))
        return d[n-1][m-1]
            ",1441307109
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0

        for i in range(len(num)):
            if i & 1:
                odd += (ord(num[i]) - ord('0'))
            else:
                even += (ord(num[i]) - ord('0'))
        return odd == even",1441281363
Ngoc-Cuong Nguyen,ngoccuongpvc,205,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        digits_freq = [0] * 10
        for c in num:
            digits_freq[ord(c) - ord('0')] += 1
        s = 0
        for i in range(10):
            s += i * digits_freq[i]

        if s & 1:
            return 0

        MOD = 10**9 + 7
        
        @lru_cache(None)
        def c(n, k): 
            if k == 0:
                return 1
            if n == k:
                return 1
            else:
                return (c(n-1, k-1) + c(n-1, k)) % MOD

        @lru_cache(None)
        def dp(d, diff, n_even, n_odd):
            if n_even < 0 or n_odd < 0:
                return 0

            if d == -1:
                return 1 if diff == 0 else 0

            res = 0
            for e in range(digits_freq[d] + 1):
                remain_even = n_even-e
                remain_odd = n_odd-(digits_freq[d]-e)
                if remain_even < 0 or remain_odd < 0:
                    continue

                temp = dp(d-1, diff + e*d - (digits_freq[d]-e)*d, remain_even, remain_odd)
                temp = (temp * c(n_even, e) * c(n_odd, digits_freq[d]-e)) % MOD
                res = (res + temp) % MOD
            return res
            
        return dp(9, 0, (len(num) + 1) // 2, len(num) // 2)",1441385680
Anuj Anand,coleworld223,206,3627,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 1};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312661
Anuj Anand,coleworld223,206,3628,cpp,"using i64 = long long;
i64 dis[800][800][2];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
      using i64 = long long;
      const i64 INF = 1e18;
      int n = g.size();
      int m = g[0].size();
      int vis[n][m][2];
      for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
          for (int k = 0; k < 2; ++k) {
            dis[i][j][k] = INF;
            vis[i][j][k] = 0;
          }
        }
      }
      
      auto valid = [&] (int x, int y) -> bool {
        return x >= 0 and x < n and y >= 0 and y < m;
      };
      array <int, 2> c = {1, 2};
      priority_queue <array <i64, 4>> pq;
      dis[0][0][0] = 0;
      pq.push({0, 0, 0, 0});
      while (!pq.empty()) {
        auto [d, x, y, move] = pq.top();
        d = -d;
        pq.pop();
        if (vis[x][y][move]) { continue; }
        vis[x][y][move] = 1;
        for (int dx = -1; dx <= 1; dx++) {
          for (int dy = -1; dy <= 1; dy++) if (abs(dx) + abs(dy) == 1) {
            int nx = x + dx;
            int ny = y + dy;
            if (!valid(nx, ny)) { continue; }
            i64 nd = max(d + c[move], (i64) g[nx][ny] + c[move]);
            if (nd < dis[nx][ny][1 - move]) {
              dis[nx][ny][1 - move] = nd;
              pq.push({-nd, nx, ny, 1 - move});
            }
          }
        }
      }
      return min(dis[n - 1][m - 1][0], dis[n - 1][m - 1][1]);
    }
};",1441312149
Anuj Anand,coleworld223,206,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
      array <int, 2> c = {0, 0};
      for (int i = 0; i < num.size(); ++i) {
        c[i % 2] += (num[i] - '0');
      }
      return c[0] == c[1];
    }
};",1441282080
Anuj Anand,coleworld223,206,3637,cpp,"int mod = 1e9 + 7;
struct mi {
    int64_t v; explicit operator int64_t() const { return v % mod; }
    mi() { v = 0; }
    mi(int64_t _v) {
        v = (-mod < _v && _v < mod) ? _v : _v % mod;
        if (v < 0) v += mod;
    }
    friend bool operator==(const mi& a, const mi& b) {
        return a.v == b.v; }
    friend bool operator!=(const mi& a, const mi& b) {
        return !(a == b); }
    friend bool operator<(const mi& a, const mi& b) {
        return a.v < b.v; }
 
    mi& operator+=(const mi& m) {
        if ((v += m.v) >= mod) v -= mod;
        return *this; }
    mi& operator-=(const mi& m) {
        if ((v -= m.v) < 0) v += mod;
        return *this; }
    mi& operator*=(const mi& m) {
        v = v*m.v%mod; return *this; }
    mi& operator/=(const mi& m) { return (*this) *= inv(m); }
    friend mi pow(mi a, int64_t p) {
        mi ans = 1; assert(p >= 0);
        for (; p; p /= 2, a *= a) if (p&1) ans *= a;
        return ans;
    }
    friend mi inv(const mi& a) { assert(a.v != 0);
        return pow(a,mod-2); }
 
    mi operator-() const { return mi(-v); }
    mi& operator++() { return *this += 1; }
    mi& operator--() { return *this -= 1; }
    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }
    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }
    friend mi operator+(mi a, const mi& b) { return a += b; }
    friend mi operator-(mi a, const mi& b) { return a -= b; }
    friend mi operator*(mi a, const mi& b) { return a *= b; }
    friend mi operator/(mi a, const mi& b) { return a /= b; }
    friend ostream& operator<<(ostream& os, const mi& m) {
        os << m.v; return os;
    }
    friend istream& operator>>(istream& is, mi& m) {
        int64_t x; is >> x;
        m.v = x;
        return is;
    }
    friend void __print(const mi &x) {
        cerr << x.v;
    }
};

struct fact {
  mi fac[1000];
  mi ifac[1000];
  fact() {
    fac[0] = ifac[0] = 1;
    for (int i = 1; i < 1000; ++i) {
      fac[i] = fac[i - 1] * i;
      ifac[i] = inv(fac[i]);
    }
  }
};

fact F;
mi C(int n, int r) {
  if (n <= 0 or r > n) { return (mi)0; }
  return F.fac[n] * F.ifac[r] * F.ifac[n - r];
}

mi dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(string num) {
      int n = num.size();
      for (int i = 0; i < 10; ++i) {
        for (int j = 0; j < 81; ++j) {
          for (int k = 0; k < 801; k++) {
            dp[i][j][k] = 0;
          }
        }
      }
      vector <int> cnt (10);
      int T = 0;
      for (char x : num) {
        cnt[x - '0'] += 1;
        T += (x - '0');
      }
      
      if (T % 2) { return 0; }
      T /= 2;
      
      for (int x = 0; x <= cnt[0]; x++) {
        dp[0][x][0] += 1 * F.ifac[x] * F.ifac[cnt[0] - x];
      }
      for (int i = 0; i < 9; ++i) {
        int nxt = i + 1;
        int tot = cnt[i + 1];
        int cur_tot = cnt[i];
        for (int take = 0; take <= 80; take++) {
          for (int sum = 0; sum <= 800; sum++) {
            if (dp[i][take][sum] == 0) { continue; }
            for (int x = 0; x <= tot; x++) {
              int ntake = take + x;
              int nsum = sum + x * (i + 1);
              if (nsum <= 800 and ntake <= 80) dp[i + 1][ntake][nsum] += dp[i][take][sum] * F.ifac[x] * F.ifac[tot - x];
            }
          }
        }
      }
      
      // cout << dp[2][2][3] << '\n';
      // cout << dp[3][2][3] << '\n';
      int siz = n / 2;
      // cout << siz << ' ';
      // cout << T << '\n';
      // cout << dp[9][siz][T] << '\n';
      mi ans = dp[9][siz][T] * F.fac[siz] * F.fac[n - siz];
      return ans.v;
    }
};",1441367561
Vivan,Vivan_geekfreak,207,3627,java,"import java.util.*;
class Solution 
{
    public int minTimeToReach(int[][] moveTime)
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var dist = new int[n][m];
        int i = 0;
        if(n>0)
            do
            {
                Arrays.fill(dist[i], Integer.MAX_VALUE);
                i++;
            } 
            while (i < n);
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0});
        dist[0][0] = 0;
        int[][] dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for(;!pq.isEmpty();)
        {
            var curr = pq.poll();
            var time = curr[0];
            var row = curr[1];
            var col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0; 
            do 
            {
                var dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = Math.max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.offer(new int[]{newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
            while (dirIndex < dirs.length);
        }
        return dist[n - 1][m - 1];
    }
}
",1441366743
Vivan,Vivan_geekfreak,207,3628,java,"import java.util.*;

class Solution 
{
    public int minTimeToReach(int[][] moveTime) 
    {
        var n = moveTime.length;
        var m = moveTime[0].length;
        var d = new int[n][m][2];
        int i = 0;
        do 
        {
            int j = 0;
            do 
            {
                d[i][j][0] = Integer.MAX_VALUE;
                d[i][j][1] = Integer.MAX_VALUE;
                j++;
            } 
            while (j < m);
            i++;
        } 
        while (i < n);
        d[0][0][0] = 0;
        var pq = new PriorityQueue<int[]>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, 0, 0, 0});
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for(;(!(!pq.isEmpty())==false);)
        {
            var current = pq.poll();
            var t = current[0];
            var iCur = current[1];
            var jCur = current[2];
            var p = current[3];

            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            int dirIndex = 0;
            do 
            {
                var dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.offer(new int[]{nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            } 
            while (dirIndex < directions.length);
        }

        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441332797
Vivan,Vivan_geekfreak,207,3636,java,"class Solution 
{
    public boolean isBalanced(String num) 
    {
        int evenSum = 0;
        int oddSum = 0;
        int i=0;
        if(num.length()>0)
            do
            {
                int digit = num.charAt(i) - '0'; 
                if (!(i % 2 == 0) == false)
                    evenSum += digit;
                else
                    oddSum += digit;
                i++;
            }
            while(i<num.length());
        return evenSum == oddSum;
    }
}
",1441292613
Vivan,Vivan_geekfreak,207,3637,java,"import java.util.*;
class Solution
{
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;
    private long powerMod(long a, long b) 
    {
        long res = 1;
        a %= MOD;
        while (b > 0) 
        {
            if (!((b & 1) == 1) ==false)
                res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }
    private void initFact(int n) 
    {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        int i = 1;
        do 
        {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        }
        while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do 
        {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        }
        while (j >= 0);
    }
    public int countBalancedPermutations(String num) 
    {
        var n = num.length();
        var freq = new int[10];
        long totalSum = 0;
        var C=Arrays.copyOfRange(num.toCharArray(), 0, n);
        int i=0;
        if(n>0)
            do
            {
                char c=C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            }
            while(i<n);

        if (!(totalSum % 2 != 0) ==false)
            return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        var dp = new long[k + 1][(int) sumHalf + 1];
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0)==false)
            {
                d++;
                continue;
            }
            int c = k;
            do 
            {
                long s = sumHalf;
                do 
                {
                    if (!(dp[c][(int) s] == 0)==false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    do 
                    {
                        if (!(t > Math.min(freq[d], k - c)) ==false)
                            break;
                        if (!(s + (long) d * t > sumHalf)==false)
                            break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                        t++;
                    } 
                    while (true);
                    s--;
                } 
                while (s >= 0);
                c--;
            } 
            while (c >= 0);
            d++;
        } 
        while (d <= 9); 

        long validAssignments = dp[k][(int) sumHalf];
        if (!(validAssignments == 0) == false)
            return 0;
        long prodFactFd = 1;
        int digit=0;
        do 
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        while(digit <= 9);
        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int) answer;
    }
}
",1441392291
Fasdr,Fasdr,208,3627,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][] time = new int[n][m];
        int max = Integer.MAX_VALUE;
        for (int row[] : time) {
            Arrays.fill(row, max);
        }
        // t, i, j
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2];
            if (time[i][j] <= t) {
                continue;
            }
            time[i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int nt = Math.max(moveTime[ni][nj] + 1, t + 1);
                frontier.add(new int[] {nt, ni, nj});
            }
        }
        
        return time[n - 1][m - 1];
    }
}",1441297738
Fasdr,Fasdr,208,3628,java,"class Solution {
    
    private static int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length, m = moveTime[0].length;
        int[][][] time = new int[2][n][m];
        int max = Integer.MAX_VALUE;
        for (int[][] table : time) {
            for (int[] row : table) {
                Arrays.fill(row, max);
            }
        }
        // t, i, j, a
        Queue<int[]> frontier = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        frontier.add(new int[] {0, 0, 0, 0});
        while (!frontier.isEmpty()) {
            int[] cur = frontier.remove();
            int t = cur[0], i = cur[1], j = cur[2], a = cur[3];
            if (time[a][i][j] <= t) {
                continue;
            }
            time[a][i][j] = t;
            for (int[] move : dirs) {
                int ni = i + move[0], nj = j + move[1];
                if (ni < 0 || ni >= n || nj < 0 || nj >= m) {
                    continue;
                }
                int extra = (a == 0) ? 1 : 2;
                int nt = Math.max(moveTime[ni][nj], t) + extra;
                frontier.add(new int[] {nt, ni, nj, 1 - a});
            }
        }
        
        return Math.min(time[0][n - 1][m - 1], time[1][n - 1][m - 1]);
    }
}",1441306270
Fasdr,Fasdr,208,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int n = num.length();
        int odd = 0, even = 0;
        for (int i = 0; i < n; i += 2) {
            even += (num.charAt(i) - '0');
        }
        for (int i = 1; i < n; i += 2) {
            odd += (num.charAt(i) - '0');
        }
        return even == odd;
    }
}",1441282457
Fasdr,Fasdr,208,3637,java,"class Solution {
    public int countBalancedPermutations(String num) {
        int[] qty = new int[10];
        long mod = 1_000_000_007;
        int n = num.length();
        int total = 0;
        for (char chr : num.toCharArray()) {
            total += chr - '0';
        }
        if (total == 0) {
            total = 1;
        }
        total = 2 * total;
        long[][] dp = new long[total + 1][2 * n + 1];
        dp[total / 2][n] = 1;
        for (char chr : num.toCharArray()) {
            int digit = chr - '0';
            qty[digit]++;
            long[][] newDp = new long[total + 1][2 * n + 1];
            for (int sum = 0; sum < total + 1; sum++) {
                for (int cnt = 0; cnt < 2 * n + 1; cnt++) {
                    if (dp[sum][cnt] == 0) {
                        continue;
                    }
                    // add to even
                    newDp[sum + digit][cnt + 1] = (newDp[sum + digit][cnt + 1] + dp[sum][cnt]) % mod;
                    // add to odd
                    newDp[sum - digit][cnt - 1] = (newDp[sum - digit][cnt - 1] + dp[sum][cnt]) % mod;
                }
            }
            dp = newDp;
        }
        
        long res = n % 2 == 0? dp[total / 2][n] : dp[total / 2][n + 1];
        int half = n / 2;
        for (int i = 1; i <= half; i++) {
            res = (res * i * i) % mod;
        }
        
        if (n % 2 != 0) {
            res = (res * (half + 1)) % mod;
        }
        
        for (int digitQty : qty) {
            for (int i = 2; i <= digitQty; i++) {
                res = (res * modInv(i, mod)) % mod;
            }
        }
        
        return (int) res;
    }
    
    private long modInv(long num, long mod) {
        return pow(num, mod - 2, mod);
    }
    
    private long pow(long base, long exp, long mod) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp = exp >> 1;
        }
        
        return res;
    }
    
}",1441367839
Gautam Ankoji,gautamankoji,209,3627,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[float('inf')] * m for _ in range(n)]
        d[0][0] = 0
        v = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        q = [(0, 0, 0)]
        while q:
            t, i, j = heapq.heappop(q)
            if t > d[i][j]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + 1
                    if d[ni][nj] > nt:
                        d[ni][nj] = nt
                        heapq.heappush(q, (nt, ni, nj))
        res = d[n - 1][m - 1]
        return d[n - 1][m - 1]",1441323814
Gautam Ankoji,gautamankoji,209,3628,python3,"class Solution:
    def minTimeToReach(self, time: List[List[int]]) -> int:
        n, m = len(time), len(time[0])
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0
        v = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        q = [(0, 0, 0, 0)]
        while q:
            t, i, j, p = heapq.heappop(q)
            if t > d[i][j][p]: 
                continue
            for di, dj in v:
                ni, nj = di + i, dj + j
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, time[ni][nj]) + (2 if p else 1)
                    if d[ni][nj][1 - p] > nt:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(q, (nt, ni, nj, 1 - p))
        res = min(d[n - 1][m - 1])
        return res",1441327957
Gautam Ankoji,gautamankoji,209,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        res1, res2 = 0, 0
        for i, d in enumerate(num):
            if i % 2 != 0:
                res2 += int(d)
            else:
                res1 += int(d)
        return res1 == res2
",1441291369
Gautam Ankoji,gautamankoji,209,3637,python3,"MOD = 1_000_000_007

class Solution:
    def power(self, base: int, exp: int, mod: int) -> int:
        res = 1
        base %= mod
        while exp:
            if exp & 1:
                res = res * base % mod
            base = base * base % mod
            exp >>= 1
        return res
    
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        e, O = (n + 1) // 2, n // 2
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1
        tot_sum = sum(d * cnt[d] for d in range(10))
        if tot_sum % 2: return 0
        t_sum = tot_sum // 2
        max_val = 80
        fact = [1] * (max_val + 1)
        for i in range(1, max_val + 1):
            fact[i] = fact[i - 1] * i % MOD
        not_fact = [1] * (max_val + 1)
        not_fact[max_val] = self.power(fact[max_val], MOD - 2, MOD)
        for i in range(max_val - 1, -1, -1):
            not_fact[i] = not_fact[i + 1] * (i + 1) % MOD
        def comb(n: int, k: int) -> int:
            return (fact[n] * not_fact[k] % MOD * not_fact[n - k] % MOD) if k <= n else 0
        dp = [[0] * (t_sum + 1) for _ in range(e + 1)]
        dp[0][0] = 1
        for d in range(10):
            if not cnt[d]: continue
            for t in range(e, -1, -1):
                for s in range(t_sum, -1, -1):
                    if dp[t][s]:
                        for k in range(1, cnt[d] + 1):
                            if t + k <= e and s + d * k <= t_sum:
                                dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD
        p_cnt = 1
        for d in range(10):
            p_cnt = p_cnt * fact[cnt[d]] % MOD
        ans = (dp[e][t_sum] * fact[e] % MOD * fact[O] % MOD * self.power(p_cnt, MOD - 2, MOD)) % MOD
        return ans
",1441386398
Nguyễn Minh,minhnguyenxuan60,210,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<vector<int>> dp(n, vector<int>(m, 1e9 + 1e8));
        dp[0][0] = 0;

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        for (int k = 0; k < n * m; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    for (int r = 0; r < 4; r++) {
                        int i1 = i + diri[r], j1 = j + dirj[r];
                        if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                        dp[i1][j1] = min(dp[i1][j1], dp[i][j] + 1);
                        if (i1 != 0 || j1 != 0) dp[i1][j1] = max(dp[i1][j1], moveTime[i1][j1] + 1);
                    }
                }
            }
        }

        return dp[n - 1][m - 1];
    }
};",1441297906
Nguyễn Minh,minhnguyenxuan60,210,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> q;
        q.push({{0, 1}, {0, 0}});

        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> diri = {0, 0, -1, 1}, dirj = {1, -1, 0, 0};
        vector<vector<bool>> vis(n, vector<bool>(m));
        while(!q.empty()) {
            int u = q.top().first.first, t = q.top().first.second, i = q.top().second.first, j = q.top().second.second;
            q.pop();
            if (vis[i][j]) continue;
            vis[i][j] = true;
            if (i == n - 1 && j == m - 1) {
                return max(u, moveTime[i][j] + 1);
            }

            for (int k = 0; k < 4; k++) {
                int i1 = i + diri[k], j1 = j + dirj[k];
                if (i1 < 0 || j1 < 0 || i1 >= n || j1 >= m) continue;

                q.push({{max(u, moveTime[i1][j1]) + t, 3 - t}, {i1, j1}});
            }
        }
        return 0;
    }
};",1441313182
Nguyễn Minh,minhnguyenxuan60,210,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for (int i = 0; i < (int)num.size(); i++) {
            if (i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281260
Nguyễn Minh,minhnguyenxuan60,210,3637,cpp,"class Solution {
public:

    const int mod = 1e9 + 7;
    int countBalancedPermutations(string num) {
        vector<vector<int64_t>> c(100, vector<int64_t> (100, 0));
        for (int i = 0; i < 100; i++) c[i][0] = 1;
        for (int i = 1; i < 100; i++) {
            for (int j = i; j < 100; j++) {
                c[j][i] = (c[j - 1][i] + c[j - 1][i - 1]) % mod;
            }
        }

        // for (int i = 0; i <= 10; i++) {
        //     for (int j = 0; j <= 10; j++) cout << c[i][j] << "" "";
        //     cout << '\n';
        // }

        vector<int> cnt(10);
        int total = 0;
        for (char c: num) {
            cnt[c - '0']++;
            total += c - '0';
        }

        if (total % 2) return 0;
        total /= 2;

        int len = num.size() / 2;

        vector<vector<int64_t>> dp(len + 1, vector<int64_t>(total + 1, 0));

        dp[0][0] = 1;
        int curNum = 0;
        
        for (int num = 0; num < 10; num++) {
            vector<vector<int64_t>> tmp(len + 1, vector<int64_t>(total + 1, 0));
            for (int l = 0; l <= curNum; l++) {
                for (int sum = 0; sum <= total; sum++) {
                    for (int used = 0; used <= cnt[num]; used++) {
                        int numLeft = l + used, numRight = curNum - l + cnt[num] - used;
                        if (sum + num * used > total || numLeft > len) break;
                        tmp[numLeft][sum + num * used] += dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod;
                        // if (dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod > 1) {
                        //     // cout << numLeft << "" "" << used << "" "" << numRight << "" "" << cnt[num] - used << "" "" << dp[l][sum] << '\n';
                        //     // cout << l << "" "" << sum << "" "" << num << "" "" << '\n';
                        //     cout << dp[l][sum] * c[numLeft][used] % mod * c[numRight][cnt[num] - used] % mod << '\n';
                        // }
                        tmp[numLeft][sum + num * used] %= mod;
                    }
                }
            }
            swap(tmp, dp);
            curNum += cnt[num];
        }

        // for (int i = 0; i <= len; i++) {
        //     for (int sum = 0; sum <= total; sum++) {
        //         cout << dp[i][sum] << "" "";
        //     }
        //     cout << '\n';
        // }

        return dp[len][total];

        

        return 0;
    }
};",1441368456
user3013OR,user3013OR,211,3627,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c = h[0]
            heappop(h)
            if (r,c) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            seen[(r,c)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+1
                heappush(h,(nt,r-1,c))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+1
                heappush(h,(nt,r+1,c))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+1
                heappush(h,(nt,r,c-1))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+1
                heappush(h,(nt,r,c+1))
            
        ",1441293940
user3013OR,user3013OR,211,3628,python3,"class Solution:
    def valid(self,i,j,m,n):
        if i<0 or i>=m:
            return False
        if j<0 or j>=n:
            return False
        return True
        
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m = len(moveTime)
        n = len(moveTime[0])
        h = []
        heappush(h,(0,0,0,0))
        seen = {}
        while len(h)>0:
            t,r,c,s = h[0]
            heappop(h)
            if (r,c,s) in seen:
                continue
            if r == m-1 and c == n-1:
                return t
            ns = 1-s
            mv = 1+s
            seen[(r,c,s)]=1
            if self.valid(r-1,c,m,n):
                nt = max(t,moveTime[r-1][c])+mv
                heappush(h,(nt,r-1,c,ns))
            if self.valid(r+1,c,m,n):
                nt = max(t,moveTime[r+1][c])+mv
                heappush(h,(nt,r+1,c,ns))
            if self.valid(r,c-1,m,n):
                nt = max(t,moveTime[r][c-1])+mv
                heappush(h,(nt,r,c-1,ns))
            if self.valid(r,c+1,m,n):
                nt = max(t,moveTime[r][c+1])+mv
                heappush(h,(nt,r,c+1,ns))",1441297026
user3013OR,user3013OR,211,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s = 0
        sign = 1
        for c in num:
            val = int(c)
            s += sign * val
            sign = -sign
        return s==0
        ",1441282298
user3013OR,user3013OR,211,3637,python3,"class Solution:
    def helper(self,n,mod):
        even_n = n//2
        odd_n = n-even_n

        res = (self.fact[even_n]*self.fact[odd_n])%mod
        for i in range(10):
            res = (res*(self.inverse[self.temp[i]]))%mod
            res = (res*(self.inverse[self.cnt[i]-self.temp[i]]))%mod
        self.ans+=res
        self.ans%=mod
        return
        
    def inv(self,a,mod):
        return self.power(a,mod-2,mod)
    def power(self,a,p,mod):
        if p==0:
            return 1
        elif p==1:
            return a
        else:
            res = self.power(a,p//2,mod)
            ans = (res*res)%mod
            if p%2==1:
                ans = (ans*a)%mod
            return ans
    def dfs(self,ind,ts,tn,cs,cn,mod):
        if ind==10:
            if ts == cs*2 and cn == tn//2:
                self.helper(tn,mod)
            return
        if cs>ts//2:
            return
        if cn>tn//2:
            return
        if (tn//2-cn)*9+cs<ts//2:
            return
        for i in range(self.cnt[ind]+1):
            self.temp[ind]=i
            self.dfs(ind+1,ts,tn,cs+i*ind,cn+i,mod)
    def comb(self,a,b,mod):
        ans = self.fact[a]*self.inverse[b]*self.inverse[a-b]
        return ans%mod
    def countBalancedPermutations(self, num: str) -> int:
        self.cnt = [0 for i in range(10)]
        s = 0
        n = len(num)
        #print (n)
        for c in num:
            val = int(c)
            self.cnt[val]+=1
            s+=val
        if s%2==1:
            return 0
        self.fact = [1 for i in range(n+1)]
        self.inverse = [1 for i in range(n+1)]
        mod = int(1e9+7)
        for i in range(n):
            self.fact[i+1]=(self.fact[i]*(i+1))%mod
            self.inverse[i+1]=self.inv(self.fact[i+1],mod)
        self.ans = 0
        self.temp = [0 for i in range(10)]
        self.presum = [[] for i in range(10)]
        for i in range(10):
            base = 0
            for j in range(9,i,-1):
                for _ in range(self.cnt[j]):
                    base+=j
                    self.presum[i].append(base)
        #self.dfs(0,s,n,0,0,mod)
        dp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
        dp[0][0]=1
        ts = 0
        tn = 0
        for ind in range(10):

            temp = [[0 for j1 in range(s//2+1)]for i1 in range(n//2+1)]
            for n1 in range(n//2+1):
                for s1 in range(s//2+1):
                    n2 = tn - n1
                    s2 = ts - s1
                    if dp[n1][s1]==0:
                        continue
                    for i in range(self.cnt[ind]+1):
                        if n1+i<=n//2 and n2+self.cnt[ind]-i <= n-n//2 and s1+ind*i<=s//2 and s2+ind*(self.cnt[ind]-i) <= s//2:
                            temp[n1+i][s1+ind*i] += dp[n1][s1] * self.comb(n//2-n1,i,mod) * self.comb(n-n//2-n2,self.cnt[ind]-i,mod)
                            temp[n1+i][s1+ind*i] %=mod
            dp = temp
            ts += self.cnt[ind]*ind
            tn += self.cnt[ind]
            
                                    
        return dp[n//2][s//2]",1441362085
Ivan_len,Ivan_len,212,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
        pq.push({0, 0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            if (dp[cur[1]][cur[2]] <= cur[0]) continue;
            dp[cur[1]][cur[2]] = cur[0];
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = cur[1] + dx;
                int new_y = cur[2] + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur[0], moveTime[new_x][new_y]);
                    pq.push({t + 1, new_x, new_y});
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441297432
Ivan_len,Ivan_len,212,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        pq.push({0, 0});
        vector<vector<int>> dp(n, vector<int>(m, 1 << 30));
        while (!pq.empty()) {
            vector<pair<int, int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            auto cur = pq.top();
            pq.pop();
            int X = cur.second / m;
            int Y = cur.second % m;
            if (dp[X][Y] <= cur.first) continue;
            dp[X][Y] = cur.first;
            for (auto [dx, dy] : dir) {
                auto in = [&](int x, int y) {
                    return x >= 0 && x < n && y >= 0 && y < m;
                };
                int new_x = X + dx;
                int new_y = Y + dy;
                if (in(new_x, new_y)) {
                    int t = max(cur.first, moveTime[new_x][new_y]);
                    if (((new_x + new_y) & 1) && t + 1 < dp[new_x][new_y]) {
                        pq.push({t + 1, new_x * m + new_y});
                    }
                    if (((new_x + new_y) % 2 == 0) && t + 2 < dp[new_x][new_y]) {
                        pq.push({t + 2, new_x * m + new_y});
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};",1441303354
Ivan_len,Ivan_len,212,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0;
        int i = 0;
        for (auto c : num) {
            int cnt = (int)(c - '0');
            if (i & 1) a += cnt;
            else a -= cnt;
            i++;
        }
        return a == 0;
    }
};",1441281416
Ivan_len,Ivan_len,212,3637,cpp,"template <typename T>
T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
}
 
template <typename T>
class Modular {
public:
    using Type = typename decay<decltype(T::value)>::type;
 
    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }
 
    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }
 
    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }
 
    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }
 
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
#ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
    asm(
      ""divl %4; \n\t""
      : ""=a"" (d), ""=d"" (m)
      : ""d"" (xh), ""a"" (xl), ""r"" (mod())
    );
    value = m;
#else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
#endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }
 
    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }
 
    friend const Type& abs(const Modular& x) { return x.value; }
 
    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);
 
    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);
 
private:
    Type value;
};
 
template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }
 
template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
 
template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }
 
template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
 
template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
 
template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
 
template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
 
template<typename T, typename U>
Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
}
 
template <typename T>
bool IsZero(const Modular<T>& number) {
    return number() == 0;
}
 
template <typename T>
string to_string(const Modular<T>& number) {
    return to_string(number());
}
 
// U == std::ostream? but done this way because of fastoutput
template <typename U, typename T>
U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
}
 
// U == std::istream? but done this way because of fastinput
template <typename U, typename T>
U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
}
 
/*
using ModType = int;
 
struct VarMod { static ModType value; };
ModType VarMod::value;
ModType& md = VarMod::value;
using Mint = Modular<VarMod>;
*/
 
constexpr int md = 1000000007;
using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;
 
vector<Mint> fact(1, 1);
vector<Mint> inv_fact(1, 1);
 
Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        vector<int> cnt(10);
        for (auto c : num) cnt[(int)(c - '0')]++;
        int n = num.size();
        const int shift = ((n + 1) / 2) * 9;
        vector<vector<Mint>> d((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1)), f;
        d[0][shift] = 1; 
        int acc = 0;
        int up = 0, lo = 0;
        for (int i = 0; i <= 9; i++) {
            f.clear();
            f.resize((n + 1) / 2 + 1, vector<Mint>(shift * 2 + 1));
            acc += cnt[i];
            for (int even = 0; even <= (n + 1) / 2; even++) {
                for (int ceven = 0; ceven <= even; ceven++) {
                    int codd = cnt[i] - ceven;
                    int odd = acc - even - cnt[i] + ceven;
                    if (codd < 0) break;
                    if (odd > n / 2) break;
                    if (codd > n / 2) continue;
                    if (odd < 0) continue;
                    // even - odd
                    for (int sum = max(-shift, -(i * (n + 1) / 2)); sum <= min(shift, i * (n + 1) / 2); sum++) {
                        int pre = sum - (ceven - codd) * i;
                        if (pre < -shift) continue;
                        if (pre > shift) break;
                        f[even][sum + shift] += d[even - ceven][pre + shift] * C((n + 1) / 2 - (even - ceven), ceven) * C(n / 2 - odd, codd);
                    }
                }
            }
            swap(d, f);
        }
        Mint ans = 0;
        for (int even = 0; even <= ((n + 1) / 2); even++) ans += d[even][shift];
        return (int)ans;
    }
};",1441362584
I_have_learn,I_have_learn,213,3627,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0); 

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();
            if (r == n - 1 && c == m - 1) return currTime;

            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = 1;
                ll newCost = currTime + waitTime + cost;

                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag); 
                }
            }
        }

        return -1;
    }
};
",1441320973
I_have_learn,I_have_learn,213,3628,cpp,"
#define ll long long
const ll inf = (ll)1e16;

class Solution {
public:
    bool valid(ll r, ll c, ll n, ll m) {
        return r >= 0 && c >= 0 && r < n && c < m;
    }

    int minTimeToReach(vector<vector<int>>& moveTime) {
        ll n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> minCost(n, vector<ll>(m, inf));
        minCost[0][0] = 0;

        // Min-heap to store (currentTime, row, col, flag)
        priority_queue<tuple<ll, ll, ll, bool>, vector<tuple<ll, ll, ll, bool>>, greater<>> pq;
        pq.emplace(0, 0, 0, 0);  // Start from (0, 0) at time t = 0 with flag = false

        ll dr[] = {-1, 0, 1, 0};
        ll dc[] = {0, -1, 0, 1};

        while (!pq.empty()) {
            auto [currTime, r, c, flag] = pq.top();
            pq.pop();

            // If we reached the target cell, return the minimum time
            if (r == n - 1 && c == m - 1) return currTime;

            // Visit adjacent cells
            for (ll k = 0; k < 4; k++) {
                ll nr = r + dr[k];
                ll nc = c + dc[k];
                if (!valid(nr, nc, n, m)) continue;

                // Calculate wait time to ensure that we can enter the room
                ll waitTime = max(0LL, moveTime[nr][nc] - currTime);
                ll cost = flag ? 2 : 1;
                ll newCost = currTime + waitTime + cost;

                // Update if a cheaper path is found
                if (newCost < minCost[nr][nc]) {
                    minCost[nr][nc] = newCost;
                    pq.emplace(newCost, nr, nc, !flag);  // Toggle flag for the next move
                }
            }
        }

        return -1;  // Return -1 if unreachable
    }
};
",1441319656
I_have_learn,I_have_learn,213,3636,cpp,"class Solution {
public:
    bool isBalanced(string nums) {
        int sum1=0,sum2=0;

        for(int i=0;i<nums.size();i+=2) sum1+=nums[i]-'0';

        for(int i=1;i<nums.size();i+=2) sum2+=nums[i]-'0';
        return sum1==sum2;
    }
};",1441284219
I_have_learn,I_have_learn,213,3637,cpp,"#define MOD 1000000007
typedef long long ll;

ll fact[81];
ll inv_fact[81];

ll power_mod(ll x, ll y) {
    ll res = 1;
    x %= MOD;
    while (y > 0) {
        if (y & 1LL) {
            res = res * x % MOD;
        }
        x = x * x % MOD;
        y >>= 1LL;
    }
    return res;
}

// Precompute factorials and modular inverses
void compute_factorials() {
    fact[0] = 1;
    for (int i = 1; i <= 80; i++) fact[i] = fact[i - 1] * i % MOD;
    inv_fact[80] = power_mod(fact[80], MOD - 2);
    for (int i = 79; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

// Function to compute C(n, k) % MOD
ll comb(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
}

class Solution {
public:
    ll countBalancedPermutations(string num) {
        compute_factorials();
        
        unordered_map<char, int> freq;
        ll total_sum = 0;
        for (char c : num) {
            freq[c]++;
            total_sum += (c - '0');
        }

        if (total_sum % 2 != 0) return 0;  // Odd total sum means no balanced partition possible
        
        ll target_sum = total_sum / 2;
        int n = num.size();
        int num_even = (n + 1) / 2;
        
        vector<vector<ll>> dp(num_even + 1, vector<ll>(target_sum + 1, 0));
        dp[0][0] = 1;

        for (auto &[digit, count] : freq) {
            int d = digit - '0';
            for (int k = num_even; k >= 0; --k) {
                for (int s = target_sum; s >= 0; --s) {
                    for (int t = 1; t <= count && k + t <= num_even && s + t * d <= target_sum; ++t) {
                        dp[k + t][s + t * d] = (dp[k + t][s + t * d] + dp[k][s] * comb(count, t) % MOD) % MOD;
                    }
                }
            }
        }

        ll C_t = dp[num_even][target_sum];
        if (C_t == 0) return 0;

        ll fact_even = fact[num_even];
        ll fact_odd = fact[n - num_even];
        
        ll denominator = 1;
        for (auto &[digit, f] : freq) {
            denominator = denominator * fact[f] % MOD;
        }
        
        ll result = C_t * fact_even % MOD * fact_odd % MOD * power_mod(denominator, MOD - 2) % MOD;
        return result;
    }
};
",1441356696
nghia0510,phantrongnghia510,214,3627,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[float(""inf"") for _ in range(m)] for _ in range(n)]
        d[0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0)]

        while queue:
            t, i, j = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + 1
                    if nt < d[ni][nj]:
                        d[ni][nj] = nt
                        heappush(queue, (nt, ni, nj))
        return -1
        ",1441316415
nghia0510,phantrongnghia510,214,3628,python,"class Solution(object):
    def minTimeToReach(self, moveTime):
        n, m = len(moveTime), len(moveTime[0])
        d = [[[float(""inf"") ] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        queue = [(0, 0, 0, 0)]

        while queue:
            t, i, j, c = heappop(queue)
            if i == n - 1 and j == m - 1: 
                return t

            if t > d[i][j][c]: continue

            for di, dj in dirs:
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, moveTime[ni][nj]) + (1 if not c else 2)
                    nc = c ^ 1
                    if nt < d[ni][nj][nc]:
                        d[ni][nj][nc] = nt
                        heappush(queue, (nt, ni, nj, nc))
        return -1
        ",1441312545
nghia0510,phantrongnghia510,214,3636,python,"class Solution(object):
    def isBalanced(self, num):
        even, odd = 0, 0
    
        for i in range(len(num)):
          if i % 2 == 0:
            even += int(num[i])
          else:
            odd += int(num[i])
    
        return even == odd",1441285916
nghia0510,phantrongnghia510,214,3637,python3,"from collections import Counter
import math

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        MOD = 10 ** 9 + 7
        count = Counter(num)
        c = [0] * 10
        for d in range(10): 
            c[d] = count.get(chr(d + ord(""0"")), 0)
        total = sum(c[d] * d for d in range(10))
        if total % 2 != 0:
            return 0
        n = len(num)
        H, K  = total // 2, (n + 1) // 2
        dp0 = [[0] * (H + 1) for _ in range(K + 1)]
        dp0[0][0] = 1

        for d in range(10):
            if c[d] == 0:
                continue
            dp1 = [[0] * (H + 1) for _ in range(K + 1)]
            for k in range(K + 1):
                for h in range(H + 1):
                    if dp0[k][h] == 0:
                        continue
                    max_d = min(c[d], K - k)
                    if d > 0:
                        max_d = min(max_d, (H - h) // d)
                    for u in range(max_d + 1):
                        new_k = k + u
                        new_h = h + d * u
                        if new_k > K or new_h > H:
                            continue
                        ways = math.comb(c[d], u)
                        dp1[new_k][new_h] = (dp1[new_k][new_h] + dp0[k][h] * ways) % MOD
            dp0 = dp1

        if dp0[K][H] == 0:
            return 0

        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = (fact[i - 1] * i) % MOD

        inv_fact = [1] * (n + 1)
        inv_fact[n] = pow(fact[n], MOD - 2, MOD)
        for i in range(n - 1, -1, -1):
            inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD

        prod_inv = 1
        for i in range(10):
            prod_inv = (prod_inv * inv_fact[c[i]]) % MOD

        
        res = dp0[K][H]
        res = (res * fact[K]) % MOD
        res = (res * fact[n - K]) % MOD
        res = (res * prod_inv) % MOD

        return res
",1441394228
hcseo,hcseo,215,3627,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 2;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(1, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return dp[0][n-1][m-1];
    }
};",1441302021
hcseo,hcseo,215,3628,cpp,"int dr[4] = {1, -1, 0, 0};
int dc[4] = {0, 0, 1, -1};
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int timer = 3;
        priority_queue<vector<int>> pq;
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<int> tmp(m, 2000000000);
        vector<vector<int>> dpTmp(n, tmp);
        vector<vector<vector<int>>> dp(2, dpTmp);
        dp[0][0][0] = 0;
        pq.push({-0, 0, 0, 1});
        while(!pq.empty()){
            int nowR = pq.top()[1];
            int nowC = pq.top()[2];
            int nowTime = -pq.top()[0];
            int nowTakenTime = pq.top()[3];
            pq.pop();
            for(int i=0; i<4; ++i){
                int nextR = nowR + dr[i];
                int nextC = nowC + dc[i];
                int nextTakenTime = timer-nowTakenTime;
                if(nextR<0 || nextR >= n || nextC <0 || nextC >= m || max(nowTime, moveTime[nextR][nextC]) + nowTakenTime>=dp[nextTakenTime-1][nextR][nextC]) continue;
                dp[nextTakenTime-1][nextR][nextC] = max(nowTime, moveTime[nextR][nextC]) + nowTakenTime;
                pq.push({-dp[nextTakenTime-1][nextR][nextC], nextR, nextC, nextTakenTime});
            }
        }
        return min(dp[0][n-1][m-1], dp[1][n-1][m-1]);
    }
};",1441300575
hcseo,hcseo,215,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0;
        int sum2 = 0;
        for(int i=0; i<num.size(); ++i){
            if(i%2==0){
                sum1 += num[i]-'0';
            }else{
                sum2 += num[i]-'0';
            }
        }
        return sum1==sum2;
    }
};",1441281165
hcseo,hcseo,215,3637,cpp,"#define MOD 1000000007

int n;
long long nCr[81][81];

class Solution {
public:
    int countBalancedPermutations(string num) {
        nCr[0][0] = 1;
        for(int i=1; i<81; ++i){
            nCr[i][0] = 1;
            nCr[i][i] = 1;
            for(int j=1; j<i; ++j) nCr[i][j] = (nCr[i-1][j-1]+nCr[i-1][j])%MOD;
        }
        int totalSum = 0;
        n = num.size();
        vector<int> cnt(10);
        for(int i=0; i<n; ++i) {
            totalSum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        if(totalSum%2==1) return 0;
        vector<long long> tmp(totalSum/2+1);
        vector<vector<long long>> dp(n/2+1, tmp); // countOfGroup1 / sumOfGroup1
        dp[0][0] = 1;
        int done = 0;
        int doneSum = 0;
        for(int i=0; i<10; ++i){
            if(cnt[i]==0) continue;
            vector<vector<long long>> dpNext(n/2+1, tmp);
            for(int countOfGroup1 = 0; countOfGroup1<=n/2; ++countOfGroup1){
                for(int sumOfGroup1=0; sumOfGroup1<=totalSum/2; sumOfGroup1++){
                    if(dp[countOfGroup1][sumOfGroup1]==0) continue;
                    int countOfGroup2 = done - countOfGroup1;
                    int sumOfGroup2 = doneSum - sumOfGroup1;
                    for(int j=0; j<=cnt[i]; ++j){
                        int nextSumOfGroup1 = sumOfGroup1+j*i;
                        int nextCountOfGroup1 = countOfGroup1+j;

                        int nextCountOfGroup2 = countOfGroup2 + (cnt[i]-j);
                        int nextSumOfGroup2 = sumOfGroup2 + (cnt[i]-j)*i;

                        if(nextSumOfGroup1>totalSum/2 || nextCountOfGroup1>(n/2) || nextSumOfGroup2> totalSum/2 || nextCountOfGroup2>(n+1)/2) continue;
                        int remainSeats1 = n/2-countOfGroup1;
                        int remainSeats2 = (n+1)/2-countOfGroup2;
                        long long nowWays = (nCr[remainSeats1][j] * nCr[remainSeats2][cnt[i]-j])%MOD;
                        nowWays = (nowWays*dp[countOfGroup1][sumOfGroup1])%MOD;
                        dpNext[nextCountOfGroup1][nextSumOfGroup1] = (dpNext[nextCountOfGroup1][nextSumOfGroup1] + nowWays)%MOD;
                    }
                }
            }
            done += cnt[i];
            doneSum += cnt[i]*i;
            dp = dpNext;
        }
        return dp[n/2][totalSum/2];
    }
};",1441388329
lukewu28,lukewu28,216,3627,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1, npos});
            }
        }
        
        return -1;
    }
};",1441300860
lukewu28,lukewu28,216,3628,cpp,"
typedef pair<int, int> PII;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        // time, pos
        priority_queue<PII, vector<PII>, greater<PII>> pq;
        pq.push({0, 0});
        
        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<bool> vis(n * m, 0);
        while(!pq.empty()){
            auto x = pq.top();
            pq.pop();
            
            int pos = x.second;
            int time = x.first;
            
            if(vis[pos]) continue;
            vis[pos] = 1;
            
            int i = pos / m;
            int j = pos % m;
            
            if(i == n - 1 && j == m - 1) return time;
            
            
            int par = (i + j) % 2; 
            for(int tt = 0; tt < 4; tt++){
                    int ni = i + dy[tt], nj = j + dx[tt];
                    if(ni < 0 || ni >= n || nj < 0 || nj >= m) continue;
                    
                    int npos = m * ni + nj;
                    
                    pq.push({max(time, moveTime[ni][nj]) + 1 + par, npos});
            }
        }
        
        return -1;
    }
};",1441303488
lukewu28,lukewu28,216,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int r = 0;
        for(int i = 0 ; i < num.size(); i++){
            if(i % 2) r -= num[i] - '0';
            else r += num[i] - '0';
        }
        return r == 0;
    }
};",1441288436
lukewu28,lukewu28,216,3637,cpp,"typedef long long ll;
typedef pair<ll, ll> PII;
    const int MAXN = 80;

    const ll MOD = 1000000007;
class Solution {
public:
    ll fac[81], invfac[81];
    ll inv(ll x){return x>1?inv(MOD%x)*(MOD-MOD/x)%MOD:x;}
    void factorial() {
        fac[0] = 1;
        for (ll i = 1; i <= MAXN; i++) {
            fac[i] = fac[i - 1] * i % MOD;
        }
    }
    void inverses() {
        invfac[MAXN] = inv(fac[MAXN]);
        for (ll i = MAXN; i >= 1; i--) {
            invfac[i - 1] = invfac[i] * i % MOD;
        }
    }
    ll C(ll g, ll r) {
        return fac[g] * invfac[r] % MOD * invfac[g - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        int sum = 0;
        
        factorial();
        inverses();
        
        int freq[10] = {};
        for(int i : num) sum += i - '0', freq[i - '0']++;
        if(sum % 2) return 0;
        sum /= 2;
        
        int n = num.size() / 2;
        
        vector<vector<PII>> dp(n + 1, vector<PII>(sum + 1, {0, 0})), dp2(n + 1, vector<PII>(sum + 1, {0, 0}));
        for(int i = 0; i <= min(n, freq[0]); i++){
            dp2[n - i][sum].first = invfac[i] * invfac[freq[0] - i] % MOD;
        }
//         cout << 0 << endl;
//         for(int cnt = 0; cnt <= n; cnt++){
//                 for(int s = 0; s <= sum; s++){

//                     cout << cnt << ' ' << s << ' ' << dp2[cnt][s].first << ' '  << dp2[cnt][s].second << endl;
//                 }
//             }
        for(int i = 1; i < 10; i++){
            // cout << i << ' ' << freq[i] << endl;
            for(int cnt = 0; cnt <= n; cnt++){
                for(int s = 0; s <= sum; s++){
                    dp[cnt][s] = {0 , 0};
                    for(int k = 0; k <= freq[i]; k++){
                        if(s + k*i > sum || cnt + k > n) continue;
                        
                        ll curfac = invfac[k] * invfac[freq[i] - k] % MOD;
                        dp[cnt][s].first = (dp[cnt][s].first + (dp2[cnt + k][s + k*i].first * curfac % MOD) )% MOD;
                        // dp[cnt][s].second = (dp[cnt][s].second + (dp2[cnt + k][s + k*i].second *  % MOD) )% MOD;
                    }

                    // cout << cnt << ' ' << s << ' ' << dp[cnt][s].first << ' '  << dp[cnt][s].second << endl;
                }
            }
            swap(dp, dp2);
        }
        
        ll re = ((dp2[0][0].first * fac[n] % MOD) * fac[num.size() - n] % MOD) % MOD;
        return re;
    }
};",1441376281
vedantgore_2004,vedantgore_2004,217,3627,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<int,pair<int,int>> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({0,{0,0}});
        while(!q.empty()){
            ll t=q.top().first;
            ll x=q.top().second.first;
            ll y=q.top().second.second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+1;
                    if(vis[xx][yy]==-1)
                    q.push({tt,{xx,yy}});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441310976
vedantgore_2004,vedantgore_2004,217,3628,cpp,"class Solution {
public:
    typedef long long ll;
    typedef pair<pair<int,pair<int,int>>,int> pp;
    int minTimeToReach(vector<vector<int>>& aa) {
        ll n=aa.size();
        ll m=aa[0].size();
        vector<vector<ll>> a(n,vector<ll>(m));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++)a[i][j]=aa[i][j];
        }
        vector<ll> dx={1,0,-1,0};
        vector<ll> dy={0,1,0,-1};
        vector<vector<ll>> vis(n+1,vector<ll>(m+1,-1));
        priority_queue<pp,vector<pp>,greater<pp>> q;
        q.push({{0,{0,0}},1});
        while(!q.empty()){
            ll t=q.top().first.first;
            ll x=q.top().first.second.first;
            ll y=q.top().first.second.second;
            ll move=q.top().second;
            q.pop();
            if(vis[x][y]!=-1){
                continue;
            }else vis[x][y]=t;
            for(ll i=0;i<4;i++){
                ll xx=x+dx[i];
                ll yy=y+dy[i];
                if(xx<n && xx>=0 && yy>=0 && yy<m){
                    ll tt=max(t,a[xx][yy])+move;
                    if(vis[xx][yy]==-1)
                    q.push({{tt,{xx,yy}},(move==1? 2:1)});
                }
            }
        }
        return (int)vis[n-1][m-1];
    }
};",1441317292
vedantgore_2004,vedantgore_2004,217,3636,cpp,"class Solution {
public:
    bool isBalanced(string a) {
        int x=0;
        int y=0;
        for(int i=0;i<a.size();i++){
            if(i&1){
                x+=a[i]-'0';
            }else y+=a[i]-'0';
        }
        return x==y;
    }
};",1441282073
vedantgore_2004,vedantgore_2004,217,3637,cpp,"class Solution {
public:
    typedef long long ll;
    const int mod = 1e9 + 7;
    ll fact[81], ifact[81];

    ll modPow(ll x, ll y, ll p) {
        ll res = 1;
        x %= p;
        while (y > 0) {
            if (y & 1)
                res = res * x % p;
            y >>= 1;
            x = x * x % p;
        }
        return res;
    }

    // Function to find modular inverse of b under MOD
    ll modInverse(ll b, ll mod) { return modPow(b, mod - 2, mod); }

    // Function to perform modular division a / b under MOD
    ll div(ll a, ll b, ll mod) { return (a * modInverse(b, mod)) % mod; }

    void precompute() {
        fact[0] = 1;
        for (ll i = 1; i <= 80; i++)
            fact[i] = fact[i - 1] * i % mod;
        for (ll i = 0; i <= 80; i++)
            ifact[i] = modPow(fact[i], mod - 2, mod);
    }

    ll func(ll ind, ll tk, ll sum, string& s, vector<vector<vector<ll>>>& dp) {
        ll n = s.size();
        if (ind == n) {
            return sum == 0 && tk == 0;
        }
        if (dp[ind][tk][sum] != -1)
            return dp[ind][tk][sum];
        ll i = s[ind] - '0';
        ll ways = func(ind + 1, tk, sum, s, dp);
        if (sum >= i && tk > 0) {
            ways = (ways + func(ind + 1, tk - 1, sum - i, s, dp)) % mod;
        }
        return dp[ind][tk][sum] = ways;
    }
    int countBalancedPermutations(string s) {
        ll n = s.size();
        ll sum = 0;
        map<ll, ll> fr;
        for (int i = 0; i < n; i++) {
            sum += (s[i] - '0');
            fr[s[i] - '0']++;
        }
        if (sum & 1)
            return 0;
        else
            sum /= 2;
        precompute();
        ll k = n / 2;
        ll rem = n - k;
        vector<vector<vector<ll>>> dp(
            n + 1, vector<vector<ll>>(k + 1, vector<ll>(sum + 1, -1)));
        ll ways = func(0, k, sum, s, dp);
        ways = (ways * fact[rem]) % mod;
        ways = (ways * fact[k]) % mod;
        // cout<<ways<<endl;
        for(int i=0;i<=9;i++){
            ll x=fr[i];
            if(x>1){
                ways=div(ways,fact[x],mod);
            }
        }
        return ways%mod;
    }
};",1441382415
Kashyap Sukshavasi,enkixly,218,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int dungeonHeight = moveTime.size();
        int dungeonWidth = moveTime[0].size();
        
        int finalRoomX = dungeonHeight - 1;
        int finalRoomY = dungeonWidth - 1;
        
        vector<vector<int>> quickestPath(dungeonHeight, vector<int>(dungeonWidth, INT_MAX));
        
        queue<pair<int, pair<int, int>>> roomQueue;
        roomQueue.push({0, {0, 0}});
        quickestPath[0][0] = 0;
        
        vector<pair<int, int>> possibleMoves = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!roomQueue.empty()) {
            int timeSpent = roomQueue.front().first;
            int myX = roomQueue.front().second.first;
            int myY = roomQueue.front().second.second;
            roomQueue.pop();
            
            if (timeSpent > quickestPath[myX][myY]) continue;
            
            for (auto& nextMove : possibleMoves) {
                int nextX = myX + nextMove.first;
                int nextY = myY + nextMove.second;
                
                if (nextX >= 0 && nextX < dungeonHeight && nextY >= 0 && nextY < dungeonWidth) {
                    int timeToNext = max(timeSpent, moveTime[nextX][nextY]) + 1;
                    
                    if (timeToNext < quickestPath[nextX][nextY]) {
                        quickestPath[nextX][nextY] = timeToNext;
                        roomQueue.push({timeToNext, {nextX, nextY}});
                    }
                }
            }
        }
        
        return quickestPath[finalRoomX][finalRoomY];
    }
};",1441291465
Kashyap Sukshavasi,enkixly,218,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int height = moveTime.size();
        int width = moveTime[0].size();
        
        vector<vector<long long>> bestOddPath(height, vector<long long>(width, LLONG_MAX));
        vector<vector<long long>> bestEvenPath(height, vector<long long>(width, LLONG_MAX));
        
        priority_queue<pair<long long, tuple<int, int, int>>, 
                      vector<pair<long long, tuple<int, int, int>>>, 
                      greater<>> paths;
                      
        paths.push({0, {0, 0, 0}});
        bestEvenPath[0][0] = 0;
        
        int row[] = {-1, 0, 1, 0};
        int col[] = {0, 1, 0, -1};
        
        while (!paths.empty()) {
            auto [time, current] = paths.top();
            auto [x, y, steps] = current;
            paths.pop();
            
            if ((steps % 2 == 0 && time > bestEvenPath[x][y]) || 
                (steps % 2 == 1 && time > bestOddPath[x][y])) {
                continue;
            }
            
            if (x == height-1 && y == width-1) {
                return time;
            }
            
            for (int i = 0; i < 4; i++) {
                int nextX = x + row[i];
                int nextY = y + col[i];
                
                if (nextX < 0 || nextY < 0 || nextX >= height || nextY >= width) continue;
                
                long long nextTime = max(time, (long long)moveTime[nextX][nextY]) + (steps % 2 == 0 ? 1 : 2);
                bool isNextOdd = !bool(steps % 2);
                auto& bestPath = isNextOdd ? bestOddPath : bestEvenPath;
                
                if (nextTime < bestPath[nextX][nextY]) {
                    bestPath[nextX][nextY] = nextTime;
                    paths.push({nextTime, {nextX, nextY, steps + 1}});
                }
            }
        }
        
        return -1;
    }
};",1441296965
Kashyap Sukshavasi,enkixly,218,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for (int i = 0; i < num.size(); i++) {
            int digit = num[i] - '0';
            if (i % 2 == 0) {
                even += digit;
            } else {
                odd += digit;
            }
        }
        return even == odd;
    }
};
",1441286920
Kashyap Sukshavasi,enkixly,218,3637,python3,"MOD = 1000000007

def powerModFunc(a, b):
    res = 1
    a %= MOD
    while b > 0:
        if b & 1:
            res = res * a % MOD
        a = a * a % MOD
        b >>= 1
    return res

def initFact(n):
    fact = [1] * (n + 1)
    for i in range(1, n + 1):
        fact[i] = fact[i - 1] * i % MOD
    invFact = [1] * (n + 1)
    invFact[n] = powerModFunc(fact[n], MOD - 2)
    for i in range(n - 1, -1, -1):
        invFact[i] = invFact[i + 1] * (i + 1) % MOD
    return fact, invFact

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        freq = [0] * 10
        totalSum = 0
        
        for c in num:
            d = int(c)
            freq[d] += 1
            totalSum += d
        
        if totalSum % 2 != 0:
            return 0
        
        sumHalf = totalSum // 2
        k = (n + 1) // 2
        
        fact, invFact = initFact(n)
        
        dp = [[0] * (sumHalf + 1) for _ in range(k + 1)]
        dp[0][0] = 1
        
        for d in range(10):
            if freq[d] == 0:
                continue
            for c in range(k, -1, -1):
                for s in range(sumHalf, -1, -1):
                    if dp[c][s] == 0:
                        continue
                    for t in range(1, min(freq[d], k - c) + 1):
                        if s + d * t > sumHalf:
                            break
                        comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD
        
        validAssignments = dp[k][sumHalf]
        if validAssignments == 0:
            return 0
        
        prodFactFd = 1
        for d in range(10):
            prodFactFd = prodFactFd * fact[freq[d]] % MOD
        
        fkFnk = (fact[k] * fact[n - k]) % MOD
        invProdFactFd = powerModFunc(prodFactFd, MOD - 2)
        answer = (fkFnk * validAssignments) % MOD
        answer = (answer * invProdFactFd) % MOD
        
        return answer
",1441382904
RONAK GARG,Ronak9910,219,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int>, vector<tuple<long long, int, int>>, greater<tuple<long long, int, int>>> pq;
        pq.push({0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1);
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny});
                    }
                }
            }
        }
        return -1;
    }
};",1441303897
RONAK GARG,Ronak9910,219,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size(), m = mt[0].size();
        vector<pair<int, int>> d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        priority_queue<tuple<long long, int, int, int>, vector<tuple<long long, int, int, int>>, greater<tuple<long long, int, int, int>>> pq;
        pq.push({0, 0, 0, 0});
        vector<vector<long long>> minT(n, vector<long long>(m, 1e15));
        minT[0][0] = 0;

        while (!pq.empty()) {
            auto [t, x, y, l] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) return t;

            for (auto& dir : d) {
                int nx = x + dir.first, ny = y + dir.second;
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long long wt = max(t + 1, 1LL * mt[nx][ny] + 1) + l;
                    bool m = 0;
                    if(l == 0)
                        m = 1;
                    else
                        m = 0;
                        
                    if (wt < minT[nx][ny]) {
                        minT[nx][ny] = wt;
                        pq.push({wt, nx, ny, m});
                    }
                }
            }
        }
        return -1;
    }
};",1441316741
RONAK GARG,Ronak9910,219,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < n; i++)
        {
            int val = num[i] - '0';
            if(i & 1)
                sum1 += val;
            else
                sum2 += val;
        }
        return (sum1 == sum2);
    }
};",1441283517
RONAK GARG,Ronak9910,219,3637,cpp,"class Solution {
private:
    long long modInv(long long a, int m) {
        long long res = 1, base = a, p = m - 2;
        while (p > 0) {
            if (p & 1) res = (res * base) % m;
            base = (base * base) % m;
            p >>= 1;
        }
        return res;
    }

    long long comb(int n, int k, const vector<long long>& fact, const vector<long long>& inv_fact) {
        if (k > n) return 0;
        return ((fact[n] * inv_fact[k]) % MOD * inv_fact[n - k]) % MOD;
    }

    static const int MOD = 1e9 + 7;

public:
    int countBalancedPermutations(const std::string& num) {
        int len = num.length();
        int total = 0;
        for(auto i : num)
                total += (i - '0');
        if (total % 2 != 0) return 0;

        int half = total / 2;
        int m = (len + 1) / 2;
        std::vector<int> cnt(10, 0);
        for (char d : num) cnt[d - '0']++;

        vector<long long> fact(len + 1, 1);
        for (int i = 1; i <= len; i++) fact[i] = (fact[i - 1] * i) % MOD;

        vector<long long> inv_fact(len + 1, 1);
        inv_fact[len] = modInv(fact[len], MOD);
        for (int i = len - 1; i >= 0; i--) inv_fact[i] = (inv_fact[i + 1] * (i + 1)) % MOD;

        vector<vector<long long>> dp(m + 1, vector<long long>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (cnt[d] == 0) continue;
            for (int k = m; k >= 0; k--) {
                for (int s = half; s >= 0; s--) {
                    if (dp[k][s] == 0) continue;
                    for (int t = 1; t <= cnt[d]; t++) {
                        if (k + t > m || s + d * t > half) break;
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + dp[k][s] * comb(cnt[d], t, fact, inv_fact)) % MOD;
                    }
                }
            }
        }

        long long w = dp[m][half];
        long long res = (fact[m] * fact[len - m]) % MOD;
        for (int d = 0; d < 10; d++) res = (res * inv_fact[cnt[d]]) % MOD;
        res = (res * w) % MOD;
        return (res);
    }
};
",1441383218
Sam Chen,SamChen856,220,3627,python3,"class Solution:
    # Dijkstra, priority queue, time O(nmlog(nm)), space O(nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        pq = [(0, 0, 0)]  # (current time, x, y)
        
        while pq:
            t, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + 1
                    if dist[nx][ny] > new_t:
                        dist[nx][ny] = new_t
                        heappush(pq, (new_t, nx, ny))

        assert False",1441304382
Sam Chen,SamChen856,220,3628,python3,"class Solution:
    # Dijkstra, priority queue, time O(2nmlog(nm)), space O(2nm)
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        DIRS = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        n, m = len(moveTime), len(moveTime[0])
        dist = [[[inf] * m for _ in range(n)] for _ in range(3)]
        dist[1][0][0] = 0  # (speed, x, y)
        pq = [(0, 1, 0, 0)]  # (current time, speed, x, y)

        while pq:
            t, s, x, y = heappop(pq)

            if (x, y) == (n - 1, m - 1):
                return t

            if t > dist[s][x][y]:
                continue

            for dx, dy in DIRS:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    new_t = max(t, moveTime[nx][ny]) + s
                    new_s = 3 - s
                    if dist[new_s][nx][ny] > new_t:
                        dist[new_s][nx][ny] = new_t
                        heappush(pq, (new_t, new_s, nx, ny))

        assert False
        ",1441312485
Sam Chen,SamChen856,220,3636,python3,"class Solution:
    # 1 pass, time O(n), space O(1)
    def isBalanced(self, num: str) -> bool:
        sums = [0, 0]
        for i, x in enumerate(num):
            sums[i % 2] += int(x)
        return sums[0] == sums[1]",1441289057
Sam Chen,SamChen856,220,3637,python3,"M = 1000
MOD = 10**9 + 7

fact = [1] * (M + 1)
for i in range(M):
    fact[i + 1] = fact[i] * (i + 1) % MOD
inv_fact = [1] * (M + 1)
inv_fact[-1] = pow(fact[-1], MOD - 2, MOD)
for i in reversed(range(M)):
    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD


class Solution:
    # DP + combinatorics, time O(100L^3), space O(10L^2), L = num.length
    def countBalancedPermutations(self, num: str) -> int:
        num = list(map(int, num))

        target_sum = sum(num)
        if target_sum % 2:
            return 0
        target_sum //= 2

        L = len(num)
        L_even = (L + 1) // 2
        cnt = Counter(num)
        dp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
        dp[0][0] = 1

        for d in range(10):
            ndp = [[0] * (target_sum + 1) for _ in range(L_even + 1)]
            for i in range(L_even + 1):
                for j in range(target_sum + 1):
                    if dp[i][j] == 0:
                        continue
                    for c in range(min(cnt[d], L_even - i) + 1):
                        ni, nj = i + c, j + d * c
                        if nj <= target_sum:
                            ndp[ni][nj] = (ndp[ni][nj] + dp[i][j] * inv_fact[c] * inv_fact[cnt[d] - c]) % MOD
            dp = ndp

        return fact[L_even] * fact[L - L_even] * dp[L_even][target_sum] % MOD",1441383568
Ayush Sharma,ayush-018,221,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        
        int r = moveTime.size();
        int c = moveTime[0].size();

        vector<vector<int>> minDist(r, vector<int>(c, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> minHeap;

        minHeap.push({0, 0, 0}); // {time, row, col}
        minDist[0][0] = 0;

        vector<vector<int>> direction = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!minHeap.empty()) {
            auto current = minHeap.top();
            minHeap.pop();
            int cT = current[0];
            int cR = current[1];
            int cC = current[2];

            if (cT > minDist[cR][cC]) continue;

            for (const auto& d : direction) {
                int newRow = cR + d[0];
                int newCol = cC + d[1];

                if (newRow >= 0 && newRow < r && newCol >= 0 && newCol < c) {
                    int newTime = max(cT, moveTime[newRow][newCol]) + 1;

                    if (newTime < minDist[newRow][newCol]) {
                        minDist[newRow][newCol] = newTime;
                        minHeap.push({newTime, newRow, newCol});
                    }
                }
            }
        }

        return minDist[r - 1][c - 1] == INT_MAX ? -1 : minDist[r - 1][c - 1];

    }
};",1441321399
Ayush Sharma,ayush-018,221,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>moveTime)
    {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<int>>> minTime(n, vector<vector<int>>(m, vector<int>(2, numeric_limits<int>::max())));
        minTime[0][0][0] = 0;

        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> gPq;
        gPq.push({0, {0, 0, 0}});

        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!gPq.empty()) {
            auto [currentTime, pos] = gPq.top();
            gPq.pop();
            int row = pos[0], col = pos[1], parity = pos[2];

            if (currentTime > minTime[row][col][parity]) continue;

            for (auto [dx, dy] : directions) {
                int x = row + dx;
                int y = col + dy;

                if (x >= 0 && x < n && y >= 0 && y < m) {
                    int nextTime = max(currentTime, moveTime[x][y]) + (parity == 0 ? 1 : 2);
                    
                    if (nextTime < minTime[x][y][1 - parity]) {
                        minTime[x][y][1 - parity] = nextTime;
                        gPq.push({nextTime, {x, y, 1 - parity}});
                    }
                }
            }
        }
        
        return min(minTime[n - 1][m - 1][0], minTime[n - 1][m - 1][1]);
    }
};",1441327061
Ayush Sharma,ayush-018,221,3636,cpp,"class Solution {
private:
    int calculateEven(const string& num) {
        int evenSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 == 0) {
                evenSum += num[i] - '0';
            }
        }
        return evenSum;
    }

    int calculateOdd(const string& num) {
        int oddSum = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i % 2 != 0) {
                oddSum += num[i] - '0';
            }
        }
        return oddSum;
    }
public:
    bool isBalanced(string num) {
        ios_base::sync_with_stdio(false);
        cin.tie(nullptr);
        cout.tie(nullptr);
        int evenSum = calculateEven(num);
        int oddSum = calculateOdd(num);
        if(evenSum==oddSum) return true;
        else return false;
    }
};",1441291164
Ayush Sharma,ayush-018,221,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int n = num.size();
        int evenC = (n + 1) / 2;
        int oddC = n / 2;

        string inputString = num;
        int digitCount[10] = {0};
        for (char digit : num) {
            digitCount[digit - '0']++;
        }

        long long totalSum = 0;
        for (int digit = 0; digit < 10; digit++) {
            totalSum += (long long)digit * digitCount[digit];
        }

        if (totalSum % 2 != 0) return 0;

        long long targetSum = totalSum / 2;
        vector<long long> factorial = preFact(80, MOD);
        vector<long long> invFact = ComputeFact(factorial, MOD);

        auto comb = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFact[k] % MOD * invFact[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenC + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int digit = 0; digit < 10; digit++) {
            if (digitCount[digit] == 0) continue;
            for (int t = evenC; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue;
                    for (int k = 1; k <= digitCount[digit] && t + k <= evenC && s + (long long)digit * k <= targetSum; k++) {
                        dp[t + k][s + (long long)digit * k] = (dp[t + k][s + (long long)digit * k] + dp[t][s] * comb(digitCount[digit], k)) % MOD;
                    }
                }
            }
        }

        long long validAssign = dp[evenC][targetSum];
        long long productFactorial = 1;
        for (int digit = 0; digit < 10; digit++) {
            productFactorial = productFactorial * factorial[digitCount[digit]] % MOD;
        }

        long long result = validAssign;
        result = result * factorial[evenC] % MOD;
        result = result * factorial[oddC] % MOD;
        long long inverseProduct = power(productFactorial, MOD - 2, MOD);
        result = result * inverseProduct % MOD;

        return (int)result;
    }

private:
    vector<long long> preFact(int maxValue, int mod) {
        vector<long long> factorial(maxValue + 1, 1);
        for (int i = 1; i <= maxValue; i++) {
            factorial[i] = factorial[i - 1] * i % mod;
        }
        return factorial;
    }

    vector<long long> ComputeFact(const vector<long long>& factorial, int mod) {
        int maxValue = factorial.size() - 1;
        vector<long long> invFact(maxValue + 1, 1);
        invFact[maxValue] = power(factorial[maxValue], mod - 2, mod);
        for (int i = maxValue - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % mod;
        }
        return invFact;
    }

    long long power(long long base, long long exp, long long mod) {
        long long result = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) result = result * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return result;
    }
};
",1441365481
Evan Tian,etian6795,222,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][] d = new long[n][m];
        boolean[][] seen = new boolean[n][m];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = Long.MAX_VALUE;
            }
        }
        d[0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[2], b[2]));
        pq.add(new long[]{0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            long time = curr[2];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y]) continue;
            seen[x][y] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + 1;

                    if(next <= moveTime[nx][ny] + 1) {
                        next = moveTime[nx][ny] + 1;
                    }


                    if(next < d[nx][ny]) {
                        d[nx][ny] = next;
                        pq.add(new long[]{nx, ny, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342435
Evan Tian,etian6795,222,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dirs = { {1,0}, {-1,0}, {0,1}, {0,-1} };

        long[][][] d = new long[n][m][2];
        boolean[][][] seen = new boolean[n][m][2];
        for(int i = 0;i < n; i++) {
            for(int j = 0; j < m; j++) {
                Arrays.fill(d[i][j], Long.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[3], b[3]));
        pq.add(new long[]{0, 0, 0, 0});

        while(!pq.isEmpty()) {
            long[] curr = pq.poll();
            int x = (int)curr[0];
            int y = (int)curr[1];
            int p = (int)curr[2];
            long time = curr[3];

            if(x == n-1 && y == m-1) {
                return (int)time;
            }

            if(seen[x][y][p]) continue;
            seen[x][y][p] = true;
            
            for(int[] dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];

                if(nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    long next = time + ((p == 0) ? 1 : 2);

                    if(next <= moveTime[nx][ny] + ((p == 0) ? 1 : 2)) {
                        next = moveTime[nx][ny] + ((p == 0) ? 1 : 2);
                    }

                    int nextp = 1 - p;

                    if(next < d[nx][ny][nextp]) {
                        d[nx][ny][nextp] = next;
                        pq.add(new long[]{nx, ny, nextp, next});
                    }
                }
            }
        }

        return -1;
    }
}
",1441342250
Evan Tian,etian6795,222,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int e = 0;
        int o = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = Character.getNumericValue(num.charAt(i));
            if (i % 2 == 0) {
                e += digit;
            } else {
                o += digit;
            }
        }

        return e == o;
    }
}",1441343466
Evan Tian,etian6795,222,3637,java,"class Solution {
    public long MOD = 1_000_000_007;
    public long[] fact;
    public long[] invFact;
    public int n;
    public int[] f = new int[10];
    Map<String, Long> memo;

    public int countBalancedPermutations(String num) {
        for(char c : num.toCharArray()){
            f[c - '0']++;
        }
        n = num.length();

        int target = 0;
        for(int i = 0; i <= 9; i++) {
            target += i * f[i];
        }

        if(target % 2 != 0){
            return 0;
        }
        target /= 2;

        int e = (n + 1) / 2;
        int o = n / 2;

        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i - 1] * i) % MOD;
        }
        invFact[n] = expo(fact[n], MOD - 2);
        for(int i = n - 1; i >= 0; i--){
            invFact[i] = (invFact[i+1] * (i+1)) % MOD;
        }

        memo = new HashMap<>();

        long qwe = rec(0, target, e);

        long asd = 1;
        for(int i = 0; i <= 9; i++) {
            if(f[i] > n) {
                return 0;
            }
            asd = (asd * fact[f[i]]) % MOD;
        }
        asd = expo(asd, MOD - 2);

        long ans = fact[e] * fact[o] % MOD;
        ans = (ans * qwe) % MOD;
        ans = (ans * asd) % MOD;

        return (int)(ans);
    }

    private long rec(int digit, int sum, int count){
        String key = digit + "","" + sum + "","" + count;

        if(memo.containsKey(key)){
            return memo.get(key);
        }

        if(digit == 10){
            if(sum == 0 && count == 0){
                return 1;
            }
            else{
                return 0;
            }
        }

        if(sum < 0 || count < 0){
            return 0;
        }

        long total = 0;
        int max = Math.min(count, f[digit]);
        for(int i = 0; i <= max; i++){
            if(i * digit > sum){
                break;
            }
            
            long qwe = combination(f[digit], i);

            total = (total + qwe * rec(digit + 1, sum - i * digit, count - i)) % MOD;
        }

        memo.put(key, total);
        return total;
    }

    private long combination(int n, int k){
        if(k < 0 || k > n){
            return 0;
        }
        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;
    }

    private long expo(long a, long b){
        long res =1;
        a %= MOD;
        while(b >0){
            if( (b &1) ==1 ){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>=1;
        }
        return res;
    }
}
",1441384193
Paridhi Agarwal,paridhi_,224,3627,cpp,"#include <vector>
#include <queue>
#include <limits>
#include <algorithm>
#include <array>

class Solution
{
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, std::numeric_limits<int>::max()));
        int i = 0;
        if (n > 0)
            do
            {
                std::fill(dist[i].begin(), dist[i].end(), std::numeric_limits<int>::max());
                i++;
            }
            while (!(i < n)==false);
        using T = std::array<int, 3>;
        auto cmp = [](const T& a, const T& b) { return a[0] > b[0]; };
        std::priority_queue<T, std::vector<T>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        std::vector<std::vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        for (; (!(!pq.empty())==false);)
        {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];
            if (!(time > dist[row][col]) == false)
                continue;
            int dirIndex = 0;
            while (!(dirIndex < dirs.size()) ==false)
            {
                auto dir = dirs[dirIndex];
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                if (!(newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) == false)
                {
                    int newTime = std::max(time, moveTime[newRow][newCol]) + 1;
                    if (!(newTime < dist[newRow][newCol]) == false)
                    {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
                dirIndex++;
            }
        }
        return dist[n - 1][m - 1];
    }
};
",1441371856
Paridhi Agarwal,paridhi_,224,3628,cpp,"#include <vector>
#include <queue>
#include <array>
#include <climits>
#include <functional>
class Solution
{
public:
    int minTimeToReach(const std::vector<std::vector<int>>& moveTime)
    {
        int n = moveTime.size();
        int m = moveTime[0].size();
        std::vector<std::vector<std::array<int, 2>>> d(n, std::vector<std::array<int, 2>>(m, {INT_MAX, INT_MAX}));
        int i = 0;
        do
        {
            int j = 0;
            while (j < m)
            {
                d[i][j][0] = INT_MAX;
                d[i][j][1] = INT_MAX;
                j++;
            }
            i++;
        }
        while (i < n);
        d[0][0][0] = 0;
        auto cmp = [](const std::array<int, 4>& a, const std::array<int, 4>& b) {
            return a[0] > b[0];
        };
        std::priority_queue<std::array<int, 4>, std::vector<std::array<int, 4>>, decltype(cmp)> pq(cmp);
        pq.push({0, 0, 0, 0});
        std::vector<std::array<int, 2>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        for (; !(!pq.empty()) == false; )
        {
            auto current = pq.top();
            pq.pop();
            int t = current[0];
            int iCur = current[1];
            int jCur = current[2];
            int p = current[3];
            
            if (!(t > d[iCur][jCur][p]) == false)
                continue;
            
            int dirIndex = 0;
            while (!(dirIndex < directions.size()) == false)
            {
                auto dir = directions[dirIndex];
                int ni = iCur + dir[0];
                int nj = jCur + dir[1];
                
                if (!(ni >= 0 && ni < n && nj >= 0 && nj < m) == false)
                {
                    int nt = std::max(t, moveTime[ni][nj]) + (p == 0 ? 1 : 2);
                    if (!(nt < d[ni][nj][1 - p]) == false)
                    {
                        d[ni][nj][1 - p] = nt;
                        pq.push({nt, ni, nj, 1 - p});
                    }
                }
                dirIndex++;
            }
        }
        return std::min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};
",1441353548
Paridhi Agarwal,paridhi_,224,3636,cpp,"#include <string>
class Solution
{
public:
    bool isBalanced(const std::string& num)
    {
        int evenSum = 0;
        int oddSum = 0;
        int i = 0;
        do
        {
            int digit = num[i] - '0';
            if (!(i % 2 == 0) == false) 
                evenSum += digit;
            else
                oddSum += digit;
            i++;
        }
        while (!(i < num.length()) == false);
        return (!(evenSum == oddSum) == false);
    }
};
",1441295940
Paridhi Agarwal,paridhi_,224,3637,cpp,"#include <vector>
#include <string>
#include <algorithm>

class Solution {
private:
    static const int MOD = 1000000007;
    std::vector<long long> fact;
    std::vector<long long> invFact;

    long long powerMod(long long a, long long b) {
        long long res = 1;
        a %= MOD;
        while (b > 0) {
            if (!((b & 1) == 1) == false) {
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    void initFact(int n) {
        fact.resize(n + 1);
        invFact.resize(n + 1);
        fact[0] = 1;
        int i = 1;
        do {
            fact[i] = fact[i - 1] * i % MOD;
            i++;
        } while (i <= n);
        invFact[n] = powerMod(fact[n], MOD - 2);
        int j = n - 1;
        do {
            invFact[j] = invFact[j + 1] * (j + 1) % MOD;
            j--;
        } while (j >= 0);
    }

public:
    int countBalancedPermutations(std::string num) {
        int n = num.length();
        std::vector<int> freq(10, 0);
        long long totalSum = 0;
        std::vector<char> C(num.begin(), num.end());
        int i = 0;
        if (n > 0) {
            do {
                char c = C[i];
                int d = c - '0';
                freq[d]++;
                totalSum += d;
                i++;
            } while (i < n);
        }

        if (!(totalSum % 2 != 0) == false) {
            return 0;
        }
        long long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);
        std::vector<std::vector<long long>> dp(k + 1, std::vector<long long>((int)sumHalf + 1, 0));
        dp[0][0] = 1;
        int d = 0;
        do {
            if (!(freq[d] == 0) == false)
            {
                d++;
                continue;
            }
            int c = k;
            while (c >= 0)
            {
                long long s = sumHalf;
                do
                {
                    if (!(dp[c][(int)s] == 0) == false)
                    {
                        s--;
                        continue;
                    }
                    int t = 1;
                    while (true)
                    {
                        if (!(t > std::min(freq[d], k - c)) == false)
                            break;
                        if (!(s + (long long)d * t > sumHalf) == false)
                            break;
                        long long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int)(s + d * t)] = (dp[c + t][(int)(s + d * t)] + dp[c][(int)s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                while (s >= 0);
                c--;
            }
            d++;
        }
        while (d <= 9);
        long long validAssignments = dp[k][(int)sumHalf];
        if (!(validAssignments == 0) == false) {
            return 0;
        }
        long long prodFactFd = 1;
        int digit = 0;
        while (digit <= 9)
        {
            prodFactFd = prodFactFd * fact[freq[digit]] % MOD;
            digit++;
        }
        long long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;
        return (int)answer;
    }
};
",1441396969
jacobj2,jacobj2,225,3627,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[inf]*len(m[0]) for i in range(len(m))]
        dp[0][0] = inf
        heap = [(0,0,0)]
        while heap:
            time, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc] > max(time + 1, m[dr][dc] + 1):
                    dp[dr][dc] = max(time+1,m[dr][dc] + 1)
                    heappush(heap, (dp[dr][dc],dr,dc))
        return -1",1441301318
jacobj2,jacobj2,225,3628,python3,"class Solution:
    def minTimeToReach(self, m: List[List[int]]) -> int:
        dp = [[[inf,inf] for _ in range(len(m[0]))] for i in range(len(m))]
        dp[0][0][0] = 0
        heap = [(0,0,0,0)]
        while heap:
            time, od, r, c = heappop(heap)
            if r==len(m)-1 and c==len(m[0])-1:
                return time
            for dr, dc in [(r+1,c),(r-1,c),(r,c-1),(r,c+1)]:
                if od==0:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 1, m[dr][dc] + 1):
                        dp[dr][dc][1-od] = max(time+1,m[dr][dc] + 1)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
                elif od==1:
                    if 0<=dr<len(m) and 0<=dc<len(m[0]) and dp[dr][dc][1-od] > max(time + 2, m[dr][dc] + 2):
                        dp[dr][dc][1-od] = max(time+2,m[dr][dc] + 2)
                        heappush(heap, (dp[dr][dc][1-od],1-od,dr,dc))
        return -1",1441304952
jacobj2,jacobj2,225,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e = o = 0
        for i in range(len(num)):
            if i%2==0:
                e+=int(num[i])
            else:
                o+=int(num[i])
        return e==o",1441280777
jacobj2,jacobj2,225,3637,python3,"MOD = 10**9+7
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        tot = 0
        for i in range(len(num)):
            tot+=int(num[i])
        if tot%2==1:
            return 0
        ct = defaultdict(int)
        for i in range(len(num)):
            ct[int(num[i])]+=1
        r1 = len(num) - len(num)//2
        pref = [0]*10
        for i in range(len(pref)):
            pref[i] = ct[i]
            if i > 0:
                pref[i]+=pref[i-1]
        #print(pref)
        @cache
        def dfs(index, remSum, remInd):
            if remSum < 0 or remInd < 0:
                return 0
            if index==10:
                return int(remSum==0 and remInd==0)
            usedOdd = 0 if index==0 else pref[index - 1] - (len(num)//2 - remInd)
            leftOdd = len(num) - len(num)//2 - usedOdd
            if leftOdd < 0:
                return 0
            res = 0
            for x in range(ct[index]+1):
                left = ct[index] - x
                if left > leftOdd:
                    continue
                res+=(((dfs(index+1,remSum-x*index, remInd - x)*math.comb(remInd, x))%MOD)*math.comb(leftOdd,left))%MOD
                if res >= MOD:
                    res-=MOD
            return res
        a = dfs(0,tot//2,len(num)//2)
        dfs.cache_clear()
        return a",1441372719
IphoneX,hahahiehie,226,3627,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + e.w) {
                        if (w + e.w > board[e.to]) {
                            dist[e.to] = w + e.w;
                            q.add(new Edge(e.to, w + e.w));
                        } else {
                            dist[e.to] = board[e.to] + 1;
                            q.add(new Edge(e.to, board[e.to] + 1));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441298213
IphoneX,hahahiehie,226,3628,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static class DijkstraLongFaster {
        public static class Edge {
            int to;
            long w;

            int last;

            public Edge(int to, long w) {
                this.to = to;
                this.w = w;
            }

            public Edge(int to, long w, int last) {
                this.to = to;
                this.w = w;
                this.last = last;
            }
        }

        public static final long INF = Long.MAX_VALUE / 4;
        public List<Edge>[] adj;

        public DijkstraLongFaster(int n) {
            this.adj = new List[n];
            for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
        }

        public void link(int x, int y, long w) {
            adj[x].add(new Edge(y, w));
        }

        public long[] shortestPath(int src, int[] board) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
            q.add(new Edge(src, 0, 2));
            dist[src] = 0;

            while (!q.isEmpty()) {
                Edge cur = q.poll();
                if (vst[cur.to]) continue;
                int u = cur.to;
                long w = cur.w;
                int last = cur.last;
                int nextStep = last == 1 ? 2 : 1;
                vst[u] = true;

                for (Edge e : adj[u]) {
                    if (!vst[e.to] && dist[e.to] > w + nextStep) {
                        if (w + nextStep >= board[e.to] + nextStep) {
                            dist[e.to] = w + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        } else {
                            dist[e.to] = board[e.to] + nextStep;
                            q.add(new Edge(e.to, dist[e.to], nextStep));
                        }
                    }
                }
            }
            return dist;
        }

        // NOTE: w of each edge must be the same.
        public long[] bfs(int src) {
            int n = adj.length;
            long[] dist = new long[n];
            boolean[] vst = new boolean[n];
            Arrays.fill(dist, INF);

            Queue<Integer> q = new ArrayDeque<>();
            q.add(src);
            dist[src] = 0;
            vst[src] = true;

            while (!q.isEmpty()) {
                int u = q.poll();
                long w = dist[u];
                for (Edge e : adj[u]) {
                    if (!vst[e.to]) {
                        dist[e.to] = w + e.w;
                        vst[e.to] = true;
                        q.add(e.to);
                    }
                }
            }
            return dist;
        }
    }
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;

        int N = m * n;
        int[] board = new int[m * n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                board[i * n + j] = moveTime[i][j];
            }
        }

        DijkstraLongFaster g = new DijkstraLongFaster(m * n);
        for (int i = 0; i < m; i++) {
            for (int j =0; j < n; j++) {
                for (int k = 0; k < DX.length; k++) {
                    int nx = i + DX[k];
                    int ny = j + DY[k];
                    if ((nx >= 0 && nx < m && ny >= 0 && ny < n)) {
                        g.link(i * n + j, nx * n + ny, 1);
                    }
                }
            }
        }
        long[] dist = g.shortestPath(0, board);
        return (int) dist[m * n - 1];
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441304580
IphoneX,hahahiehie,226,3636,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    public boolean isBalanced(String num) {
        int n = num.length();
        int a = 0;
        int b = 0;
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) {
                a += num.charAt(i) - '0';
            } else {
                b += num.charAt(i) - '0';
            }
        }
        return a == b;
    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441281429
IphoneX,hahahiehie,226,3637,java,"import java.util.*;

class Utils {
    public static int log2(long n) {
        return 63 - Long.numberOfLeadingZeros(n);
    }

    // nums = ""aaabaaaba"" odd d[1] return [1, 2, 1, 4, 1, 2, 2]
    // d[0] for even, d[1] for odd
    public static int[][] manacher(String s) {
        int n = s.length();
        int[] d1 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; ++i) {
            int k = (i > r) ? 1 : Math.min(d1[l + r - i], r - i + 1);
            while (0 <= i - k && i + k < n && s.charAt(i - k) == s.charAt(i + k)) k++;
            d1[i] = k;
            if (i + k - 1 > r) {
                l = i - k + 1;
                r = i + k - 1;
            }
        }

        int[] d0 = new int[n];
        for (int i = 0, l = 0, r = -1; i < n; i++) {
            int k = (i > r) ? 0 : Math.min(d0[l + r - i + 1], r - i + 1);
            while (0 <= i - k - 1 && i + k < n && s.charAt(i - k - 1) == s.charAt(i + k)) {
                k++;
            }
            d0[i] = k;
            if (i + k - 1 > r) {
                l = i - k;
                r = i + k - 1;
            }
        }
        return new int[][]{d0, d1};
    }

    // generate primes that is <= n
    public static int[] genPrimes(int n) {
        if (n <= 1) return new int[0];
        boolean[] isComp = new boolean[n + 1];
        int len = 0;
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                len++;
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                }
            }
        }
        int[] ans = new int[len];
        for (int i = 2, j = 0; i <= n; i++) {
            if (!isComp[i]) {
                ans[j++] = i;
            }
        }
        return ans;
    }

    // int[0] = primeFactor, int[1] = count of that primeFactor
    // NOTE: factors[0] and factors[1] are empty list.
    public static List<int[]>[] genPrimeFactors(int n) {
        List<int[]>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            factors[i] = new ArrayList<>();
        }
        boolean[] isComp = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            if (!isComp[i]) {
                factors[i].add(new int[]{i, 1});
                for (int j = i + i; j <= n; j += i) {
                    isComp[j] = true;
                    int t = j, count = 0;
                    while (t % i == 0) {
                        count++;
                        t /= i;
                    }
                    factors[j].add(new int[]{i, count});
                }
            }
        }
        return factors;
    }

    // generate factors (not prime factors), factors[0] is empty list.
    public static List<Integer>[] genFactors(int n) {
        List<Integer>[] factors = new List[n + 1];
        for (int i = 0; i <= n; i++) factors[i] = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            for (int j = i; j <= n; j += i) {
                factors[j].add(i);
            }
        }
        return factors;
    }

    public static int lowerBound(int[] a, int target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(int[] a, int target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(int[] a, int target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int lowerBound(long[] a, long target) {
        return lowerBound(a, target, a.length);
    }

    public static int lowerBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] < target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static int upperBound(long[] a, long target) {
        return upperBound(a, target, a.length);
    }

    public static int upperBound(long[] a, long target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid] <= target) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(T[] a, T target, int n) {
        int low = 0;
        int high = n;
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a[mid].compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int lowerBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) < 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static <T extends Comparable<T>> int upperBound(List<T> a, T target) {
        int low = 0;
        int high = a.size();
        while (low < high) {
            int mid = low + ((high - low) >> 1);
            if (a.get(mid).compareTo(target) <= 0) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return low;
    }

    public static long or(int x, int y) {
        return ((long) x << 32) | ((long) y << 32 >>> 32);
    }

    // k = 0...nums.length - 1
    // After calling this function, nums[k] is the k-th number.
    public static int kthNumber(int[] nums, int k) {
        return kthNumberHelper(nums, k, 0, nums.length - 1);
    }

    // end is inclusive (0 to nums.length - 1)
    private static int kthNumberHelper(int[] nums, int K, int start, int end) {
        if (start == end) return nums[start];
        int i = partition(nums, start, end);
        return K <= i ? kthNumberHelper(nums, K, start, i) : kthNumberHelper(nums, K, i + 1, end);
    }

    // end is inclusive (0 to nums.length - 1)
    public static int partition(int[] nums, int start, int end) {
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && nums[i] < pivot) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && pivot < nums[j]) j--;
            if (i < j) nums[i++] = nums[j];
        }

        // pos is the final position for pivot.
        nums[i] = pivot;
        return i;
    }

    public static void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    // partition nums into 3 parts [smaller than pivot, equal to pivot, larger than pivot]
    public static void partition3(int[] nums, int pivot) {
        int n = nums.length;
        int l = 0, r = n - 1;
        for (int i = 0; i <= r; i++) {
            if (nums[i] < pivot) {
                swap(nums, l++, i);
            } else if (nums[i] > pivot) {
                swap(nums, r--, i--);
            }
        }
    }

    // end is inclusive
    public static void reverse(int[] nums, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            int t = nums[i];
            nums[i] = nums[j];
            nums[j] = t;
        }
    }

    // Return false if next permutation is not available. (nums is not changed for this case)
    public static boolean nextPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] >= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] > nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }

    // Return false if previous permutation is not available. (nums is not changed for this case)
    public static boolean prevPermutation(int[] nums) {
        int n = nums.length;
        if (n <= 1) return false;
        int i = n - 1;
        while (i - 1 >= 0 && nums[i - 1] <= nums[i]) {
            i--;
        }
        if (i <= 0) return false;
        for (int j = n - 1; j >= i; j--) {
            if (nums[j] < nums[i - 1]) {
                int t = nums[j];
                nums[j] = nums[i - 1];
                nums[i - 1] = t;

                reverse(nums, i, n - 1);
                break;
            }
        }
        return true;
    }


    // a, b could be negative
    // remainder >= 0
    // return [a / b, a % b]
    public static int[] divMod(int a, int b) {
        int r = a % b;
        int c = a / b;
        if (r < 0) {
            r += Math.abs(b);
            c++;
        }
        return new int[]{c, r};
    }

    public static List<Integer> negativeBase(int n, int base) {
        List<Integer> digits = new ArrayList<>();
        if (n == 0) {
            digits.add(0);
            return digits;
        }
        while (n != 0) {
            // t[0] = n / base
            // t[1] = n % base;
            int[] t = divMod(n, base);
            digits.add(t[1]);
            n = t[0];
        }
        Collections.reverse(digits);
        return digits;
    }

    // (a ^ b) % MOD
    public static long powMod(long a, long b, long MOD) {
        long res = 1L;
        a %= MOD; // In case a * a is overflow
        while (b > 0) {
            if ((b & 1) != 0) res = (res * a) % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    public static long[][] genCombination(int n) {
        long[][] C = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        return C;
    }

    public static long[][] genPermutation(int n) {
        long[][] P = new long[n + 1][n + 1];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= i && j <= n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
        return P;
    }

    public static long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }

    public static int[] preprocessLog2(int n) { // from log2(0) .... log2(n) inclusive
        int[] lg = new int[n + 1];
        for (int k = 0, i = 1; i <= n; lg[i++] = k - 1) {
            while ((1 << k) <= i) {
                k++;
            }
        }
        return lg;
    }

    public static long max(long[] nums) {
        long ret = Long.MIN_VALUE;
        for (long v : nums) ret = Math.max(ret, v);
        return ret;
    }

    public static int max(int[] nums) {
        int ret = Integer.MIN_VALUE;
        for (int v : nums) ret = Math.max(ret, v);
        return ret;
    }
}

// Tested by leetcode 1163
class SuffixArray {
    int[] s;
    int[] SA; // SA[i] => index of the i-th ranked suffix
    int[] rank; // rank[i] => the rank of i-th suffix, SA[rank[i]] == i
    int[] height; // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).

    private int[][] d;
    private int n;
    private int[] lg;

    private int log2(int n) {
        return 31 - Integer.numberOfLeadingZeros(n);
    }

    private static int[] stringToIntArray(String str) {
        int[] nums = new int[str.length()];
        for (int i = 0; i < str.length(); i++) nums[i] = str.charAt(i);
        return nums;
    }

    public SuffixArray(String str) {
        this(str, true);
    }

    public SuffixArray(String str, boolean toBuildRMQ) {
        this(stringToIntArray(str), toBuildRMQ);
    }

    public SuffixArray(int[] nums) {
        this(nums, true);
    }

    public SuffixArray(int[] nums, boolean toBuildRMQ) {
        this.s = nums;
        this.n = nums.length;
        this.SA = new int[n];
        this.rank = new int[n];
        suffixSort(s);
        if (toBuildRMQ) {
            this.height = new int[n];
            this.d = new int[log2(n) + 1][n];
            this.lg = new int[n + 1];
            buildHeight();
            buildRMQ();
        }
    }

    // height[i] = LCP(s[SA[i]], s[SA[i - 1]]).
    // ?? s[n] = 0 or s[n] = -INF.
    private void buildHeight() {
        int i, j, h;
        height[0] = 0;
        for (i = 0; i < n; i++)
            rank[SA[i]] = i;
        for (h = i = 0; i < n; i++)
            if (rank[i] > 0) {
                j = SA[rank[i] - 1];
                while (i + h < n && j + h < n && s[i + h] == s[j + h]) ++h;
                height[rank[i]] = h;
                if (h > 0) --h;
            }
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    private void buildRMQ() {
        int i, j, k;
        for (i = 0; i < n; i++)
            d[0][i] = height[i];
        for (j = 1; (1 << j) <= n; j++)
            for (i = 0; i + (1 << j) <= n; i++)
                d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
        for (lg[0] = k = 0, i = 1; i <= n; lg[i++] = k - 1)
            while ((1 << k) <= i) k++;
    }

    // LCP(i, j) = LCP(s[SA[i]], s[SA[j]]) = min{height[k] | i + 1 <= k <= j}.
    public int LCP(int i, int j) {
        if (i == j) return n - SA[i];
        if (i > j) {
            int t = i;
            i = j;
            j = t;
        }
        int k = lg[j - (++i) + 1];
        return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }

    // LCPIndex(i, j) = LCP(s[i], s[j])
    public int LCPIndex(int i, int j) {
        return LCP(rank[i], rank[j]);
    }

    private void sortIndex(int[] nums, int start, int end) {
        if (start >= end) return;
        int pos = start + ((end - start) >> 1);
        int pivot = nums[pos];

        int i = start, j = end;
        nums[pos] = nums[end];
        while (i < j) {
            while (i < j && s[nums[i]] < s[pivot]) i++;
            if (i < j) nums[j--] = nums[i];

            while (i < j && s[pivot] < s[nums[j]]) j--;
            if (i < j) nums[i++] = nums[j];
        }
        nums[i] = pivot; // index i is the final position for pivot.
        sortIndex(nums, start, i - 1);
        sortIndex(nums, i + 1, end);
    }

    private void suffixSort(int[] s) {
        int[] count = new int[n], t;
        int[] nSA = new int[n];
        int[] nRank = new int[n];
//        Integer[] tempArray = new Integer[n];
//        for (int x = 0; x < n; x++) tempArray[x] = x;
//        Arrays.sort(tempArray, (a, b) -> Integer.compare(s[a], s[b]));
//        for (int x = 0; x < n; x++) SA[x] = tempArray[x];
        int i, k;
        int minV = s[0], maxV = s[0];
        for (i = 1; i < n; i++) {
            minV = Math.min(minV, s[i]);
            maxV = Math.max(maxV, s[i]);
        }
        if ((long) maxV - minV + 1 <= (long) n) { // radix sort if alphabet size is small
            for (i = 0; i < n; i++) count[s[i] - minV]++;
            for (i = minV + 1; i <= maxV; i++) count[i - minV] += count[i - minV - 1];
            for (i = n - 1; i >= 0; i--) SA[--count[s[i] - minV]] = i;
        } else {
            for (i = 0; i < n; i++) SA[i] = i;
            sortIndex(SA, 0, n - 1);
        }
        for (rank[SA[0]] = 0, i = 1; i < n; i++) {
            rank[SA[i]] = (s[SA[i]] != s[SA[i - 1]]) ? rank[SA[i - 1]] + 1 : rank[SA[i - 1]];
        }
        for (k = 1; k < n && rank[SA[n - 1]] < n - 1; k <<= 1) {
            for (i = 0; i < n; i++) count[rank[SA[i]]] = i + 1;
            for (i = n - 1; i >= 0; i--) if (SA[i] >= k) nSA[--count[rank[SA[i] - k]]] = SA[i] - k;
            for (i = n - k; i < n; i++) nSA[--count[rank[i]]] = i;
            t = SA;
            SA = nSA;
            nSA = t;
            for (nRank[SA[0]] = 0, i = 1; i < n; i++) {
                nRank[SA[i]] = (SA[i] + k >= n || SA[i - 1] + k >= n || rank[SA[i]] != rank[SA[i - 1]] || rank[SA[i] + k] != rank[SA[i - 1] + k]) ? nRank[SA[i - 1]] + 1 : nRank[SA[i - 1]];
            }
            t = rank;
            rank = nRank;
            nRank = t;
        }
    }
}

class Combination {
    long[] factorial;
    long[] inverseFactorial;
    long MOD;

    // O(maxSize) for preprocessing
    // MOD must be prime
    public Combination(int maxSize, long MOD) {
        factorial = new long[maxSize + 1];
        inverseFactorial = new long[maxSize + 1];
        factorial[0] = 1;
        inverseFactorial[0] = 1;
        this.MOD = MOD;
        for (int i = 1; i <= maxSize; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
            inverseFactorial[i] = inverse(factorial[i]);
        }
    }

    // x, y are long[1]
    // ax + by = gcd(a, b)
    private long extGcd(long a, long b, long[] x, long[] y) {
        if (b == 0) {
            x[0] = 1;
            y[0] = 0;
            return a;
        } else {
            long r = extGcd(b, a % b, y, x);
            y[0] -= x[0] * (a / b);
            return r;
        }
    }

    // (a * x) % MOD = 1
    // x is the inverse element
    public long inverse(long a) {
        long[] x = new long[1], y = new long[1];
        extGcd(a, MOD, x, y);
        return (x[0] % MOD + MOD) % MOD;
    }

    // m >= n
    // O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        else if (m == n) return factorial[m];
            //return factorial[m] * inverse(factorial[m - n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD;
    }

    // m >= n
    // O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
            //return factorial[m] * inverse(factorial[m - n]) % MOD * inverse(factorial[n]) % MOD;
        else return factorial[m] * inverseFactorial[m - n] % MOD * inverseFactorial[n] % MOD;
    }
}

class CombinationNoMod {

    long[][] C;
    long[][] P;

    public CombinationNoMod(int maxSize) {
        C = new long[maxSize + 1][maxSize + 1];
        P = new long[maxSize + 1][maxSize + 1];
        int m = C.length;
        int n = C[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (j == 0 || i == j) C[i][j] = 1;
                else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]);
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j <= i && j < n; j++) {
                if (i == 0 || j == 0) P[i][j] = 1;
                else P[i][j] = P[i][j - 1] * (i - j + 1);
            }
        }
    }

    // m >= n. O(1)
    public long P(int m, int n) {
        if (m == 0 || n == 0) return 1;
        return P[m][n];
    }

    // m >= n. O(1)
    public long C(int m, int n) {
        if (m == 0 || n == 0 || m == n) return 1;
        return C[m][n];
    }
}

class Fraction {
    long n, d; // n / d (d != 0)

    public Fraction(long n, long d) {
        if (d == 0) {
            this.n = Long.MAX_VALUE;
            this.d = 1;
            return;
        }
        long g = gcd(Math.abs(n), Math.abs(d));
        this.n = n / g;
        this.d = d / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    public void add(Fraction other) {
        long numerator = this.n * other.d + this.d * other.n;
        long denominator = this.d * other.d;
        long g = gcd(Math.abs(numerator), Math.abs(denominator));
        this.n = numerator / g;
        this.d = denominator / g;
        if (this.d < 0) {
            this.d = -this.d;
            this.n = -this.n;
        }
    }

    @Override
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        if (anObject instanceof Fraction) {
            Fraction anotherObject = (Fraction) anObject;
            return n == anotherObject.n && d == anotherObject.d;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (int) (n * 31 + d);
    }

    private long gcd(long x, long y) {
        return x != 0 ? gcd(y % x, x) : y;
    }
}

class UnionFind {
    int[] parent;
    int[] sz;

    // from 0 ... n - 1
    public UnionFind(int n) {
        parent = new int[n];
        sz = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public void clear() {
        for (int i = 0; i < parent.length; i++) {
            parent[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int x) {
        //return parent[x] == x ? x : (parent[x] = find(parent[x]));
        if (parent[x] == x) return x;
        int px = x;
        while (px != parent[px]) px = parent[px];
        while (x != px) {
            int next = parent[x];
            parent[x] = px;
            x = next;
        }
        return px;
    }

    // px is the final parent
    public boolean union(int x, int y) {
        int px = find(x);
        int py = find(y);
        if (px == py) return false;
        parent[py] = px;
        sz[px] += sz[py];
        return true;
    }

    public int size(int x) {
        return sz[find(x)];
    }

    public UnionFind clone() {
        UnionFind cloned = new UnionFind(parent.length);
        for (int i = 0; i < parent.length; i++) {
            cloned.parent[i] = parent[i];
            cloned.sz[i] = sz[i];
        }
        return cloned;
    }
}

class Trie {
    static class TrieNode {
        TrieNode[] next = new TrieNode[26];
        boolean isWord = false;
        long count = 0L;
    }

    TrieNode root = new TrieNode();

    public void add(String word) {
        add(word, 1L);
    }

    public void remove(String word) {
        add(word, -1L);
    }

    private void add(String word, long count) {
        TrieNode cur = root;
        cur.count += count;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null) cur.next[c] = new TrieNode();
            cur = cur.next[c];
            cur.count += count;
        }
        cur.isWord = true;
    }

    public boolean contains(String word) {
        TrieNode cur = root;
        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.next[c] == null || cur.next[c].count <= 0L) return false;
            cur = cur.next[c];
            //if (cur.isWord) return true;
        }
        return cur.isWord;
    }
}

// Tested by Leetcode 1707 and Leetcode 1803
class TrieBinary {
    static class TrieNode {
        TrieNode[] next = new TrieNode[2];
        long count;
    }

    private TrieNode root;
    private int numOfBits;

    public TrieBinary(int numOfBits) { // normally 31 for int and 63 for long
        this.numOfBits = numOfBits;
        this.root = new TrieNode();
    }

    public void add(long v) {
        add(v, 1L);
    }

    public void remove(long v) { // Tested by Leetcode 1938
        add(v, -1L);
    }

    public void add(long v, long count) {
        TrieNode cur = root;
        root.count += count;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null) cur.next[b] = new TrieNode();
            cur = cur.next[b];
            cur.count += count;
        }
    }

    // Tested by Leetcode 1707
    public long xorMax(long v) {
        TrieNode cur = root;
        long key = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[1 - b] != null && cur.next[1 - b].count > 0) {
                cur = cur.next[1 - b];
                key |= (1L - b) << i;
            } else {
                cur = cur.next[b];
                key |= (long) b << i;
            }
        }
        return key ^ v;
    }

    public boolean contains(long v) {
        TrieNode cur = root;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int b = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (cur.next[b] == null || cur.next[b].count <= 0) return false;
            cur = cur.next[b];
        }
        return true;
    }

    // Tested by Leetcode 1803
    // count(x ^ v <= limit)
    public long xorLessOrEqualCount(long v, long limit) {
        if (limit < 0) return 0;
        TrieNode cur = root;
        long ans = 0;
        for (int i = numOfBits - 1; i >= 0; i--) {
            int bitLimit = ((limit >>> i) & 1) == 0 ? 0 : 1;
            int bitV = ((v >>> i) & 1) == 0 ? 0 : 1;
            if (bitLimit == 1) {
                ans += (cur.next[bitV] != null ? cur.next[bitV].count : 0);
            }
            cur = cur.next[bitV ^ bitLimit];
            if (cur == null) break;
            if (i == 0) ans += cur.count;
        }
        return ans;
    }
}

// Lazy execution example is in https://leetcode.com/submissions/detail/1034182539/
// Refer to AlgorithmCompilation.java

// [Template] Classic Segment Tree (Range Sum), used for Template
class ClassicSegmentTree { // For Range Sum
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final int L, R;

    public ClassicSegmentTree(int[] input) {
        L = 0;
        R = input.length - 1;
        root = new TreeNode();
        build(root, L, R, input);
    }

    private void build(TreeNode root, int l, int r, int[] input) {
        if (l == r) {
            root.sum = input[l];
            return;
        }
        int m = (l + r) >> 1;
        root.left = new TreeNode();
        root.right = new TreeNode();
        build(root.left, l, m, input);
        build(root.right, m + 1, r, input);
        root.sum = root.left.sum + root.right.sum;
    }

    public void set(int index, int value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, int L, int R, int index, int value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        int M = L + ((R - L) >> 1);
        if (index <= M) {
            set(root.left, L, M, index, value);
        } else {
            set(root.right, M + 1, R, index, value);
        }
        root.sum = root.left.sum + root.right.sum;
    }

    // Sum[queryL...queryR] inclusive
    public long query(int queryL, int queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, int L, int R, int queryL, int queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        int M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 307
class DynamicSegmentTreeRangeSum {
    class TreeNode {
        TreeNode left, right;
        long sum;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeSum(long l, long r) {
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return sum(cur);
    }

    public void add(long index, long value) {
        set(index, get(index) + value);
    }

    private long sum(TreeNode node) {
        return node == null ? 0L : node.sum;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.sum = value;
            return;
        }
        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.sum = sum(root.left) + sum(root.right);
    }

    // Sum[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return 0L;
        if (queryL <= L && R <= queryR) return root.sum;
        long M = L + ((R - L) >> 1);
        return query(root.left, L, M, queryL, queryR) + query(root.right, M + 1, R, queryL, queryR);
    }
}

// Tested by Leetcode 239, 2926
class DynamicSegmentTreeRangeMax {
    class TreeNode {
        TreeNode left, right;
        long max = Long.MIN_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMax(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return max(cur);
    }

    private long max(TreeNode node) {
        return node == null ? Long.MIN_VALUE : node.max;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.max = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.max = Math.max(max(root.left), max(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MIN_VALUE;
        if (queryL <= L && R <= queryR) return root.max;
        long M = L + ((R - L) >> 1);
        return Math.max(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class DynamicSegmentTreeRangeMin {
    class TreeNode {
        TreeNode left, right;
        long min = Long.MAX_VALUE;
    }

    private final TreeNode root;
    private final long L, R;

    public DynamicSegmentTreeRangeMin(long l, long r) {  // [l, r] inclusive
        L = l;
        R = r;
        root = new TreeNode();
    }

    public long get(long index) {
        long l = L, r = R;
        TreeNode cur = root;
        while (l < r && cur != null) {
            long m = (l + r) >> 1;
            if (index <= m) {
                cur = cur.left;
                r = m;
            } else {
                cur = cur.right;
                l = m + 1;
            }
        }
        return min(cur);
    }

    private long min(TreeNode node) {
        return node == null ? Long.MAX_VALUE : node.min;
    }

    public void set(long index, long value) {
        set(root, L, R, index, value);
    }

    private void set(TreeNode root, long L, long R, long index, long value) {
        if (index < L || R < index) return;
        if (L == R) {
            root.min = value;
            return;
        }

        long M = L + ((R - L) >> 1);
        if (index <= M) {
            if (root.left == null) root.left = new TreeNode();
            set(root.left, L, M, index, value);
        } else {
            if (root.right == null) root.right = new TreeNode();
            set(root.right, M + 1, R, index, value);
        }
        root.min = Math.min(min(root.left), min(root.right));
    }

    // Max[queryL...queryR] inclusive
    public long query(long queryL, long queryR) {
        return query(root, L, R, queryL, queryR);
    }

    // [queryL, queryR] is range of query, [L, R] are range of TreeNode.
    private long query(TreeNode root, long L, long R, long queryL, long queryR) {
        if (root == null || queryL > R || queryR < L) return Long.MAX_VALUE;
        if (queryL <= L && R <= queryR) return root.min;
        long M = L + ((R - L) >> 1);
        return Math.min(query(root.left, L, M, queryL, queryR), query(root.right, M + 1, R, queryL, queryR));
    }
}

class BinaryIndexTree {
    private long[] c;
    private int n;

    // NOTE: index is from 1 to n. (NOT 0 ... n - 1)
    public BinaryIndexTree(int n) {
        this.n = n;
        this.c = new long[n + 1];
    }

    // Add value to position k, k is from 1 to n.
    public void add(int k, long value) {
        while (k <= n) {
            c[k] += value;
            k += (k & (k ^ (k - 1)));
        }
    }

    // k is from 1 to n.
    public long getSum(int k) {
        long sum = 0;
        while (k > 0) {
            sum += c[k];
            k -= (k & (k ^ (k - 1)));
        }
        return sum;
    }
}

class RangeSum {
    BinaryIndexTree tree;
    int start;

    // [low, high] inclusive
    public RangeSum(int low, int high) {
        start = low;
        tree = new BinaryIndexTree(high - low + 1);
    }

    public void add(int index, long value) {
        tree.add(index - start + 1, value);
    }

    public long get(int index) {
        return tree.getSum(index - start + 1) - tree.getSum(index - start);
    }

    public void set(int index, long value) {
        tree.add(index - start + 1, value - get(index));
    }

    // [l, r] inclusive
    public long getSum(int l, int r) {
        return tree.getSum(r - start + 1) - tree.getSum(l - start);
    }
}

class RangeMax {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMax(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MIN_VALUE);
    }

    public RangeMax(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.max(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMax(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MIN_VALUE, resr = Long.MIN_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.max(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.max(t[--r], resr);
        }
        return Math.max(resl, resr);
    }
}

class RangeMin {
    int start;
    int n;
    long[] t;

    // [low, high] inclusive
    public RangeMin(int low, int high) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, Long.MAX_VALUE);
    }

    public RangeMin(int low, int high, long defaultValue) {
        start = low;
        n = high - low + 1;
        t = new long[n * 2 + 2];
        Arrays.fill(t, defaultValue);
    }

    long get(int index) {
        return t[index - start + n];
    }

    void set(int index, long value) {
        index -= start;
        for (t[index += n] = value; (index >>= 1) > 0; ) {
            t[index] = Math.min(t[index << 1], t[index << 1 | 1]);
        }
    }

    // [l, r] inclusive
    long getMin(int l, int r) {
        l -= start;
        r = (r + 1 - start); // make it as [l, r)
        long resl = Long.MAX_VALUE, resr = Long.MAX_VALUE;
        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {
            if ((l & 1) != 0) resl = Math.min(resl, t[l++]);
            if ((r & 1) != 0) resr = Math.min(t[--r], resr);
        }
        return Math.min(resl, resr);
    }
}

// Including topological sort.
class GraphIntegerFaster {
    public List<Integer>[] adj;

    public GraphIntegerFaster(int n) {
        adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    // directed edge x -> y
    public void link(int x, int y) {
        adj[x].add(y);
    }

    public List<Integer> getChildren(int x) {
        return adj[x];
    }

    private static final int TEMPORARY = 1;
    private static final int PERMANENT = 2;

    // x -> y means x should be processed before y
    // The input is a directed graph.
    // 1. return null, means there is a cycle inside the graph, or the input is
    // invalid.
    // 2. return List<Node> as the result.
    public List<Integer> topologicalSort() {
        //Map<E, Integer> vst = new HashMap<>();
        int n = adj.length;
        int[] vst = new int[n];
        List<Integer> result = new ArrayList<>();
        for (int x = 0; x < n; x++) {
            if (!topologicalSort(x, vst, result)) {
                return null;
            }
        }
        Collections.reverse(result);
        return result;
    }

    private boolean topologicalSort(int root, int[] vst, List<Integer> result) {
        if (vst[root] == PERMANENT) {
            return true;
        }
        if (vst[root] == TEMPORARY) { // found cycle
            return false;
        }

        vst[root] = TEMPORARY;
        for (int child : getChildren(root)) {
            if (!topologicalSort(child, vst, result)) {
                return false;
            }
        }
        result.add(root);
        vst[root] = PERMANENT;
        return true;
    }
}

class DijkstraLongFaster {
    public static class Edge {
        int to;
        long w;

        public Edge(int to, long w) {
            this.to = to;
            this.w = w;
        }
    }

    public static final long INF = Long.MAX_VALUE / 4;
    public List<Edge>[] adj;

    public DijkstraLongFaster(int n) {
        this.adj = new List[n];
        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();
    }

    public void link(int x, int y, long w) {
        adj[x].add(new Edge(y, w));
    }

    public long[] shortestPath(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        PriorityQueue<Edge> q = new PriorityQueue<>((a, b) -> Long.compare(a.w, b.w));
        q.add(new Edge(src, 0));
        dist[src] = 0;

        while (!q.isEmpty()) {
            Edge cur = q.poll();
            if (vst[cur.to]) continue;
            int u = cur.to;
            long w = cur.w;
            vst[u] = true;

            for (Edge e : adj[u]) {
                if (!vst[e.to] && dist[e.to] > w + e.w) {
                    dist[e.to] = w + e.w;
                    q.add(new Edge(e.to, w + e.w));
                }
            }
        }
        return dist;
    }

    // NOTE: w of each edge must be the same.
    public long[] bfs(int src) {
        int n = adj.length;
        long[] dist = new long[n];
        boolean[] vst = new boolean[n];
        Arrays.fill(dist, INF);

        Queue<Integer> q = new ArrayDeque<>();
        q.add(src);
        dist[src] = 0;
        vst[src] = true;

        while (!q.isEmpty()) {
            int u = q.poll();
            long w = dist[u];
            for (Edge e : adj[u]) {
                if (!vst[e.to]) {
                    dist[e.to] = w + e.w;
                    vst[e.to] = true;
                    q.add(e.to);
                }
            }
        }
        return dist;
    }
}

class TreapSet<E> {
    private class Node {
        E key;
        int priority, count, total;
        Node left, right, pnt;

        public Node(E key, int priority, Node pnt) {
            this.key = key;
            this.priority = priority;
            this.pnt = pnt;
            this.count = 1;
            this.total = 1;
        }
    }

    private static final Random RANDOM = new Random();
    private final Comparator<? super E> comparator;
    private Node root;

    public TreapSet(Comparator<? super E> comparator) {
        this.comparator = comparator;
    }

    public boolean isEmpty() {
        return root == null;
    }

    public void clear() {
        root = null;
    }

    public int size() {
        return root == null ? 0 : root.total;
    }

    private int leftRank(Node p) {
        return p.left != null ? p.left.total : 0;
    }

    private int rightRank(Node p) {
        return p.right != null ? p.right.total : 0;
    }

    private void rotateLeft(Node x) {
        Node y = x.right;
        if ((x.right = y.left) != null) y.left.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.left) x.pnt.left = y;
        else x.pnt.right = y;
        y.left = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    private void rotateRight(Node x) {
        Node y = x.left;
        if ((x.left = y.right) != null) y.right.pnt = x;
        y.pnt = x.pnt;
        if (x == root) root = y;
        else if (x == x.pnt.right) x.pnt.right = y;
        else x.pnt.left = y;
        y.right = x;
        x.pnt = y;
        x.total = leftRank(x) + rightRank(x) + x.count;
        y.total = leftRank(y) + rightRank(y) + y.count;
    }

    public void add(E key) {
        if (root == null) {
            root = new Node(key, RANDOM.nextInt(), null);
            return;
        }
        Node x = root, p = null;
        while (x != null) {
            ++((p = x).total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                ++(x.count);
                return;
            }
        }

        x = new Node(key, RANDOM.nextInt(), p);
        if (comparator.compare(key, p.key) < 0) p.left = x;
        else p.right = x;
        while ((p = x.pnt) != null && p.priority < x.priority) {
            if (p.left == x) rotateRight(p);
            else rotateLeft(p);
        }
    }

    public void remove(E key) {
        Node x = root, p = null;
        while (x != null) {
            --(x.total);
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) x = x.right;
            else {
                if (--(x.count) > 0) return;
                break;
            }
        }
        if (x == null) return;
        while (x.left != null || x.right != null) {
            if (x.left == null || (x.right != null && x.right.priority > x.left.priority)) {
                rotateLeft(x);
            } else {
                rotateRight(x);
            }
        }
        if ((p = x.pnt) != null) {
            if (p.left == x) p.left = null;
            else p.right = null;
        } else {
            root = null;
        }
        // delete x;
    }

    // number of elements smaller than key
    public int lowerCount(E key) {
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                sum += leftRank(x) + x.count;
                x = x.right;
            } else {
                sum += leftRank(x);
                break;
            }
        }
        return sum;
    }

    // number of elements larger than key
    public int higherCount(E key) {
        //return size() - lowerCount(key) - count(key);
        int sum = 0;
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp > 0) x = x.right;
            else if (cmp < 0) {
                sum += rightRank(x) + x.count;
                x = x.left;
            } else {
                sum += rightRank(x);
                break;
            }
        }
        return sum;
    }

    public int index(E key) {
        return lowerCount(key);
    }

    public E get(int index) // index = 0 ... size - 1
    {
        Node p = root;
        ++index;
        while (true) {
            int t = leftRank(p);
            if (index <= t) p = p.left;
            else {
                if ((index -= t + p.count) <= 0) break;
                p = p.right;
            }
        }
        return p.key;
    }

    public int count(E key) {
        Node x = root;
        while (x != null) {
            int cmp = comparator.compare(key, x.key);
            if (cmp < 0) x = x.left;
            else if (cmp > 0) {
                x = x.right;
            } else {
                return x.count;
            }
        }
        return 0;
    }

    public E first() {
        if (root == null) return null;
        Node x = root;
        while (x.left != null) {
            x = x.left;
        }
        return x.key;
    }

    public E last() {
        if (root == null) return null;
        Node x = root;
        while (x.right != null) {
            x = x.right;
        }
        return x.key;
    }

    public boolean contains(E key) {
        return count(key) > 0;
    }

    public E ceiling(E key) {
        int id = lowerCount(key);
        return id >= size() ? null : get(id);
    }

    public E floor(E key) {
        int id = size() - higherCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E lower(E key) {
        int id = lowerCount(key) - 1;
        return id < 0 ? null : get(id);
    }

    public E higher(E key) {
        int id = size() - higherCount(key);
        return id >= size() ? null : get(id);
    }

    // return the first index whose value >= target
    // if this value doesn't exist, return index = size()
    public int lowerBound(E target) {
        return lowerCount(target);
    }

    // return the first index whose value > target
    // if this value doesn't exist, return index = size()
    public int upperBound(E target) {
        return size() - higherCount(target);
    }

    public List<E> keys() {
        List<E> list = new ArrayList<>();
        inorder(root, list);
        return list;
    }

    private void inorder(Node x, List<E> list) {
        if (x == null) return;
        inorder(x.left, list);
        list.add(x.key);
        inorder(x.right, list);
    }
}

class ArraySum {
    long[] sum;
    int n;

    // nums index starts from 0 to nums.length - 1;
    public ArraySum(int[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    public ArraySum(long[] nums) {
        n = nums.length;
        sum = new long[nums.length + 1];
        for (int i = 1; i <= nums.length; i++) {
            sum[i] = sum[i - 1] + nums[i - 1];
        }
    }

    // [l, r], index starts from 0
    public long getSum(int l, int r) {
        // error handling
        if (l > r || !(l >= 0 && l < n && r >= 0 && r < n)) return 0L;
        return sum[r + 1] - sum[l];
    }
}

class TwoDArraySum {
    int[][] sum;
    int m, n;

    // nums index starts from 0
    public TwoDArraySum(final int[][] nums) {
        m = nums.length;
        n = nums[0].length;
        sum = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + nums[i - 1][j - 1];
            }
        }
    }

    // [(x1, y1), (x2, y2)], index starts from 0
    // x1 <= x2 and y1 <= y2
    public int getSum(int x1, int y1, int x2, int y2) {
        if (!(x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && x2 >= 0 && x2 < m && y2 >= 0 && y2 < n) || x1 > x2 || y1 > y2)
            return 0;
        return sum[x2 + 1][y2 + 1] - sum[x2 + 1][y1] - sum[x1][y2 + 1] + sum[x1][y1];
    }
}

class ArrayUtils {
    static void fill(int[] array, int defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(int[][] array, int defaultValue) {
        for (int[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(int[][][] array, int defaultValue) {
        for (int[][] a2 : array) {
            for (int[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(int[][][][] array, int defaultValue) {
        for (int[][][] a3 : array) {
            for (int[][] a2 : a3) {
                for (int[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(int[][][][][] array, int defaultValue) {
        for (int[][][][] a4 : array) {
            for (int[][][] a3 : a4) {
                for (int[][] a2 : a3) {
                    for (int[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(int[][][][][][] array, int defaultValue) {
        for (int[][][][][] a5 : array) {
            for (int[][][][] a4 : a5) {
                for (int[][][] a3 : a4) {
                    for (int[][] a2 : a3) {
                        for (int[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }

    static void fill(long[] array, long defaultValue) {
        Arrays.fill(array, defaultValue);
    }

    static void fill(long[][] array, long defaultValue) {
        for (long[] a1 : array) {
            Arrays.fill(a1, defaultValue);
        }
    }

    static void fill(long[][][] array, long defaultValue) {
        for (long[][] a2 : array) {
            for (long[] a1 : a2) {
                Arrays.fill(a1, defaultValue);
            }
        }
    }

    static void fill(long[][][][] array, long defaultValue) {
        for (long[][][] a3 : array) {
            for (long[][] a2 : a3) {
                for (long[] a1 : a2) {
                    Arrays.fill(a1, defaultValue);
                }
            }
        }
    }

    static void fill(long[][][][][] array, long defaultValue) {
        for (long[][][][] a4 : array) {
            for (long[][][] a3 : a4) {
                for (long[][] a2 : a3) {
                    for (long[] a1 : a2) {
                        Arrays.fill(a1, defaultValue);
                    }
                }
            }
        }
    }

    static void fill(long[][][][][][] array, long defaultValue) {
        for (long[][][][][] a5 : array) {
            for (long[][][][] a4 : a5) {
                for (long[][][] a3 : a4) {
                    for (long[][] a2 : a3) {
                        for (long[] a1 : a2) {
                            Arrays.fill(a1, defaultValue);
                        }
                    }
                }
            }
        }
    }
}

class CharacterUtils {
    static boolean[] vowel = new boolean[128];

    static {
        vowel['a'] = vowel['e'] = vowel['i'] = vowel['o'] = vowel['u'] = true;
        vowel['A'] = vowel['E'] = vowel['I'] = vowel['O'] = vowel['U'] = true;
    }

    static boolean isVowel(char ch) {
        return vowel[ch];
    }

    static boolean isLetter(char ch) {
        return ((ch - 'a') >= 0 && (ch - 'a') < 26) ||
                ((ch - 'A') >= 0 && (ch - 'A') < 26);
    }

    static boolean isLowerCase(char ch) {
        return (ch - 'a') >= 0 && (ch - 'a') < 26;
    }

    static boolean isUpperCase(char ch) {
        return (ch - 'A') >= 0 && (ch - 'A') < 26;
    }

    static boolean isDigit(char ch) {
        return (ch - '0') >= 0 && (ch - '0') <= 9;
    }
}

class DoubleUtils {
    private static final double EPS = 1e-8;

    public static int compare(double a, double b) {
        if (a - b > EPS) return 1;
        else if (a - b < -EPS) return -1;
        else return 0;
    }

    public static boolean isInteger(double a) {
        return compare(floor(a), a) == 0;
    }

    public static double floor(double a) {
        return Math.floor(a + EPS);
    }

    public static double ceil(double a) {
        return Math.ceil(a - EPS);
    }
}

class MatrixUtils {
    static final long MOD = 1_000_000_007L;

    // matrix[n][n], matrix[i][i] = 1
    static long[][] genIdentityMatrix(int n) {
        long[][] matrix = new long[n][n];
        for (int i = 0; i < n; i++) matrix[i][i] = 1;
        return matrix;
    }

    static long[][] multiply(long[][] a, long[][] b, long MOD) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD;
                }
            }
        }
        return res;
    }

    static long[][] multiply(long[][] a, long[][] b) {
        int m1 = a.length;
        int n1 = a[0].length;
        int m2 = b.length;
        int n2 = b[0].length;
        if (n1 != m2) return null;
        long[][] res = new long[m1][n2];
        for (int i = 0; i < m1; i++) {
            for (int j = 0; j < n2; j++) {
                for (int k = 0; k < n1; k++) {
                    res[i][j] = (res[i][j] + a[i][k] * b[k][j]);
                }
            }
        }
        return res;
    }

    // a^b % MOD
    static long[][] powMod(long[][] a, long b, long MOD) {
        int n = a.length;
        long[][] res = genIdentityMatrix(n);
        while (b > 0) {
            if ((b & 1) != 0) res = multiply(res, a, MOD);
            a = multiply(a, a, MOD);
            b >>= 1;
        }
        return res;
    }

    static void print(long[][] matrix) {
        for (int i = 0; i < matrix.length; i++) {
            System.out.println(Arrays.toString(matrix[i]));
        }
    }
}

class IntegerUtils {
    static long[] power10 = new long[19]; // 10^i

    static {
        power10[0] = 1L;
        for (int i = 1; i < power10.length; i++) {
            power10[i] = power10[i - 1] * 10;
        }
    }

    // swap index i and j of integer (long) num. i == 0 means the lowest position.
    static long swapDigit(long num, int i, int j) {
        if (i == j) return num;
        long di = num / power10[i] % 10L;
        long dj = num / power10[j] % 10L;
        return num - di * power10[i] - dj * power10[j] + dj * power10[i] + di * power10[j];
    }
}

class StringUtils {
    // This function is deprecated, please hash(int l, int r) in class StableStringHash or StringHash
    // rolling hash of substrings of 's' with length == k
    // long[pos] = hash(s.substring(pos, pos + k))
    public static long[] rollingHash(String s, int k) {
        long[] ans = new long[s.length() - k + 1];
        int seed1 = 31;
        int seed2 = 131;
        int h1 = 0, h2 = 0, power1 = 1, power2 = 1;
        for (int i = 0; i < k; i++) {
            h1 = h1 * seed1 + s.charAt(i);
            h2 = h2 * seed2 + s.charAt(i);

            power1 *= seed1;
            power2 *= seed2;
        }

        ans[0] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        for (int i = k; i < s.length(); i++) {
            h1 = h1 * seed1 + s.charAt(i) - power1 * s.charAt(i - k);
            h2 = h2 * seed2 + s.charAt(i) - power2 * s.charAt(i - k);
            ans[i - k + 1] = ((long) h1 << 32) | ((long) h2 << 32 >>> 32);
        }

        return ans;
    }

    public static int[] kmpNext(String s) {
        int n = s.length();
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s.charAt(i) != s.charAt(k)) k = next[k - 1];
            if (s.charAt(i) == s.charAt(k)) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(String s, String p) {
        int[] next = kmpNext(p);
        int n = s.length();
        int m = p.length();
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p.charAt(j) != s.charAt(i)) {
                j = next[j - 1];
            }
            if (p.charAt(j) == s.charAt(i)) j++;
            if (j == m) return true;
        }
        return false;
    }

    public static int[] kmpNext(int[] s) {
        int n = s.length;
        int[] next = new int[n];
        next[0] = 0;
        for (int i = 1; i < n; i++) {
            int k = next[i - 1];
            while (k > 0 && s[i] != s[k]) k = next[k - 1];
            if (s[i] == s[k]) {
                next[i] = k + 1;
            } else {
                next[i] = 0;
            }
        }
        return next;
    }

    // s is the original String
    // p is the pattern String
    public static boolean kmpMatch(int[] s, int[] p) {
        int[] next = kmpNext(p);
        int n = s.length;
        int m = p.length;
        for (int i = 0, j = 0; i < n; i++) {
            while (j > 0 && p[j] != s[i]) {
                j = next[j - 1];
            }
            if (p[j] == s[i]) j++;
            if (j == m) return true;
        }
        return false;
    }

    // Z[i] = longest length of common prefix of str[0 ... n - 1] and str[i ... n - 1]
    // Tested by LC2223, LC459
    public static int[] zFunction(String str) {
        int n = str.length();
        int[] Z = new int[n];
        // [L,R] makes a window which matches with prefix of s
        int L = 0, R = 0;
        Z[0] = n;
        for (int i = 1; i < n; ++i) {
            if (i > R) {
                L = R = i;
                while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                Z[i] = R - L;
                R--;
            } else {
                int k = i - L;
                if (Z[k] < R - i + 1) {
                    Z[i] = Z[k];
                } else {
                    L = i;
                    while (R < n && str.charAt(R - L) == str.charAt(R)) R++;
                    Z[i] = R - L;
                    R--;
                }
            }
        }
        return Z;
    }
}

// Better to use this when length of string >= 2^11
class StringHash {
    static class SingleStringHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleStringHash(String s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length();
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s.charAt(i - 1)) % MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleStringHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L;

    public StringHash(String s) {
        hash1 = new SingleStringHash(s, SEED1, MOD);
        hash2 = new SingleStringHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(String s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length(); i++) {
            h1 = (h1 * SEED1 + s.charAt(i)) % MOD;
            h2 = (h2 * SEED2 + s.charAt(i)) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(char[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class IntegerArrayHash {
    static class SingleIntegerArrayHash {
        long[] h;
        long[] pow;
        final long SEED;
        final long MOD;

        public SingleIntegerArrayHash(int[] s, long SEED, long MOD) { // example: SEED = 131L;
            this.SEED = SEED;
            this.MOD = MOD;
            int n = s.length;
            h = new long[n + 1];
            pow = new long[n + 1];
            pow[0] = 1;
            for (int i = 1; i <= n; i++) pow[i] = (pow[i - 1] * SEED) % MOD;
            //h[i] = hash[s[0...i - 1]]
            h[0] = 0;
            for (int i = 1; i <= n; i++) {
                h[i] = (h[i - 1] * SEED + s[i - 1]) % MOD;
                if (h[i] < 0) h[i] += MOD;
            }
        }

        // hash[s[l....r]]
        public long hash(int l, int r) {
            long ret = (h[r + 1] - h[l] * pow[r - l + 1]) % MOD;
            return ret >= 0 ? ret : ret + MOD;
        }
    }

    private SingleIntegerArrayHash hash1, hash2;
    static final long SEED1 = 31L, SEED2 = 131L;
    static final long MOD = 1_000_000_007L; // or 1_000_000_123L

    public IntegerArrayHash(int[] s) {
        hash1 = new SingleIntegerArrayHash(s, SEED1, MOD);
        hash2 = new SingleIntegerArrayHash(s, SEED2, MOD);
    }

    public long hash(int l, int r) {
        return (hash1.hash(l, r) << 32) | (hash2.hash(l, r) << 32 >>> 32);
    }

    public static long hashCode(int[] s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.length; i++) {
            h1 = (h1 * SEED1 + s[i]) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s[i]) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }

    public static long hashCode(List<Integer> s) {
        long h1 = 0, h2 = 0;
        for (int i = 0; i < s.size(); i++) {
            h1 = (h1 * SEED1 + s.get(i)) % MOD;
            if (h1 < 0) h1 += MOD;
            h2 = (h2 * SEED2 + s.get(i)) % MOD;
            if (h2 < 0) h2 += MOD;
        }
        return (h1 << 32) | (h2 << 32 >>> 32);
    }
}

class RMQ { // NOTE!!! query return index, not value
    // tested by LC 1438,239
    final long[] a; // input data array copy
    int[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQ(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQ(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new int[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = i;
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = a[d[j - 1][i]] >= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                } else {
                    d[j][i] = a[d[j - 1][i]] <= a[d[j - 1][i + (1 << (j - 1))]] ? d[j - 1][i] : d[j - 1][i + (1 << (j - 1))];
                }
    }

    // i <= j, and index starts from 0.
    public int query(int i, int j) { // NOTE!!! return index, not value
        int k = log2[j - i + 1];
        if (useMax) return a[d[k][i]] >= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
        else return a[d[k][i]] <= a[d[k][j - (1 << k) + 1]] ? d[k][i] : d[k][j - (1 << k) + 1];
    }
}

class RMQValue { // NOTE!!! query return value, not index
    final long[] a; // input data array copy
    long[][] d;

    int[] log2;
    boolean useMax;

    private static long[] intArrayToLongArray(int[] nums) {
        long[] ret = new long[nums.length];
        for (int i = 0; i < nums.length; i++) ret[i] = nums[i];
        return ret;
    }

    // useMax == true means RMQMax
    public RMQValue(int[] input, boolean useMax) {
        this(intArrayToLongArray(input), useMax);
    }

    public RMQValue(long[] input, boolean useMax) {
        int n = input.length;
        this.a = input;
        this.log2 = Utils.preprocessLog2(n);
        this.useMax = useMax;
        this.d = new long[log2[n] + 1][n];
        for (int i = 0; i < n; i++) d[0][i] = a[i];
        for (int j = 1; (1 << j) <= n; j++)
            for (int i = 0; i + (1 << j) <= n; i++)
                if (useMax) {
                    d[j][i] = Math.max(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                } else {
                    d[j][i] = Math.min(d[j - 1][i], d[j - 1][i + (1 << (j - 1))]);
                }
    }

    // i <= j, and index starts from 0.
    public long query(int i, int j) {
        int k = log2[j - i + 1];
        if (useMax) return Math.max(d[k][i], d[k][j - (1 << k) + 1]);
        else return Math.min(d[k][i], d[k][j - (1 << k) + 1]);
    }
}

// Tested by 2827
// Similar: 1012, 2376, 902, 2719, 2801, 357, 1215, 1397
class DigitDP {
    static final boolean ENABLE_DEBUG_MODE = false; // TODO: set it to true if you want to print more debug info
    static final long UNSET = -1;
    // dp[isStart][hasLimit][pos] | [odd][even][r]
    // (isStart, hasLimit, pos) is generic, (odd, even, r) is use case specific
    long[][][][][][] dp;
    int K;

    public long digitDP(long num, int k) {
        String numString = String.valueOf(num); // TODO
        this.dp = new long[2][2][numString.length()][numString.length() + 1][numString.length() + 1][k];
        this.K = k;

        if (ENABLE_DEBUG_MODE) System.out.println(""num = "" + numString);
        ArrayUtils.fill(dp, UNSET);
        long ans = dfs(new StringBuilder(), numString, 1, 1, 0, 0, 0, 0);
        if (ENABLE_DEBUG_MODE) System.out.println(""---------------------\n"");
        return ans;
    }

    long dfs(StringBuilder curResult, String s, int isStart, int hasLimit, int pos, int odd, int even, int r) {
        if (pos == s.length()) {
            if (isStart == 1) return 0; // NOTE: special check for num == 0. TODO
            if (r == 0 && odd == even) { // TODO
                if (ENABLE_DEBUG_MODE) System.out.println(""result = "" + curResult);
                return 1;
            } else {
                return 0;
            }
        }
        if (dp[isStart][hasLimit][pos][odd][even][r] != UNSET) return dp[isStart][hasLimit][pos][odd][even][r];

        int start = 0;
        int end = (hasLimit == 1) ? s.charAt(pos) - '0' : 9; // TODO: check if it is binary string or not

        long ans = 0;
        for (int digit = start; digit <= end; digit++) {
            if (isStart == 1 && digit == 0) { // NOTE: handle leading zeros
                // [0, 999..9]
                // [0， 10^(len(s) - pos - 1) - 1]
                ans += dfs(new StringBuilder(), s, 1, 0, pos + 1, 0, 0, 0);
                continue;
            }
            int newHasLimit = (hasLimit == 1 && digit == s.charAt(pos) - '0') ? 1 : 0;

            int newOdd = odd + (digit % 2); // TODO
            int newEven = even + (digit % 2 == 0 ? 1 : 0); // TODO
            int newR = (isStart == 1 ? digit % this.K : (r * 10 + digit) % this.K); // TODO;

            if (ENABLE_DEBUG_MODE) curResult.append(digit);
            ans += dfs(curResult, s, 0, newHasLimit, pos + 1, newOdd, newEven, newR);
            if (ENABLE_DEBUG_MODE) curResult.deleteCharAt(curResult.length() - 1);

        }
        return dp[isStart][hasLimit][pos][odd][even][r] = ans;
    }
}

class Printer {
    static boolean ENABLE_LOCAL_PRINT = false;

    static void println(String x) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.println(x);
    }

    static void printf(String format, Object... args) {
        if (!ENABLE_LOCAL_PRINT) return; // do nothing
        System.out.printf(format, args);
    }
}


public class Solution {
    private static final int INF = 1_000_000_001;
    private static final long MOD = 1_000_000_007L;

    private static final int UNSET = -131;
    // 4 neighbors
    private static final int[] DX = {-1, 0, 1, 0}; // up, right, down, left
    private static final int[] DY = {0, 1, 0, -1};

    // 8 neighbors
    //    private static final int[] DX = {-1, -1, 0, 1, 1,  1, 0,  -1};
    //    private static final int[] DY = {0,   1, 1, 1, 0, -1, -1, -1};

    // knight
    //    private static final int[] DX = {-2, -2, -1, 1, 2, 2, 1, -1};
    //    private static final int[] DY = {-1, 1, 2, 2, 1, -1, -2, -2};

    static Combination comb = new Combination(100, MOD);
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int sum = 0;
        int targetLength0 = 0;
        int targetLength1 = 0;
        long[] digitCount = new long[10];
        for (int i = 0; i < n; i++) {
            sum += num.charAt(i) - '0';
            digitCount[num.charAt(i) - '0']++;
            if (i % 2 == 0) {
                targetLength0++;
            } else {
                targetLength1++;
            }
        }
        if (sum % 2 != 0) return 0;
        int targetSum = sum / 2;


        long[][][] dp = new long[10][n + 1][sum + 1];

        for (int i = 0; i <= digitCount[0] && i <= targetLength0; i++) {
            if (targetLength0 >= i && targetLength1 >= (int) digitCount[0] - i) {
                dp[0][i][0] = comb.C(targetLength0, i) * comb.C(targetLength1, (int) digitCount[0] - i) % MOD;
            }
        }

        int[] preSum = new int[10];
        preSum[0] = (int) digitCount[0];
        for (int i = 1; i < 10; i++) {
            preSum[i] = preSum[i - 1] + (int) digitCount[i];
        }
        for (int i = 1; i <= 9; i++) {

            for (int j = 0; j <= targetLength0; j++) {
                for (int k = 0; k <= targetSum; k++) {
                    if (dp[i - 1][j][k] == 0) continue;

                    for (int c = 0; c <= digitCount[i]; c++) {
                        if (c + j > targetLength0) break;
                        if (c * i + k > targetSum) break;
                        int c2 = (int) digitCount[i] - c;
                        int len2 = targetLength1 - (preSum[i - 1] - j);
                        if (len2 >= 0 && len2 <= targetLength1 && len2 >= c2) {
                            dp[i][j + c][k + c * i] = (dp[i][j + c][k + c * i] + dp[i - 1][j][k] * comb.C(targetLength0 - j, c) % MOD * comb.C(len2, c2)) % MOD;
                        }
                    }
                }
            }
        }
        return (int) dp[9][targetLength0][targetSum];


    }

    public static void main(String[] args) throws Exception {
        long startTime = System.currentTimeMillis();
        Printer.ENABLE_LOCAL_PRINT = true;
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */





        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        /* ------------------------------------------------------- */
        System.out.println((System.currentTimeMillis() - startTime) + ""ms"");
    }
}",1441385012
JOZLEETCODE,JLZ998112,227,3627,java,"class Solution {
    private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][] dist = new int[m][n];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i], Max);
            }
        }
        dist[0][0] = 0;        
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x,y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            if(r==m-1 && c==n-1){
                return cd;
            }
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n && dist[nr][nc] == Max){
                    int nd = Math.max(cd+1, g[nr][nc]+1);
                    dist[nr][nc] = nd;
                    pq.offer(new int[]{nr, nc, nd});
                }
            }
        }
        return -1;
    }
}",1441294725
JOZLEETCODE,JLZ998112,227,3628,java,"class Solution {
     private int[][] dirs = {{-1, 0}, {1,0}, {0, -1}, {0, 1}};
    private int Max = (int)2e9;
    public int minTimeToReach(int[][] g) {
        int m = g.length;
        int n = g[0].length;
        int[][][] dist = new int[m][n][3];
        for(int i=0; i<m; ++i){
            for(int j=0; j<n; ++j){
                Arrays.fill(dist[i][j], Max);
            }
        }
        dist[0][0][1] = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<>( (x, y) -> Integer.compare(x[2], y[2]));
        pq.offer(new int[]{0, 0, 0, 1});
        while(!pq.isEmpty()){
            int[] top = pq.poll();
            int r = top[0];
            int c = top[1];
            int cd = top[2];
            int steps = top[3];
            if(r==m-1 && c==n-1){
                return cd;
            }
            int nsteps = (steps == 1?2:1);
            for(int[] d: dirs){
                int nr = r+d[0];
                int nc = c+d[1];
                if(nr>=0 && nr<m && nc>=0 && nc<n ){
                    int nd = Math.max(cd+steps, g[nr][nc]+steps);
                    if(dist[nr][nc][nsteps] > nd){
                        dist[nr][nc][nsteps] = nd;
                        pq.offer(new int[]{nr, nc, nd, nsteps});
                    }
                }
            }
        }
        return -1;
    }
}",1441305565
JOZLEETCODE,JLZ998112,227,3636,java,"class Solution {
    public boolean isBalanced(String s) {
        char[] c = s.toCharArray();
        int n = c.length;
        int odd = 0;
        int even = 0;
        for(int i=0; i<n; ++i){
            int cind = c[i]-'0';
            if(i%2==0){
                even += cind;
            }else{
                odd += cind;
            }
        }
        return odd == even;
    }
}",1441283731
JOZLEETCODE,JLZ998112,227,3637,java,"class Solution {
    private final long Mod = (long) (1e9 + 7);
    private long[][][] dp;
    private int oddi = 0;
    private int eveni = 0;
    private long sum = 0;
    private final int nums = 10;

    public int countBalancedPermutations(String s) {
        int n = s.length();
        initfact();
        oddi = 0;
        eveni = 0;
        sum = 0;

        int[] count = new int[10];

        for (int i = 0; i < n; ++i) {
            int cind = s.charAt(i) - '0';
            ++count[cind];
            if (i % 2 == 0) {
                ++eveni;
            } else {
                ++oddi;
            }
            sum += cind;
        }
        dp = new long[nums][800][oddi + 1];

        for (int i = 0; i < nums; ++i) {
            for (int j = 0; j < 800; ++j) {
                Arrays.fill(dp[i][j], -1);
            }

        }
        if (sum % 2 != 0) {
            return 0;
        }
        sum /= 2;
        long rt = solve(count, 0, 0, oddi);

        return (int) rt;
    }

    private long solve(int[] a, int i, int osum, int indexes) {
        if (indexes < 0) {
            return 0;
        }
        if (i == nums) {
            if (osum != sum || indexes != 0) {
                return 0;
            } else {
                long ep = fact[eveni];
                long op = fact[oddi];
                long res = ep * op;
                res %= Mod;
                return res;
            }
        }
        if (dp[i][osum][indexes] != -1) {
            return dp[i][osum][indexes];
        }
        long res = 0;
        for (int j = 0; j <= a[i]; ++j) {
            int nosum = osum + j * i;
            long cur = solve(a, i + 1, nosum, indexes - j);
            cur *= modinverse(fact[j]);
            cur %= Mod;
            int toodd = a[i] - j;
            cur *= modinverse(fact[toodd]);
            cur %= Mod;
            res += cur;
            res %= Mod;
        }
        dp[i][osum][indexes] = res;
        return res;
    }

    private long[] fact = new long[101];

    private void initfact() {
        fact[0] = 1;
        for (int i = 1; i <= 100; ++i) {
            fact[i] = fact[i - 1] * i;
            fact[i] %= Mod;
        }
    }

    private long modinverse(long a) {
        long m = Mod;
        long y = 0;
        long x = 1;
        while (a > 1) {
            long q = a / m;
            long t = m;
            m = a % m;
            a = t;
            t = y;
            y = x - q * y;
            x = t;
        }
        if (x < 0) {
            x += Mod;
        }
        return x;
    }
}",1441372874
Kalix1110,Kalix1110,229,3627,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n=v.size(),m=v[0].size();
        vll dis(n+5,vl(m+5,1e13));
        
        priority_queue<vl,vll,greater<vl>>pq;
        dis[0][0]=0;
        pq.push({0,0,0});
        
        while(pq.size()>0){
            auto p=pq.top();
            pq.pop();
            ll wt=p[0];
            int x=p[1];
            int y=p[2];
            
            if(wt>dis[x][y]) continue;
            for(auto &it:delta1){
                int nx=x+it[0];
                int ny=y+it[1];
                
                if(nx<0 || ny<0 || nx>=n || ny>=m) continue;
                ll d=max(wt,(ll)v[nx][ny])+1;
                if(d < dis[nx][ny]){
                    dis[nx][ny]=d;
                    pq.push({d,nx,ny});
                }
            }
        }
        
        return dis[n-1][m-1];
    }
};",1441297076
Kalix1110,Kalix1110,229,3628,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size(), m = v[0].size();
        
        // 3D distance array: dis[x][y][iinc] where iinc is 0 or 1
        vector<vector<vector<long long>>> dis(n, vector<vector<long long>>(m, vector<long long>(2, 1e13)));
        
        // Priority queue for Dijkstra's algorithm
        priority_queue<vector<long long>, vector<vector<long long>>, greater<vector<long long>>> pq;
        
        // Initialize starting point
        dis[0][0][0] = 0;
        pq.push({0, 0, 0, 0});  // {distance, x, y, iinc}
        
        // Direction vectors for 4 possible moves
        vector<vector<int>> delta1 = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto p = pq.top();
            pq.pop();
            
            long long wt = p[0];
            int x = p[1];
            int y = p[2];
            int iinc = p[3];
            
            // Skip if this path is outdated
            if (wt > dis[x][y][iinc]) continue;
            
            // Traverse through all possible moves
            for (auto &it : delta1) {
                int nx = x + it[0];
                int ny = y + it[1];
                
                if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;
                
                // Calculate new distance
                long long d = max(wt, (long long)v[nx][ny]) + iinc + 1;
                int new_iinc = 1 - iinc;  // Toggle increment for the next step
                
                if (d < dis[nx][ny][new_iinc]) {
                    dis[nx][ny][new_iinc] = d;
                    pq.push({d, nx, ny, new_iinc});
                }
            }
        }
        
        // Get the minimum time to reach the bottom-right corner
        return min(dis[n-1][m-1][0], dis[n-1][m-1][1]);
    }
};
",1441331796
Kalix1110,Kalix1110,229,3636,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};


class Solution {
public:
    bool isBalanced(string num) {
        ll a=0,b=0;
        int f=0;
        for(auto &it:num){
            if(f) a+=it-'0';
            else b+=it-'0';
            
            f=!f;
        }
        
        return a==b;
    }
};",1441281597
Kalix1110,Kalix1110,229,3637,cpp,"/*
	Name :- Tafheem Ahemad
	its always me vs me
*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
template <typename T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// order_of_key (k) : Number of items strictly smaller than k .
// find_by_order(k) : K-th element in a set (counting from zero).

#define ll long long int
#define ld long double
#define F first
#define S second
#define vl vector<ll>
#define vi vector<int>
#define vb vector<bool>
#define vs vector<string>
#define vll vector<vl>
#define vii vector<vi>
#define pii pair<int,int>
#define pll pair<ll,ll>
#define ump unordered_map
#define all(v) v.begin(),v.end()
#define take_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cin>>a[i][j];}}
#define print_matrix(a,n,m) for(int i=0; i<n; i++){for(int j=0; j<m; j++){cout<<a[i][j]<<' ';}cout<<endl;}
#define input(a) for(auto &x:a) cin>>x;
#define printv(a) for(auto &i:a) cout<<i<<' '; cout<<endl;
#define yes(x) if(x) cout<<""YES""<<endl; else cout<<""NO""<<endl;
#define cl(n) for(int i=0;i<=n+5;i++) g[i].clear()
#define memset(arr,val) memset(arr,val,sizeof(arr))
#define bpc(x) __builtin_popcountll(x)
#define __lcm(a,b) (a/__gcd(a, b)*b)
#define pq_max priority_queue<ll>
#define pq_min priority_queue<ll,vl,greater<ll>>
#define in insert
#define pb push_back
#define fast() ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);cout.precision(numeric_limits<double>::max_digits10);
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
const int MOD=1e9+7;
vector<vector<ll>>delta1={{1,0},{-1,0},{0,-1},{0,1}};
vector<vector<ll>>delta2={{1,0},{-1,0},{0,-1},{0,1},{1,1},{-1,1},{1,-1},{-1,-1}};

ll power(ll a,ll n , ll mod=MOD){
	a%=mod;
    ll res=1;
    while(n){
        if(n%2){
            res=res*a;
			res%=mod;
            n--;
        }else{
            a=(a*a);
			a%=mod;
            n/=2;
        }
    }
    
    return res;
}



const int N=100;

// array to store inverse of 1 to N 
ll  factorialNumInverse[N + 1]; 
  
// array to precompute inverse of 1! to N! 
ll  naturalNumInverse[N + 1]; 
  
// array to store factorial of first N numbers 
ll  fact[N + 1]; 


void factorial(ll  p=MOD) 
{ 
    fact[0] = 1; 
  
    // precompute factorials 
    for (ll i = 1; i <= N; i++) { 
        fact[i] = (fact[i - 1] * i) % p; 
    } 
} 

ll inv(ll x){
    return power(fact[x],MOD-2);
}

class Solution {
public:
    ll dp[85][900][50];
    int n;
    ll solve(int i,int sum,int odd,string &s){
        
        if(sum<-400) return 0;
        if(i==s.size()){
            // cout<<sum<<endl;
            if(sum==0) return 1;
            return 0;
        }
        if(dp[i][sum+400][odd] != -1) return dp[i][sum+400][odd];
        
        ll ans=0;
        ll even=(n-i)-odd;
        if(odd>0) ans+=(solve(i+1,sum-(s[i]-'0'),odd-1,s)*odd)%MOD;
        ans%=MOD;
        
        if(even>0) ans+=(solve(i+1,sum+(s[i]-'0'),odd,s)*even)%MOD;
         ans%=MOD;
        
        return dp[i][sum+400][odd]=ans;
    }
    int countBalancedPermutations(string num) {
        memset(dp,-1);
        factorial(MOD); 
         n=num.size();
        ll odd=n/2;
        ll even=n/2;
        if(n%2) odd++;
        ll ans= solve(0,0,odd,num);
        vl v(10);
        for(auto &it:num) v[it-'0']++;
        for(int i=0;i<10;i++){
            if(v[i]==0) continue;
            ans*=inv(v[i]);
            ans%=MOD;
        }
        
        return ans;
    }
};",1441372921
dapu81000,dapu81000,232,3627,cpp,"class Solution {
public:
    int dp[55][55] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        #define pii pair<int,int>
        priority_queue<pii, vector<pii>, greater<pii>> pq;
        pq.push({0, 0});
        while(!pq.empty()){
            pii tmp = pq.top();pq.pop();
            int x = tmp.second/m, y = tmp.second%m, dist = tmp.first;
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+1, moveTime[xx][yy]+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441306672
dapu81000,dapu81000,232,3628,cpp,"class Solution {
public:
    int dp[755][755] = {};
    int dir[4][2] = {0,1,0,-1,1,0,-1,0};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        memset(dp, 0x3f,sizeof dp);
        dp[0][0] = 0;

        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        pq.push({0, 0, 0});
        while(!pq.empty()){
            vector<int> v=pq.top();pq.pop();
            int x = v[1]/m, y = v[1]%m, dist = v[0], add = v[2];
            for(int i=0;i<4;i++){
                int xx = x+dir[i][0], yy = y+dir[i][1];
                if(xx<0 || xx>=n || yy<0 || yy>=m) continue;
                int cur = max(dist+add+1, moveTime[xx][yy]+add+1);
                if(dp[xx][yy]>cur){
                    pq.push({cur, xx*m+yy, !add});
                    dp[xx][yy] = cur;
                }
            }
        }
        return dp[n-1][m-1];
    }
};",1441314240
dapu81000,dapu81000,232,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int res[2] = {};
        for(int i=0;i<num.size();i++){
            int cur = (i&1)^1;
            res[cur] += num[i]-'0';
        }
        return res[0] == res[1];
    }
};",1441281741
dapu81000,dapu81000,232,3637,cpp,"class Solution {
public:
    int dp[41][401] = {};
    int fac[88] = {};
    const int mod = 1e9+7;
    void build(){
        fac[0] = fac[1] = 1;
        for(int i=2;i<=80;i++){
            fac[i] = (1ll*fac[i-1]*i)%mod;
        }
    }
    int powmod(long long x,int n){
        long long res = 1;
        while(n){
            if(n&1) res = (res*x)%mod;
            x = (x*x)%mod;
            n>>=1;
        }
        return res;
    }
    int cnt[10] = {};
    int countBalancedPermutations(string num) {
        build();
        int tot = 0;
        for(char ch:num) tot += ch-'0', cnt[ch-'0']++;
        if(tot&1) return 0;
        if(tot==1) return 1;
        int mid = tot/2, n = num.size();
        dp[0][0] = 1;

        for(int i=0;i<n;i++){
            int cur = num[i]-'0';
            for(int j=min(i+1,n/2);j>0;j--){
                for(int k=mid;k>=cur;k--){
                    dp[j][k] += dp[j-1][k-cur];
                    dp[j][k] %= mod;
                }
            }
        }
        long long res = dp[n/2][mid];
        res = (res*fac[n/2])%mod;
        res = (res*fac[n-n/2])%mod;

        for(int i=0;i<=9;i++){
            if(cnt[i]>1){
                res = (res*powmod(fac[cnt[i]],mod-2))%mod;
            }
        }
        return res;
    }
};",1441367211
Anh Tài Trần,anh_tai,234,3627,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 );
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441372865
Anh Tài Trần,anh_tai,234,3628,cpp,"#define mp make_pair
long long dp[751][751][2]; 
long long oo = 1e14;

int dr[4] = {1,-1,0,0};
int dc[4] = {0,0,1,-1}; 

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int h = moveTime.size();
        int w = moveTime[0].size();
        for (int r = 0; r < h; r++){
            for (int c = 0; c < w; c++){
                dp[r][c][0] = dp[r][c][1] = oo; 
            }
        }

        dp[0][0][0] = 0;
        set<pair<long long, vector<int>>> pq;
        pq.insert(mp(0LL, vector<int>(3))); 
        while (pq.size()){
            auto it = pq.begin();
            long long dist = it->first;
            vector<int> v = it->second;
            int r = v[0], c = v[1], f = v[2];
            pq.erase(pq.begin());
            if (dist > dp[r][c][f]){
                continue; 
            }
            
            for (int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if (nr >= 0 && nr < h && nc >= 0 && nc < w){
                    long long n_dist = max(dist, 1LL * moveTime[nr][nc]) + (1 + f);
                    if (n_dist < dp[nr][nc][1 - f]){
                        dp[nr][nc][1 - f] = n_dist;
                        vector<int> vv = {nr, nc, 1 - f}; 
                        pq.insert(make_pair(n_dist, vv)); 
                    }
                }
            }
        }
        
        return min(dp[h-1][w-1][0], dp[h-1][w-1][1]); 
    }
};",1441371858
Anh Tài Trần,anh_tai,234,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s = 0, mul = 1;
        for (char&c : num){
            s += mul * (c - '0');
            mul = mul * -1;
        }
        return s == 0; 
    }
};",1441350523
Anh Tài Trần,anh_tai,234,3637,cpp,"int fact[81], ifact[81];

const int mod = 1e9 + 7;

int add(int u, int v){
    u += v;
    if (u >= mod) u -= mod;
    return u; 
}

int sub(int u, int v){
    return add(u, mod - v);
}

int mul(int u, int v){
    return 1LL * u * v % mod;
}

int power(int u, int v){
    int res = 1;
    while (v > 0){
        if (v & 1){
            res = mul(res, u);
        }
        u = mul(u, u);
        v >>= 1;
    }
    return res; 
}

void init(){
    if (fact[0] > 0){
        return; 
    }
    
    fact[0] = ifact[0] = 1;
    for (int i = 1; i <= 80; i++){
        fact[i] = mul(fact[i-1],i);
        ifact[i] = power(fact[i], mod - 2);
        //cout << i << "" "" << fact[i] << "" "" << ifact[i] << ""\n""; 
    }
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        init(); 
        int n = num.size();
        vector<int> cnt(10);
        int tot = 0; 
        for (char& c : num){
            cnt[c - '0']++;
            tot += (c - '0');
        }

        if (tot&1){
            return 0; 
        }

        tot >>= 1; 
        vector<vector<int>> dp(41, vector<int>(361)), ndp(41, vector<int>(361)); 
        dp[0][0] = 1;

        // for (int sum = 0; sum <= tot; sum++){
        //     for (int digits = 0; digits <= (n + 1) / 2; digits++){
        //         for (int d = 0; d < 10; d++){
        //             for (int sk = 0; sk <= cnt[d];sk++){
        //                 int n_sum = sum + sk * d;
        //                 int n_digits = digits + sk;
        //                 if (n_sum <= tot && n_digits <= (n + 1) / 2){
        //                     ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], ifact[sk]));
        //                 }
        //             }
        //         }
        //     }
        // }
        
        for (int d = 0; d < 10; d++){
            for (int sk = 0; sk <= cnt[d]; sk++){
                for (int sum = 0; sum <= tot; sum++){
                    for (int digits = 0; digits <= (n + 1) / 2; digits++){
                        int n_sum = sum + sk * d;
                        int n_digits = digits + sk;
                        if (n_sum <= tot && n_digits <= (n + 1) / 2){
                            ndp[n_digits][n_sum] = add(ndp[n_digits][n_sum], mul(dp[digits][sum], mul(ifact[sk], ifact[cnt[d] - sk])));
                        }
                    } 
                }   
            }

            for (int sum = 0; sum <= tot; sum++){
                for (int digits = 0; digits <= (n + 1) / 2; digits++){
                    dp[digits][sum] = ndp[digits][sum];
                    ndp[digits][sum] = 0; 
                }
             }
        }
        
        int ans = mul(fact[(n + 1) / 2], dp[(n + 1) / 2][tot]);
        ans = mul(ans, fact[n -(n + 1) / 2]);
        return ans; 
    }
};",1441385911
Pikachu0123,Pikachu0123,236,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        queue<vector<int>> q;
        q.push({0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.front()[0];
            int c = q.front()[1];
            int d = q.front()[2];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = d;
                if (d < moveTime[nr][nc]){
                    new_d = moveTime[nr][nc];
                }
                if (new_d + 1 < dis[nr][nc]){
                    dis[nr][nc] = new_d + 1;
                    q.push({nr, nc, new_d + 1});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441298296
Pikachu0123,Pikachu0123,236,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        int dr[4] = {1, 0, -1, 0};
        int dc[4] = {0, -1, 0, 1};
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e15));
        dis[0][0] = 0;
        while(!q.empty()){
            int r = q.top()[1];
            int c = q.top()[2];
            int d = -q.top()[0];
            int type = q.top()[3];
            q.pop();
            for(int i=0; i<4; i++){
                int nr =r + dr[i];
                int nc = c + dc[i];
                if (nr < 0 or nc < 0 or nr >= n or nc >= m) continue;
                int new_d = max(d, moveTime[nr][nc]);
                int cost = new_d + (type == 0 ? 1 : 2);
                if (cost < dis[nr][nc]){
                    dis[nr][nc] = cost;
                    q.push({-cost,nr, nc, !type});
                }
            }
        }

        return dis[n-1][m-1];
    }
};",1441303211
Pikachu0123,Pikachu0123,236,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        int n = num.size();
        for(int i=0; i<n; i+=2) sum1 += num[i]-'0';
        for(int i=1; i<n; i+=2) sum2 += num[i] - '0';
        return sum1 == sum2;
    }
};",1441281379
Pikachu0123,Pikachu0123,236,3637,cpp,"
const int mod = 1e9 + 7;
const int offset = 730;
long long dp[10][1500][42];
long long ncr[101][101];

void precompute_nCr() {
    for (int i = 0; i <= 100; ++i) {
        ncr[i][0] = ncr[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            ncr[i][j] = (ncr[i-1][j-1] + ncr[i-1][j]) % mod;
        }
    }
}

class Solution {
long long solve(int i,  int sum, int odd, int even, vector<int> &freq){
    if (i == 10){
        if (sum == 0) return 1;
        else return 0;
    }
    if (freq[i] == 0){
        return solve(i + 1, sum, odd, even, freq);
    }
    if (dp[i][sum+offset][even] != -1) return dp[i][sum+offset][even];
    long long ans = 0;
    int val = freq[i];
    for(int j=0; j<=val; j++){
        int taken_odd = j;
        int taken_even = val - j;
        if (odd >= taken_odd and even >= taken_even){
            (ans += ((ncr[odd][taken_odd] * 1LL * ncr[even][taken_even]) % mod * solve(i + 1, sum - i * taken_odd + i * taken_even, odd - taken_odd, even - taken_even, freq)) % mod) %= mod;
        }
    }
    return dp[i][sum+offset][even] = ans;
}
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> freq(10, 0);
        
        for(char &ch : num)
            freq[ch-'0'] += 1;
        int odd = (n + 1) / 2, even = n / 2;
        memset(dp, -1, sizeof dp);
        memset(ncr, 0, sizeof ncr);
        precompute_nCr();
        return solve(0, 0, odd, even, freq);
    }
};",1441369861
pooyaz,pooyaz,237,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        vector<vector<int>> cnt(n, vector<int>(m, -1));
        priority_queue<vector<int>> q;
        q.push({0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2];
            if(cnt[i][j] != -1) continue;
            cnt[i][j] = dis;
            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj] == -1){
                    int ndist = max(t[ni][nj], dis) + 1;
                    q.push({-ndist, ni, nj});
                }
            }
        }
        return cnt[n - 1][m - 1];
    }
};",1441319916
pooyaz,pooyaz,237,3628,cpp,"class Solution {
public:
    int cnt[760][760][2];
    int minTimeToReach(vector<vector<int>>& t) {
        int n = t.size();
        int m = t[0].size();
        int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        memset(cnt, -1, sizeof cnt);
        priority_queue<vector<int>> q;
        q.push({0, 0, 0, 0});
        while(!q.empty()){
            vector<int> v = q.top();
            q.pop();
            int dis = -v[0];
            int i = v[1], j = v[2], s = v[3];
            if(cnt[i][j][s] != -1) continue;
            
            cnt[i][j][s] = dis;
            if(i == n - 1 && j == m - 1) break;

            for(int d = 0; d < 4; d++){
                int ni = i + dir[d][0];
                int nj = j + dir[d][1];
                int ns = 1 - s;
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && cnt[ni][nj][ns] == -1){
                    int ndist = max(t[ni][nj], dis) + 1 + s;
                    q.push({-ndist, ni, nj, ns});
                }
            }
        }
        if(cnt[n - 1][m - 1][0] == -1){
            return cnt[n - 1][m - 1][1];
        }
        else if(cnt[n - 1][m - 1][1] == -1){
            return cnt[n - 1][m - 1][0];
        }
        return min(cnt[n - 1][m - 1][0], cnt[n - 1][m - 1][1]);
    }
};",1441331858
pooyaz,pooyaz,237,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.length(); i++){
            if(i % 2) sum += num[i] - '0';
            else sum -= num[i] - '0';
        }
        return sum == 0;
    }
};",1441281862
pooyaz,pooyaz,237,3637,cpp,"#define Mod 1000000007L

class Solution {
public:
    int n;
    int sum[11];
    int dig[11];
    int cnt[11] = {};
    long long com[50][50] = {};
    long long dp[11][50][500];

    long long mem(int idx, int sp, int rem){
        if(idx == 10){
            return sp == 0 && rem == 0;
        }
        long long& ref = dp[idx][sp][rem];
        if(ref != -1) return ref;
        ref = 0;

        int sp2 = dig[idx] - sp;
        int rem2 = sum[idx] - rem;
        for(int i = 0; i <= cnt[idx]; i++){
            if(i > sp || i * idx > rem) continue;
            if(cnt[idx] - i > sp2 || (cnt[idx] - i) * idx > rem2) continue;
            long long nex = mem(idx + 1, sp - i, rem - i * idx);
            long long c1 = com[i][sp];
            long long c2 = com[cnt[idx] - i][sp2];
            // cout << idx << ' ' << sp << ' ' << rem << ' ' << i << ' ' << nex << ' ' << c1 << ' ' << c2 << endl;
            ref = (ref + nex * (c1 * c2 % Mod)) % Mod;
            // cout << ref << endl;
        }
        return ref;
    }
    int countBalancedPermutations(string num) {
        n = num.length();
        memset(dp, -1, sizeof dp);
        for(int i = 0; i < n; i++){
            int d = num[i] - '0';
            cnt[d]++;
        }
        for(int i = 9; i >= 0; i--){
            sum[i] = sum[i + 1] + cnt[i] * i;
            dig[i] = dig[i + 1] + cnt[i];
        }
        if(sum[0] % 2) return 0;
        for(int i = 0; i <= dig[0] / 2 + 1; i++){
            com[0][i] = 1;
            com[i][i] = 1;
        }
        for(int i = 1; i <= dig[0] / 2 + 1; i++){
            for(int j = 1; j < i; j++){
                com[j][i] = (com[j - 1][i - 1] + com[j][i - 1]) % Mod;
                // cout << i << ' ' << j << ' ' << com[j][i] << ' ' << com[j - 1][i - 1] << ' ' << com[j][i - 1] << endl;
            }
        }
        
        long long ans = mem(0, dig[0] / 2, sum[0] / 2);
        return (int)ans;
    }
};",1441382229
KGowtham04,KGowtham04,238,3627,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int n, m;
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({0, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+1;
                    pq.push({newTime, {newX, newY}});
                    seen[newX][newY] = true;
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }

    

    
};",1441325312
KGowtham04,KGowtham04,238,3628,cpp,"class Solution {
public:
    int n, m;
    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        n = moveTime.size(), m = moveTime[0].size();

        priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;

        vector<vector<bool>> seen(n, vector<bool> (m, false));

        pq.push({{0, 1}, {0, 0}});
        seen[0][0] = true;

        while(pq.size()){
            int time = pq.top().first.first;
            int move = pq.top().first.second;
            int x = pq.top().second.first;
            int y = pq.top().second.second;
            pq.pop();

            if(x==n-1 and y==m-1) return time;

            for(int i=0; i<4; i++){
                int newX = x + directions[i].first;
                int newY = y + directions[i].second;

                if(isValid(newX, newY) and !seen[newX][newY]){
                    int newTime = max(time, moveTime[newX][newY])+move;
                    int newMove = move == 2 ? 1 : 2; 
                    pq.push({{newTime, newMove}, {newX, newY}});
                    seen[newX][newY] = true;
                    
                }
            }
        }

        return 0;

        
    }

    bool isValid(int x, int y){
        return (x>=0 and x<n and y>=0 and y<m);
    }       
};",1441338140
KGowtham04,KGowtham04,238,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {

        int odd = 0, even  = 0;

        for(int i=0; i<num.size(); i++){
            if(i%2==0){
                even += num[i] - 48;
            }
            else{
                odd+= num[i] - 48;
            }
        }

        return even == odd;
        
    }
};",1441289755
KGowtham04,KGowtham04,238,3637,cpp,"typedef long long ll;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int MOD = 1e9+7;
                int n = num.size();
        int m = (n + 1) / 2; // Number of even indices (0-based)

        // Count digits
        int count_digits[10] = {0};
        ll sum_total =0;
        for(char ch: num){
            int d = ch - '0';
            count_digits[d]++;
            sum_total += d;
        }

        // If total sum is odd, no balanced permutation exists
        if(sum_total %2 !=0){
            return 0;
        }
        ll sum_target = sum_total /2;

        // Precompute factorial and inverse factorial
        vector<ll> fact(n+1, 1);
        for(int i=1;i<=n;i++) fact[i] = fact[i-1] * i % MOD;

        // Compute inverse factorial
        vector<ll> inv_fact(n+1,1);
        inv_fact[n] = power_mod_func(fact[n], MOD-2, MOD);
        for(int i=n-1;i>=0;i--){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }

        // Compute product of inverse factorials of counts
        // Not needed in the final formula
        // ll inv_fact_prod_counts =1;
        // for(int d=0; d<=9; d++) {
        //     inv_fact_prod_counts = inv_fact_prod_counts * inv_fact[count_digits[d]] % MOD;
        // }

        // Initialize DP
        // dp[k][s] represents the number of ways to assign k digits with sum s, adjusted by inverse factorials
        vector<vector<ll>> dp_prev(m+1, vector<ll>(sum_target +1, 0));
        dp_prev[0][0] =1;

        for(int d=0; d<=9; d++){
            int c_d = count_digits[d];
            if(c_d ==0){
                continue;
            }
            // Initialize next layer
            vector<vector<ll>> dp_next(m+1, vector<ll>(sum_target +1, 0));

            for(int k=0; k<=m; k++){
                for(ll s=0; s<=sum_target; s++){
                    if(dp_prev[k][s] ==0){
                        continue;
                    }
                    // Try assigning t digits of this digit to even positions
                    for(int t=0; t<=c_d && t <= m -k; t++){
                        if(s + (ll)t *d > sum_target){
                            continue;
                        }
                        // Update dp_next
                        dp_next[k +t][s + (ll)t *d] = (dp_next[k +t][s + (ll)t *d] + dp_prev[k][s] * inv_fact[t] % MOD * inv_fact[c_d - t] % MOD) % MOD;
                    }
                }
            }
            // Update dp_prev
            dp_prev = move(dp_next);
        }

        // After processing all digits, check dp_prev[m][sum_target]
        ll dp_final = 0;
        if(m <= n && sum_target <= sum_total){
            dp_final = dp_prev[m][sum_target];
        }

        // Compute the final answer
        // The correct formula is: fact[m] * fact[n -m} * dp_final % MOD
        ll answer = fact[m] * fact[n -m] % MOD;
        answer = answer * dp_final % MOD;

        return (int)answer;
    }
    
   ll power_mod_func(ll x, ll power, ll mod_val) {
        ll result = 1;
        x %= mod_val;
        while(power > 0){
            if(power & 1){
                result = result * x % mod_val;
            }
            x = x * x % mod_val;
            power >>=1;
        }
        return result;
    }
};",1441388333
Varun Deep Saini,sojabhai,240,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<pair<int, int>> directions = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };
        
        vector<vector<int>> dist(n, vector<int>(m, 1e18));
        dist[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;

        pq.emplace(0, make_pair(0, 0));
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            
            int w = curr.first;
            int x = curr.second.first;
            int y = curr.second.second;
            
            if (x == n -1 && y == m -1) {
                return (int)w;
            }
            
            if (w > dist[x][y]) {
                continue;
            }
            
            for (auto &dir : directions) {
                int nx = x + dir.first;
                int ny = y + dir.second;
                
                if (nx >=0 && nx < n && ny >=0 && ny < m) {
                    int timee = max((int)w, (int)moveTime[nx][ny]);
                    int d = timee + 1;
                    
                    if (d < dist[nx][ny]) {
                        dist[nx][ny] = d;
                        pq.emplace(d, make_pair(nx, ny));
                    }
                }
            }
        }
        #undef int
        return 69;
    }
};
",1441374028
Varun Deep Saini,sojabhai,240,3628,cpp,"class Solution {
public:
    vector<pair<int, int>> directions = { {-1,0}, {1,0}, {0,-1}, {0,1} };
        
    struct Compare {
    bool operator()(const vector<long long>& a, const vector<long long>& b) const {
            return a[0] > b[0];
        }
    };

    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist1(n, vector<int>(m, LLONG_MAX));
        vector<vector<int>> dist2(n, vector<int>(m, LLONG_MAX));
        
        priority_queue<vector<int>, vector<vector<int>> , Compare> pq;
        
        dist1[0][0] = 0;
        pq.push({0, 0, 0, 0});
        
        while(!pq.empty()){
            auto current = pq.top();
            pq.pop();
            
            int timee = current[0];
            int i = current[1];
            int j = current[2];
            int k = current[3];
            
            if(i == n-1 && j == m-1){
                return timee;
            }
            
            if( (k == 0 && timee > dist1[i][j]) ||
                (k == 1 && timee > dist2[i][j]) ){
                continue;
            }
            
            for(auto &[di, dj] : directions){
                int ni = i + di;
                int nj = j + dj;
                
                if(ni >= 0 && ni < n && nj >= 0 && nj < m){
                    
                    int cost = (k == 0) ? 1 : 2;
                    
                    int movee = max(timee, (int)moveTime[ni][nj]);
                    
                    int tot = movee + cost;
                    
                    if(k == 1){
                        if(tot < dist1[ni][nj]){
                            dist1[ni][nj] = tot;
                            pq.push({tot, ni, nj, 0});
                        }
                    }
                    else{
                        if(tot < dist2[ni][nj]){
                            dist2[ni][nj] = tot;
                            pq.push({tot, ni, nj, 1});
                        }
                    }
                }
            }
        }
        #undef int
        return -1;

    }
};",1441368729
Varun Deep Saini,sojabhai,240,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even_sum = 0; 
        int odd_sum = 0;  

        for(int i = 0; i < num.length(); ++i){
            if(i % 2 == 0){
                even_sum += num[i] - '0';
            }
            else{
                odd_sum += num[i] - '0';
            }
        }

        return even_sum == odd_sum;

    }
};",1441350550
Varun Deep Saini,sojabhai,240,3637,cpp,"#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MOD = 1e9 + 7;
int z = 0;

int fact[102];
int inv_fact[102];

class Solution {
public:

    void pre() {
        if(z) return;
        z = 1;

        fact[0] = 1;
        for(int i = 1; i <= 101; i++) fact[i] = fact[i-1] * i % MOD;

        inv_fact[101] = power(fact[101], MOD - 2);
        for(int i = 100; i >= 0; i--) inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        
    }

    int power(int a , int b){
        int res = 1;
        a %= MOD;
        while(b > 0){
            if(b & 1){
                res = res * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int comb(int n, int r){
        return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD;
    }

    int countBalancedPermutations(string num) {
        pre();
        map<int ,int> freq;
        int n = num.length();
        int sum = 0;
        for(auto &i : num){
            freq[i - '0']++;
            sum += i - '0';
        }
        
        if(sum % 2 != 0){
            return 0;
        }
        
        int target = sum / 2;
        
        int even = (n + 1) / 2; 
        int odd = n / 2;       
        
        vector<vector<int>> dp(target + 1, vector<int>(even + 1, 0));
        dp[0][0] = 1;
        
        for(int d = 0; d <= 9; d++){
            if(freq[d] == 0) continue;
            for(int i = target; i >= 0; i--){
                for(int j = even; j >= 0; j--){
                    if(dp[i][j] == 0) continue;

                    // add cnt d
                    for(int cnt = 1; cnt <= freq[d]; cnt++){
                        if(cnt + j > even) break;
                        if(i + cnt*d > target) break;
                        dp[i + cnt*d][j + cnt] = (dp[i + cnt*d][j + cnt] + dp[i][j] * comb(freq[d], cnt)) % MOD;
                    }
                }
            }
        }
        
        int ways = dp[target][even];
        
        int den = 1;
        for(int d = 0; d <= 9; d++) den = den * fact[freq[d]] % MOD;
        den = power(den, MOD - 2);

        int ans = ways * fact[even] % MOD;
        ans = ans * fact[odd] % MOD;
        ans = ans * den % MOD;
        
        return ans;
    }
};
#undef int",1441388578
otto,_otto,241,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        dist = [[inf] * m for _ in range(n)]
        dist[0][0] = 0
        hp = []
        heappush(hp, (0, 0, 0))

        while hp:
            curr, r, c = heappop(hp)
            if r == n-1 and c == m-1:
                return curr
            if curr > dist[r][c]:
                continue
            for dr, dc in pairwise([-1, 0, 1, 0, -1]):
                nr, nc = r + dr, c + dc
                if 0 <= nr < n and 0 <= nc < m:
                    new = max(curr, moveTime[nr][nc]) + 1
                    if new < dist[nr][nc]:
                        dist[nr][nc] = new
                        heappush(hp, (new, nr, nc))
        return -1",1441304953
otto,_otto,241,3628,python3,"class Solution:
    def minTimeToReach(self, A: List[List[int]]) -> int:
        n = len(A)
        m = len(A[0])

        dist = [[[inf] * 2 for _ in range(m)] for _ in range(n)]
        dist[0][0][0] = 0

        hp = []
        heappush(hp, (0, 0, 0, 0))
        while hp:
            t, i, j, p = heappop(hp)
            if i == n-1 and j == m-1:
                return t
            if t > dist[i][j][p]: continue

            for di, dj in pairwise([-1, 0, 1, 0, -1]):
                ni, nj = i + di, j + dj
                if 0 <= ni < n and 0 <= nj < m:
                    curr = max(t, A[ni][nj])
                    cos = 1 if p == 0 else 2
                    new = curr + cos
                    next_p = 1 - p
                    if new < dist[ni][nj][next_p]:
                        dist[ni][nj][next_p] = new
                        heappush(hp, (new, ni, nj, next_p))

        return -1
",1441323111
otto,_otto,241,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        
        a = b = 0
        for i, x in enumerate(str(num)):
            if i % 2 == 0:
                a += int(x)
            else:
                b += int(x)
        return a == b",1441281200
otto,_otto,241,3637,python3,"MOD = int(1e9 + 7)
MAXN = 81
fac = [1] * (MAXN + 1)
inv_fac = [1] * (MAXN + 1)
for i in range(1, MAXN + 1): fac[i] = fac[i - 1] * i % MOD
inv_fac[MAXN] = pow(fac[MAXN], MOD - 2, MOD)
for i in range(MAXN, 0, -1): inv_fac[i - 1] = inv_fac[i] * i % MOD
comb = [[0] * (MAXN + 1) for _ in range(MAXN + 1)]
for n in range(MAXN + 1):
    comb[n][0] = 1
    for k in range(1, n + 1):
        comb[n][k] = (comb[n - 1][k - 1] + comb[n - 1][k]) % MOD

class Solution:
    def countBalancedPermutations(self, s: str) -> int:
        n = len(s)
        c = [0] * 10
        fuck = 0
        for ch in s: 
            c[int(ch)] += 1
            fuck += int(ch)
        if fuck % 2 != 0: return 0
        target = fuck // 2
        even = (n + 1) // 2
        odd = n // 2
        dp = [[0] * (even + 1) for _ in range(target + 1)]
        dp[0][0] = 1

        for d in range(10):
            f = c[d]
            if f == 0:
                continue
            ndp = [dp_row[:] for dp_row in dp]
            for s in range(target + 1):
                for cnt in range(even + 1):
                    v = dp[s][cnt]
                    if v == 0:
                        continue
                    for k in range(1, min(f, even - cnt) + 1):
                        news = s + d * k
                        newcnt = cnt + k
                        if news > target or newcnt > even: break
                        ndp[news][newcnt] = (ndp[news][newcnt] + v * comb[f][k]) % MOD
            dp = ndp

        shit = dp[target][even] # slots
        
        # combs
        fuck_even = fac[even]
        for d in range(10):
            for k in range(0, min(c[d], even) + 1):
                if k > even: break
                if target - d * k < 0: break
                if dp[s - d * k][even - k] == 0:continue
                ways = comb[c[d]][k]
                fuck_even = fuck_even * inv_fac[k] % MOD
                break
        fuck_odd = fac[odd]
        for d in range(10):
            fuck_odd = fuck_odd * inv_fac[c[d]] % MOD
        tot = fuck_even * fuck_odd % MOD

        return (shit * tot) % MOD",1441382688
garyjhu,garyjhu,242,3627,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + 1 < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + 1;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441295879
garyjhu,garyjhu,242,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length, n = moveTime[0].length;
        PriorityQueue<Node> pq = new PriorityQueue<Node>();
        pq.add(new Node(0, 0, 0));
        long[][] dist = new long[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = 1_000_000_000_000_000L;
            }
        }
        dist[0][0] = 0;
        int[][] dirs = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};
        while (!pq.isEmpty()) {
            Node node = pq.poll();
            if (node.dist > dist[node.r][node.c]) continue;
            for (int[] dir : dirs) {
                int x = node.r + dir[0];
                int y = node.c + dir[1];
                int e = (x + y) % 2 == 1 ? 1 : 2;
                if (0 <= x && x < m && 0 <= y && y < n && Math.max(node.dist, moveTime[x][y]) + e < dist[x][y]) {
                    long d = Math.max(node.dist, moveTime[x][y]) + e;
                    dist[x][y] = d;
                    pq.add(new Node(x, y, d));
                }
            }
        }
        return (int) dist[m - 1][n - 1];
    }

    private static record Node(int r, int c, long dist) implements Comparable<Node> {
        @Override
        public int compareTo(Node o) {
            return Long.compare(dist, o.dist);
        }
    }
}
",1441297024
garyjhu,garyjhu,242,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int sumE = 0, sumO = 0;
        int n = num.length();
        for (int i = 0; i < n; i++) {
            if (i % 2 == 0) sumE += num.charAt(i) - '0';
            else sumO += num.charAt(i) - '0';
        }
        return sumE == sumO;
    }
}
",1441284545
garyjhu,garyjhu,242,3637,java,"import java.util.ArrayList;
import java.util.Arrays;

class Solution {
    static ModIntFactory factory = new ModIntFactory(1_000_000_007);
    static long[] invFac;
    public int countBalancedPermutations(String num) {
        if (invFac == null) init();
        int n = num.length();
        int sum = 0;
        int[] count = new int[10];
        for (char c : num.toCharArray()){
            sum += c - '0';
            count[c - '0']++;
        }
        if (sum % 2 == 1) return 0;
        int goal = sum / 2;
        long[][] dp = new long[n + 1][goal + 1];
//        ModIntFactory.ModInt[][] dp = new ModIntFactory.ModInt[n + 1][goal + 1];
//        for (ModIntFactory.ModInt[] row : dp) Arrays.fill(row, factory.create(0));
        dp[0][0] = 1;
//        dp[0][0] = factory.create(1);
        for (int i = 0; i < 10; i++) {
            long[][] tp = new long[n + 1][goal + 1];
//            ModIntFactory.ModInt[][] tp = new ModIntFactory.ModInt[n + 1][goal + 1];
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) tp[j][k] = factory.create(0);
//            }
            for (int j = 0; j < n; j++) {
                for (int k = 0; k <= goal; k++) {
                    for (int l = 0; l <= count[i]; l++) {
                        if (j + l <= n && k + l * i <= goal) {
                            tp[j + l][k + l * i] = (tp[j + l][k + l * i] + factory.create(dp[j][k]).mul(invFac[l]).mul(invFac[count[i] - l]).value);
//                            tp[j + l][k + l * i].addAsg(dp[j][k].mul(factory.factorial(l).mul(factory.factorial(count[i] - l)).inv()));
                        }
                    }
                }
            }
            dp = tp;
//            for (int j = 0; j <= n; j++) {
//                for (int k = 0; k <= goal; k++) {
//                    System.out.print(dp[j][k] + "" "");
//                }
//                System.out.println();
//            }
//            System.out.println();
        }
//        System.out.println();
        return factory.factorial(n / 2).mul(factory.factorial((n + 1) / 2)).mul(dp[n / 2][goal]).value;
//        ModIntFactory.ModInt res = dp[n / 2][goal].mul(factory.factorial(n / 2)).mul(factory.factorial((n + 1) / 2));
//        return res.value;
    }
    
    static void init() {
        invFac = new long[100];
        for (int i = 0; i < 100; i++) invFac[i] = factory.factorial(i).inv().value;
    }

    static class ModIntFactory {
        private final ModArithmetic ma;
        private final int mod;

        private final boolean usesMontgomery;
        private final ModArithmetic.ModArithmeticMontgomery maMontgomery;

        private ArrayList<Integer> factorial;

        public ModIntFactory(int mod) {
            this.ma = ModArithmetic.of(mod);
            this.usesMontgomery = ma instanceof ModArithmetic.ModArithmeticMontgomery;
            this.maMontgomery = usesMontgomery ? (ModArithmetic.ModArithmeticMontgomery) ma : null;
            this.mod = mod;

            this.factorial = new ArrayList<>();
        }

        public ModInt create(long value) {
            if ((value %= mod) < 0) value += mod;
            if (usesMontgomery) {
                return new ModInt(maMontgomery.generate(value));
            } else {
                return new ModInt((int) value);
            }
        }

        private void prepareFactorial(int max){
            factorial.ensureCapacity(max+1);
            if(factorial.size()==0) factorial.add(1);
            if (usesMontgomery) {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), maMontgomery.generate(i)));
                }
            } else {
                for(int i=factorial.size(); i<=max; i++){
                    factorial.add(ma.mul(factorial.get(i-1), i));
                }
            }
        }

        public ModInt factorial(int i){
            prepareFactorial(i);
            return create(factorial.get(i));
        }

        public ModInt permutation(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), factorial.get(r)));
        }
        public ModInt combination(int n, int r){
            if(n < 0 || r < 0 || n < r) return create(0);
            prepareFactorial(n);
            return create(ma.div(factorial.get(n), ma.mul(factorial.get(r),factorial.get(n-r))));
        }

        public int getMod() {
            return mod;
        }

        public class ModInt {
            private int value;
            private ModInt(int value) {
                this.value = value;
            }
            public int mod() {
                return mod;
            }
            public int value() {
                if (usesMontgomery) {
                    return maMontgomery.reduce(value);
                }
                return value;
            }
            public ModInt add(ModInt mi) {
                return new ModInt(ma.add(value, mi.value));
            }
            public ModInt add(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3);
            }
            public ModInt add(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.add(value, mi1.value)).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt add(ModInt mi1, ModInt... mis) {
                ModInt mi = add(mi1);
                for (ModInt m : mis) mi.addAsg(m);
                return mi;
            }
            public ModInt add(long mi) {
                return new ModInt(ma.add(value, ma.remainder(mi)));
            }
            public ModInt sub(ModInt mi) {
                return new ModInt(ma.sub(value, mi.value));
            }
            public ModInt sub(long mi) {
                return new ModInt(ma.sub(value, ma.remainder(mi)));
            }
            public ModInt mul(ModInt mi) {
                return new ModInt(ma.mul(value, mi.value));
            }
            public ModInt mul(ModInt mi1, ModInt mi2) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mul(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return new ModInt(ma.mul(value, mi1.value)).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mul(ModInt mi1, ModInt... mis) {
                ModInt mi = mul(mi1);
                for (ModInt m : mis) mi.mulAsg(m);
                return mi;
            }
            public ModInt mul(long mi) {
                return new ModInt(ma.mul(value, ma.remainder(mi)));
            }
            public ModInt div(ModInt mi) {
                return new ModInt(ma.div(value, mi.value));
            }
            public ModInt div(long mi) {
                return new ModInt(ma.div(value, ma.remainder(mi)));
            }
            public ModInt inv() {
                return new ModInt(ma.inv(value));
            }
            public ModInt pow(long b) {
                return new ModInt(ma.pow(value, b));
            }
            public ModInt addAsg(ModInt mi) {
                this.value = ma.add(value, mi.value);
                return this;
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2) {
                return addAsg(mi1).addAsg(mi2);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3);
            }
            public ModInt addAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return addAsg(mi1).addAsg(mi2).addAsg(mi3).addAsg(mi4);
            }
            public ModInt addAsg(ModInt... mis) {
                for (ModInt m : mis) addAsg(m);
                return this;
            }
            public ModInt addAsg(long mi) {
                this.value = ma.add(value, ma.remainder(mi));
                return this;
            }
            public ModInt subAsg(ModInt mi) {
                this.value = ma.sub(value, mi.value);
                return this;
            }
            public ModInt subAsg(long mi) {
                this.value = ma.sub(value, ma.remainder(mi));
                return this;
            }
            public ModInt mulAsg(ModInt mi) {
                this.value = ma.mul(value, mi.value);
                return this;
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2) {
                return mulAsg(mi1).mulAsg(mi2);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3);
            }
            public ModInt mulAsg(ModInt mi1, ModInt mi2, ModInt mi3, ModInt mi4) {
                return mulAsg(mi1).mulAsg(mi2).mulAsg(mi3).mulAsg(mi4);
            }
            public ModInt mulAsg(ModInt... mis) {
                for (ModInt m : mis) mulAsg(m);
                return this;
            }
            public ModInt mulAsg(long mi) {
                this.value = ma.mul(value, ma.remainder(mi));
                return this;
            }
            public ModInt divAsg(ModInt mi) {
                this.value = ma.div(value, mi.value);
                return this;
            }
            public ModInt divAsg(long mi) {
                this.value = ma.div(value, ma.remainder(mi));
                return this;
            }
            @Override
            public String toString() {
                return String.valueOf(value());
            }
            @Override
            public boolean equals(Object o) {
                if (o instanceof ModInt) {
                    ModInt mi = (ModInt) o;
                    return mod() == mi.mod() && value() == mi.value();
                }
                return false;
            }
            @Override
            public int hashCode() {
                return (1 * 37 + mod()) * 37 + value();
            }
        }

        private static abstract class ModArithmetic {
            abstract int mod();
            abstract int remainder(long value);
            abstract int add(int a, int b);
            abstract int sub(int a, int b);
            abstract int mul(int a, int b);
            int div(int a, int b) {
                return mul(a, inv(b));
            }
            int inv(int a) {
                int b = mod();
                if (b == 1) return 0;
                long u = 1, v = 0;
                while (b >= 1) {
                    int t = a / b;
                    a -= t * b;
                    int tmp1 = a; a = b; b = tmp1;
                    u -= t * v;
                    long tmp2 = u; u = v; v = tmp2;
                }
                if (a != 1) {
                    throw new ArithmeticException(""divide by zero"");
                }
                return remainder(u);
            }
            int pow(int a, long b) {
                if (b < 0) throw new ArithmeticException(""negative power"");
                int r = 1;
                int x = a;
                while (b > 0) {
                    if ((b & 1) == 1) r = mul(r, x);
                    x = mul(x, x);
                    b >>= 1;
                }
                return r;
            }

            static ModArithmetic of(int mod) {
                if (mod <= 0) {
                    throw new IllegalArgumentException();
                } else if (mod == 1) {
                    return new ModArithmetic1();
                } else if (mod == 2) {
                    return new ModArithmetic2();
                } else if (mod == 998244353) {
                    return new ModArithmetic998244353();
                } else if (mod == 1000000007) {
                    return new ModArithmetic1000000007();
                } else if ((mod & 1) == 1) {
                    return new ModArithmeticMontgomery(mod);
                } else {
                    return new ModArithmeticBarrett(mod);
                }
            }

            private static final class ModArithmetic1 extends ModArithmetic {
                int mod() {return 1;}
                int remainder(long value) {return 0;}
                int add(int a, int b) {return 0;}
                int sub(int a, int b) {return 0;}
                int mul(int a, int b) {return 0;}
                int pow(int a, long b) {return 0;}
            }
            private static final class ModArithmetic2 extends ModArithmetic {
                int mod() {return 2;}
                int remainder(long value) {return (int) (value & 1);}
                int add(int a, int b) {return a ^ b;}
                int sub(int a, int b) {return a ^ b;}
                int mul(int a, int b) {return a & b;}
            }
            private static final class ModArithmetic998244353 extends ModArithmetic {
                private final int mod = 998244353;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmetic1000000007 extends ModArithmetic {
                private final int mod = 1000000007;
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int res = a + b;
                    return res >= mod ? res - mod : res;
                }
                int sub(int a, int b) {
                    int res = a - b;
                    return res < 0 ? res + mod : res;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
            private static final class ModArithmeticMontgomery extends ModArithmeticDynamic {
                private final long negInv;
                private final long r2;

                private ModArithmeticMontgomery(int mod) {
                    super(mod);
                    long inv = 0;
                    long s = 1, t = 0;
                    for (int i = 0; i < 32; i++) {
                        if ((t & 1) == 0) {
                            t += mod;
                            inv += s;
                        }
                        t >>= 1;
                        s <<= 1;
                    }
                    long r = (1l << 32) % mod;
                    this.negInv = inv;
                    this.r2 = (r * r) % mod;
                }
                private int generate(long x) {
                    return reduce(x * r2);
                }
                private int reduce(long x) {
                    x = (x + ((x * negInv) & 0xffff_ffffl) * mod) >>> 32;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return generate((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
                @Override
                int inv(int a) {
                    return super.inv(reduce(a));
                }
                @Override
                int pow(int a, long b) {
                    return generate(super.pow(a, b));
                }
            }
            private static final class ModArithmeticBarrett extends ModArithmeticDynamic {
                private static final long mask = 0xffff_ffffl;
                private final long mh;
                private final long ml;
                private ModArithmeticBarrett(int mod) {
                    super(mod);
                    /**
                     * m = floor(2^64/mod)
                     * 2^64 = p*mod + q, 2^32 = a*mod + b
                     * => (a*mod + b)^2 = p*mod + q
                     * => p = mod*a^2 + 2ab + floor(b^2/mod)
                     */
                    long a = (1l << 32) / mod;
                    long b = (1l << 32) % mod;
                    long m = a * a * mod + 2 * a * b + (b * b) / mod;
                    mh = m >>> 32;
                    ml = m & mask;
                }
                private int reduce(long x) {
                    long z = (x & mask) * ml;
                    z = (x & mask) * mh + (x >>> 32) * ml + (z >>> 32);
                    z = (x >>> 32) * mh + (z >>> 32);
                    x -= z * mod;
                    return (int) (x < mod ? x : x - mod);
                }
                @Override
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                @Override
                int mul(int a, int b) {
                    return reduce((long) a * b);
                }
            }
            private static class ModArithmeticDynamic extends ModArithmetic {
                final int mod;
                ModArithmeticDynamic(int mod) {
                    this.mod = mod;
                }
                int mod() {
                    return mod;
                }
                int remainder(long value) {
                    return (int) ((value %= mod) < 0 ? value + mod : value);
                }
                int add(int a, int b) {
                    int sum = a + b;
                    return sum >= mod ? sum - mod : sum;
                }
                int sub(int a, int b) {
                    int sum = a - b;
                    return sum < 0 ? sum + mod : sum;
                }
                int mul(int a, int b) {
                    return (int) (((long) a * b) % mod);
                }
            }
        }
    }
}
",1441383191
samjack,samjack,243,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time + 1, moveTime[nx][ny] + 1)
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
        
        return -1",1441292166
samjack,samjack,243,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dir = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up
        
        pq = [(0, 0, 0)]
        vis = [[float('inf')] * m for _ in range(n)]
        vis[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in dir:
                nx, ny = x + dx, y + dy

                time += ((nx + ny + 1) % 2 + 1)
                if 0 <= nx < n and 0 <= ny < m:
                    nt = max(time, moveTime[nx][ny] + ((nx + ny + 1) % 2 + 1))
                    
                    if nt < vis[nx][ny]:
                        vis[nx][ny] = nt
                        heapq.heappush(pq, (nt, nx, ny))
                time -= ((nx + ny + 1) % 2 + 1)
        
        return -1
",1441307140
samjack,samjack,243,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum, odd_sum = 0, 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum
",1441281017
samjack,samjack,243,3637,cpp,"#include <bits/stdc++.h>
#define vi vector<int>
#define vb vector<bool>
#define vl vector<long long>
#define vii vector<vector<int>>
#define vll vector<vector<long long>>
#define pi pair<int, int>
#define pl pair<ll, ll>
#define vpi vector<pair<int, int>>
#define vpl vector<pair<ll, ll>>
#define a first 
#define b second
#define pb push_back
#define hset unordered_set
#define hmap unordered_map
#define vm vector<mi>
#define vmm vector<vector<mi>>
using namespace std;
const int MOD = 1e9+7;
using ll = long long;
using big = __int128_t;
using ld = long double;
int uMin(int& a, int b){return a = min(a,b);}
int uMax(int& a, int b){return a = max(a,b);}
struct mi {
  ll v;
  explicit operator int() const { return v; }
  mi() { v = 0; }
  mi(ll _v) : v(_v % MOD) { v += (v < 0) * MOD; }
  bool operator<(const mi& other) const {
    return v < other.v;
  }
  friend std::ostream& operator<<(std::ostream& os, const mi& m) {
      os << m.v;
      return os;
  }
};
mi &operator+=(mi &a, mi b) {
  if ((a.v += b.v) >= MOD) a.v -= MOD;
  return a;
}
mi &operator-=(mi &a, mi b) {
  if ((a.v -= b.v) < 0) a.v += MOD;
  return a;
}
mi operator+(mi a, mi b) { return a += b; }
mi operator-(mi a, mi b) { return a -= b; }
mi operator*(mi a, mi b) { return mi(a.v * b.v); }
mi &operator*=(mi &a, mi b) { return a = a * b; }
mi pow(mi a, ll p) {
  assert(p >= 0);
  return p == 0 ? 1 : pow(a * a, p / 2) * (p & 1 ? a : 1);
}
mi inv(mi a) {
  assert(a.v != 0);
  return pow(a, MOD - 2);
}
mi operator/(mi a, mi b) { return a * inv(b); }
bool operator==(mi a, mi b) {return a.v == b.v;}
template <class T>
class Matrix {
private:
    vector<std::vector<T>> data;
    size_t size;
public:
    Matrix(size_t n, T v = T()) : size(n), data(n, std::vector<T>(n, v)) {}
    Matrix(const Matrix<T>& other) : size(other.size), data(other.data) {}
    T& operator()(size_t i, size_t j) { return data[i][j]; }
    const T& operator()(size_t i, size_t j) const { return data[i][j]; }
    Matrix<T> operator+(const Matrix<T>& other) const {
        Matrix<T> result(size);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result(i, j) = data[i][j] + other(i, j);
        return result;
    }
    Matrix<T> operator*(const Matrix<T>& other) const {
        Matrix<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                for (size_t k = 0; k < size; ++k)
                    result(i, k) += data[i][j] * other(j, k);
        return result;
    }
    std::vector<T> operator*(const std::vector<T>& vec) const {
        std::vector<T> result(size, 0);
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                result[j] += data[i][j] * vec[i];
        return result;
    }
    Matrix<T> pow(ll e) const {
        Matrix<T> result = identity(size);
        Matrix<T> base = *this;
        while(e) {
            if(e&1) result = result * base;
            base = base * base;
            e>>=1;
        }
        return result;
    }
    bool operator==(const Matrix<T>& other) const {
        for (size_t i = 0; i < size; ++i)
            for (size_t j = 0; j < size; ++j)
                if (data[i][j] != other(i, j))
                    return false;
        return true;
    }
    static Matrix<T> identity(size_t n) {
        Matrix<T> id(n, 0);
        for (size_t i = 0; i < n; ++i)
            id(i, i) = 1;
        return id;
    }
    friend std::ostream& operator<<(std::ostream& os, const Matrix<T>& matrix) {
        os << ""[\n"";
        for (const auto& row : matrix.data) {
            os << ""\t["";
            for(int i = 0; i<row.size(); i++)
                os << row[i] << (i==row.size()-1?""]\n"":"", "");
        }
        os << ""]\n"";
        return os;
    }
};
template <class T> class BIT {
    int N; vector<T> data;
    bool c, queried;
    public:
    BIT(int _N, bool constant) : c(constant) {
        N = _N+1;
        data.resize(N);
        if(constant) queried = 0;
    }
    void add(int p, T x) { if(c){assert(!queried); data[p]+=x;}else for (p++;p<=N;p+=p&-p) data[p-1]+=x; }
    T sum(int l, int r) { return sum(r)-(l==0?0:sum(l-1)); }
    T sum(int r) { 
        if(c){
            if(!queried){
                queried = 1;
                partial_sum(data.begin(),data.end(),data.begin());
            }
            return data[r];
        }
        T s = 0; r++; for(;r;r-=r&-r)s+=data[r-1]; return s; }
    int lower_bound(T sum) {
        assert(!c);
        if (sum <= 0) return -1;
        int pos = 0;
        for (int pw = 1<<25; pw; pw >>= 1) {
            int npos = pos+pw;
            if (npos <= N && data[npos-1] < sum)
                pos = npos, sum -= data[pos-1];
        }
        return pos;
    }
};
template <class T> class RURQ {
    BIT<T> bit1, bit2;
    int sz;
    RURQ(int size) : sz(size), bit1(size), bit2(size) {}
    void add(int start, int end, T value) {
        bit1.add(start, value);
        bit2.add(start, value*(start - 1));
        if(end != sz-1){
            bit1.add(end+1, -value);
            bit2.add(end+1, -value*end);
        }
    }
    T pref(int index) {
        if(index==-1) return 0;
        return (bit1.sum(index))*index-bit2.sum(index);
    }
    T sum(int start, int end) {
        return pref(end)-pref(start-1);
    }
};
struct Line {
    long double m,b;
    Line(long double slope, long double yIntercept) : m(slope), b(yIntercept) {}
    long double getY(long double x) const {
        return m * x + b;
    }
};

struct LineContainer {
    std::vector<Line> lines;
    bool isAbove(const Line& l1, const Line& l2, const Line& l3) const {
        return (l3.b - l1.b) * (l1.m - l2.m) > (l2.b - l1.b) * (l1.m - l3.m);
    }
    void add(long double slope, long double yIntercept) {
        Line newLine(slope, yIntercept);
        while (lines.size() >= 2 && !isAbove(lines[lines.size() - 2], 
                                    lines[lines.size() - 1], newLine))
            lines.pop_back();
        lines.push_back(newLine);
    }
    long double queryMax(long double x) const {
        if (lines.empty())
            return -LLONG_MAX;
        int left = 0, right = lines.size() - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (lines[mid].getY(x) < lines[mid + 1].getY(x))
                left = mid + 1;
            else right = mid;
        }
        return lines[left].getY(x);
    }
};
vl euclid(ll a, ll b) {
    vl x = {1, 0, a};
    vl y = {0, 1, b};
    while(y[2]){
        ll k = x[2] / y[2];
        x[0]-=k*y[0];
        x[1]-=k*y[1];
        x[2]-=k*y[2];
        swap(x, y);
    }
    return x;  // x[0] * a + x[1] * b = x[2], x[2] = gcd(a, b)
}
pl modSolver(vpl& mods){
    pl ans = {mods[0].a,mods[0].b};
    for(int i = 1; i<mods.size(); i++){
        vl g = euclid(ans.b, mods[i].b);
        if((mods[i].a-ans.a)%g[2]) return {-1,-1};
        ans.a+=(mods[i].a-ans.a)/g[2]*ans.b*g[0];
        ans.b = ans.b/g[2]*mods[i].b;
        ans.a%=ans.b;
        ans.a+=ans.b;
        ans.a%=ans.b;
    }
    return ans;
}
int sq(ll n){
    ll a = 0;
    for(int i = 31; i>=0; i--){
        ll x = 1<<i|a;
        if(x*x <= n) a = x;
    }
    return a;
}
struct LZST {
    ll n;
    vector<pair<vl,bool>> nodes; // [[val,min,max,add],isSet]
    vi left,right;
    private:
        void set(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0] = num*(r-l+1);
            g[1] = g[2] = g[3] = num;
            nodes[i].b = 1;
        }
        void add(ll num, int i, ll l, ll r){
            vl& g = nodes[i].a;
            g[0]+=num*(r-l+1);
            g[1]+=num;
            g[2]+=num;
            g[3]+=num;
        }
        void prop(int i, ll l, ll r){
            ll m = l+((r-l)>>1);
            if(left[i] == -1){
                left[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(right[i] == -1){
                right[i] = nodes.size();
                nodes.pb({vl(4),0});
                left.pb(-1);
                right.pb(-1);
            }
            if(nodes[i].b){
                nodes[i].b = 0;
                if(l != r){
                    ll a = nodes[i].a[3];
                    set(a,left[i],l,m);
                    set(a,right[i],m+1,r);
                }
            }else if(nodes[i].a[3]){
                if(l != r){
                    ll a = nodes[i].a[3];
                    add(a,left[i],l,m);
                    add(a,right[i],m+1,r);
                }
            }
            nodes[i].a[3] = 0;
        }
        void upd(int i){
            vl& g = nodes[i].a, l = nodes[left[i]].a, r = nodes[right[i]].a;
            g[0] = l[0]+r[0];
            g[1] = l[1]<r[1]?l[1]:r[1];
            g[2] = l[2]>r[2]?l[2]:r[2];
        }
        void set(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                set(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) set(s,e,num,left[i],l,m);
            else if(s > m) set(s,e,num,right[i],m+1,r);
            else{
                set(s,m,num,left[i],l,m);
                set(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        void add(ll s, ll e, ll num, int i, ll l, ll r){
            if(l == s && r == e){
                add(num,i,l,r);
                return;
            }
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) add(s,e,num,left[i],l,m);
            else if(s > m) add(s,e,num,right[i],m+1,r);
            else{
                add(s,m,num,left[i],l,m);
                add(m+1,e,num,right[i],m+1,r);
            }
            upd(i);
        }
        ll sum(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[0];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return sum(s,e,left[i],l,m);
            if(s > m) return sum(s,e,right[i],m+1,r);
            return sum(s,m,left[i],l,m)+sum(m+1,e,right[i],m+1,r);
        }
        ll min(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[1];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return min(s,e,left[i],l,m);
            if(s > m) return min(s,e,right[i],m+1,r);
            ll a = min(s,m,left[i],l,m), b = min(m+1,e,right[i],m+1,r);
            return a<b?a:b;
        }
        ll max(ll s, ll e, int i, ll l, ll r){
            if(l == s && r == e) return nodes[i].a[2];
            prop(i,l,r);
            ll m = l+((r-l)>>1);
            if(e <= m) return max(s,e,left[i],l,m);
            if(s > m) return max(s,e,right[i],m+1,r);
            ll a = max(s,m,left[i],l,m), b = max(m+1,e,right[i],m+1,r);
            return a>b?a:b;
        }
    public:
        LZST(ll N){
            n = N;
            nodes.pb({vl(4),0});
            left.pb(-1);
            right.pb(-1);
        }
        void set(ll s, ll e, ll num){
            set(s,e,num,0,0,n-1);
        }
        void add(ll s, ll e, ll num){
            add(s,e,num,0,0,n-1);
        }
        ll sum(ll s, ll e){
            return sum(s,e,0,0,n-1);
        }
        ll min(ll s, ll e){
            return min(s,e,0,0,n-1);
        }
        ll max(ll s, ll e){
            return max(s,e,0,0,n-1);
        }
        ll get(ll s){
            return sum(s,s,0,0,n-1);
        }
        void add(ll s, ll num){
            add(s,s,num,0,0,n-1);
        }
        void set(ll s, ll num){
            set(s,s,num,0,0,n-1);
        }
        friend std::ostream& operator<<(std::ostream& os, LZST& m) {
            os << ""["";
            for(int i = 0; i<m.n; i++) os << m.get(i) << (i==m.n-1?""]"":"", "");
            return os;
        }
};
int dGet(int a, vi& d){return d[a]<0?a:(d[a]=dGet(d[a],d));}
bool unite(int a, int b, vi& d){
    a = dGet(a,d), b = dGet(b,d);
    if(a == b) return 0;
    if(d[a]>d[b]) swap(a,b);
    d[a]+=d[b];
    d[b] = a;
    return 1;
}
int lg(int n){
    int i = 0;
    for(n>>=1; n; n>>=1) i++;
    return i;
}
vector<pair<vm,vm>> genSeeds(int cnt){
    auto seed = chrono::high_resolution_clock::now().time_since_epoch().count();
    mt19937 rng(static_cast<unsigned int>(seed));
    vector<pair<vm,vm>> ans(cnt,{vm(2),vm(2)});
    for(int i = 0; i<cnt; i++){
        ans[i].a[0]=ans[i].b[0]=1;
        ans[i].a[1] = uniform_int_distribution<int>(1,MOD-1)(rng);
        ans[i].b[1] = 1/ans[i].a[1];
    }
    return ans;
}
struct Hash {
    vector<pair<vm,vm>>& h;
    string s;
    vector<pair<BIT<mi>,BIT<mi>>> v;
    void resizeHashes(int n){
        while(h[0].a.size() < n){
            int sz = h[0].a.size();
            for(int i = 0; i<h.size(); i++){
                h[i].a.pb(h[i].a[sz-1]*h[i].a[1]);
                h[i].b.pb(h[i].b[sz-1]*h[i].b[1]);
            }
        }
    }
    Hash(string& str, vector<pair<vm,vm>>& seeds, bool constant=1) : h(seeds),s(str){
        resizeHashes(str.size());
        v.reserve(h.size());
        for(int i = 0; i<h.size(); i++) v.emplace_back(BIT<mi>(s.size(),constant),BIT<mi>(s.size(),constant));
        for(int i = 0; i<s.size(); i++){
            for(int j = 0; j<h.size(); j++){
                v[j].a.add(i,(s[i]+1)*h[j].a[i]);
                v[j].b.add(i,(s[i]+1)*h[j].b[i]);
            }
        }
    }
    void rep(int ind, char c){
        for(int i = 0; i<h.size(); i++){
            v[i].a.add(ind,(c-s[ind])*h[i].a[ind]);
            v[i].b.add(ind,(c-s[ind])*h[i].b[ind]);
        }
        s[ind] = c;
    }
    pair<vm,int> get(int a, int b){
        bool rev = a>b;
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = v[i].b.sum(b,a)*h[i].a[a];
            else ans[i] = v[i].a.sum(a,b)*h[i].b[a];
        return {ans,abs(a-b)+1};
    }
    pair<vm,int> comb(pair<vm,int>& left, pair<vm,int>& right, bool rev=0){
        resizeHashes(rev?right.b:left.b);
        vm ans(h.size());
        for(int i = 0; i<h.size(); i++)
            if(rev) ans[i] = left.a[i]*h[i].a[right.b]+right.a[i];
            else ans[i] = left.a[i]+right.a[i]*h[i].a[left.b];
        return {ans,left.b+right.b};
    }
};
struct PairHash {
    size_t operator()(const std::pair<std::vector<mi>, int>& p) const {
        return p.a[0].v;
    }
};
class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> cnt(10);
        for(char c: num) cnt[c-'0']++;
        vector<mi> fac(n+1);
        fac[0] = 1;
        for(int i = 1; i<=n; i++) fac[i] = fac[i-1]*i;
        vector<mi> facInv(n+1);
        for(int i = 0; i<=n; i++) facInv[i] = 1/fac[i];
        int sum = 0;
        for(char c: num) sum+=c-'0';
        if(sum&1) return 0;
        vector<vector<mi>> dp((sum>>1)+1,vector<mi>(num.size()/2+1));
        dp[0][0] = fac[n/2]*fac[(n+1)/2];
        for(int i = 0; i<10; i++)
            for(int j = dp.size()-1; j>=0; j--)
                for(int k = dp[j].size()-1; k>=0; k--)
                    for(int l = 0; l<=min(i?j/i:INT_MAX,min(cnt[i],k)); l++)
                        if(l == 0) dp[j][k] = dp[j][k]/fac[cnt[i]];
                        else dp[j][k]+=dp[j-l*i][k-l]*facInv[l]*facInv[cnt[i]-l];
        return dp[dp.size()-1][dp[0].size()-1].v;
    }
};",1441352749
James_067,James_067,245,3627,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 1 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441304201
James_067,James_067,245,3628,cpp,"#define tiiii tuple<int,int,int,int>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) 
    {
        int n = a.size(), m = a[0].size();
        
        vector<vector<int>> b(n, vector<int>(m, numeric_limits<int>::max()));
        
        priority_queue<tiiii, vector<tiiii>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        
        b[0][0] = 0;
        vector<pair<int, int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!pq.empty()) 
        {
            auto [t, x, y, s] = pq.top();
            pq.pop();

            if (x == n - 1 && y == m - 1) { return t; }

            for (auto [dx, dy] : dir) 
            {
                int nx = x + dx , ny = y + dy;

                if (nx >= 0 && nx < n && ny >= 0 && ny < m) 
                {
                    int next_t = max(t, a[nx][ny]) + s;
                    int next_s = (s == 1) ? 2 : 1;

                    if (next_t < b[nx][ny]) 
                    {
                        b[nx][ny] = next_t;
                        pq.emplace(next_t, nx, ny, next_s);
                    }
                }
            }
        }

        return -1;   
    }
};",1441303283
James_067,James_067,245,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) 
    {
        int sum1 = 0 , sum2 = 0;
        for( int i = 0; i < s.size(); i++ )
        {
             if(i&1) sum1 += ( s[i] - '0' );
            else sum2 += ( s[i] - '0' );
        }
        return sum1 == sum2;
    }
};",1441281735
James_067,James_067,245,3637,cpp,"
#define MOD 1000000007
#define ll long long

ll mod(ll a, ll m = MOD) { return (a % m + m) % m; }

template <class T>
class Math 
{
public:
    vector<T> fact, invfact;
    Math() {}
    Math(int n) 
    {
        fact.resize(n + 1);
        invfact.resize(n + 1);

        fact[0] = invfact[0] = 1;
        for (int i = 1; i <= n; i++) 
        {
            fact[i] = mod(i * fact[i - 1]);
            invfact[i] = modinv(fact[i]);
        }
    }
    T modinv(T x, T m = MOD) { return expo(x, m - 2, m); }
    T expo(T base, T exp, T m = MOD) 
    {
        T res = 1;
        while (exp) 
        {
            if (exp & 1) res = mod(res * base, m);
            base = mod(base * base, m);
            exp >>= 1;
        }
        return res;
    }
    T choose(T n, T k) 
    {
        if (k < 0 || k > n || n < 0) return 0;
        T ans = fact[n];
        ans = mod(ans * invfact[n - k]);
        ans = mod(ans * invfact[k]);
        return ans;
    }
};

class Solution {
public:
    int countBalancedPermutations(string s) 
    {
        int n = s.size(), tot_d_sum = 0;
        int n1 = (n + 1) / 2 , n2 = n - n1;
        
        Math<ll> M(s.size());
        
        vector<int> freq(10);
        for (auto& d : s) 
        {
            freq[d - '0']++;
            tot_d_sum += (d - '0');
        }
        
        if (tot_d_sum % 2 != 0) return 0;
        
        int target_sum = tot_d_sum / 2;
        
        int dp[11][1001][41][41];
        memset(dp, -1, sizeof(dp));
        
        auto f = [&](auto&& self, int i, int j, int k, int l) -> ll
        {
            if (k > n1 || j > target_sum || l > n2 ) return 0;
            if (i == 10) return (j == target_sum && k == n1) ? 1 : 0;
            if (dp[i][j][k][l] != -1) return dp[i][j][k][l];
            
            ll result = 0;
            for (int c = 0; c <= freq[i]; ++c) 
            {
                if (c <= n1 - k && j + c * i <= target_sum && freq[i] - c <= n2 - l) 
                {
                    ll ways_to_choose_c = 1;
                    ll ways_to_fill_remaining = mod(M.choose(n1 - k, c)* M.choose(n2 - l , freq[i] - c));
                    result = (result + mod(mod(ways_to_choose_c * ways_to_fill_remaining) * self(self, i + 1, j + c * i, k + c, l + (freq[i] - c)))) % MOD;
                }
            }
            
            return dp[i][j][k][l] = result;
        };
        
        return f(f, 0, 0, 0, 0);
    }
};
",1441390801
xymabinogi,xymabinogi,246,3627,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = 1;
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441303362
xymabinogi,xymabinogi,246,3628,cpp,"using pi = array<int,3>;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<int>> d(n, vector<int>(m, INT_MAX));
        vector<vector<int>> visited(n, vector<int>(m, 0));
        d[0][0] = 0;
        
        priority_queue<pi, vector<pi>, greater<pi>> pq;
        pq.push({0, 0, 0});
        
        vector<int> dir{0, -1, 0, 1, 0};
        while(!pq.empty()){
            auto [dd, i, j] = pq.top(); pq.pop();
            //cout << dd <<"" ""<< i <<"" ""<< j << ""\n"";
            if (i == n - 1 and j == m - 1) return dd;
            
            if (visited[i][j]) continue;
            visited[i][j] = 1;
            for (int k = 0; k < 4; k++){
                int ni = i + dir[k];
                int nj = j + dir[k + 1];
                if (ni < 0 || nj < 0 || ni >= n || nj >= m) continue;
                if (visited[ni][nj]) continue;
                int updated = -1;
                int added = ((ni + nj) % 2 == 0 ? 2 : 1);
                if (dd >= grid[ni][nj]) updated = dd + added;
                else {
                    updated = grid[ni][nj] + added;
                }
                if (updated < d[ni][nj]){
                    d[ni][nj] = updated;
                    pq.push({updated, ni, nj});
                }
                
            }
        }
        return -1;
        
    }
};",1441302979
xymabinogi,xymabinogi,246,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int even = 0, odd = 0;
        for (int i = 0; i < n; i++){
            int v = num[i] - '0';
            if (i % 2) even += v;
            else odd += v;
        }
        return even == odd;
    }
};",1441281584
xymabinogi,xymabinogi,246,3637,cpp,"using i64 = long long;
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}
 
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % P)} {}
    
    constexpr int norm(int x) const {
        if (x < 0) {
            x += P;
        }
        if (x >= P) {
            x -= P;
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(P - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, P - 2);
    }
    constexpr MInt &operator*=(MInt rhs) {
        x = 1LL * x * rhs.x % P;
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1E9 + 7;
using Z = MInt<P>;
 
struct Comb {
    int n;
    std::vector<Z> _fac;
    std::vector<Z> _invfac;
    std::vector<Z> _inv;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        vector<int> cnt(10, 0);
        int tot = 0;
        for (auto ch : num){
            cnt[ch - '0']+= 1;
            tot += (ch - '0');
        }
        if (tot % 2) return 0;
        tot /= 2;
        
        Z res = 0;
        int n_first = n / 2 + n % 2;
        int n_second = n / 2;
       
        
        vector<vector<Z>> dp(n_first + 1, vector<Z>(tot + 1));
        dp[0][0] = Z(1);
        
        
        
        for (int i = 0; i < 10; i++) if (cnt[i]){
            for (int k = n_first; k >= 0; k--){
                for (int l = tot; l >= 0; l--){
                    if (!dp[k][l].val()) continue;
                    for (int j = 1; j <= cnt[i]; j++){
                        if (k + j > n_first) continue;
                        if (l + j * i <= tot){
                            dp[k + j][l + j * i] += dp[k][l] * comb.binom(cnt[i], j);
                        }
                    }
                }
            }
        }
        Z multi = comb.fac(n_first) * comb.fac(n_second);
        for (int i = 0; i < 10; i++){
            multi *= comb.invfac(cnt[i]);
        }
        
        dp[n_first][tot] *= multi;
        return  dp[n_first][tot].val();
        
        
        
        
        
    }
};",1441374001
luck,papaya,247,3627,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited ; 
        priority_queue< tuple<int64, int64 >> q ; 
        
        visited.assign( n , false ) ;  
        dis.assign( n , INF ); 

        dis[ src ] = 0 ; //start_time[ src ] ; 
        q.emplace( -dis[ src ] ,  src ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }
            if( visited[ u ] ) {
                continue ; 
            }
            visited[ u ] = true ; 
            for( auto [ v , w ] : g[u] ) {
                if( visited[v] ) {
                    continue ; 
                }
                int64 DD  = dis[u] + w ; 
                DD = max( DD , start_time[v] + 1 ) ; 

                if( dis[v] >  DD ) {
                    
                    dis[v] = DD ;
                    q.emplace( -dis[v] , v ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int ma22in( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 } ,  { 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    a = { { 56 , 93 } , { 3 , 38 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441312773
luck,papaya,247,3628,cpp,"#include <bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 
const int64 INF = 1e18 ; 

class DijkStra { 
private:
    vector< vector< pair<int,int64> > > g ; 
    int n  ; 
public:
    vector<int64> dis[2] ; 
    vector<int64> start_time ; 

public:
    void init( int tn ) {
        n = tn ; 
        g.assign( n , {} ) ; 
        start_time.assign( n , 0 ) ; 
    }
    inline void add_edge( int64 u , int64 v , int64 w ) {
        g[u].emplace_back( v , w ) ; 
    }
    
    int64 dijkstra( int src , int dst  ){

        vector< bool > visited[2]; 
        priority_queue< tuple<int64, int64 , int  >> q ; 
        
        visited[0].assign( n , false ) ;  
        visited[1] = visited[0] ; 

        dis[0].assign( n , INF ); 
        dis[1].assign( n , INF ) ; 

        dis[1][ src ] = 0 ; //start_time[ src ] ; 
        q.emplace(  0  ,  src , 1 ) ; 

        while( q.size() > 0 ) {
            auto p = q.top() ; 
            q.pop() ; 
            auto [ now_acc_cost , u , is_odd ] = p ; 
            now_acc_cost = -now_acc_cost ; 

            int W = 2 ; 
            if( is_odd ) {
                W = 1 ; 
            }

            // cout << ""u: "" << u << "" "" << now_acc_cost << ""\n"" ; 

            if( u == dst ) {
                return now_acc_cost ; 
            }

            if( visited[ is_odd ][ u ] ) {
                continue ; 
            }
            visited[ is_odd ][ u ] = true ; 

            int next_odd = 1 - is_odd ; 

            for( auto [ v , _ ] : g[u] ) {
                if( visited [ next_odd ] [ v ] ) {
                    continue ; 
                }
                int64 DD  = now_acc_cost + W ; 
                DD = max( DD , start_time[v] + W ) ; 

                if( dis[next_odd][v] >  DD ) {
                    
                    dis[next_odd][v] = DD ;
                    q.emplace( -dis[next_odd][v] , v , next_odd ) ; 
                }
            }
        }
        return INF ; 
    }
} ; 

vector< vector<int>> Dirs = { 
    { -1 , 0 } , { 1 , 0 } , 
    { 0 , 1 } , { 0 , -1 } 
} ; 

class Solution {
public:
    int n ; 
    int m ; 
    DijkStra t ; 
    vector<vector<int>> b ; 

    int get( int i , int j ) {
        return i * m + j ; 
    }
    bool is_in( int i , int j ) {
        return i >= 0 && i < n && j >= 0 && j < m ; 
    }
    int solve() { 

        t.init( n * m ) ; 

        for( int i = 0 ; i < n ; i++ ) { 

            for( int j = 0 ; j < m;  j++ ) { 
                int u = get( i , j ) ; 

                t.start_time[ u ] = b[i][j] ; 

                for( auto &p : Dirs ) {

                    int ni = i + p[0] ;
                    int nj = j + p[1] ;

                    if( !is_in( ni , nj )) {
                        continue; ; 
                    }
                    int v = get( ni , nj ) ; 
                    t.add_edge( u , v , 1 ) ; 
                }
            }
        }
        int src = get( 0 , 0 ) ; 
        int dst = get( n - 1 , m - 1 ) ; 

        // cout << "" over init\n"" ; 

        return t.dijkstra( src , dst ) ; 

    }
    int minTimeToReach(vector<vector<int>>& a) {
        n = a.size() ; 
        m = a[0].size() ; 
        b = a ;
        return solve() ;  
    }
};




int mai33n( )  { 
    Solution  t; 

    vector< vector<int> > a ;
    
    a = { { 0 , 4 } , { 4 , 4 }} ; 
    
    a = { { 0 , 0 , 0 , 0 } ,  { 0 , 0 , 0 , 0 } } ; 

    a = { { 0 , 1 } , { 1 , 2 }} ; 

    // a = { { 56 , 93 } , { 3 , 38 } } ; 


    a = { { 0,58 } , { 27,69 } } ; 

    auto ans = t.minTimeToReach (  a ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441324094
luck,papaya,247,3636,python3,"import math 
import copy
from typing import * 
from heapq import * 
from collections import * 

class Solution:
    def isBalanced(self, num: str) -> bool:
        
        
        a = [ int( x ) for x in num ] ; 
        n = len( a ) ; 
        
        
        s1 = 0 ; 
        s2 = 0 ;
        
        for i in range( n ) :
            if( i % 2 == 0 ) :
                s1 += a[i] ; 
            else  :
                s2 += a[i] ;
        
        # print( s1 , s2 ) ; 
        
        return s1 == s2 ; 
    
    
def main( ) : 

    t = Solution() ; 

    num = ""1234""
    
    # num = ""24123"" ; 
    
    ans = t.isBalanced ( num ) ; 

    print(  ans ); 

if __name__ == '__main__':
    main()",1441289883
luck,papaya,247,3637,cpp,"#include<bits/stdc++.h>
using namespace std ; 
using int64 = long long ; 

const int64 INF = 1e18 ; 
const int64 MOD = 1e9 + 7 ; 
const int BASE = 720 ; //int64 base = 720 ; 
const int UP =  BASE * 2 ; 

struct Comb { 
    vector< vector<int64> > C ;
    int n ; 

    void init( int tn ){
        n = tn ;
        C.assign( n + 1 , vector<int64>( n + 1 , 0 ) ) ;

        C[0][0] = 1 ; 
        for( int i = 1 ; i <= n ; i++ ) {
            C[i][0] = C[i][i] = 1 ; 
            for(int j = 1 ; j < i ; j++ ) {
                C[i][j] = C[i-1][j] + C[i-1][j-1] ;
                C[i][j] %= MOD ;
            }
        }
    }
} ; 

class Solution {
public:
    vector<int> a  , cnt ; 
    int n ; 
    int need_select ; 
    Comb comb ; 
    vector< int > aft_sum ; 

    int get( char c ) {
        return int( c ) - int( '0' ) ; 
    }
    vector< vector< vector<int64 >> > cache ; // f[2] ; 
    
    int64 dp( int choices , int other_choices  ,  int d  , int sum ) { 
        
        // cout << "" choices: "" << choices << "" D: "" << d << "" sum: "" << sum << ""\n"" ; 

        if( d >= 10 ) {
            return (choices == 0 && sum == BASE) ? 1 : 0 ; 
        }
        auto &ret = cache[ choices][d][sum] ;
        if( -1 != ret ) {
            return ret ;
        }
        ret = 0 ; 

        if( aft_sum[d] +  sum < BASE ) { // all select 
            return 0 ; 
        }
        if( aft_sum[d] - sum > BASE ) { // all not select 
            return 0 ; 
        }


        int all_s = cnt[d] * d ; 
        int all_cnt = cnt[d] ; 
        for( int select_cnt = 0 ; select_cnt <= cnt[d] && select_cnt <= choices ;  select_cnt++ ) { 
            
            if( other_choices - (all_cnt-select_cnt)  < 0 ) {
                continue ; 
            }
            
            int select_sum_s1 = d * select_cnt ; 
            int other_s2 = all_s - select_sum_s1 ; 

            int64 cnt = dp( choices - select_cnt ,  other_choices - (all_cnt-select_cnt) ,  d + 1 , sum + select_sum_s1 - other_s2 ) ; 
            int64 cnt2 = comb.C[ choices ][ select_cnt ] ; 
            int64 cnt3 = comb.C[ other_choices ] [ all_cnt - select_cnt ] ; 

            int64 t_ans = ( cnt * cnt2 ) % MOD ; 
            t_ans = ( t_ans * cnt3 ) % MOD ; 

            // if( select_cnt >= 1 ) { 
            //     // cout << "" choices: "" << choices << "" selec_cnt: "" << select_cnt << "" D: "" <<d << "" t_ans: "" << t_ans << ""\n"" ; 
            // }

            ret = ( ret + t_ans ) % MOD ; 
        }
        return ret ; 
    }

    void init( ) { 
        aft_sum.assign( 13 , 0 ) ; 
        for( int j = 9 ; j >= 0 ; j-- ) {
            int val = cnt[j] * j ; 
            aft_sum[j] = aft_sum[j+1] + val ; 
        }
    }
    int solve() { 
        init() ; 

        comb.init( n + 1 ) ; 

        cache.resize( n + 1 ) ; 
        for( int i = 0 ; i <= n ;i++ ) { 
            cache[i].assign( 10 , vector<int64> ( UP + 1 , -1  )) ; 
        }

        int sum = accumulate( a.begin()  ,a.end() , 0 ) ; 
        if( sum % 2 != 0 ) {
            return 0 ; 
        }
        auto ans = dp(  need_select  , n - need_select ,   0 , BASE  ) ; 
        return ans ; 
    }
    int countBalancedPermutations(string num) {

        n = num.size() ; 
        need_select = ( n + 1 ) / 2 ; 
        
        cnt.assign( 10 , 0 ) ; 
        a.assign( n + 1 , 0 ) ; 
        for( int i = 0 ; i < n ; i++ ) { 
            int d = get( num[i] ) ; 
            a[ i + 1 ] = d ; 
            cnt[d]++ ; 
        }
        return solve() ;  
    }
};




int ma33in( )  { 
    Solution  t; 

    string s = ""123"" ; 

    // s = ""112"" ; 

    // s = ""12345"" ; 

    // s = ""4567"" ; 

    auto ans = t.countBalancedPermutations ( s ) ; 
    cout << ans << ""\n"" ;


    return 0 ; 
}
",1441380293
Aylup,Aylup,248,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 3>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto [d, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + 1, moveTime[rd][cd] + 1), rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441314422
Aylup,Aylup,248,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        using aiii = std::array<int, 4>;
        int n = moveTime.size(), m = moveTime[0].size(), inf = 2e9;
        std::priority_queue<aiii, std::vector<aiii>, std::greater<aiii>> pq;
        std::vector<std::vector<int>> dist(n, std::vector<int>(m, inf));
        auto inBounds = [&](int r, int c) {
            return 0 <= r && r < n && 0 <= c && c < m;
        };
        std::vector<std::array<int, 2>> delta{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        pq.push({0, 0, 0, 0});
        while (!pq.empty()) {
            auto [d, b, r, c] = pq.top();
            pq.pop();
            if (d >= dist[r][c]) continue;
            dist[r][c] = d;
            for (auto [dr, dc] : delta) {
                int rd = r + dr, cd = c + dc;
                if (inBounds(rd, cd)) {
                    pq.push({std::max(d + b + 1, moveTime[rd][cd] + b + 1), b ^ 1, rd, cd});
                }
            }
        }
        return dist[n - 1][m - 1];
    }
};",1441316347
Aylup,Aylup,248,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i % 2) {
                ans += num[i] - '0';
            } else {
                ans -= num[i] - '0';
            }
        }
        return ans == 0;
    }
};",1441294643
Aylup,Aylup,248,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        mod = 10**9 + 7
        total = sum(map(int, num))
        if total % 2 != 0:
            return 0
        n = len(num)
        m = (n + 1) // 2
        m2 = n // 2
        fact = [1] * (n + 1)
        for i in range(1, n + 1):
            fact[i] = fact[i - 1] * i
            fact[i] %= mod
        target = total // 2
        count = Counter(map(int, num))
        pfx = [0] * 11
        for i in range(10):
            pfx[i] = pfx[i - 1] + count[i]
        @cache
        def dp(i, j, k):
            if k > target:
                return 0
            if i == 10:
                if j != m or k != target:
                    return 0
                return (fact[m] * fact[m2]) % mod
            ans = 0
            high = min(m, count[i])
            for z in range(0, high + 1):
                val = dp(i + 1, j + z, k + z * i)
                val *= pow(fact[z], -1, mod)
                val %= mod
                val *= pow(fact[count[i] - z], -1, mod)
                val %= mod
                
                ans += val
                ans %= mod
            return ans
        return dp(0, 0, 0)",1441381250
abhishek vaish,abhishekvaish,249,3627,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + 1, moveTime[nx][ny]+1):
                    dist[nx][ny] = max(dist[i][j] + 1, moveTime[nx][ny] + 1)
                    hpush(h, (dist[nx][ny], nx, ny) )
                
        # return 
                
        ",1441294943
abhishek vaish,abhishekvaish,249,3628,python3,"from heapq import heappush as hpush, heappop as hpop
inf = float('inf')
delta = [ (0,1), (0,-1), (-1,0), (1,0) ]

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n,m = len(moveTime),len(moveTime[0])
        dist = [ [inf]*m for i in range(n)  ]
        
        h = [ (0,0,0,1) ]
        dist[0][0] = 0
        
        while len(h) > 0:
            d,i,j,mv = hpop(h)
            if dist[i][j] != d : continue
            if i == n-1 and j == m-1: return d
            for dx,dy in delta:
                nx,ny = i+dx,j+dy
                if -1 < nx < n and -1 < ny < m and dist[nx][ny] >  max(dist[i][j] + mv, moveTime[nx][ny]+mv):
                    dist[nx][ny] = max(dist[i][j] + mv, moveTime[nx][ny] + mv)
                    hpush(h, (dist[nx][ny], nx, ny,  1 if mv == 2 else 2  ) )
                ",1441299436
abhishek vaish,abhishekvaish,249,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o = 0,0
        for i in range(len(num)):
            if i % 2 == 0:
                e += int(num[i])
            else:
                o += int(num[i])
        return e == o
            ",1441281220
abhishek vaish,abhishekvaish,249,3637,python3,"MOD = 10**9+7
fact = [1] * 81
ifact = [1] * 81
for i in range(1,81):
    fact[i] = (i * fact[i-1]) % MOD

ifact[80] = pow(fact[80],-1,MOD)
for i in range(79,-1, -1):
    ifact[i] = (ifact[i+1] * (i+1)) % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        s = sum(map(int,num))
        if s%2 == 1: return 0
        mx = [0]*10
        for x in num:
            mx[int(x)] += 1
        # print(""---""*n)
        def count_perm(count):
            # print(count)
            si = sum(count)
            p1, p2 = fact[si] , fact[n - si]
            for i in range(10):
                c1 = count[i]
                c2 = mx[i] - count[i]
                p1 = (p1 * ifact[c1]) % MOD
                p2 = (p2 * ifact[c2]) % MOD
                
            
            return (p1 * p2) % MOD
        
        @cache
        def DP(x, ele, target):
            if ele < 0 : return 0
            if target < 0 : return 0
            if x == 10 :
                if ele == 0 and target == 0:
                    return (fact[n//2] * fact[n-(n//2)]) % MOD
                return 0
            
            p = 0
            for i in range(mx[x]+1):
                c = DP(x+1,ele-i, target - (x*i))
                p += (c * ifact[i] * ifact[mx[x]-i]) % MOD
            return p % MOD
        
        return DP(0,n//2,s//2)
            
            
        
#         def dfs(x, count):
#             if x == 10:
#                 # print(count)
#                 sum_ = sum([ x*i for i,x in enumerate(count)])
#                 sum_i = sum(count)
#                 if n % 2 == 0 and sum_i != n // 2:
#                     return 0
#                 if n % 2 == 1 and sum_i != n // 2 :
#                     return 0
#                 if sum_ == s // 2 :
#                     return count_perm(count)
#                 return 0 
            
#             res = 0
#             for i in range(mx[x]+1):
#                 count[x] = i
#                 res = (res + dfs(x+1, count)) % MOD
#             count[x] = 0
#             return res
        
#         return dfs(0,[0]*10)

# 2
# 1
# 0
# 793764298
# 144920189
            
        ",1441382043
Zardinality,Zardinality,250,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<long long>> dist(n, vector<long long>(m, LLONG_MAX));
        dist[0][0] = 0;
        priority_queue<pair<long long, pair<int, int>>, 
                      vector<pair<long long, pair<int, int>>>,
                      greater<pair<long long, pair<int, int>>>> pq;
        
        pq.push({0, {0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + 1LL;
                    
                    if (wait_time < dist[new_row][new_col]) {
                        dist[new_row][new_col] = wait_time;
                        pq.push({wait_time, {new_row, new_col}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441326235
Zardinality,Zardinality,250,3628,cpp,"using ll = long long;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>>(m, vector<ll>(2, LLONG_MAX)));
        dist[0][0][0] = 0;
        priority_queue<pair<ll, array<int, 3>>, 
                      vector<pair<ll, array<int, 3>>>,
                      greater<pair<ll, array<int, 3>>>> pq;
        
        pq.push({0, {0, 0, 0}});
        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!pq.empty()) {
            auto [curr_time, pos] = pq.top();
            auto [row, col, step] = pos;
            pq.pop();
            
            if (curr_time > dist[row][col][step]) continue;
            
            for (const auto& [dx, dy] : directions) {
                int new_row = row + dx;
                int new_col = col + dy;
                
                if (new_row >= 0 && new_row < n && new_col >= 0 && new_col < m) {
                    long long wait_time = max(curr_time, (long long)moveTime[new_row][new_col]) + (step == 0?1LL:2LL);
                    int nstep = 1-step;
                    if (wait_time < dist[new_row][new_col][nstep]) {
                        dist[new_row][new_col][nstep] = wait_time;
                        pq.push({wait_time, {new_row, new_col, nstep}});
                    }
                }
            }
        }
        auto& pres = dist[n-1][m-1];
        return min(pres[0], pres[1]);
    }
};",1441339665
Zardinality,Zardinality,250,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ns = num.size();
        int en = 0;
        int on = 0;
        for(int i=0;i<ns;i++){
            if(i%2){
                en += (num[i]-'0');
            }
            else{
                on += (num[i]-'0');
            }
        }
        return en == on;
    }
};",1441287239
Zardinality,Zardinality,250,3637,cpp,"#define PRIME 1000000007
using ll = long long;
class Solution {
public:
    int countBalancedPermutations(string num) {
        int ns = num.size();
        vector<int> buf(ns, 0);
        int tsum = 0;
        for(int i=0;i<ns;i++){
            buf[i] = num[i]-'0';
            tsum += buf[i];
        }
        vector<int> freq(10, 0);
        for (char c : num) {
            freq[c - '0']++;
        }
        
        if(tsum%2) return 0;
        int target = tsum/2;
        int even_cnt = ns/2;
        vector<vector<ll>> dp(even_cnt+1, vector<ll>(target+1, 0));
        dp[0][0] = 1;
        for(int i=0;i<ns;i++){
            vector<vector<ll>> ndp = dp;
            int cdigit = buf[i];
            for(int j=0;j<even_cnt;j++){
                for(int k=0;k<=target;k++){
                    if(k+cdigit<=target){
                        // std::cout<<j+1<<"" ""<<k+cdigit<<"" ""<<dp.size()<<"" ""<<dp[0].size()<<endl;
                        ndp[j+1][k+cdigit] += dp[j][k];
                        ndp[j+1][k+cdigit] %= PRIME;
                    }
                }
            }
            dp = std::move(ndp);
        }
        int num_subsets = dp.back().back();
        auto factorial = [](int n){
            if(!n) return 1LL;
            ll res = n;
            while(--n){
                res *= n;
                res %= PRIME;
            }
            return res;
        };
                auto modPow = [&](ll base, ll exp) {
            ll result = 1;
            while (exp > 0) {
                if (exp & 1) result = (result * base) % PRIME;
                base = (base * base) % PRIME;
                exp >>= 1;
            }
            return result;
        };
        
        auto modInverse = [&](ll n) {
            return modPow(n, PRIME - 2);
        };
        // cout<<num_subsets<<"" ""<<factorial(even_cnt)<<endl;
        ll even_fact = factorial(even_cnt);
        ll odd_fact = factorial(ns-even_cnt);
        auto result = ((num_subsets * even_fact) % PRIME) * odd_fact % PRIME;
                
        for (int i = 0; i < 10; i++) {
            if (freq[i] > 1) {
                result = (result * modInverse(factorial(freq[i]))) % PRIME;
            }
        }
        return result;
    }
};",1441395191
minamego001,minamego001,252,3627,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[55][55];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({0, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({-max(cur,moveTime[nx][ny]) - 1 , {nx,ny}});
            }
        }
        return 0;
    }
};",1441294632
minamego001,minamego001,252,3628,cpp,"class Solution {
public:
    int dx[4] = {0,0,1,-1};
    int dy[4] = {1,-1,0,0};
    int n,m;
    int ans[760][760];
    bool isValid(int i , int j) {
        return i>=0 && j>=0 && i<n && j<m && ans[i][j] == -1;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<pair<int,int>,pair<int,int>>>q;
        n = moveTime.size();
        m = moveTime[0].size();
        memset(ans,-1,sizeof(ans));
        q.push({{0,0}, {0,0}});
        while(!q.empty()) {
            auto a = q.top();
            q.pop();
            int x = a.second.first;
            int y = a.second.second;
            int cur = -a.first.first;
            if(ans[x][y] != -1) continue;
            ans[x][y] = cur;
            if(x == n-1 && y == m-1) return cur;
            int add = -a.first.second;
            int nadd = -1;
            if(add == 1) nadd = -2;
            for(int i = 0 ; i<4 ; ++i) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                if(isValid(nx,ny)) q.push({{-max(cur,moveTime[nx][ny]) + nadd, nadd} , {nx,ny}});
            }
        }
        return 0;
    }
};",1441299481
minamego001,minamego001,252,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a = 0 , b = 0;
        for(int i = 0 ; i<num.size(); ++i) {
            if(i&1) a+= num[i]-'0';
            else b += num[i]-'0';
        }
        return a == b;
    }
};",1441281602
minamego001,minamego001,252,3637,cpp,"class Solution {
public:
    int cnt[10];
    const int mod = 1e9 + 7;
unsigned long long fac[88];
long long ncr[88][88];
unsigned long long power(unsigned long long x, 
                                  int y)
{
    unsigned long long res = 1; // Initialize result
 
    x = x % mod; // Update x if it is more than or
    // equal to p
 
    while (y > 0) 
    {
     
        // If y is odd, multiply x with result
        if (y & 1)
            res = (res * x) % mod;
 
        // y must be even now
        y = y >> 1; // y = y/2
        x = (x * x) % mod;
    }
    return res;
}
 
// Returns n^(-1) mod p
unsigned long long modInverse(unsigned long long n
                                            )
{
    return power(n, mod - 2);
}
 
// Returns nCr % p using Fermat's little
// theorem.
unsigned long long nCr(unsigned long long n,
                                 int r)
{
    // If n<r, then nCr should return 0
    if (n < r)
        return 0;
    // Base case
    if (r == 0)
        return 1;
 
    return (fac[n] * modInverse(fac[r]) % mod
            * modInverse(fac[n - r]) % mod)
           % mod;
}
    int dp[10][41][730];
    int ans = 0;
    int acc[11];
    long long solve(int i, int odd,int even, int sum) {
        if(sum == ans && odd == 0 && even == 0) return 1;
        if(sum > ans || odd < 0 || i == 10 || even < 0) return 0;

        int &ret = dp[i][odd][sum];
        if(~ret) return ret;
        ret = 0;
        for(int a = 0 ; a<= cnt[i] ; ++a) {
            long long x =  (ncr[odd][a] * solve(i+1,odd - a, even - (cnt[i] - a), sum + a * i))%mod;
            //cout<<i<< "" ""<<a<<"" ""<<sum<<"" ""<<x<<"" ""<<endl;
            x = (x * ncr[even][cnt[i]-a]) % mod;
            ret += x;
            ret%=mod;
        }
        return ret;
        
    }
    int countBalancedPermutations(string num) {
        int sum = 0;
        for(auto a : num) 
            {
                sum += a - '0';
                cnt[a-'0']++;
            }
        
        int n = num.size();
            fac[0] = 1;
    for (int i = 1; i <= n; i++)
        fac[i] = (fac[i - 1] * i) % mod;
    acc[0] = cnt[0];
    for(int i = 1 ; i<=9 ; ++i) acc[i] = cnt[i] + acc[i-1];
    for(int i = 0 ; i <=n ; ++i) 
        for(int j = 0 ; j<=i ; ++j) ncr[i][j] = nCr(i,j);
        int odd = (n+1)/2;
        int even = n/2;
        if(sum & 1) return 0;
        ans = sum/2;
        memset(dp,-1,sizeof(dp));
        return solve(0,odd,even,0);
    }
};",1441377894
derrick2001,derrick2001,253,3627,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>>> pq;
        pq.push({0,0,0});
        dd[0][0]= 0;        
        while(pq.size()) {
            auto[d, x, y] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_++;
                    if (t_ < dd[nx][ny]) {
                        pq.push({t_,nx,ny});
                        dd[nx][ny] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441337233
derrick2001,derrick2001,253,3628,cpp,"int dr[] = {1, -1, 0, 0};
int dc[] = {0, 0, 1, -1};
const int iinf = 1e9;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        int dd[n+5][m+5][2];
        memset(dd, 0x3f, sizeof(dd));
        priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, greater<tuple<int,int,int,int>>> pq;
        pq.push({0,0,0,0});
        dd[0][0][0] = 0;        
        while(pq.size()) {
            auto[d, x, y,p] = pq.top(); pq.pop();
            if (x == n-1 && y == m-1) {
                return d;
            }
            if (d > dd[x][y][p]) {
                continue;
            }
            for(int i=0;i<4;i++) {
                int nx = x + dr[i], ny = y +dc[i];
                if (nx>=0 && nx <n && ny>=0 && ny<m) {
                    int t_ = max(d, moveTime[nx][ny]);
                    t_ += (1 + (p!=0));
                    if (t_ < dd[nx][ny][p^1]) {
                        pq.push({t_,nx,ny,p^1});
                        dd[nx][ny][p^1] = t_;
                    }
                    
                }
            }
        }
        return -1;
    }
};",1441334453
derrick2001,derrick2001,253,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        e,o=0,0
        for i,x in enumerate(num):
            if i%2:
                o += int(x)
            else:
                e += int(x)
        return o==e
        ",1441305760
derrick2001,derrick2001,253,3637,cpp,"const int MOD = 1e9 + 7;
typedef long long ll;



ll power_mod(ll x, ll y, ll mod) {
    ll res = 1;
    x %= mod;
    while(y > 0){
        if(y & 1LL){
            res = res * x % mod;
        }
        x = x * x % mod;
        y >>= 1LL;
    }
    return res;
}


struct Factorials {
    vector<long long> fact;
    vector<long long> inv_fact;
    int max_n;

    Factorials(int n_max) : max_n(n_max), fact(n_max + 1, 1), inv_fact(n_max + 1, 1) {
        for(int i = 1; i <= max_n; ++i){
            fact[i] = fact[i-1] * i % MOD;
        }
        inv_fact[max_n] = power_mod(fact[max_n], MOD - 2, MOD);
        for(int i = max_n -1; i >=0; --i){
            inv_fact[i] = inv_fact[i+1] * (i+1) % MOD;
        }
    }


    ll comb(int n, int k){
        if(n < k || k < 0) return 0;
        return fact[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD;
    }

    ll factorial(int n){
        if(n < 0 || n > max_n) return 0;
        return fact[n];
    }
};

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.length();
        Factorials factorials(n);

        
        int freq[10] = {0};
        for(char ch : num){
            freq[ch - '0']++;
        }
    
        int total_sum = 0;
        for(int d =0; d <=9; ++d){
            total_sum += d * freq[d];
        }

        
        if(total_sum % 2 != 0){
            return 0;
        }

        int target_sum = total_sum / 2;
        int k = (n +1)/2; 

        vector<vector<int>> dp(k +1, vector<int>(target_sum +1, 0)); //sm at even
        dp[0][0] = 1;

        for(int d =0; d <=9; ++d){
            if(freq[d] ==0) continue;
            vector<vector<int>> temp(k +1, vector<int>(target_sum +1, 0));
            for(int c =0; c <=k; ++c){
                for(int s =0; s <=target_sum; ++s){
                    if(dp[c][s] ==0) continue;
                    for(int m =0; m <= min(freq[d], k - c); ++m){
                        if(s + d * m > target_sum) break;
                        // Number of ways to choose m digits of this digit
                        // which is C(freq[d], m)
                        ll combinations = factorials.comb(freq[d], m);
                        temp[c + m][s + d * m] = (temp[c + m][s + d * m] + dp[c][s]%MOD * combinations%MOD) % MOD;
                    }
                }
            }
            dp = temp;
        }
        
        int ways = dp[k][target_sum];


        if(ways ==0){
            return 0;
        }
        int fk = factorials.factorial(k);
        int fck = factorials.factorial(n -k);

        int denom =1;
        for(int d =0; d <=9; ++d){
            denom = denom * factorials.fact[freq[d]] % MOD;
        }

        long long numerator = 1LL* fk * fck % MOD;


        long long inv = power_mod(denom, MOD -2, MOD);
        long long ans = 1LL* ways * numerator % MOD;
        ans = ans%MOD * inv % MOD;

        return (int)ans;
    }
};",1441352897
Jiabei Zhu,zzjjbb,255,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 1, t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441316122
Jiabei Zhu,zzjjbb,255,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        dis = [[inf] * n for _ in range(m)]
        q = [(0, (0, 0))]
        moveTime[0][0] = -100
        while q:
            # print(q[0])
            t, (i, j) = heapq.heappop(q)
            
            if not ((0 <= i < m) and (0 <= j < n)):
                continue
            nd = max(moveTime[i][j] + 2 - ((i + j) & 1), t)
            # print(nd)
            if nd < dis[i][j]:
                dis[i][j] = nd
                nnd = nd + 1 + ((i + j) & 1)
                for di in [-1, 1]:
                    heapq.heappush(q, (nnd, (i + di, j)))
                for dj in [-1, 1]:
                    heapq.heappush(q, (nnd, (i, j + dj)))
            if t >= dis[-1][-1]:
                print(dis)
                return dis[-1][-1]
        ",1441315209
Jiabei Zhu,zzjjbb,255,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(map(int, num[::2])) == sum(map(int, num[1::2]))",1441281111
Jiabei Zhu,zzjjbb,255,3637,python3,"M = 1_000_000_007
fact = [1]
for i in range(1, 100):
    fact.append(fact[-1] * i % M)
ifact = [pow(i, -1, M) for i in fact]
 

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        num = list(map(int, num))
        goal = rgoal = sum(num)
        if goal % 2:
            return 0
        goal >>= 1
        c = Counter(num)
        c = [c[i] for i in range(10)]
        l = defaultdict(int)
        l[0, 0] = 1
        ctl = 0
        for di in range(10):
            nl = defaultdict(int)
            cdi = c[di]
            for (cs, cl), cnt in l.items():
                for i in range(cdi + 1):
                    ad = (cnt * fact[cl + i]) % M
                    ad = (ad * ifact[cl]) % M
                    ad = (ad * ifact[i]) % M
                    ad = (ad * fact[ctl + cdi - cl - i]) % M
                    ad = (ad * ifact[ctl - cl]) % M
                    ad = (ad * ifact[cdi - i]) % M
                    # print(cnt, ad)
                    nl[cs + di * i, cl + i] += ad
            l = nl
            ctl += cdi
        # print(nl)
        # print(l)
        ans = 0
        for (cs, cl), cnt in l.items():
            if cs == goal and cl == n // 2:
                ans = (ans + cnt) % M
        return ans
",1441396831
youknowwho99,youknowwho99,256,3627,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2]});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2]});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441330065
youknowwho99,youknowwho99,256,3628,cpp,"class Solution {
public:
    
    int minTimeToReach(vector<vector<int>>& vec) {
        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>q;
        q.push({0,0,0,0});
        int n=vec.size();
        int  m=vec[0].size();
        vector<vector<int>>vis(n,vector<int>(m));
        // vector<vector<int>>vis(n+1,vector<int>(m+1));
         vector<vector<int>>dis(n,vector<int>(m,INT_MAX));
        dis[0][0]=0;
        while(!q.empty()){
            vector<int>a=q.top();
            q.pop();
            vis[a[1]][a[2]]=1;
            // if(a[1]==n-1 && a[2]==m-1)break;
            // cout << a[0] <<"" "" << a[1] << "" "" << a[2] << endl;
            if( a[1]+1<n && !vis[a[1]+1][a[2]] ){
                int t;
                if(a[3]==0)
                 t=max(vec[a[1]+1][a[2]]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]+1][a[2]]+2,a[0]+2);
                if(dis[a[1]+1][a[2]]>t){
                dis[a[1]+1][a[2]]=min(dis[a[1]+1][a[2]],t);
                q.push({dis[a[1]+1][a[2]],a[1]+1,a[2],a[3]^1});
                }
            }
            if( a[2]+1<m && !vis[a[1]][a[2]+1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]+1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]+1]+2,a[0]+2);
                if(dis[a[1]][a[2]+1]>t){
                dis[a[1]][a[2]+1]=min(dis[a[1]][a[2]+1],t);
                q.push({dis[a[1]][a[2]+1],a[1],a[2]+1,a[3]^1});
                }
            }
            if(  a[1]-1>=0 && !vis[a[1]-1][a[2]] ){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]-1][a[2]]+1,a[0]+1);
                else
                    t=max(vec[a[1]-1][a[2]]+2,a[0]+2);
                if(dis[a[1]-1][a[2]]>t){
                dis[a[1]-1][a[2]]=min(dis[a[1]-1][a[2]],t);
                q.push({dis[a[1]-1][a[2]],a[1]-1,a[2],a[3]^1});
                }
            }
            if(a[2]-1>=0 && !vis[a[1]][a[2]-1]){
                int t;
                if(a[3]==0)
                t=max(vec[a[1]][a[2]-1]+1,a[0]+1);
                if(a[3]==1)
                    t=max(vec[a[1]][a[2]-1]+2,a[0]+2);
                if(dis[a[1]][a[2]-1]>t){
                dis[a[1]][a[2]-1]=min(dis[a[1]][a[2]-1],t);
                q.push({dis[a[1]][a[2]-1],a[1],a[2]-1,a[3]^1});
                }
            }
        }
        return dis[n-1][m-1];
    }
};",1441335847
youknowwho99,youknowwho99,256,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int e=0;
        int o=0;
        for(int i=0;i<s.length();i+=2){
            e+=s[i]-'0';
        }
        for(int i=1;i<s.length();i+=2){
            o+=s[i]-'0';
        }
        return o==e;
    }
};",1441281561
youknowwho99,youknowwho99,256,3637,cpp,"class Solution {
public:
    long long powerMod(long long base, long long exp, long long mod) {
        long long res = 1;
        base %= mod;
        while (exp > 0) {
            if (exp & 1) res = res * base % mod;
            base = base * base % mod;
            exp >>= 1;
        }
        return res;
    }
    int countBalancedPermutations(string num) {
        const int MOD = 1'000'000'007;
        int len = num.size();
        int evenCount = (len + 1) / 2; 
        int oddCount = len / 2; 

        int digitCount[10] = {0};
        for (char ch : num) {
            digitCount[ch - '0']++;
        }

        long long totalSum = 0;
        for (int d = 0; d < 10; d++) {
            totalSum += (long long)d * digitCount[d];
        }

        if (totalSum % 2 != 0) return 0; 
        long long targetSum = totalSum / 2;

        const int MAX_LEN = 80;
        vector<long long> factorial(MAX_LEN + 1, 1);
        for (int i = 1; i <= MAX_LEN; i++) {
            factorial[i] = factorial[i - 1] * i % MOD;
        }

        vector<long long> invFactorial(MAX_LEN + 1, 1);
        invFactorial[MAX_LEN] = powerMod(factorial[MAX_LEN], MOD - 2, MOD);
        for (int i = MAX_LEN - 1; i >= 0; i--) {
            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;
        }

        auto combination = [&](int n, int k) -> long long {
            if (k > n) return 0;
            return factorial[n] * invFactorial[k] % MOD * invFactorial[n - k] % MOD;
        };

        vector<vector<long long>> dp(evenCount + 1, vector<long long>(targetSum + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d < 10; d++) {
            if (digitCount[d] == 0) continue; 
            for (int t = evenCount; t >= 0; t--) {
                for (long long s = targetSum; s >= 0; s--) {
                    if (dp[t][s] == 0) continue; 
                    for (int k = 1; k <= digitCount[d] && t + k <= evenCount && s + (long long)d * k <= targetSum; k++) {
                        dp[t + k][s + (long long)d * k] = (dp[t + k][s + (long long)d * k] + dp[t][s] * combination(digitCount[d], k)) % MOD;
                    }
                }
            }
        }

        long long validPermutations = dp[evenCount][targetSum];

        long long productFactorials = 1;
        for (int d = 0; d < 10; d++) {
            productFactorials = productFactorials * factorial[digitCount[d]] % MOD;
        }

        long long result = validPermutations;
        result = result * factorial[evenCount] % MOD;
        result = result * factorial[oddCount] % MOD;

        long long invProduct = powerMod(productFactorials, MOD - 2, MOD);
        result = result * invProduct % MOD;

        return (int)result;
    }


};
",1441384835
Akash,Akash_0P,257,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 3>, vector<array<long long, 3>>, greater<array<long long, 3>>> pq;
            pq.push({0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + cur;
                            pq.push({dp[nr][nc], nr, nc});
                        }
                    }else if(moveTime[nr][nc] + 1 < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1;
                        pq.push({dp[nr][nc], nr, nc});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};",1441364556
Akash,Akash_0P,257,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        vector<int> dx = {0, 0, -1, 1};
        vector<int> dy = {1, -1, 0, 0};

        auto valid = [&](int i, int j) {
            return (i >= 0 && j >= 0 && i < n && j < m);
        };

        auto f = [&]() {

            vector<vector<long long>> dp(n, vector<long long> (m, 1e18));
            dp[0][0] = 0;

            priority_queue<array<long long, 4>, vector<array<long long, 4>>, greater<array<long long, 4>>> pq;
            pq.push({0, 0, 0, 0});

            while(!pq.empty()) {
                auto [cur, i, j, flag] = pq.top(); pq.pop();

                if(cur > dp[i][j]) continue;

                for(int k = 0; k < 4; k++) {
                    int nr = i + dx[k], nc = j + dy[k];
                    if(!valid(nr, nc)) continue;

                    if(cur >= moveTime[nr][nc]) {
                        if(1 + flag + cur < dp[nr][nc]) {
                            dp[nr][nc] = 1 + flag + cur;
                            pq.push({dp[nr][nc], nr, nc, !flag});
                        }
                    }else if(moveTime[nr][nc] + 1 + flag < dp[nr][nc]) {
                        dp[nr][nc] = moveTime[nr][nc] + 1 + flag;
                        pq.push({dp[nr][nc], nr, nc, !flag});
                    }
                }
            }

            return dp[n - 1][m - 1];

        };

        return f();
    }
};
",1441366468
Akash,Akash_0P,257,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();

        vector<int> v(2);

        for(int i = 0; i < n; i++) {
            v[i & 1] += num[i] - '0';
        }

        return v[0] == v[1];
    }
};",1441281902
Akash,Akash_0P,257,3637,cpp,"using ll = long long;

const int N = 2e5 + 5, M = 1e9 + 7;
ll fact[N], ifact[N];

ll add(ll a, ll b) {
  return (a + b) % M;
}

ll mul(ll a, ll b) {
  return (a * b) % M;
}

ll expo(ll a, ll b) {
  ll res = 1;
  while(b) {
    if(b & 1) res = mul(res, a);
    a = mul(a, a);
    b >>= 1;
  }
  return res;
}

void pre() {
  fact[0] = 1;
  for(ll i = 1; i < N; i++) fact[i] = mul(i, fact[i - 1]);
  ifact[N-1] = expo(fact[N-1], M-2);
  for(ll i = N-2; i >= 0; i--) ifact[i] = mul(i + 1, ifact[i + 1]);
}

ll nCr(ll n, ll r) {
  if(r > n) return 0;
  return mul(fact[n], mul(ifact[n - r], ifact[r]));
}

int flag = 0;

class Solution {
public:
    int countBalancedPermutations(string num) {
        if(!flag) pre();
            
        int n = num.size(), target = 0;

        vector<int> freq(10);
        for(auto &i: num) freq[i - '0']++, target += i - '0';

        if(target & 1) return 0;

        vector dp(11, vector (n, vector (target + 1, -1)));

        vector<pair<int, int>> temp;

        auto f = [&](int i, int s, int val, auto && f) -> ll {

            if(i == 10) {
                if(val == 0 && s == 0) return mul(fact[(n + 1) / 2], fact[n / 2]);
                return 0;
            }

            if(dp[i][s][val] != -1) return dp[i][s][val];

            ll ans = 0;

            for(int x = 0; x <= freq[i]; x++) {
                if(s - x >= 0 && val - x * i >= 0) {
                    ans = add(ans, mul(mul(ifact[x], ifact[freq[i] - x]), f(i + 1, s - x, val - x * i, f)));
                }
            }

            return dp[i][s][val] = ans;

        };

        return f(0, (n + 1) / 2, target / 2, f);

    }
};",1441384985
Hongbo Zhong,neverbackdown,258,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 0, 0)]
        while Q:
            t, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = 1+max(moveTime[x][y], t)
                    heappush(Q, (new_t, x, y))
        
            ",1441305664
Hongbo Zhong,neverbackdown,258,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        dist = defaultdict(lambda: float('inf'))
        seen = set()
        Q = [(0, 1, 0, 0)]
        while Q:
            t, c, i, j = heappop(Q)
            if (i, j) == (n-1, m-1):
                return t
            if (i, j) in seen:
                continue
            seen.add((i, j))

            for x, y in ((i+1, j), (i-1, j), (i, j+1), (i, j-1)):
                if 0<=x<n and 0<=y<m:
                    new_t = c+max(moveTime[x][y], t)
                    heappush(Q, (new_t, 1 if c==2 else 2, x, y))",1441308620
Hongbo Zhong,neverbackdown,258,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            d = int(num[i])
            if i%2 == 0:
                even += d
            else:
                odd += d
        return even == odd",1441281665
Hongbo Zhong,neverbackdown,258,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        n = len(num)
        digits = [int(ch) for ch in num]
        total = sum(digits)
        if total%2 == 1:
            return 0
            
        mod = 10**9+7
        memo = [defaultdict(lambda: 0) for _ in range(n)]
        for i in range(n):
            d = digits[i]
            if i == 0:
                memo[i][(d, 1)] = 1
                memo[i][(0, 0)] = 1
            else:
                for num, cnt in memo[i-1]:
                    memo[i][(num+d, cnt+1)] += memo[i-1][(num, cnt)]
                    memo[i][(num, cnt)] += memo[i-1][(num, cnt)]

        ans = memo[n-1][(total//2, n//2)]*perm(n//2, n//2)*perm(n-n//2, n-n//2)
        counter = Counter(digits)
        for freq in counter.values():
            ans //= perm(freq, freq)
        return ans % mod",1441391236
RAHUL YADAV,imdotrahul,259,3627,cpp,"#include <vector>
#include <queue>
#include <algorithm>
#include <limits>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int rows = moveTime.size();
        if (rows == 0) return 0;
        int cols = moveTime[0].size();
        if (cols == 0) return 0;

        vector<vector<int>> minTime(rows, vector<int>(cols, numeric_limits<int>::max()));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        initializePriorityQueue(pq, minTime);
        vector<vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!pq.empty()) {
            auto current = pq.top();
            pq.pop();
            int currentTime = current[0];
            int currentRow = current[1];
            int currentCol = current[2];

            if (currentTime > minTime[currentRow][currentCol]) continue;

            exploreNeighbors(currentRow, currentCol, currentTime, moveTime, minTime, pq, directions);
        }

        return getMinTimeToDestination(minTime, rows, cols);
    }

private:
    void initializePriorityQueue(priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                                  vector<vector<int>>& minTime) {
        pq.push({0, 0, 0});
        minTime[0][0] = 0;
    }

    void exploreNeighbors(int row, int col, int time, vector<vector<int>>& moveTime, 
                          vector<vector<int>>& minTime, priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq, 
                          const vector<vector<int>>& directions) {
        for (const auto& dir : directions) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];

            if (isValidCell(newRow, newCol, minTime)) {
                int newTime = calculateNewTime(time, moveTime[newRow][newCol]);
                updateMinTime(newRow, newCol, newTime, minTime, pq);
            }
        }
    }

    bool isValidCell(int row, int col, const vector<vector<int>>& minTime) {
        return row >= 0 && row < minTime.size() && col >= 0 && col < minTime[0].size();
    }

    int calculateNewTime(int currentTime, int moveTime) {
        return max(currentTime, moveTime) + 1;
    }

    void updateMinTime(int row, int col, int newTime, vector<vector<int>>& minTime, 
                       priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>>& pq) {
        if (newTime < minTime[row][col]) {
            minTime[row][col] = newTime;
            pq.push({newTime, row, col});
        }
    }

    int getMinTimeToDestination(const vector<vector<int>>& minTime, int rows, int cols) {
        return minTime[rows - 1][cols - 1];
    }
};",1441385871
RAHUL YADAV,imdotrahul,259,3628,cpp,"
class Solution {
public:
    int minTimeToReach(std::vector<std::vector<int>>& moveTime) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        std::vector<std::vector<std::vector<int>>> minTime(rows, std::vector<std::vector<int>>(cols, std::vector<int>(2, std::numeric_limits<int>::max())));
        
        minTime[0][0][0] = 0;
        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>> priorityQueue;
        priorityQueue.push({0, 0, 0, 0});

        std::vector<std::vector<int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!priorityQueue.empty()) {
            auto current = priorityQueue.top();
            priorityQueue.pop();
            int currentTime = current[0];
            int row = current[1];
            int col = current[2];
            int parity = current[3];
            
            if (currentTime > minTime[row][col][parity]) continue;
            
            exploreNeighbors(currentTime, row, col, parity, moveTime, minTime, priorityQueue, directions);
        }
        
        return std::min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }

private:
    void exploreNeighbors(int currentTime, int row, int col, int parity, 
                          const std::vector<std::vector<int>>& moveTime,
                          std::vector<std::vector<std::vector<int>>>& minTime,
                          std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, std::greater<std::vector<int>>>& priorityQueue,
                          const std::vector<std::vector<int>>& directions) {
        int rows = moveTime.size();
        int cols = moveTime[0].size();
        
        for (const auto& direction : directions) {
            int newRow = row + direction[0];
            int newCol = col + direction[1];
            
            if (isValid(newRow, newCol, rows, cols)) {
                int nextTime = std::max(currentTime, moveTime[newRow][newCol]) + (parity == 0 ? 1 : 2);
                if (nextTime < minTime[newRow][newCol][1 - parity]) {
                    minTime[newRow][newCol][1 - parity] = nextTime;
                    priorityQueue.push({nextTime, newRow, newCol, 1 - parity});
                }
            }
        }
    }

    bool isValid(int row, int col, int rows, int cols) {
        return row >= 0 && row < rows && col >= 0 && col < cols;
    }
};",1441366801
RAHUL YADAV,imdotrahul,259,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.size();
        int sumeven = 0;
        int sumodd = 0;
        for(int i = 0;i<n;i+=2)
        {
            sumeven+=num[i]-'0';
        }
        for(int i = 1;i<n;i+=2)
            {
                sumodd += num[i]-'0';
            }

        if(sumodd == sumeven)
        {
            return true;
        }
        else{
            return false;
        }
    }
};",1441291928
RAHUL YADAV,imdotrahul,259,3637,cpp,"#define MOD 1000000007
typedef long long ll;

vector<ll> factorial;
vector<ll> inv_factorial;

ll mod_power(ll base, ll exp) {
    ll result = 1;
    base %= MOD;
    while (exp > 0) {
        if (exp & 1) result = result * base % MOD;
        base = base * base % MOD;
        exp >>= 1;
    }
    return result;
}

void initialize_factorials(int limit) {
    factorial.assign(limit + 1, 1);
    for (int i = 1; i <= limit; i++) {
        factorial[i] = factorial[i - 1] * i % MOD;
    }
    inv_factorial.assign(limit + 1, 1);
    inv_factorial[limit] = mod_power(factorial[limit], MOD - 2);
    for (int i = limit - 1; i >= 0; i--) {
        inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % MOD;
    }
}

ll compute_combinations(int digit_count[], int digit, int used, int half_length) {
    if (used > digit_count[digit] || used > half_length) return 0;
    return (factorial[digit_count[digit]] * inv_factorial[used] % MOD) * inv_factorial[digit_count[digit] - used] % MOD;
}

void fill_dp_table(int digit_count[], vector<vector<ll>>& dp, ll half_sum, int half_length) {
    for (int d = 0; d <= 9; d++) {
        if (digit_count[d] == 0) continue;
        for (int c = half_length; c >= 0; c--) {
            for (ll s = half_sum; s >= 0; s--) {
                if (dp[c][s] == 0) continue;
                for (int t = 1; t <= min(digit_count[d], half_length - c); t++) {
                    if (s + (ll)d * t > half_sum) break;
                    ll combinations = compute_combinations(digit_count, d, t, half_length - c);
                    dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * combinations) % MOD;
                }
            }
        }
    }
}

class Solution {
public:
    int countBalancedPermutations(string digits) {
        int length = digits.size();
        int digit_count[10] = {0};
        ll total_digit_sum = 0;
        for (char c : digits) {
            int digit = c - '0';
            digit_count[digit]++;
            total_digit_sum += digit;
        }
        if (total_digit_sum % 2 != 0) return 0;
        ll half_sum = total_digit_sum / 2;
        int half_length = (length + 1) / 2;
        initialize_factorials(length);
        vector<vector<ll>> dp(half_length + 1, vector<ll>(half_sum + 1, 0));
        dp[0][0] = 1;
        fill_dp_table(digit_count, dp, half_sum, half_length);
        ll valid_permutations = dp[half_length][half_sum];
        if (valid_permutations == 0) return 0;
        ll product_factorials = 1;
        for (int d = 0; d <= 9; d++) {
            product_factorials = product_factorials * factorial[digit_count[d]] % MOD;
        }
        ll combinations_k_nk = (factorial[half_length] * factorial[length - half_length]) % MOD;
        ll inv_product_factorials = mod_power(product_factorials, MOD - 2);
        ll final_answer = (combinations_k_nk * valid_permutations) % MOD;
        final_answer = (final_answer * inv_product_factorials) % MOD;

        return (int)final_answer;
    }
};
",1441378126
Jingzhe Tang,skywalkert,261,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 51, maxm = 2501, INF = 0x3f3f3f3f;
        static int f[maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<pair<int, int> > cand[2];
        auto upd = [&](int x, int y, int t) {
            // printf(""chk %d %d %d\n"", x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[x][y] || t <= tim[x][y])
                return;
            // assert(cur <= t && t <= cur + 1);
            f[x][y] = t;
            cand[t - cur].push_back({x, y});
            // printf(""new %d %d: %d\n"", x, y, t);
        };
        f[0][0] = 0;
        cand[0].push_back({0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d\n"", cur, pos, cand[0].size(), cand[1].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1 && f[x][y] == INF; ++dx)
                    for(int dy = -1; dy <= 1 && f[x][y] == INF; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c || f[xx][yy] >= cur)
                            continue;
                        f[x][y] = cur + 1;
                    }
                // if(f[x][y] != cur + 1) {
                //     printf(""cur %d x %d y %d pos %d\n"", cur, x, y, pos);
                //     for(int i = 0; i < r; ++i)
                //         for(int j = 0; j < c; ++j)
                //             printf(""%d%c"", f[i][j] < INF ? f[i][j] : -1, "" \n""[j == c - 1]);
                // }
                // assert(f[x][y] == cur + 1);
                if(f[x][y] == cur + 1) {
                    // printf(""new2 %d %d: %d\n"", x, y, cur + 1);
                    cand[1].push_back({x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(x + dx, y + dy, f[x][y] + 1);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                ++cur;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        return f[r - 1][c - 1];
    }
};",1441346708
Jingzhe Tang,skywalkert,261,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& tim) {
        static const int maxn = 751, maxm = 562501, INF = 0x3f3f3f3f;
        static int f[2][maxn][maxn];
        static pair<int, int> ord[maxm];
        int r = tim.size(), c = tim[0].size(), n = 0;
        for(int i = 0; i < r; ++i)
            for(int j = 0; j < c; ++j) {
                f[0][i][j] = f[1][i][j] = INF;
                ord[n++] = {i, j};
            }
        sort(ord, ord + n, [&](auto const &u, auto const &v) {
            return tim[u.first][u.second] < tim[v.first][v.second];
        });
        int cur = 0, pos = 0;
        vector<array<int, 3> > cand[3];
        auto upd = [&](int o, int x, int y, int t) {
            // printf(""chk %d %d %d %d\n"", o, x, y, t);
            if(x < 0 || x >= r || y < 0 || y >= c || t >= f[o][x][y])
                return;
            if(t - !o <= tim[x][y]) {
                f[o][x][y] = tim[x][y] + 2 - o;
            } else {
                assert(cur <= t && t <= cur + 2);
                f[o][x][y] = t;
                cand[t - cur].push_back({o, x, y});
            }
            // printf(""new %d %d %d: %d\n"", o, x, y, t);
        };
        f[0][0][0] = 0;
        cand[0].push_back({0, 0, 0});
        while(pos < n || !cand[0].empty()) {
            // printf(""cur %d pos %d cand %d %d %d\n"", cur, pos, cand[0].size(), cand[1].size(), cand[2].size());
            while(pos < n) {
                auto &[x, y] = ord[pos];
                if(f[0][x][y] < INF && f[1][x][y] < INF) {
                    ++pos;
                    continue;
                }
                if(tim[x][y] > cur)
                    break;
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        int xx = x + dx, yy = y + dy;
                        if(xx < 0 || xx >= r || yy < 0 || yy >= c)
                            continue;
                        if(f[1][x][y] == INF && f[0][xx][yy] < cur)
                            f[1][x][y] = cur + 1;
                        if(f[0][x][y] == INF && f[1][xx][yy] < cur)
                            f[0][x][y] = cur + 2;
                    }
                if(f[0][x][y] >= cur && f[0][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 0, x, y, f[0][x][y]);
                    cand[f[0][x][y] - cur].push_back({0, x, y});
                }
                if(f[1][x][y] >= cur && f[1][x][y] <= cur + 2) {
                    // printf(""new2 %d %d %d: %d\n"", 1, x, y, f[1][x][y]);
                    cand[f[1][x][y] - cur].push_back({1, x, y});
                }
                ++pos;
            }
            while(!cand[0].empty()) {
                auto &[o, x, y] = cand[0].back();
                for(int dx = -1; dx <= 1; ++dx)
                    for(int dy = -1; dy <= 1; ++dy) {
                        if(!dx == !dy)
                            continue;
                        upd(!o, x + dx, y + dy, f[o][x][y] + 1 + o);
                    }
                cand[0].pop_back();
            }
            if(!cand[1].empty()) {
                cand[1].swap(cand[0]);
                cand[2].swap(cand[1]);
                ++cur;
            } else if(!cand[2].empty()) {
                cand[2].swap(cand[0]);
                cur += 2;
            } else if(pos < n) {
                auto &[x, y] = ord[pos];
                cur = tim[x][y];
            }
        }
        // for(int i = 0; i < r; ++i)
        //     for(int j = 0; j < c; ++j)
        //         printf(""[%d|%d]%c"", f[0][i][j] < INF ? f[0][i][j] : -1, f[1][i][j] < INF ? f[1][i][j] : -1, "" \n""[j == c - 1]);
        return min(f[0][r - 1][c - 1], f[1][r - 1][c - 1]);
    }
};",1441380781
Jingzhe Tang,skywalkert,261,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int dt = 0;
        for(char ch: num)
            dt = ch - '0' - dt;
        return !dt;
    }
};",1441280946
Jingzhe Tang,skywalkert,261,3637,cpp,"class Solution {
public:
    int countBalancedPermutations(string num) {
        typedef long long LL;
        static const int maxd = 10, maxm = 41, maxh = 361, mod = (int)1e9 + 7;
        static int f[maxm][maxh], iact[maxm << 1 | 1], ctr[maxd + 1];
        int n = num.size(), s = 0;
        memset(ctr, 0, sizeof ctr);
        for(char ch: num) {
            int o = ch - '0';
            ++ctr[o];
            s += o;
        }
        if(s & 1)
            return 0;
        int m = n >> 1, h = s >> 1;
        for(int i = 0; i <= m; ++i)
            memset(f[i], 0, (h + 1) * sizeof(int));
        iact[1] = 1;
        for(int i = 2; i <= n; ++i)
            iact[i] = mod - (int)(mod / i * (LL)iact[mod % i] % mod);
        iact[0] = 1;
        for(int i = 1; i <= n; ++i)
            iact[i] = (LL)iact[i - 1] * iact[i] % mod;
        f[0][0] = 1;
        for(int o = 0; o < maxd; ++o) {
            if(!ctr[o])
                continue;
            for(int i = m; i >= 0; --i)
                for(int j = h; j >= 0; --j) {
                    int ways = 0;
                    for(int k = min(ctr[o], o ? min(i, j / o) : i); k >= 0; --k)
                        ways = (ways + (LL)f[i - k][j - o * k] * iact[k] % mod * iact[ctr[o] - k]) % mod;
                    f[i][j] = ways;
                }
        }
        int ways = f[m][h];
        for(int i = 2; i <= m; ++i)
            ways = (LL)ways * i * i % mod;
        if(m + m < n)
            ways = (LL)ways * (n - m) % mod;
        return ways;
    }
};",1441307509
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3627,cpp,"struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 1);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny,  (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441364022
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3628,cpp,"#include <bits/stdc++.h>
using namespace std;

struct node {
    long long time;
    int x, y, step;
    bool operator<(const node& a) const {
        return time > a.time;
    }
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size();
        int m = a[0].size();
        
        int dx[] = {0, -1, 0, 1};
        int dy[] = {1, 0, -1, 0};

        
        const long long INF = 1e18;
        vector<vector<long long>> dist0(n, vector<long long>(m, INF));
        vector<vector<long long>> dist1(n, vector<long long>(m, INF));
        
        priority_queue<node> pq;
        
        dist0[0][0] = 0;
        pq.push(node{0, 0, 0, 0});
        
        while (!pq.empty()) {
            node current = pq.top();
            pq.pop();
            
            long long cost = current.time;
            int x = current.x;
            int y = current.y;
            int step = current.step;
            
            if ((step == 0 && cost > dist0[x][y]) ||
                (step == 1 && cost > dist1[x][y])) {
                continue;
            }
            
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];
                
                if (nx < 0 || nx >= n || ny < 0 || ny >= m)
                    continue;
                
                long long nc = max(cost, (long long)a[nx][ny]);
                
                long long new_cost = nc + ((step == 0) ? 1 : 2);                
                if ((step ^ 1) == 0) {
                    if (new_cost < dist0[nx][ny]) {
                        dist0[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
                else {
                    if (new_cost < dist1[nx][ny]) {
                        dist1[nx][ny] = new_cost;
                        pq.push(node{new_cost, nx, ny, (step ^ 1)});
                    }
                }
            }
        }
        
        long long answer = min(dist0[n - 1][m - 1], dist1[n - 1][m - 1]);
        return (int)answer;
    }
};",1441362661
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n = s.size();
        int e = 0, o = 0;
        for(int i = 0; i< n; i++) {
            if(i & 1) {
                e += s[i] - '0';
                continue;
            }
            o += s[i] - '0';
            
        }

        return (e == o);
    }
};",1441283173
AVIJIT_BISWAS,AVIJIT_BISWAS,262,3637,cpp,"class Solution {
public:
  
int power(long long n, long long k, int mod) {
  int ans = 1 % mod; n %= mod; if(n < 0) n += mod;

  while(k) {
    if(k & 1) ans = 1ll *  ans * n % mod;
    n = 1ll *  n * n % mod;
    k >>= 1;
  }

  return ans;
}
    int countBalancedPermutations(string num) {
        const int mod = 1e9 + 7;
        int n = num.size();
        int m = (n + 1) / 2;


        int cnt[10] = {0};
        for(char ch : num) {
            cnt[ch - '0']++;
        }

        long long t = 0;
        for(int i = 0; i < 10; i++) {
            t += 1ll * i * cnt[i];
        }

        if(t % 2 != 0) return 0;

        long long tot = t / 2;

        const int q = 80;
        vector<long long> fac(q + 1, 1);
        for(int i = 1; i <= q; i++) {
            fac[i] = fac[i -1] * i % mod;
        }

        vector<long long> inv_fac(q + 1, 1);
        inv_fac[q] = power(fac[q], mod - 2, mod);
        for(int i = q - 1; i >= 0; i--){
            inv_fac[i] = 1ll * inv_fac[i +1] * (i +1) % mod;
        }

        auto ncr = [&](int n, int k) -> long long {
            if(k > n) return 0;
            return fac[n] * inv_fac[k] % mod * inv_fac[n -k] % mod;
        };

        vector<vector<long long>> dp(m + 1, vector<long long>(tot + 1, 0));
        dp[0][0] = 1;

        for(int i =0; i < 10; i++) {
            if(!cnt[i]) continue;
            for(int t = m; t >= 0; t--){
                for(long long s = tot; s >= 0; s--){
                    if(dp[t][s] == 0) continue;
                    for(int k = 1; k <= cnt[i] and t + k <= m and s + 1ll * i * k <= tot; k++){
                        dp[t + k][s + 1ll * i * k] = (dp[t + k][s + 1ll * i * k] + dp[t][s] * ncr(cnt[i], k)) % mod;
                    }
                }
            }
        }

        long long calc = 1;
        for(int i = 0; i < 10; i++) {
            calc = calc * fac[cnt[i]] % mod;
        }

        int ans = 1ll * (dp[m][tot] % mod) * fac[m] % mod;
        ans = 1ll * ans * fac[n / 2] % mod;
        ans = 1ll * ans * power(calc, mod -2, mod) % mod;

        return ans;
    }
};",1441393320
birds3345,birds3345,264,3627,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;
        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, coord] = pq.top();
            auto [i, j] = coord;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + 1;
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {i + 1, j}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + 1;
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {i, j + 1}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + 1;
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {i - 1, j}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + 1;
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {i, j - 1}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441297556
birds3345,birds3345,264,3628,cpp,"class Solution {
public:
    int valid(int i, int j, int n, int m)
    {
        return i >= 0 && i < n && j >= 0 && j < m;
    }
    
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int res = 0;
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        priority_queue<pair<int, pair<bool, pair<int, int>>>, vector<pair<int, pair<bool, pair<int, int>>>>, greater<>> pq;
        pq.push({0, {true, {0, 0}}});
        dist[0][0] = 0;
        
        while (!pq.empty())
        {
            auto [time, info] = pq.top();
            auto move = info.first;
            auto [i, j] = info.second;
            pq.pop();
            
            if (i == n - 1 && j == m - 1)
                return time;
            
            if (valid(i + 1, j, n, m))
            {
                int newTime = max(time, moveTime[i + 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i + 1][j])
                {
                    pq.push({newTime, {!move, {i + 1, j}}});
                    dist[i + 1][j] = newTime;
                }
            }
            
            if (valid(i, j + 1, n, m))
            {
                int newTime = max(time, moveTime[i][j + 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j + 1])
                {
                    pq.push({newTime, {!move, {i, j + 1}}});
                    dist[i][j + 1] = newTime;
                }
            }
            
            if (valid(i - 1, j, n, m))
            {
                int newTime = max(time, moveTime[i - 1][j]) + (move ? 1 : 2);
                if (newTime < dist[i - 1][j])
                {
                    pq.push({newTime, {!move, {i - 1, j}}});
                    dist[i - 1][j] = newTime;
                }
            }
            
            if (valid(i, j - 1, n, m))
            {
                int newTime = max(time, moveTime[i][j - 1]) + (move ? 1 : 2);
                if (newTime < dist[i][j - 1])
                {
                    pq.push({newTime, {!move, {i, j - 1}}});
                    dist[i][j - 1] = newTime;
                }
            }
        }
        
        return -1;
    }
};",1441303359
birds3345,birds3345,264,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0;
        int odd = 0;
        
        for (int i = 0; i < num.size(); i++)
        {
            if (i & 1)
                odd += num[i] - '0';
            else
                even += num[i] - '0';
        }
        
        return even == odd;
    }
};",1441280998
birds3345,birds3345,264,3637,cpp,"long long dp[81][1441][41];

class Solution {
public:
    int MOD = 1e9 + 7;
    
    long long solve(int i, int sum, int evenCount, string& num, int totalEven, int totalOdd)
    {
        if (dp[i][sum + 720][evenCount] != -1)
            return dp[i][sum + 720][evenCount];
        if (i == num.size())
            return sum == 0 && evenCount == totalEven;
        
        int oddCount = i - evenCount;
        
        long long res = 0;
        if (oddCount < totalOdd)
            res = (res + solve(i + 1, sum + (num[i] - '0'), evenCount, num, totalEven, totalOdd) * (totalOdd - oddCount)) % MOD;
        if (evenCount < totalEven)
            res = (res + solve(i + 1, sum - (num[i] - '0'), evenCount + 1, num, totalEven, totalOdd) * (totalEven - evenCount)) % MOD;
        
        return dp[i][sum + 720][evenCount] = res;
    }
    
    long long factorial(long long n)
    {
        long long res = 1;
        for (int i = 1; i <= n; i++)
            res = (res * i) % MOD;
        
        return res;
    }
    
    long long modInverse(long long a, long long mod)
    {
        long long m0 = mod, t, q;
        long long x0 = 0, x1 = 1;
        if (mod == 1) return 0;
        while (a > 1)
        {
            q = a / mod;
            t = mod;
            mod = a % mod, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0) x1 += m0;
        return x1;
    }
    
    int countBalancedPermutations(string num) {
        memset(dp, -1, sizeof(dp));
        long long res = solve(0, 0, 0, num, num.size() / 2, num.size() - num.size() / 2);
        
        unordered_map<char, int> freq;
        for (char c: num)
            freq[c]++;
        
        for (auto& [k, v]: freq)
        {
            long long fact = factorial(v);
            long long invFact = modInverse(fact, MOD);
            
            res = (res * invFact) % MOD;
        }
        
        return res;
    }
};",1441393394
junbinliang,junbinliang,267,3627,cpp,"vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
int d[55][55];
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j] = 2e9;
            }
        }
        
        queue<pair<int, int>> q;
        q.push({0, 0});
        d[0][0] = 0;
        
        while(q.size()) {
            pair<int, int> p = q.front();
            q.pop();
            int r = p.first, c = p.second;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                if(d[rr][cc] > max(d[r][c] + 1, a[rr][cc] + 1)) {
                    d[rr][cc] = max(d[r][c] + 1, a[rr][cc] + 1);
                    q.push({rr, cc});
                }
            }
        }
        
        return d[n - 1][m - 1];
    }
};",1441292763
junbinliang,junbinliang,267,3628,java,"
class Solution {
    public int minTimeToReach(int[][] a) {
        int[][] dir = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        int n = a.length, m = a[0].length;
        int[][][] d = new int[n][m][2];
        boolean[][][] st = new boolean[n][m][2];
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = 2000000000;
            }
        }
        
        PriorityQueue<int[]> pq = new PriorityQueue<>((x, y) -> {
            return x[3] - y[3];
        });
        d[0][0][0] = 0;
        pq.add(new int[]{0, 0, 0, 0});
        
        while(pq.size() > 0) {
            int[] p = pq.poll();
            int r = p[0], c = p[1], t = p[2], dis = p[3];
            if(st[r][c][t]) continue;
            st[r][c][t] = true;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(int[] di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > Math.max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = Math.max(d[r][c][t] + w, a[rr][cc] + w);
                    pq.add(new int[]{rr, cc, t ^ 1, d[rr][cc][t ^ 1]});
                }
            }
        }
        
        
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}

/*
vector<vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
const int INF = 2e9;
int d[760][760][2];

struct P {
    int r, c, t;
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                d[i][j][0] = d[i][j][1] = INF;
            }
        }
        
        queue<P> q;
        q.push({0, 0, 0});
        d[0][0][0] = 0;
        while(q.size()) {
            P p = q.front(); q.pop();
            int r = p.r, c = p.c;
            int t = p.t;
            int w = 1;
            if(t % 2 == 1) w = 2;
            for(auto& di : dir) {
                int rr = r + di[0], cc = c + di[1];
                if(rr < 0 || rr >= n || cc < 0 || cc >= m) continue;
                
                if(d[rr][cc][t ^ 1] > max(d[r][c][t] + w, a[rr][cc] + w)) {
                    d[rr][cc][t ^ 1] = max(d[r][c][t] + w, a[rr][cc] + w);
                    q.push({rr, cc, t ^ 1});
                }
            }
        }
        
            
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
    
    
};
*/",1441305515
junbinliang,junbinliang,267,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int s1 = 0, s2 = 0;
        for(int i = 0; i < s.size(); i++) {
            if(i % 2 == 0) s1 += s[i] - '0';
            else s2 += s[i] - '0';
        }
        return s1 == s2;
    }
};",1441280910
junbinliang,junbinliang,267,3637,cpp,"const int MOD = 1e9 + 7;
int tot = 0;
using ll = long long;
long long fact[100];

ll fpow(ll x, int y){
	ll res = 1;
	while(y){
		if(y & 1) res = (res * x) % MOD;
		x = (x * x) % MOD;
		y >>= 1;
	}
	return res;
}  

ll modInverse(ll a, ll m) {
    ll m0 = m;
    ll y = 0, x = 1;
    if (m == 1)
        return 0;
    while (a > 1) {
          // q is quotient
        ll q = a / m;
        ll t = m;
        // m is remainder now, process
        // same as Euclid's algo
        m = a % m;
        a = t;
        t = y;
        // Update x and y
        y = x - q * y;
        x = t;
    }
    // Make x positive
    if (x < 0)
        x += m0;
    return x;
}


bool yes = false;
long long C[101][101];
void init() {
    if(yes) return;
    yes = true;
    C[0][0] = 1;
    for(int i = 1;i <= 100; i++) {
      C[i][0]=1;
      for(int j = 1;j <= i;j++) {
        C[i][j] = ( C[i-1][j] + C[i-1][j-1] ) % MOD;
      }
    }
}

long long dp[11][370][45];
int p[10];
int toteven = 0, totodd = 0;

class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        vector<int> cnt(10);
        tot = 0;
        for(char c : s) {
            cnt[c - '0']++;
            tot += (c - '0');
        }
        
        if(tot % 2 == 1) {
            return 0;
        }
        
        for(int i = 0; i < 10; i++) {
            for(int j = 0; j <= tot / 2 + 1; j++) {
                for(int k = 0; k <= (s.size() / 2 + 1); k++) {
                    dp[i][j][k] = -1;
                }
            }
        }
        
        p[0] = cnt[0];
        for(int i = 1; i < 10; i++) {
            p[i] = cnt[i] + p[i - 1];
        }
        
        toteven = s.size() / 2;
        totodd = s.size() - toteven;
        
        int ans = dfs(cnt, 0, tot / 2, (s.size() + 1) / 2);
        //cout << endl;
        return ans;
    }
    
    long long dfs(vector<int>& cnt, int i, int s, int odd) { //10 * 360 * 40
        if(i >= cnt.size()) {
            if(odd == 0 && s == 0) {
                return 1;
            }
            return 0;
        }
        if(dp[i][s][odd] != -1) {
            return dp[i][s][odd];
        }
        

        if(cnt[i] == 0) {
            return dp[i][s][odd] = dfs(cnt, i + 1, s, odd);
        }
        long long ans = 0;
        
        
        int sum = 0;
        if(i > 0) sum = p[i - 1];
        int oddtaken = totodd - odd;
        int remainEven = toteven - (sum - oddtaken);
        
        //cout << i << "" "" << s << "" "" << odd << "" "" << oddtaken << "" "" << sum << ""  "" << remainEven << endl;
        
        
        for(int x = 0; x <= min(odd, cnt[i]); x++) {
            int sum1 = x * i;
            if(sum1 <= s) {
                if(remainEven < 0 || remainEven < (cnt[i] - x)) continue;
                long long w1 = C[odd][x];
                long long w2 = C[remainEven][cnt[i] - x];
                ll w = (w1 * w2) % MOD;
                
                /*if(i == 5 || i == 6) {
                    cout << i <<"" ""  << odd << endl;
                    cout << x << ""  "" << w1 << "" "" << w2 << "" "" << w <<""  "" << dfs(cnt, i + 1, s - sum1, odd - x) << endl << endl;
                }*/
                
                ans += (w * dfs(cnt, i + 1, s - sum1, odd - x));
                ans %= MOD;
            }
        }
        //cout << i << "" "" << s << "" "" << odd << ""  "" << ans << endl;
        return dp[i][s][odd] = ans;
    }
};

//""4567""   8
//""46453"" 6",1441383288
uf21-6,uf21-6,268,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        
        # Initialize distance matrix with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        dist[0][0] = 0  # Start from top-left corner with time 0
        
        # Min-heap priority queue: each entry is (time, row, col)
        pq = [(0, 0, 0)]
        
        # Possible directions: up, right, down, left
        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            time, row, col = heapq.heappop(pq)
            
            # If the current time exceeds known minimum, skip
            if time > dist[row][col]:
                continue
            
            for dr, dc in directions:
                newRow, newCol = row + dr, col + dc
                
                # Check if within bounds
                if 0 <= newRow < n and 0 <= newCol < m:
                    # Calculate the time to move to this cell
                    newTime = max(time, moveTime[newRow][newCol]) + 1
                    
                    # Update if found a shorter time to this cell
                    if newTime < dist[newRow][newCol]:
                        dist[newRow][newCol] = newTime
                        heapq.heappush(pq, (newTime, newRow, newCol))
        
        return dist[n - 1][m - 1]
",1441316581
uf21-6,uf21-6,268,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows, cols = len(moveTime), len(moveTime[0])
        
        # Initialize distance array with a large number
        dist = [[[float('inf')] * 2 for _ in range(cols)] for _ in range(rows)]
        dist[0][0][0] = 0
        
        # Min-heap priority queue to process cells in ascending time
        heap = [(0, 0, 0, 0)]  # (time, row, col, parity)
        
        # Possible moves: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            time, x, y, parity = heapq.heappop(heap)
            
            # Skip if we already have a shorter path
            if time > dist[x][y][parity]:
                continue
            
            # Explore neighboring cells
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                # Check if neighbor is within bounds
                if 0 <= nx < rows and 0 <= ny < cols:
                    next_time = max(time, moveTime[nx][ny]) + (2 if parity else 1)
                    
                    # Update distance if a shorter path is found
                    if next_time < dist[nx][ny][1 - parity]:
                        dist[nx][ny][1 - parity] = next_time
                        heapq.heappush(heap, (next_time, nx, ny, 1 - parity))
        
        return min(dist[rows - 1][cols - 1][0], dist[rows - 1][cols - 1][1])
",1441309467
uf21-6,uf21-6,268,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                odd += int(num[i])
            else:
                even += int(num[i])
        return even == odd",1441283881
uf21-6,uf21-6,268,3637,python3,"MOD = 1_000_000_007

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        N = len(num)
        E = (N + 1) // 2  # Number of even indices (0-based)
        O = N // 2         # Number of odd indices

        # Count frequency of each digit
        cnt = [0] * 10
        for ch in num:
            cnt[int(ch)] += 1

        # Calculate total sum
        total_sum = sum(d * cnt[d] for d in range(10))

        # If total_sum is odd, no balanced permutation exists
        if total_sum % 2 != 0:
            return 0

        sum_target = total_sum // 2

        # Precompute factorial and inverse factorial
        MAX = 80
        factorial = [1] * (MAX + 1)
        for i in range(1, MAX + 1):
            factorial[i] = factorial[i - 1] * i % MOD

        inv_fact = [1] * (MAX + 1)
        inv_fact[MAX] = pow(factorial[MAX], MOD - 2, MOD)
        for i in range(MAX - 1, -1, -1):
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD

        # Function to compute combination C(n, k) mod MOD
        def comb(n, k):
            if k > n:
                return 0
            return factorial[n] * inv_fact[k] % MOD * inv_fact[n - k] % MOD

        # Initialize DP table
        dp = [[0] * (sum_target + 1) for _ in range(E + 1)]
        dp[0][0] = 1

        for d in range(10):
            if cnt[d] == 0:
                continue
            for t in range(E, -1, -1):
                for s in range(sum_target, -1, -1):
                    if dp[t][s] == 0:
                        continue
                    for k in range(1, cnt[d] + 1):
                        if t + k > E or s + d * k > sum_target:
                            break
                        dp[t + k][s + d * k] = (dp[t + k][s + d * k] + dp[t][s] * comb(cnt[d], k)) % MOD

        number_of_valid_assignments = dp[E][sum_target]

        # Compute product of factorials of digit counts
        product_cnt_d_fact = 1
        for d in range(10):
            product_cnt_d_fact = product_cnt_d_fact * factorial[cnt[d]] % MOD

        # Compute the final answer
        answer = number_of_valid_assignments
        answer = answer * factorial[E] % MOD
        answer = answer * factorial[O] % MOD
        inv_product = pow(product_cnt_d_fact, MOD - 2, MOD)
        answer = answer * inv_product % MOD

        return answer
",1441395798
naresh50,naresh50,269,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 1 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323940
naresh50,naresh50,269,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;
        int[][] dp = moveTime;  
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        long[][] visited = new long[n][m];
        for (long[] row : visited) {
            java.util.Arrays.fill(row, Long.MAX_VALUE);
        }
        visited[0][0] = 0;

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        queue.offer(new int[]{0, 0, 0, 1}); 
        while (!queue.isEmpty()) {
            int[] curr = queue.poll();
            int time = curr[0], x = curr[1], y = curr[2], step = curr[3];

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            for (int[] dir : directions) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                
                if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                    int nextTime = Math.max(dp[nx][ny], time) + step;
                    int nextStep = (step == 1) ? 2 : 1;

                    if (nextTime < visited[nx][ny]) {
                        visited[nx][ny] = nextTime;
                        queue.offer(new int[]{nextTime, nx, ny, nextStep});
                    }
                }
            }
        }

        return -1;  
    }
}
",1441323065
naresh50,naresh50,269,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int count=0;
        for(int i=0;i<num.length();i++){
            int val = (int)num.charAt(i) -48;
            if(i%2==0) count+=val;
            else  count-=val;
        }
        if(count==0) return true;
        else return false;
    }
}",1441292047
naresh50,naresh50,269,3637,java,"class Solution {
    int mod = (int)1e9 +7;
    
    public int countBalancedPermutations(String num) {
        int n = num.length();
        long halfFact1 = factorial(n/2);
        long halfFact2 = factorial((n+1)/2);

        long[] factArray = new long[81];
         long[] modArray = new long[81];
        formArray(factArray , modArray);
       

        
        int[] count  = new int[10];
        int total=0;
        for(int i=0;i<num.length();i++){
            int val=num.charAt(i)-'0';
            count[val]++;
            total+=val;
        }
        if(total%2==1) return 0;
        long[][][] dp= new long[10][810][81];
        for(int i=0;i<dp.length;i++){
            for(int j=0;j<dp[i].length;j++){
                Arrays.fill(dp[i][j],-1);
            }
        }
        long ans = helper(0,total/2 , num.length()/2 , dp,count ,factArray , halfFact1 , halfFact2 ,modArray);
        ans%=mod;
        return (int)ans;
        
    }
    public long helper(int num , int sum , int rem , long[][][] dp , int[] count , long[] factArr , long h1 , long h2 , long[] modArr ){
        if(num==10){
           if(sum==0 && rem==0) return (h1*h2)%mod;
            else return 0;
        }
        if(dp[num][sum][rem]!=-1) return dp[num][sum][rem];
        long ans=0;

        int freq = count[num];
        
        for(int i=0;i<=freq;i++){
            long temp = 0;
            if(sum>=i*num && rem>=i) temp+=helper(num+1 , sum-(i*num) , rem-i ,  dp,count , factArr ,h1,h2 , modArr );
            if(i>0) temp = (temp * modArr[i]) % mod;
            if(freq-i >0) temp = (temp * modArr[freq-i]) % mod;

            ans+=temp;
            ans%=mod;
        }
        return dp[num][sum][rem] = ans%mod;
    }
    public long factorial(int n){
        long ans=1;
        for(int i=1;i<=n;i++){
            ans*=i;
            ans%=mod;
        }
        return ans;
    }
    public void formArray(long[] arr, long[] modArr){
        arr[1]=1L;
        arr[0]=1L;
        for(int i=2;i<=80;i++){
            arr[i] = (long)i*arr[i-1];
            arr[i]%=mod;
        }

        for(int i=0;i<arr.length;i++){
            modArr[i]=modInverse(arr[i]);
        }
    }
    public  long modInverse(long a) {
        return modExp(a, mod - 2);
    }

    public long modExp(long base, long exp) {
        long res = 1;
        while (exp > 0) {
            if ((exp & 1) == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp >>= 1;
        }
        return res;
    }
}",1441383508
her0e1c1,her0e1c1,270,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        heappush(pq, (nt + 1, ni, nj))
                ",1441298882
her0e1c1,her0e1c1,270,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M, N = len(moveTime), len(moveTime[0])
        pq = [(0, 0, 0, 0)]
        vis = set([(0, 0)])
        while pq:
            t, i, j, c = heappop(pq)
            # print(t, i, j)
            if (i, j) == (M - 1, N - 1):
                return t
            for di, dj in [(1, 0), (0, 1), (-1, 0), (0, -1)]:
                ni, nj = i + di, j + dj
                if 0 <= ni < M and 0 <= nj < N:
                    mv = moveTime[ni][nj]
                    nt = t
                    if t < mv:
                        nt = t + mv - t
                    if (ni, nj) not in vis:
                        vis.add((ni, nj))
                        nc = 1 if c == 0 else 0
                        heappush(pq, (nt + 1 + c, ni, nj, nc))
                        ",1441302584
her0e1c1,her0e1c1,270,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o = e = 0
        for i, n in enumerate(num):
            if i % 2 == 0:
                e += int(n)
            else:
                o += int(n)
        return o == e",1441282100
her0e1c1,her0e1c1,270,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        @cache
        def dfs(i, c, c2, acc):
            if i > 10:
                return 0
            if acc > total // 2:
                return 0
            if c > N1 or c2 > N2:
                return 0
            if c == N1 and c2 == N2:
                if acc == total // 2:
                    return 1
                return 0
            rv = 0
            for k in range(C[i] + 1):  # nCr
                n1 = N1 - c
                n2 = N2 - c2
                k2 = C[i] - k
                rv += comb(n1, k) * comb(n2, k2) * dfs(i + 1, c + k, c2 + k2, acc + k * i)
                rv %= M
            return rv
        
        C = defaultdict(int)
        N1, N2 = len(num) // 2, (len(num) + 1) // 2
        total = 0
        for n in num:
            C[int(n)] += 1
            total += int(n)
        if total % 2 == 1:
            return 0
        # print(total, N1, N2, C)
        M = 10 ** 9 + 7
        return dfs(0, 0, 0, 0) % M",1441395883
Jashanpreet Singh,jashanp2005,271,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309945
Jashanpreet Singh,jashanp2005,271,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
    #define int long long
    int n = moveTime.size();
    int m = moveTime[0].size();
    priority_queue<pair<pair<int, int>, pair<int, int>>, vector<pair<pair<int, int>, pair<int, int>>>, greater<pair<pair<int, int>, pair<int, int>>>> pq;
    vector<vector<int>> dis(n, vector<int>(m, 1e16));

    vector<int> dx = {-1, 1, 0, 0};
    vector<int> dy = {0, 0, -1, 1};

    pq.push({{0, false}, {0, 0}});
    dis[0][0] = 0;

    while (!pq.empty()) {
        int x = pq.top().second.first;
        int y = pq.top().second.second;
        bool fact = pq.top().first.second;
        int d = pq.top().first.first;
        pq.pop();

        int t = fact ? 2 : 1;

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                int newDist = max(d, (int)moveTime[nx][ny]) + t;
                if (dis[nx][ny] > newDist) {
                    dis[nx][ny] = newDist;
                    pq.push({{dis[nx][ny], !fact}, {nx, ny}});
                }
            }
        }
    }
    #undef int
    return dis[n - 1][m - 1];
}
};",1441309340
Jashanpreet Singh,jashanp2005,271,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
    int ans = 0, ans2 = 0;
    int n = num.length();
    for(int i = 0; i < n; i++) {
        if(i % 2 == 0) 
            ans += num[i] - '0';  
        else 
            ans2 += num[i] - '0';  
    }
    return ans == ans2;
}
};",1441283829
Jashanpreet Singh,jashanp2005,271,3637,cpp,"
vector<int> fact(101), inv(101);

vector<int> v(10, 0);

class Solution {
#define int long long

const int mod = 1e9 + 7;
const int N = 100;

int n;
int tot = 0;

int binaryexpo(int a, int b) {
    int ans = 1;
    while (b > 0) {
        if (b & 1) {
            ans = (ans * a) % mod;
        }
        a = (a * a) % mod;
        b >>= 1;
    }
    return ans;
}

void findinverse() {
    for (int i = 0; i <= N; i++) {
        inv[i] = binaryexpo(fact[i], mod - 2);
    }
}

void findfact() {
    fact[0] = 1;
    for (int i = 1; i <= N; i++) {
        fact[i] = (fact[i - 1] * i) % mod;
    }
}

int solve(int index, int count, int sum, vector<vector<vector<int>>> &dp) {
    if (index == 10) {
        if (2 * sum == tot && count == (n+1)/2) {
            return (fact[count]%mod * fact[n - count]%mod) % mod;
        }
        return 0; 
    }

    if(dp[index][count][sum] != -1) return dp[index][count][sum];

    int ans = 0;
    for (int i = 0; i <= v[index]; i++) {
        if (count + i <= (n + 1) / 2) {
            int term = (((solve(index + 1, count + i, sum + index * i, dp) * inv[i]) % mod) * inv[v[index] - i]) % mod;
            ans = (ans + term) % mod;
        }
    }
    return dp[index][count][sum] = ans;
}

public:
    int countBalancedPermutations(string num) {
        findfact();
    findinverse();
    tot = 0;
    n = num.length();
    v.assign(10, 0);

        

    for (char c : num) {
        tot += c - '0';
        v[c - '0']++;
    }

        vector<vector<vector<int>>> dp(10, vector<vector<int>>(n/2 + 2, vector<int>(tot+1, -1)));

    return solve(0, 0, 0, dp);
}
};
#undef int
",1441389745
craggy,craggy,272,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        d = deque()
        d.append((0, 0, 0))
        vis = [[0 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        while len(d) > 0:
            t, r, c = d.popleft()
            if vis[r][c] and vis[r][c] <= t: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                d.append((max(t, moveTime[nr][nc])+1, nr, nc))
            
        return vis[len(moveTime)-1][len(moveTime[0])-1]
        ",1441300823
craggy,craggy,272,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        vis = [[-1 for j in range(len(moveTime[0]))] for i in range(len(moveTime))]
        heap = [(0, 0, 0)]
        while len(heap):
            t, r, c = heappop(heap)
            if vis[r][c] != -1: continue
            vis[r][c] = t
            for dr, dc in [(-1, 0), (0, 1), (1, 0), (0, -1)]:
                nr, nc = r+dr, c+dc
                if nc < 0 or nr < 0 or nr == len(moveTime) or nc == len(moveTime[0]): continue
                heappush(heap, (max(t, moveTime[nr][nc])+1+(r+c)%2, nr, nc))

        return vis[len(moveTime)-1][len(moveTime[0])-1]

    

        ",1441309959
craggy,craggy,272,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        t = [0,0]
        for i in range(len(num)):
            t[i%2] += int(num[i])

        return t[0] == t[1]
        ",1441281821
craggy,craggy,272,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        M = int(1e9)+7
        cnt = Counter(num)
        fct = [1]
        for i in range(len(num)):
            fct.append((fct[-1] * (i+1))%M)
            
        inv_fct = [1] * (len(num) + 1)
        for i in range(1, len(fct)):
            inv_fct[i] = pow(fct[i], M - 2, M)

        @cache
        def get(diff_val, diff_num, i):
            if i == 10: return (fct[len(num)//2+len(num)%2] * fct[len(num)//2]) % M if ((diff_val == 0 and diff_num == (len(num) % 2))) else 0
            ret = 0
            if cnt[str(i)] == 0: return get(diff_val, diff_num, i+1)
            for j in range(cnt[str(i)]+1):
                a = j
                b = cnt[str(i)]-j
                ret = (ret + get(diff_val+i*a-i*b, diff_num+a-b, i+1) * inv_fct[j] * inv_fct[cnt[str(i)] - j]) % M


            return ret

        return get(0, 0, 0)

        ",1441396118
invertedwinger,invertedwinger,273,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<int>> dist(n, vector<int> (m,2e9));
        dist[0][0] = 0;
        set<pair<int,pair<int,int>>> s;
        s.insert({0, {0,0}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            int d = it->first, x = it->second.first, y = it->second.second;
            s.erase(it);
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    int D = max(d+1, a[x1][y1]+1);
                    if(D<dist[x1][y1]){
                        if(dist[x1][y1] < 2e9) s.erase({dist[x1][y1], {x1,y1}});
                        s.insert({D, {x1,y1}});
                        dist[x1][y1] = D;
                    }
                }
            }
        }

        return dist[n-1][m-1];
        
    }
};",1441304415
invertedwinger,invertedwinger,273,3628,cpp,"typedef long long ll;
const ll INF = 1e18;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        vector<vector<vector<ll>>> dist(n, vector<vector<ll>> (m, vector<ll> (2,INF)));
        dist[0][0][1] = INF;
        set<pair<ll,pair<pair<int,int>, int >>> s;
        s.insert({0, {{0,0}, 1}});
        int dx[] = {1,0,-1,0}; int dy[] = {0,1,0,-1};
        while(!s.empty()){
            auto it = s.begin();
            ll d = it->first, x = it->second.first.first, y = it->second.first.second, z = it->second.second;
            s.erase(it);
            z = 1-z;
            for(int k=0; k<4; k++){
                int x1 = x+dx[k], y1 = y+dy[k];
                if(x1>=0 && x1<n && y1>=0 && y1<m){
                    ll D =max(d+z+1, 1LL*a[x1][y1]+z+1);
                    if(D<dist[x1][y1][z]){
                        if(dist[x1][y1][z] < INF) s.erase({dist[x1][y1][z], {{x1,y1},z}});
                        s.insert({D, {{x1,y1}, z}});
                        dist[x1][y1][z] = D;
                    }
                }
            }
        }

        return min(dist[n-1][m-1][0], dist[n-1][m-1][1]);
        
    }        
    
};",1441324071
invertedwinger,invertedwinger,273,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        int c1 = 0, c2 = 0;
        for(int i=0; i<n; i++){
            if(i&1) c1 += num[i]-'0';
            else c2 += num[i]-'0';
        }
        return (c1 == c2);
    }
};",1441283779
invertedwinger,invertedwinger,273,3637,cpp,"typedef long long ll;
const ll mod = 1e9+7;
const ll N=45;
ll fct[N],inv[N],invfct[N];
ll ncr(ll n,ll r){
    if(n<0 || r<0 || n-r<0)return 0;
    ll ans = fct[n]*invfct[r];
    ans%=mod;
    ans = ans * invfct[n-r];
    ans%=mod;
    return ans;
}
void init(){
    fct[0]=fct[1]=1;
    inv[1]=1;
    invfct[0]=invfct[1]=1;
    for(ll i=2;i<N;i++){
        fct[i]=i*fct[i-1]%mod;
        inv[i]=ll(mod-inv[mod%i])*(mod/i)%mod;
        invfct[i]=ll(inv[i])*invfct[i-1]%mod;
    }
}
class Solution {
public:
    int countBalancedPermutations(string s) {
        init();
        int sum = 0;
        int n = s.length();
        for(int i=0; i<n; i++) sum += s[i]-'0';
        if(sum&1) return 0;
        int cnt[10] = {0};
        for(int i=0; i<n; i++) cnt[s[i]-'0']++;
        sum /=2;
        int x = n/2, y = n-x;
        vector<vector<ll>> ways(sum+1, vector<ll> (x+1, 0));
        ways[0][0] = 1;
        int total = 0;
        for(int k=0; k<10; k++){
            vector<vector<ll>> temp(sum+1, vector<ll> (x+1, 0));
            for(int t=0; t<=cnt[k]; t++){
                for(int sm = 0; sm <= sum; sm++){
                    for(int i=0; i<=x; i++){
                        int j = total - i;
                            int X = i+t, Y = j+(cnt[k]-t), S = sm+t*k;
                            if(S>sum || X>x || Y>y || ways[sm][i] == 0) continue;
                            ll z = (ncr(x-i, t)*ncr(y-j, cnt[k]-t))%mod;
                            temp[S][X] = (temp[S][X] + z*ways[sm][i])%mod;
                    }
                }
            }
            total += cnt[k];
            ways = temp;
        }
        return ways[sum][x];
    }
};",1441383901
Chen Jian,xiaojian9527,275,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        f = [[0] * m for _ in range(n)]

        d = [(0, 1), (0, -1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m

        seen = set()
        pq = [(0, 0, 0)]
        while pq:
            h, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if inArea(nx, ny):
                    if (nx, ny) not in seen:
                        seen.add((nx, ny))
                        t = max(h, moveTime[nx][ny])+1
                        heappush(pq, (t, nx, ny))
        return -1
        ",1441316329
Chen Jian,xiaojian9527,275,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # step: 0, 1
        n, m = len(moveTime), len(moveTime[0])
        seen = set()
        pq = [(0, 0, 0, 0)]
        d = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def inArea(x, y):
            return 0 <= x < n and 0 <= y < m
        
        while pq:
            h, step, x, y = heappop(pq)
            if (x, y) == (n-1, m-1):
                return h

            ns = 1-step
            for dx, dy in d:
                nx, ny = x+dx, y+dy
                if not inArea(nx, ny):
                    continue

                if (nx, ny, ns) in seen:
                    continue
                seen.add((nx, ny, ns))
                nh = max(h, moveTime[nx][ny]) + step + 1
                heappush(pq, (nh, ns, nx, ny))
        return -1
        ",1441329221
Chen Jian,xiaojian9527,275,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        for i, c in enumerate(num):
            if i % 2 == 0:
                odd -= int(c)
            else:
                odd += int(c)
        return odd == 0",1441283871
Chen Jian,xiaojian9527,275,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        sm = 0
        n = len(num)
        cnt = defaultdict(int)
        for c in num:
            sm += int(c)
            cnt[int(c)] += 1
        if sm % 2: return 0

        even = (n+1) // 2
        odd = n // 2

        MOD = 10 ** 9 + 7
        @cache
        def dfs(i: int, s: int, oc: int, ec: int) -> int:
            if i == 10:
                return s == 0 and oc == 0 and ec == 0
                
            if oc < 0 or ec < 0: return 0

            if cnt[i] == 0:
                return dfs(i+1, s, oc, ec)

            ans = 0
            for j in range(0, cnt[i]+1):
                if j > oc: break
                k = cnt[i] - j
                if k > ec: continue
                # print(comb(oc, j), comb(ec, k))
                ans += comb(oc, j) * comb(ec, k) * dfs(i+1, s + j * i - k * i, oc -j, ec - k) % MOD
            return ans % MOD
            
        return dfs(0, 0, odd, even)",1441396468
eatfood,eatfood,276,3627,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=deque()
        dq.append((0,0))
        while len(dq):
            x,y=dq.popleft()
            # check to improve
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    newdist = max(dp[x][y]+1, mt[nx][ny]+1)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.append((nx,ny))
        # for i in range(n):
        #     print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441298031
eatfood,eatfood,276,3628,python3,"dx=[0,0,1,-1]
dy=[1,-1,0,0]
from sortedcontainers import SortedList

class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        
        n=len(mt)
        m=len(mt[0])
        inf=int(2e9+5)

        def valid(x,y):
            return 0<=x<n and 0<=y<m
        
        dp=[[inf]*m for _ in range(n)]
        dp[0][0]=0
        dq=SortedList()
        dq.add((0,0,0))
        while len(dq):
            d,x,y=dq.pop(0)
            # check self
            if d > dp[x][y]:
                continue
            # check nbrs
            for i in range(4):
                nx=x+dx[i]
                ny=y+dy[i]
                if valid(nx,ny):
                    w = 1 if ((x+y)%2 == 0) else 2
                    newdist = max(d+w, mt[nx][ny]+w)
                    if newdist < dp[nx][ny]:
                        dp[nx][ny]=newdist
                        dq.add((newdist,nx,ny))
        for i in range(n):
            print(dp[i])
        assert dp[n-1][m-1] != inf
        return dp[n-1][m-1]
                        
            ",1441306775
eatfood,eatfood,276,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        cnt=0
        for i,ch in enumerate(s):
            d = ord(ch)-ord('0')
            cnt += d if (i % 2 == 0) else -d
        return cnt==0",1441284963
eatfood,eatfood,276,3637,python3,"'''
dp[d][num slots left][tot sum]
'''
from collections import defaultdict
mod=int(1e9+7)

f = [0] * 81
f[0] = 1
for i in range(1, 81):
    f[i] = f[i-1]*i % mod
fi = [0] * 81
fi[80] = pow(f[80], mod-2, mod)
for i in range(79, -1, -1):
    fi[i] = fi[i+1] * (i+1) % mod


# print(f[:10])
# print(fi[:10])

class Solution:
    def countBalancedPermutations(self, s: str) -> int:

        def choose(n,k):
            if k==0 or k==n:
                return 1
            if k>n or k<0:
                return 0
            return (f[n] * fi[k] * fi[n-k]) % mod
                
            
        arr=[ord(ch)-ord('0') for ch in s]
        freq=defaultdict(int)
        for x in arr:
            freq[x]+=1
        sm=sum(arr)
        if sm % 2 != 0:
            return 0
        tgt=sm//2
        slots=(len(arr)+1) // 2
        slots2 = len(arr)-slots
        # need to make tgt with exactly slots numbers
        dp=[[0]*(tgt+1) for _ in range(slots+1)]

        dp[slots][0]=1 # empty string

        num_processed = 0
        for x, fx in freq.items():
            # init dp2
            dp2=[[0]*(tgt+1) for _ in range(slots+1)]
            # for ns in range(len(dp)-1, -1, -1):
            for ns in range(len(dp)):
                for sm in range(len(dp[0])):
                    if dp[ns][sm] == 0:
                        continue
                    for k in range(0, fx+1): # pick k of x to continue this value
                        if k > ns:
                            break
                        if sm + k*x > tgt:
                            break
                        # pick k from ns to put the nums into
                        w1=choose(ns, k)
                        rem2 = slots2 - (num_processed - (slots-ns))
                        w2=choose(rem2, fx-k)
                        # print(ns, sm, k, x)
                        # print('w1', ns, k, w1)
                        # print('w2', rem2, fx-k, w2)
                        dp2[ns-k][sm + k*x] += dp[ns][sm] * (w1 * w2 % mod) % mod
                        dp2[ns-k][sm + k*x] %= mod
            
            num_processed += fx
            dp,dp2=dp2,dp
            
        #     print(x, fx)
        #     for row in dp:
        #         print(row)
        # print(tgt)
        return dp[0][tgt]
        ",1441390678
codinghermit05,codinghermit05,279,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        # Initialize distance array with infinity
        dist = [[float('inf')] * m for _ in range(n)]
        
        # Priority queue to store (time, row, col)
        # Python's heapq is used instead of Java's PriorityQueue
        pq = [(0, 0, 0)]
        dist[0][0] = 0
        
        # All four directions: up, right, down, left
        dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
        
        while pq:
            # Get current state with minimum time
            time, row, col = heapq.heappop(pq)
            
            # Skip if we've found a better path
            if time > dist[row][col]:
                continue
            
            # Try all four directions
            for dx, dy in dirs:
                new_row = row + dx
                new_col = col + dy
                
                # Check if new position is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate new time (wait until moveTime if necessary)
                    new_time = max(time, moveTime[new_row][new_col]) + 1
                    
                    # If found better path, update and add to queue
                    if new_time < dist[new_row][new_col]:
                        dist[new_row][new_col] = new_time
                        heapq.heappush(pq, (new_time, new_row, new_col))
        
        return dist[n-1][m-1]",1441322051
codinghermit05,codinghermit05,279,3628,python3,"from typing import List
import heapq

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        if not moveTime or not moveTime[0]:
            return 0
            
        n, m = len(moveTime), len(moveTime[0])
        
        # Directions for movement: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # Priority queue to store (current_time, is_odd_move, row, col)
        pq = [(0, False, 0, 0)]  # Start at (0,0) with time 0
        
        # Keep track of visited states including the odd/even move status
        visited = set()
        
        while pq:
            current_time, is_odd_move, row, col = heapq.heappop(pq)
            
            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return current_time
                
            # Skip if we've seen this state
            state = (row, col, is_odd_move)
            if state in visited:
                continue
            visited.add(state)
            
            # Try all possible moves
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy
                
                # Check if move is valid
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Move cost alternates between 1 and 2 seconds
                    move_cost = 2 if is_odd_move else 1
                    
                    # Wait until we can enter the new room
                    wait_time = max(0, moveTime[new_row][new_col] - current_time)
                    
                    # Total time includes: current time + waiting time + move cost
                    new_time = current_time + wait_time + move_cost
                    
                    # Add new state to priority queue with flipped odd/even status
                    heapq.heappush(pq, (new_time, not is_odd_move, new_row, new_col))
        
        return -1  # If no path is found
",1441300207
codinghermit05,codinghermit05,279,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Initialize variables to store sums
        even_sum = 0
        odd_sum = 0
        
        # Iterate through the string using index
        for i in range(len(num)):
            # Convert character to integer
            digit = int(num[i])
            
            # If index is even, add to even_sum
            if i % 2 == 0:
                even_sum += digit
            # If index is odd, add to odd_sum
            else:
                odd_sum += digit
        
        # Return true if sums are equal, false otherwise
        return even_sum == odd_sum",1441284044
codinghermit05,codinghermit05,279,3637,python3,"class Solution(object):
    MOD = 1000000007

    def countBalancedPermutations(self, num):
        """"""
        Count the number of balanced permutations of a given number string.
        
        :type num: str
        :rtype: int
        """"""
        # Initialize basic variables
        length = len(num)
        total_sum = sum(int(digit) for digit in num)
        counts = [0] * 10
        for digit in num:
            counts[int(digit)] += 1
        
        # Early return if sum is odd (can't be balanced)
        if total_sum % 2 != 0:
            return 0
        
        half_sum = total_sum // 2
        m = (length + 1) // 2
        
        # Precompute factorials and their inverses
        factorial = [1] * (length + 1)
        for i in range(1, length + 1):
            factorial[i] = factorial[i - 1] * i % self.MOD
        
        inv_factorial = [1] * (length + 1)
        inv_factorial[length] = self.mod_inverse(factorial[length], self.MOD)
        for i in range(length - 1, -1, -1):
            inv_factorial[i] = inv_factorial[i + 1] * (i + 1) % self.MOD
        
        # Initialize DP table for counting balanced subsets
        dp = [[0] * (half_sum + 1) for _ in range(m + 1)]
        dp[0][0] = 1
        
        # Fill DP table
        for d in range(10):
            if counts[d] == 0:
                continue
                
            for k in range(m, -1, -1):
                for s in range(half_sum, -1, -1):
                    if dp[k][s] == 0:
                        continue
                        
                    for t in range(1, counts[d] + 1):
                        if k + t > m or s + d * t > half_sum:
                            break
                        dp[k + t][s + d * t] = (dp[k + t][s + d * t] + 
                                               dp[k][s] * 
                                               self.comb(counts[d], t, factorial, inv_factorial, self.MOD)) % self.MOD
        
        # Calculate final result
        w = dp[m][half_sum]
        result = factorial[m] * factorial[length - m] % self.MOD
        
        for d in range(10):
            result = result * inv_factorial[counts[d]] % self.MOD
            
        result = result * w % self.MOD
        return int(result)
    
    def mod_inverse(self, a, m):
        """"""
        Calculate modular multiplicative inverse using fast exponentiation.
        """"""
        result = 1
        p = m - 2
        base = a
        
        while p > 0:
            if p & 1:
                result = result * base % m
            base = base * base % m
            p >>= 1
            
        return result
    
    def comb(self, n, k, factorial, inv_factorial, m):
        """"""
        Calculate combination (n choose k) using precomputed factorials.
        """"""
        if k > n:
            return 0
        return factorial[n] * inv_factorial[k] % m * inv_factorial[n - k] % m",1441354877
yaominzh,yaominzh,280,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  
        visited = [[False] * m for _ in range(n)]
        min_heap = [(0, 0, 0)]  # (time, x, y)
        
        while min_heap:
            current_time, x, y = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if visited[x][y]:
                continue
            visited[x][y] = True
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
                    wait_time = max(current_time + 1, moveTime[nx][ny]+1)
                    heapq.heappush(min_heap, (wait_time, nx, ny))
        return -1
",1441367140
yaominzh,yaominzh,280,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
        visited = [[float('inf')] * m for _ in range(n)]
        min_heap = [(0, 0, 0, 1)]  # (time, x, y, next_move_time)
        
        while min_heap:
            current_time, x, y, move_cost = heapq.heappop(min_heap)
            
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            if current_time >= visited[x][y]:
                continue
            visited[x][y] = current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    wait_time = max(current_time + move_cost, moveTime[nx][ny]+move_cost)
                    next_move_cost = 1 if move_cost == 2 else 2
                    heapq.heappush(min_heap, (wait_time, nx, ny, next_move_cost))
        
        return -1 
    
",1441380163
yaominzh,yaominzh,280,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
    
        for i in range(len(num)):
            if i % 2 == 0:  
                even_sum += int(num[i])
            else:          
                odd_sum += int(num[i])
    
        return even_sum == odd_sum
        ",1441287516
yaominzh,yaominzh,280,3637,python3,"class Solution:
    def countBalancedPermutations(self, num: str) -> int:

        mod = 10**9 + 7

        total_counts = [0] * 10
        for ch in num:
            total_counts[int(ch)] += 1

        n = len(num)
        n_even = (n + 1) // 2  # Number of even indices (0-based)
        n_odd = n // 2         # Number of odd indices

        max_sum = sum(d * c for d, c in enumerate(total_counts))
        if max_sum % 2 != 0:
            return 0
        half_sum = max_sum // 2

        MAX_N = n + 1
        factorials = [1] * (MAX_N)
        inv_factorials = [1] * (MAX_N)

        for i in range(1, MAX_N):
            factorials[i] = (factorials[i - 1] * i) % mod

        inv_factorials[MAX_N - 1] = pow(factorials[MAX_N - 1], mod - 2, mod)
        for i in range(MAX_N - 2, -1, -1):
            inv_factorials[i] = (inv_factorials[i + 1] * (i + 1)) % mod

        # Initialize DP array
        dp = [ [0] * (n_even + 1) for _ in range(half_sum + 1) ]
        dp[0][0] = 1  # Base case

        # Fill DP array
        for d in range(10):
            c_d = total_counts[d]
            if c_d == 0:
                continue
            # Precompute combinations C(c_d, k_d)
            comb = [1]  # C(c_d, 0)
            for k_d in range(1, c_d + 1):
                comb.append((comb[-1] * (c_d - k_d + 1) * pow(k_d, mod - 2, mod)) % mod)
            # Update DP array
            for s in range(half_sum, -1, -1):
                for k in range(n_even, -1, -1):
                    val = dp[s][k]
                    if val == 0:
                        continue
                    for count in range(1, min(c_d, n_even - k) + 1):
                        new_s = s + count * d
                        new_k = k + count
                        if new_s > half_sum or new_k > n_even:
                            break
                        dp[new_s][new_k] = (dp[new_s][new_k] + val * comb[count]) % mod

        ways = dp[half_sum][n_even]

        if ways == 0:
            return 0

        perm_even = factorials[n_even]
        perm_odd = factorials[n_odd]

        total_counts_product = 1
        for cnt in total_counts:
            total_counts_product = (total_counts_product * inv_factorials[cnt]) % mod

        answer = (ways * factorials[n_even] * factorials[n_odd]) % mod
        answer = (answer * total_counts_product) % mod

        return answer

",1441347489
Jie Chen,JustJie,282,3627,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<i64, int, int>;

constexpr i64 inf = i64(1e18) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({encode(i, j), t + p, p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -1, 1);
        while (!h.empty()) {
            auto [cur, t, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441324013
Jie Chen,JustJie,282,3628,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;
using Info = tuple<int, int, int>;

constexpr int inf = int(2e9) + 5;
constexpr int dir[] {-1, 0, 1, 0, -1};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();

        auto encode = [&](int r, int c) {
            return r * m + c;
        };
        auto decode = [&](int e) {
            return pair(e / m, e % m);
        };

        priority_queue<Info, vector<Info>, greater<Info>> h;
        vector dis(n, vector<i64>(m, inf));

        auto add = [&](int i, int j, int t, int p) {
            if (dis[i][j] > t + p) {
                dis[i][j] = t + p;
                h.push({t + p, encode(i, j), 1 ^ 2 ^ p});
            }
        };

        auto good = [&](int i, int j) {
            if (i < 0 || i >= n) {
                return false;
            }
            if (j < 0 || j >= m) {
                return false;
            }
            return true;
        };

        add(0, 0, -2, 2);
        while (!h.empty()) {
            auto [t, cur, p] = h.top();
            auto [i, j] = decode(cur);
            h.pop();

            if (t != dis[i][j]) {
                continue;
            }

            for (int d = 0; d < 4; d++) {
                int ni = i + dir[d];
                int nj = j + dir[d + 1];
                if (good(ni, nj)) {
                    add(ni, nj, max(t, mt[ni][nj]), p);
                }
            }
        }

        return dis[n - 1][m - 1];
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441326480
Jie Chen,JustJie,282,3636,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

class Solution {
public:
    bool isBalanced(string s) {
        int sum = 0;
        for (int i = 0; i < s.size(); i++) {
            if (i % 2 == 0) {
                sum += (s[i] - '0');
            } else {
                sum -= (s[i] - '0');
            }
        }
        return (sum == 0);
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441323288
Jie Chen,JustJie,282,3637,cpp,"/********************************************
 * author : Jie Chen (3rd Year CS)
 * school : Rochester Institute of Technology
 * created: 11.02.2024 22:28:17
*********************************************/
#include <bits/stdc++.h>

using namespace std;

#ifdef BROKEN_CODE
#include <bits/LC_parser.h>
#include <bits/debug.h>
#else
#define dbg(...) 10082002
#define dbp(...) ""Need Internship""
#endif

using i64 = long long;

// Credit: Jiangly
template<class T>
constexpr T power(T a, i64 b) {
    T res = 1;
    for (; b; b /= 2, a *= a) {
        if (b % 2) {
            res *= a;
        }
    }
    return res;
}

constexpr i64 mul(i64 a, i64 b, i64 p) {
    i64 res = a * b - i64(1.L * a * b / p) * p;
    res %= p;
    if (res < 0) {
        res += p;
    }
    return res;
}
template<int P>
struct MInt {
    int x;
    constexpr MInt() : x{} {}
    constexpr MInt(i64 x) : x{norm(x % getMod())} {}
    
    static int Mod;
    constexpr static int getMod() {
        if (P > 0) {
            return P;
        } else {
            return Mod;
        }
    }
    constexpr static void setMod(int Mod_) {
        Mod = Mod_;
    }
    constexpr int norm(int x) const {
        if (x < 0) {
            x += getMod();
        }
        if (x >= getMod()) {
            x -= getMod();
        }
        return x;
    }
    constexpr int val() const {
        return x;
    }
    explicit constexpr operator int() const {
        return x;
    }
    constexpr MInt operator-() const {
        MInt res;
        res.x = norm(getMod() - x);
        return res;
    }
    constexpr MInt inv() const {
        assert(x != 0);
        return power(*this, getMod() - 2);
    }
    constexpr MInt &operator*=(MInt rhs) & {
        x = 1LL * x * rhs.x % getMod();
        return *this;
    }
    constexpr MInt &operator+=(MInt rhs) & {
        x = norm(x + rhs.x);
        return *this;
    }
    constexpr MInt &operator-=(MInt rhs) & {
        x = norm(x - rhs.x);
        return *this;
    }
    constexpr MInt &operator/=(MInt rhs) & {
        return *this *= rhs.inv();
    }
    friend constexpr MInt operator*(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res *= rhs;
        return res;
    }
    friend constexpr MInt operator+(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res += rhs;
        return res;
    }
    friend constexpr MInt operator-(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res -= rhs;
        return res;
    }
    friend constexpr MInt operator/(MInt lhs, MInt rhs) {
        MInt res = lhs;
        res /= rhs;
        return res;
    }
    friend constexpr std::istream &operator>>(std::istream &is, MInt &a) {
        i64 v;
        is >> v;
        a = MInt(v);
        return is;
    }
    friend constexpr std::ostream &operator<<(std::ostream &os, const MInt &a) {
        return os << a.val();
    }
    friend constexpr bool operator==(MInt lhs, MInt rhs) {
        return lhs.val() == rhs.val();
    }
    friend constexpr bool operator!=(MInt lhs, MInt rhs) {
        return lhs.val() != rhs.val();
    }
};
 
template<>
int MInt<0>::Mod = 998'244'353;
 
template<int V, int P>
constexpr MInt<P> CInv = MInt<P>(V).inv();
 
constexpr int P = 1'000'000'007; // 998'244'353;
using Z = MInt<P>;

// Credit: Jiangly
struct Comb {
    int n;
    vector<Z> _fac, _invfac, _inv, _pw2;
    
    Comb() : n{0}, _fac{1}, _invfac{1}, _inv{0}, _pw2{1} {}
    Comb(int n) : Comb() {
        init(n);
    }
    
    void init(int m) {
        if (m <= n) return;
        _fac.resize(m + 1);
        _invfac.resize(m + 1);
        _inv.resize(m + 1);
        _pw2.resize(m + 1);
        
        for (int i = n + 1; i <= m; i++) {
            _fac[i] = _fac[i - 1] * i;
            _pw2[i] = _pw2[i - 1] * 2;
        }
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) {
            _invfac[i - 1] = _invfac[i] * i;
            _inv[i] = _invfac[i] * _fac[i - 1];
        }
        n = m;
    }
    
    Z pw2(int m) {
        if (m > n) init(2 * m);
        return _pw2[m];
    }
    Z fac(int m) {
        if (m > n) init(2 * m);
        return _fac[m];
    }
    Z invfac(int m) {
        if (m > n) init(2 * m);
        return _invfac[m];
    }
    Z inv(int m) {
        if (m > n) init(2 * m);
        return _inv[m];
    }
    Z binom(int n, int m) {
        if (n < m || m < 0) return 0;
        return fac(n) * invfac(m) * invfac(n - m);
    }
} comb;

constexpr int D = 10;
constexpr int N = 81;
constexpr int LIM = 800;

class Solution {
public:
    int countBalancedPermutations(string s) {
        int n = s.size();

        vector<int> cnt(D);
        vector<int> pre(D + 1);
        vector<int> pre2(D + 1);
        int sum = 0;
        for (int i = 0; i < n; i++) {
            int d = s[i] - '0';
            sum += d;
            cnt[d]++;
        }
        for (int d = 0; d < D; d++) {
            pre[d + 1] = pre[d] + cnt[d];
            pre2[d + 1] = pre2[d] + cnt[d] * d;
        }

        if (sum & 1) {
            return 0;
        }

        int w = sum / 2;
        int e = (n + 1) / 2;
        vector dp(e + 1, vector<Z>(w + 1));
        dp[0][0] = 1;

        int o = n - e;
        for (int d = 0; d < D; d++) {
            if (cnt[d] == 0) {
                continue;
            }
            vector ndp(n, vector<Z>(w + 1));
            for (int ec = 0; ec <= e; ec++) {
                int oc = pre[d] - ec;
                for (int eps = 0; eps <= w; eps++) {
                    int ops = pre2[d] - eps;
                    if (dp[ec][eps].val() == 0) {
                        continue;
                    }
                    // cout << ""DP GOOD: "" << ec << "" "" << eps << "" "" << ops << ""\n"";
                    for (int euse = 0; euse <= cnt[d]; euse++) {
                        int ouse = cnt[d] - euse;
                        if (ec + euse > e) {
                            // cout << ""1\n"";
                            break;
                        }
                        if (eps + euse * d > w) {
                            // cout << ""2\n"";
                            break;
                        }
                        if (oc + ouse > o) {
                            // cout << ""3\n"";
                            continue;
                        }
                        if (ops + ouse * d > w) {
                            // cout << ""4\n"";
                            continue;
                        }
                        // cout << ec + euse << "" "" << eps + euse * d << "" "" << ops + ouse * d << ""\n"";
                        ndp[ec + euse][eps + euse * d] += (dp[ec][eps] * comb.binom(e - ec, euse) * comb.binom(o - oc, ouse));
                    }
                }
            }
            dp = std::move(ndp);
        }

        return dp[e][w].val();
    }
};

#ifdef BROKEN_CODE
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    exec(&Solution::LoveJenney); // CHANGE FOR PROBLEM
}
#endif

// ~ JustJie",1441380513
kavascg,kavascgjmd39,283,3627,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                 
                    ll val = max((ll)a[ni][nj]+1 , abs(top.first) + 1);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441328219
kavascg,kavascgjmd39,283,3628,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;

struct cmp{
bool operator()(pi<ll,pi<ll,ll>>& a, pi<ll,pi<ll,ll>>&b ){
    return abs(a.first) > abs(b.first);
}
};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& a) {
        int n = a.size(), m = a[0].size();
        priority_queue< pi< ll,pi<ll,ll>>, vt<pi<ll,pi<ll,ll>>>, cmp>pq;
        pq.push({0 , {0, 0}});
        vt<vt<ll>>dp(n , vt<ll>(m , 1e18));
        vt<int>dx = {1 , 0 , -1 , 0}, dy = {0, -1 , 0, 1};
        
        while(pq.size()){
            pi<ll,pi<ll,ll>>top = pq.top(); pq.pop();
            // cout << top.second.first <<"" ""<<top.second.second<<"" ""<<top.first<<""   "";
            if(top.second.first == n-1 && top.second.second == m-1){
                return abs(top.first);
            }
            rep(k , 0  , 4){
                int i = top.second.first , j = top.second.second;
                int ni = i + dx[k], nj = j + dy[k];
                if(ni < n && ni >=0 && nj >= 0 && nj < m ){
                    ll x = ((top.first >= 0 )? 1: 2);
                    ll val = max((ll)a[ni][nj]+x , abs(top.first) + x);
                    if(dp[ni][nj] > val){
                        dp[ni][nj] = val;
                        if(top.first >= 0){
                        pq.push({-val, {ni, nj}});}
                        else {
                            pq.push({val, {ni, nj}});
                        }
                    }
                }
            }
        }
        return 1e9;
    }
};",1441327440
kavascg,kavascgjmd39,283,3636,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
class Solution {
public:
    bool isBalanced(string s) {
        ll sum1 = 0, sum2 = 0;
     for(int i = 0 ; i<s.size() ; i++ ){
         if(i & 1){
             sum1 += s[i]-'0';
         }
         else {
             sum2 += s[i]-'0';
         }
     }
        return sum1 == sum2;
    }
};",1441282187
kavascg,kavascgjmd39,283,3637,cpp,"#define ll long long 
#define all(a) a.begin(), a.end()
#define rep(i, a, b) for (ll i = a; i < b; i++)
#define repr(i , n, a) for(ll i =n ; i >= a; i--)
#define pi pair
#define vt vector
const ll N = 2e5 + 5;
const ll mod = 1e9 + 7;
int dp[10][81][721];
vector<ll> fac, inv_fac;
ll binexpo(ll x, ll y, ll mod) {
    ll res = 1;
    while (y > 0) {
        if (y & 1)
            res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
void precompute_factorials(ll n, ll mod) {
    fac.resize(n + 1);
    inv_fac.resize(n + 1);
    fac[0] = fac[1] = 1;
    for (ll i = 2; i <= n; i++) {
        fac[i] = fac[i - 1] * i % mod;
    }
    inv_fac[n] = binexpo(fac[n], mod - 2, mod);
    for (ll i = n - 1; i >= 0; i--) {
        inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
    }
}

class Solution {
    int count(vt<int>&a, int i , int len , int sum , int n, int s){
        if(i == 10){
            if(len == n/2 && sum == s){
                return (fac[n/2]*fac[n-n/2])%mod;
            }
            return 0;
        }
        if(dp[i][len][sum] != -1){
            return dp[i][len][sum];
        }
        ll res = 0;
        for(int j = 0  ; j<a[i]+1 ; j++){
            res += (ll)count(a, i+1 , len+j , sum + j*i, n, s) * (ll)(((ll)inv_fac[j] * (ll)inv_fac[a[i]-j]) % mod); res %= mod;
        }
        return dp[i][len][sum] = res;
    }
public:
    int countBalancedPermutations(string a) {
        memset(dp, -1 , sizeof(dp));
        precompute_factorials(81, mod);
        vt<int>v(10, 0);
        ll sum = 0;
        rep(i , 0 , a.size()){
           v[a[i]-'0']++;
            sum += (a[i]-'0');
        }
        if(sum & 1){return 0;}
        sum /= 2;
        ll res = count(v, 0 , 0 ,0 , a.size(), sum  );
       
        return res;
    }
};",1441382036
leetcode_3604,leetcode_3604,284,3627,cpp,"class Solution {
public:
       typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 1;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441387316
leetcode_3604,leetcode_3604,284,3628,cpp,"class Solution {
public:
   typedef long long LL;
    int s[760][760][2];
    int minTimeToReach(vector<vector<int>>& moveTime) {
        memset(s, -1, sizeof(s));
        int n = moveTime.size();
        int m = moveTime[0].size();
        const LL offset = 750 * 750 * 2;
        priority_queue<LL, vector<LL>, greater<LL>> pq;
        pq.push(0);
        int dx[4] = {1, -1, 0, 0};
        int dy[4] = {0, 0, 1, -1};
        while(!pq.empty()) {
            LL v = pq.top(); pq.pop();
            LL cost = v / offset;
            int r = v % offset / 2 / m;
            int c = v % offset / 2  % m;
            int st = v % 2;
            //printf(""%d %d %d %d\n"", r, c, st, cost);
            if(r == n-1 && c == m-1) return cost;
            for(int i = 0; i < 4; ++i) {
                int nr = r + dx[i];
                int nc = c + dy[i];
                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                LL new_cost = cost + 1;
                if (st == 1) new_cost = cost + 2;
                if (cost < moveTime[nr][nc]) new_cost  = (new_cost - cost) + moveTime[nr][nc];
                if(s[nr][nc][!st] == -1 || s[nr][nc][!st] > new_cost) {
                    s[nr][nc][!st] = new_cost;
                    pq.push(new_cost * offset + (nr * m + nc) * 2 + !st);
                }
            }
        }
        return -1;
    }
};",1441386429
leetcode_3604,leetcode_3604,284,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int odd(0), even(0);
        for(int i = 0; i < num.size(); ++i) {
            if(i&1) odd += num[i]-'0';
            else even += num[i]-'0';
        }
        return odd == even;
    }
};",1441389379
leetcode_3604,leetcode_3604,284,3637,cpp,"class Solution {
public:
    typedef long long LL;
    LL dp[11][81][810];
    LL mod = 1000000007;
    LL C[90][90];
    int cnt[10];
    int countBalancedPermutations(string s) {
        memset(cnt, 0, sizeof(cnt));
        int sum(0);
        for(auto ch: s) {
            ++cnt[ch - '0'];
            sum += ch - '0';
        }
        if(sum % 2 == 1) return 0;
        memset(C, 0, sizeof(C));
        C[0][0] = 1;
        for(int i = 1; i <= 80; ++i) {
            C[i][0] = 1;
            for(int j = 1; j <= 80; ++j) {
                C[i][j] = C[i-1][j] + C[i-1][j-1];
                C[i][j]  %= mod;
            }
        }
        memset(dp, 0, sizeof(dp));
        //printf(""%lld %lld\n"", C[4][2], C[5][2]);
        int n = s.size();
        dp[0][0][0] = 1;
        int t(0);
        for(int i = 0; i < 10; ++i) {
            for(int j = 0; j <= cnt[i]; ++j) {
                //printf(""%d %d %d\n"", i, j, cnt[i]);
                for(int l = 0; j + l <= n/2; ++l) {
                    for(int k = 0; k + j * i <= sum/2; ++k) {
                        if(n-n/2 - (t - l) < 0) continue;
                        // 
                        dp[i+1][l+j][k+j*i] += C[n/2 - l][j] * C[n-n/2 - (t - l)][cnt[i]-j] % mod * dp[i][l][k] % mod;
                        dp[i+1][l+j][k+j*i] %= mod;
                        //printf(""%d %d %d %d %lld %lld\n"", i, j, l, k, dp[i+1][l+j][k+j*i], dp[i][l][k]);
                    }// 1254, 2145, 5214, 5412, 
                    // 2 * 2 * 2
                }
            }
            t += cnt[i];
        }
        LL ans = dp[10][n/2][sum/2] % mod;
        int f(0);
        for(int i = 0;i < 10; ++i) if (cnt[i] > 0) ++f;
        //if (n % 2 == 0 && f > 1) ans = ans * 2 % mod;
        return ans;
    }
};",1441356783
Sk Najir,Najir581,285,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        set<pair<int, pair<int, int>>> st;
        st.insert({0, {0, 0}});
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;
        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());
            int x = it.first;
            int i = it.second.first;
            int j = it.second.second;
            if (i == n - 1 and j == m - 1)
                return max(x , v[n - 1][m - 1]);
            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 and b >= 0 and a < n and b < m and vis[a][b] == 0) {
                    st.insert({max(x + 1, v[a][b]+1), {a, b}});
                    vis[a][b] = 1;
                }
            }
        }
        return 1;
    }
};",1441318252
Sk Najir,Najir581,285,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& v) {
        int n = v.size();
        int m = v[0].size();
        int r[] = {0, 0, -1, 1};
        int c[] = {1, -1, 0, 0};
        
        set<pair<int, pair<int, pair<int, int>>>> st;
        st.insert({0, {1, {0, 0}}});
        
        vector<vector<int>> vis(n, vector<int>(m, 0));
        vis[0][0] = 1;

        while (!st.empty()) {
            auto it = *st.begin();
            st.erase(st.begin());

            int x = it.first;
            int op = it.second.first;
            int i = it.second.second.first;
            int j = it.second.second.second;

            if (i == n - 1 && j == m - 1) {
                return max(x, v[n - 1][m - 1]);
            }

            for (int k = 0; k < 4; k++) {
                int a = i + r[k], b = j + c[k];
                if (a >= 0 && b >= 0 && a < n && b < m && vis[a][b] == 0) {
                    vis[a][b] = 1;
                    if (op == 1) {
                        st.insert({max(x + 1, v[a][b] + 1), {2, {a, b}}});
                    } else {
                        st.insert({max(x + 2, v[a][b] + 2), {1, {a, b}}});
                    }
                }
            }
        }
        // Add return statement for when no path is found to the destination.
        return -1;
    }
};
",1441335699
Sk Najir,Najir581,285,3636,cpp,"class Solution {
public:
    bool isBalanced(string s) {
        int n=s.size();
        int sm1=0,sm2=0;
        for(int i=0;i<n;i++){
            if(i%2)sm1+=(s[i]-'0');
            else sm2+=(s[i]-'0');
        }
        return sm1==sm2;
    }
};",1441283378
Sk Najir,Najir581,285,3637,cpp,"const int MOD = 1e9 + 7;
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
template<const int mod>
struct mint {
    int val;
    constexpr mint(long long x = 0) : val((x % mod + mod) % mod) {}
    explicit operator int() const { return val; }
    mint& operator+=(const mint &b) { val += b.val; val -= mod * (val >= mod); return *this; }
    mint& operator-=(const mint &b) { val -= b.val; val += mod * (val < 0); return *this; }
    mint& operator*=(const mint &b) { val = 1ll * val * b.val % mod; return *this; }
    mint& operator/=(const mint &b) { return *this *= b.inv(); }
    mint inv() const { int x = 1, y = 0, t; for(int a=val, b=mod; b; swap(a, b), swap(x, y)) t = a/b, a -= t * b, x -= t * y; return mint(x); }
    mint power(int b) const { mint a = *this, res(1); for(; b; a *= a, b /= 2)  if(b & 1) res *= a; return res; }
    mint operator-() const { return val == 0 ? 0 : mod - val; }
    mint& operator++() { val = val == mod - 1 ? 0 : val + 1; return *this; }
    mint& operator--() { val = val == 0 ? mod - 1 : val - 1; return *this; }
    mint operator++(int32_t) { mint before = *this; ++*this; return before; }
    mint operator--(int32_t) { mint before = *this; --*this; return before; }
    friend mint operator+(const mint &a, const mint &b) {return mint(a) += b;}
    friend mint operator-(const mint &a, const mint &b) {return mint(a) -= b;}
    friend mint operator*(const mint &a, const mint &b) {return mint(a) *= b;}
    friend mint operator/(const mint &a, const mint &b) {return mint(a) /= b;}
    friend bool operator==(const mint &a, const mint &b) {return a.val == b.val;}
    friend bool operator!=(const mint &a, const mint &b) {return a.val != b.val;}
    friend bool operator<(const mint &a, const mint &b) {return a.val < b.val;}
    friend istream& operator>>(istream &in, mint &a) {return in >> a.val;}
    friend ostream& operator<<(ostream &os, const mint &a) {return os << a.val;}
};
using Mint = mint<MOD>;
 
namespace comb {
    int n(0);
    vector<Mint> _fac{1}, _invfac{1}, _inv{0};
    void init(int m) {
        m = min (m, MOD - 1);
        if (m <= n) return;
        _fac.resize(m + 1); _invfac.resize(m + 1); _inv.resize(m + 1);
        for (int i = n + 1; i <= m; i++) _fac[i] = _fac[i - 1] * i;
        _invfac[m] = _fac[m].inv();
        for (int i = m; i > n; i--) _invfac[i - 1] = _invfac[i] * i, _inv[i] = _invfac[i] * _fac[i - 1];
        n = m;
    }
    Mint fac(int m) { if (m > n) init(2 * m); return _fac[m]; }
    Mint invfac(int m) { if (m > n) init(2 * m); return _invfac[m]; }
    Mint inv(int m) { if (m > n) init(2 * m); return _inv[m]; }
    Mint ncr(int n, int r) { if (n < r || r < 0) return 0; return fac(n) * invfac(r) * invfac(n - r); }
}
using comb::fac;
using comb::inv;
using comb::invfac;
using comb::ncr;
// shortcut type
typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef vector<vi> vii;
typedef vector<ll> vl;
typedef vector<vl> vll;
typedef pair<int, int> pi;
typedef pair<ll, ll> pl;

// Constants
class Solution {
int dp[82][1600][60];
string s;
int odd;
int f(int i,int sm,int odnum){
    if(odnum>odd)return 0;
    if(i<0){
        if(odd==odnum){
            return sm==0;
        }
        return 0;
    }
if(dp[i][sm+1000][odnum]!=-1)return dp[i][sm+1000][odnum];
    int x=f(i-1,sm+(s[i]-'0'),odnum+1);
    int y=f(i-1,sm-(s[i]-'0'),odnum);

    return dp[i][sm+1000][odnum]=((0LL+x+y)%MOD);
    
}
vi fact;
void pre(){
    fact.resize(90);
    fact[0]=1;
    for(int i=1;i<=89;i++){
        fact[i]=(1LL*fact[i-1]*i)%MOD;
    }
}
public:

    int countBalancedPermutations(string num) {
        pre();
        s=num;
        memset(dp,-1,sizeof(dp));
        int n=s.size();
        odd=n/2;
     map<int,int>m;
        for(auto it:s){
            m[it-'0']++;
        }
      int ans= f(n-1,0,0);
        ans=max(ans,0);
        //cout<<ans<<endl;
        Mint a=ans;
        a=(a*fact[odd]*fact[n-odd]);
        for(auto it:m){
            a=(a/(Mint)fact[it.second]);
        }
        return (int)a;
        
        
    }
};",1441395990
Michael Bao,tcmmichaelb139,286,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, -1));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            ans[v.first][v.second] = dist;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                q.push({max(dist + 1, moveTime[x][y]+1), {x, y}});
            }
        }
        for (int i= 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << ans[i][j] << "" \n""[j+1 == m];
            }
        }
        return ans[n-1][m-1];
    }
};",1441313231
Michael Bao,tcmmichaelb139,286,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        vector<int> dx = {1, 0, -1, 0}, dy = {0, 1, 0, -1};
        int n = size(moveTime);
        int m = size(moveTime[0]);
        vector<vector<int>> ans(n, vector<int>(m, 2e9));
        vector<vector<int>> vis(n, vector<int>(m, 0));
        ans[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> q;
        q.push({0, {0, 0}});
        while (!q.empty()) {
            int dist; pair<int, int> v;
            tie(dist, v) = q.top();
            q.pop();
            if (vis[v.first][v.second]) continue;
            vis[v.first][v.second] = true;
            if (v.first == n && v.second == m) break;
            for (int a = 0; a < 4; a++) {
                int x = v.first + dx[a], y = v.second + dy[a];
                if (x < 0 || y < 0 || x >= n || y >= m) continue;
                if (vis[x][y]) continue;
                int add = v.first+v.second;
                int ndist = max(dist, moveTime[x][y]) + 1+(add&1);
                if (ans[x][y] <= ndist) continue;
                ans[x][y] = ndist;
                q.push({ndist, {x, y}});
            }
        }
        return ans[n-1][m-1];
    }
};",1441328073
Michael Bao,tcmmichaelb139,286,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int osum = 0;
        int esum = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i&1) osum += num[i]-'0';
            else esum += num[i]-'0';
        }
        return osum == esum;
    }
};",1441284864
Michael Bao,tcmmichaelb139,286,3637,cpp,"class Solution {
public:
    long long MOD = 1e9+7;
    long long add(long long a, long long b) { return (a+b)%MOD;}
    long long mult(long long a, long long b) { return a*b%MOD; }

    long long binpow(long long a, long long b) {
        long long ret = 1;
        while (b) {
            if (b & 1) ret = mult(ret, a);
            a = mult(a, a);
            b >>=1;
        }
        return ret;
    }
    long long fac[50], inv[50];
    void init() {
        fac[0] = 1;
        fac[1] = 1;
        inv[0] = 1;
        inv[1] = 1;
        for (int i = 2; i < 50; i++) {
            fac[i] = mult(i, fac[i-1]);
            inv[i] = binpow(fac[i], MOD-2);
        }
    }
    long long nCr(long long a, long long b) {
        return mult(fac[a], mult(inv[b], inv[a-b]));
    }
    int countBalancedPermutations(string num) {
        init();
        int n = num.length();
        int sum = 0;
        map<int, int> cnt;
        for (int i = 0; i < n; i++) {
            sum += num[i]-'0';
            cnt[num[i]-'0']++;
        }
        int halfsum = sum/2+1;
        if (sum & 1) return 0;
        long long dp[11][halfsum][n/2+1];
        memset(dp, 0ll, sizeof dp);
        dp[0][0][0] = 1;
        int rem = 0;
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < halfsum;j++) {
                for (int k = 0; k <= n/2; k++) {
                    for (int a = 0; a <= cnt[i]; a++) {  
                        if (j + a*i >= halfsum) break;
                        if (k + a > n/2) break;
                        int kalt = rem - k;
                        if (kalt < 0) continue;
                        if ((n+1)/2 < cnt[i]-a + kalt) continue;
                        assert(n/2-k >= a);
                        assert((n+1)/2-kalt >= cnt[i]-a);
                        // cout << i << ' ' << j << ' ' << k << ' ' << kalt << ' ' << a << ' ' << dp[i][j][k] << '\n';
                        dp[i+1][j+a*i][k+a] = add(dp[i+1][j+a*i][k+a], 
                            mult(dp[i][j][k], 
                            mult(nCr(n/2-k, a), nCr(((n+1)/2)-kalt, cnt[i]-a))));
                    }
                }
            }
            rem += cnt[i];
        }
        return dp[10][halfsum-1][n/2];
    }
};",1441389966
quynhit,quynhit,287,3627,cpp,"#include <vector>
#include <queue>
#include <limits>

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int R = moveTime.size();
        int C = moveTime[0].size();
        
        vector<vector<int>> dist(R, vector<int>(C, numeric_limits<int>::max()));
        auto cmp = [](const array<int, 3>& a, const array<int, 3>& b) { return a[0] > b[0]; };
        priority_queue<array<int, 3>, vector<array<int, 3>>, decltype(cmp)> pq(cmp);
        
        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        auto inside = [&](int r, int c) -> bool{
            return r >= 0 && r < R && c >= 0 && c < C;
        };
        
        while (!pq.empty()) {
            auto curr = pq.top();
            pq.pop();
            int time = curr[0], row = curr[1], col = curr[2];
            if (time > dist[row][col]) continue;
            for(int dir = 0; dir < 4; dir++){
                int newRow = row + dx[dir];
                int newCol = col + dy[dir];
                
                if (inside(newRow, newCol)) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[R - 1][C - 1];
    }
};",1441329395
quynhit,quynhit,287,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        #define int long long
        int n = moveTime.size(), m = moveTime[0].size();
        auto inside = [&](int r, int c){
            return r >= 0 && r < n && c >= 0 && c < m;
        };
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, LLONG_MAX)));
        d[0][0][0] = 0;
        priority_queue<pair<int, vector<int>>, vector<pair<int, vector<int>>>, greater<>> q;
        q.push({0, {0, 0, 0}});
        const int dx[4] = {1, 0, -1, 0};
        const int dy[4] = {0, 1, 0, -1};
        while (!q.empty()) {
            auto [t, v] = q. top();
            q.pop();
            int i = v[0], j = v[1], p = v[2];
            if (t > d[i][j][p]) continue;
            for(int dir = 0; dir < 4; dir++){
                int ni = i + dx[dir], nj = j + dy[dir];
                if (inside(ni, nj)) {
                    int nt = max(t, 1LL * moveTime[ni][nj]) + (p ? 2 : 1);
                    if (nt < d[ni][nj][!p]) {
                        d[ni][nj][!p] = nt;
                        q.push({nt, {ni, nj, !p}});
                    }
                }
            }
        }
        return min(d[n-1][m-1][0], d[n-1][m-1][1]);
        #undef int
    }
};",1441347079
quynhit,quynhit,287,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int even = 0, odd = 0;
        for(int i = 0; i < size(num); i++){
            if(i & 1){
                odd += num[i] - '0';
            } else {
                even += num[i] - '0';
            }
        }
        return even == odd;
    }
};",1441280930
quynhit,quynhit,287,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
#define int long long

int power_mod(int base, int exponent) {
    int result = 1;
    base %= MOD;
    while (exponent > 0) {
        if (exponent & 1) {
            result = result * base % MOD;
        }
        base = base * base % MOD;
        exponent >>= 1;
    }
    return result;
}

class Solution {
public:
    #undef int
    int countBalancedPermutations(string num) {
        #define int long long 
        int total_sum = 0;
        vector<int> frequency(10, 0);
        for (auto c : num) {
            frequency[c - '0']++;
            total_sum += (c - '0');
        }
        if (total_sum & 1) return 0;
        int n = size(num);
        int half_sum = total_sum / 2, half_length = (n + 1) / 2;
        vector<int> factorial(n + 1, 1);
        for (int i = 1; i <= n; i++)
            factorial[i] = factorial[i - 1] * i % MOD;
        vector<int> inverse_factorial(n + 1, 1);
        inverse_factorial[n] = power_mod(factorial[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--)
            inverse_factorial[i] = inverse_factorial[i + 1] * (i + 1) % MOD;
        vector<vector<int>> dp(half_length + 1, vector<int>(half_sum + 1, 0));
        dp[0][0] = 1;
        for (int digit = 0; digit <= 9; digit++) {
            if (frequency[digit] == 0) continue;
            for (int count = half_length; count >= 0; count--)
                for (int sum = half_sum; sum >= 0; sum--) {
                    if (dp[count][sum] == 0) continue;
                    for (int times = 1; times <= min(frequency[digit], half_length - count); times++) {
                        if (sum + digit * times > half_sum) break;
                        int combinations = (factorial[frequency[digit]] * inverse_factorial[times] % MOD) * inverse_factorial[frequency[digit] - times] % MOD;
                        dp[count + times][sum + digit * times] = (dp[count + times][sum + digit * times] + dp[count][sum] * combinations) % MOD;
                    }
                }
        }

        int valid_assignments = dp[half_length][half_sum];
        if (valid_assignments == 0) return 0;
        int product_factorials = 1;
        for (int digit = 0; digit <= 9; digit++)
            product_factorials = product_factorials * factorial[frequency[digit]] % MOD;
        int fk_fnk = (factorial[half_length] * factorial[n - half_length]) % MOD;
        int inv_product_factorials = power_mod(product_factorials, MOD - 2);
        return (((fk_fnk * valid_assignments) % MOD) * inv_product_factorials) % MOD;
        #undef int
    }
};",1441385400
Abhi7527,Abhi7527,288,3627,cpp,"class Solution {
public:
int dirr[4]={-1,0,1,0};
int dirc[4]={0,-1,0,1};
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n=moveTime.size();
        int m=moveTime[0].size();
        vector<vector<int>>dp(moveTime.size(),vector<int>(moveTime[0].size(),INT_MAX));
        queue<pair<int,int>>q;
        dp[0][0]=0;
        q.push({0,0});
        while(!q.empty()){
            int row=q.front().first;
            int col=q.front().second;
            q.pop();
            for(int k=0;k<4;k++){
                int rowi=row+dirr[k];
                int coli=col+dirc[k];
                if(rowi<n && coli<m && rowi>=0 && coli>=0){
                    int l=dp[row][col];
                    int b=moveTime[rowi][coli];
                    int y=max(l,b);
                    if(dp[rowi][coli]>y+1){
                        dp[rowi][coli]=y+1;
                        q.push({rowi,coli});
                    }
                }
            }
        }
        return dp[n-1][m-1];
        
    }
};",1441298215
Abhi7527,Abhi7527,288,3628,cpp,"#include <vector>
#include <queue>
#include <utility>
#include <limits.h>

using namespace std;

class Solution {
public:
    int dirr[4] = {-1, 0, 1, 0};
    int dirc[4] = {0, -1, 0, 1};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));
        priority_queue<pair<int, pair<int, pair<int,int>>>, vector<pair<int, pair<int, pair<int,int>>>>, greater<pair<int, pair<int, pair<int,int>>>>> pq;
        
        dp[0][0] = 0;
        pq.push({0, {0, {0,1}}}); // {time, {row, col}}

        while (!pq.empty()) {
           int dis=pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second.first;
            int step=pq.top().second.second.second;
            pq.pop();

            if (row == n - 1 && col == m - 1) {
                return dis;
            }

            for (int k = 0; k < 4; ++k) {
                int newRow = row + dirr[k];
                int newCol = col + dirc[k];

                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(dis, moveTime[newRow][newCol]);
                    if (dp[newRow][newCol] > newTime+step) {
                        dp[newRow][newCol] = newTime+step;
                        if(step==1){
                        pq.push({ dp[newRow][newCol], {newRow, {newCol,2}}});
                        }
                        else{
                            pq.push({ dp[newRow][newCol], {newRow, {newCol,1}}});
                            
                        }
                    }
                }
            }
        }
        return dp[n - 1][m - 1];
    }
};
",1441319049
Abhi7527,Abhi7527,288,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int a=0;
        int b=0;
        for(int i=0;i<num.size();i++){
            if(i%2==0){
                a+=num[i]-'0';
            }
            else{
                b+=num[i]-'0';
            }
        }
        if(a==b){
            return true;
        }
        return false;
    }
};",1441283773
Abhi7527,Abhi7527,288,3637,cpp,"class Solution {
public:
int mod=1e9+7;
int l;
int lena,lenb;
vector<vector<long long>>pnc;
int yi(vector<vector<long long>>&pn,int n,int r){
    if(n==r || r==0){
        return 1;
    }
    if(pn[n][r]!=-1){
        return pn[n][r];
    }
    return pn[n][r]=(yi(pn,n-1,r)+yi(pn,n-1,r-1))%mod;
}

long long y(vector<vector<vector<long long>>>&dp,int i,int sum,int len,vector<pair<int,int>>&vec,vector<int>&p){
    
    if(i==vec.size()){
        if(sum==0){
       return 1;
    }
        return 0;
    }
    if(dp[i][sum][len]!=-1){
        return dp[i][sum][len];
    }
    long long ans=0;
    int gh=p[i]-len;
    for(int k=0;k<=vec[i].second;k++){
        
        if(len>=k && gh>=vec[i].second-k && sum>=k*vec[i].first){
            
            long long h=(pnc[len][k]*pnc[gh][vec[i].second-k])%mod;
            ans=(ans+h*(y(dp,i+1,sum-k*vec[i].first,len-k,vec,p)%mod))%mod;
        }
    }
    return dp[i][sum][len]=ans%mod;
}

    int countBalancedPermutations(string num) {
        pnc=vector<vector<long long>>(41,vector<long long>(41,-1));
        for(int i=0;i<=40;i++){
            for(int j=0;j<=40;j++){
                if(i>=j){
                     pnc[i][j]=yi(pnc,i,j);
                }
               
            }
        }
        l=num.length();
        unordered_map<int,int>mp;
        int l=0;
        for(auto it:num){
           mp[it-'0']++;
            l+=it-'0';
        }
        vector<pair<int,int>>vec;
        vector<int>p;
        int li=num.length();
        for(auto it:mp){
            p.push_back(li);
            vec.push_back({it.first,it.second});
            li-=it.second;
        }
        
        if(l%2){
            return 0;
        }
        vector<vector<vector<long long>>>dp(vec.size(),vector<vector<long long>>(l/2+1,vector<long long>(num.length()/2+1,-1)));
        return y(dp,0,l/2,num.length()/2,vec,p);
        
    }
};",1441396105
Anshuman Kanungo,PeacefulGuy,291,3627,cpp,"#include <vector>
#include <queue>
#include <climits>
#include <algorithm>

using namespace std;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;

        pq.push({0, 0, 0});
        dist[0][0] = 0;
        
        vector<vector<int>> dirs = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
        
        while (!pq.empty()) {
            vector<int> curr = pq.top();
            pq.pop();
            int time = curr[0];
            int row = curr[1];
            int col = curr[2];

            if (time > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(time, moveTime[newRow][newCol]) + 1;
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, newRow, newCol});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};
",1441372568
Anshuman Kanungo,PeacefulGuy,291,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        // 3D array to store minimum time
        int[][][] d = new int[n][m][2];
        for (int[][] layer : d) {
            for (int[] row : layer) {
                java.util.Arrays.fill(row, Integer.MAX_VALUE);
            }
        }
        d[0][0][0] = 0;

        // Priority queue stores {time, x, y, p}
        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));
        q.offer(new int[]{0, 0, 0, 0}); // {time, x, y, p}

        // Directions for movement (down, right, up, left)
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!q.isEmpty()) {
            int[] current = q.poll();
            int t = current[0];
            int i = current[1];
            int j = current[2];
            int p = current[3];

            if (t > d[i][j][p]) continue;

            for (int[] dir : directions) {
                int ni = i + dir[0];
                int nj = j + dir[1];

                // Check bounds
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                    int nt = Math.max(t, moveTime[ni][nj]) + (p == 1 ? 2 : 1);

                    // Update minimum time if found a better path
                    if (nt < d[ni][nj][1 - p]) {
                        d[ni][nj][1 - p] = nt;
                        q.offer(new int[]{nt, ni, nj, 1 - p}); // Update state
                    }
                }
            }
        }

        // Return the minimum time to reach the bottom-right corner
        return Math.min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
}
",1441345048
Anshuman Kanungo,PeacefulGuy,291,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0;
        int oddSum = 0;

        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0'; // Convert char to integer

            if (i % 2 == 0) { // Even index
                evenSum += digit;
            } else { // Odd index
                oddSum += digit;
            }
        }

        return evenSum == oddSum;
    }
}
",1441292483
Anshuman Kanungo,PeacefulGuy,291,3637,java,"import java.util.Arrays;

class Solution {
    private static final int MOD = 1000000007;
    private long[] fact;
    private long[] invFact;

    private long powerMod(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerMod(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        long totalSum = 0;
        int[] freq = new int[10];

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;
        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;

        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = (fact[freq[d]] * invFact[t] % MOD) * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = (fact[k] * fact[n - k]) % MOD;
        long invProdFactFd = powerMod(prodFactFd, MOD - 2);
        long answer = (fkFnk * validAssignments) % MOD;
        answer = (answer * invProdFactFd) % MOD;

        return (int) answer;
    }
}
",1441381843
Titas,ads3k,294,3627,python3,"from heapq import heappush, heappop
from typing import List

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        # Array to store minimum time to reach each cell
        dp = [[float('inf')] * m for _ in range(n)]
        dp[0][0] = 0

        # Priority queue to store (current_time, row, col)
        pq = [(0, 0, 0)]

        # Directions: right, down, left, up
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while pq:
            curr_time, row, col = heappop(pq)

            # If we've reached the target
            if row == n - 1 and col == m - 1:
                return curr_time

            # Skip if we've found a better path
            if curr_time > dp[row][col]:
                continue

            # Try all possible directions
            for dx, dy in directions:
                new_row, new_col = row + dx, col + dy

                # Check if new position is within bounds
                if 0 <= new_row < n and 0 <= new_col < m:
                    # Calculate waiting time if needed
                    wait_time = max(0, moveTime[new_row][new_col] - curr_time)
                    next_time = curr_time + wait_time + 1  # Add 1 for movement

                    # Update if we found a better path
                    if next_time < dp[new_row][new_col]:
                        dp[new_row][new_col] = next_time
                        heappush(pq, (next_time, new_row, new_col))

        return dp[n - 1][m - 1]
",1441303344
Titas,ads3k,294,3628,python3,"import heapq

class Solution(object):
    # Dummy functions
    def dummyFunc1(self): pass
    def dummyFunc2(self): pass
    def dummyFunc3(self): pass
    def dummyFunc4(self): pass
    def dummyFunc5(self): pass
    def dummyFunc6(self): pass
    def dummyFunc7(self): pass
    def dummyFunc8(self): pass
    def dummyFunc9(self): pass
    def dummyFunc10(self): pass

    def minTimeToReach(self, mt):
        # Dummy variables
        a1, a2, a3, a4, a5, a6, a7, a8, a9, a0 = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        n = len(mt)
        m = len(mt[0])
        
        d = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        d[0][0][0] = 0

        pq = [(0, (0, 0, 0))]

        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while pq:
            t, (i, j, p) = heapq.heappop(pq)
            if t > d[i][j][p]:
                continue

            d_idx = 0  # Loop variable for direction indexing
            while d_idx < len(directions):
                di, dj = directions[d_idx]
                ni, nj = i + di, j + dj

                if 0 <= ni < n and 0 <= nj < m:
                    nt = max(t, mt[ni][nj]) + (2 if p else 1)
                    
                    if nt < d[ni][nj][1 - p]:
                        d[ni][nj][1 - p] = nt
                        heapq.heappush(pq, (nt, (ni, nj, 1 - p)))

                d_idx += 1  # Increment direction index

        return min(d[n-1][m-1][0], d[n-1][m-1][1])
",1441376394
Titas,ads3k,294,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        # Dummy variables
        a, b, c, d, e, f, g, h, i, j = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        
        # Dummy functions
        def dummy_func1(): pass
        def dummy_func2(): pass
        def dummy_func3(): pass
        def dummy_func4(): pass
        def dummy_func5(): pass
        def dummy_func6(): pass
        def dummy_func7(): pass
        def dummy_func8(): pass
        def dummy_func9(): pass
        def dummy_func10(): pass
        
        # Actual solution
        even_sum, odd_sum = 0, 0
        idx = 0
        length = len(num)
        
        while idx < length:
            digit = int(num[idx])
            if idx % 2 == 0:
                even_sum += digit
            else:
                odd_sum += digit
            idx += 1
            
        return even_sum == odd_sum
",1441293345
Titas,ads3k,294,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact;
vector<ll> inv_fact;

// Dummy variables
ll a1, a2, a3, a4, a5, a6, a7, a8, a9, a0;

ll power_mod_func(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    int i = 1; // Loop variable for while loop
    while (i <= n) {
        fact[i] = fact[i - 1] * i % MOD;
        i++;
    }
    inv_fact.assign(n + 1, 1);
    inv_fact[n] = power_mod_func(fact[n], MOD - 2);
    i = n - 1; // Reset loop variable for another while loop
    while (i >= 0) {
        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        i--;
    }
}

class Solution {
public:
    // Dummy functions
    void dummyFunc1() {}
    void dummyFunc2() {}
    void dummyFunc3() {}
    void dummyFunc4() {}
    void dummyFunc5() {}
    void dummyFunc6() {}
    void dummyFunc7() {}
    void dummyFunc8() {}
    void dummyFunc9() {}
    void dummyFunc10() {}

    int countBalancedPermutations(string num) {
        int n = num.size();
        string s1 = num; // Replacing variable names with single-character ones
        string s2 = num;

        int freq[10] = {0};
        ll total_sum = 0;
        for (char c : num) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        ll sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(sum_half + 1, 0));
        dp[0][0] = 1;

        int d = 0; // Loop variable for the outer loop
        while (d <= 9) {
            if (freq[d] == 0) {
                d++;
                continue;
            }
            int c = k; // Loop variable for the next loop
            while (c >= 0) {
                ll s = sum_half; // Reset loop variable for the innermost loop
                while (s >= 0) {
                    if (dp[c][s] == 0) {
                        s--;
                        continue;
                    }
                    int t = 1; // Loop variable for the combination
                    while (t <= min(freq[d], k - c)) {
                        if (s + (ll)d * t > sum_half) break;
                        ll comb = (fact[freq[d]] * inv_fact[t] % MOD) * inv_fact[freq[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                        t++;
                    }
                    s--;
                }
                c--;
            }
            d++;
        }

        ll valid_assignments = dp[k][sum_half];
        if (valid_assignments == 0) return 0;

        ll prod_fact_fd = 1;
        int f = 0; // Loop variable for the product calculation
        while (f <= 9) {
            prod_fact_fd = prod_fact_fd * fact[freq[f]] % MOD;
            f++;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_prod_fact_fd = power_mod_func(prod_fact_fd, MOD - 2);
        ll answer = (fk_fnk * valid_assignments) % MOD;
        answer = (answer * inv_prod_fact_fd) % MOD;

        return (int)answer;
    }
};
",1441375573
Sagnik Goswami,sagi_1523,295,3627,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<ppi, vector<ppi>, greater<ppi>> pq;  // {time, {row, col}}

        pq.push({0, {0, 0}});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it.first;
            int row = it.second.first;
            int col = it.second.second;

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);
                    
                    int newTime = waitTime + 1;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, {adjRow, adjCol}});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441339781
Sagnik Goswami,sagi_1523,295,3628,cpp,"typedef pair<int, pair<int, int>> ppi;
class Solution {
private:
    bool isValid(int row, int col, int m, int n) {
        if (row < 0 || row >= m) return false;
        if (col < 0 || col >= n) return false;
        return true;
    }
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size(), n = moveTime[0].size();
        
        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;  // {time, row, col, prevMovePt (1 or 2)}

        pq.push({0, 0, 0, 2});
        dist[0][0] = 0;
        
        int dRow[4] = {-1, 1, 0, 0};
        int dCol[4] = {0, 0, -1, 1};
        
        while (!pq.empty()) {
            auto it = pq.top(); pq.pop();
            int currTime = it[0];
            int row = it[1];
            int col = it[2];
            int prevMoveTime = it[3];

            if (currTime > dist[row][col]) continue;
            
            for (int i = 0; i < 4; i++) {
                int adjRow = row + dRow[i];
                int adjCol = col + dCol[i];
                
                if (isValid(adjRow, adjCol, m, n)) {
                    int waitTime = max(currTime, moveTime[adjRow][adjCol]);

                    int timeMove = (prevMoveTime == 1) ? 2 : 1;
                    int newTime = waitTime + timeMove;
                    
                    if (newTime < dist[adjRow][adjCol]) {
                        dist[adjRow][adjCol] = newTime;
                        pq.push({newTime, adjRow, adjCol, timeMove});
                    }
                }
            }
        }
        
        return dist[m - 1][n - 1];
    }
};",1441338982
Sagnik Goswami,sagi_1523,295,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sumEven = 0, sumOdd = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sumOdd += num[i] - '0';
            else sumEven += num[i] - '0';
        }

        return sumEven == sumOdd;
    }
};",1441281467
Sagnik Goswami,sagi_1523,295,3637,cpp,"class Solution {
private:
    const int MOD = 1e9 + 7;
    vector<long long> fact;
    
    void precomputeFactorials(int n) {
        fact.resize(n + 1);
        fact[0] = 1;
        for(int i = 1; i <= n; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }
    }
    
    long long modPow(long long base, int exp) {
        long long result = 1;
        while (exp > 0) {
            if (exp & 1) result = (result * base) % MOD;
            base = (base * base) % MOD;
            exp >>= 1;
        }
        return result;
    }
    
    vector<vector<vector<int>>> dp;
    vector<int> freq, remFreq;
    string num;
    int n;
    
    int solve(int pos, int sumNeeded, int remLen) {
        if (sumNeeded < 0 || remLen < 0) return 0;
        if (pos == n) return (remLen == 0 && sumNeeded == 0);
        
        if (dp[pos][sumNeeded][remLen] != -1) 
            return dp[pos][sumNeeded][remLen];
        
        long long res = solve(pos + 1, sumNeeded, remLen);
        
        int digit = num[pos] - '0';
        if (remFreq[digit] > 0) {
            remFreq[digit]--;
            freq[digit]++;
            
            res = (res + solve(pos + 1, sumNeeded - digit, remLen - 1)) % MOD;
            
            freq[digit]--;
            remFreq[digit]++;
        }
        
        return dp[pos][sumNeeded][remLen] = res;
    }
    
    long long getPermutations() {
        long long evenDenominator = 1, oddDenominator = 1;
        
        for (int i = 0; i < 10; i++) {
            if (freq[i]) evenDenominator = (evenDenominator * fact[freq[i]]) % MOD;
            if (remFreq[i]) oddDenominator = (oddDenominator * fact[remFreq[i]]) % MOD;
        }
        
        long long evenWays = (fact[(n + 1) / 2] * modPow(evenDenominator, MOD - 2)) % MOD;
        long long oddWays = (fact[n / 2] * modPow(oddDenominator, MOD - 2)) % MOD;
        return (evenWays * oddWays) % MOD;
    }
    
public:
    int countBalancedPermutations(string s) {
        num = s;
        n = num.length();
        
        int sum = 0;
        freq.assign(10, 0);
        remFreq.assign(10, 0);
        
        for (char c : num) {
            sum += c - '0';
            remFreq[c - '0']++;
        }
        
        if (sum & 1) return 0;
        
        int halfSum = sum / 2;
        int evenPos = (n + 1) / 2;
        
        dp.assign(n + 1, vector<vector<int>>(halfSum + 1, vector<int>(evenPos + 1, -1)));
        precomputeFactorials(n);
        
        int ways = solve(0, halfSum, evenPos);
        if (ways == 0) return 0;
        
        return (ways * getPermutations()) % MOD;
    }
};",1441389799
Jaeha Yi,jaehayi1,296,3627,python3,"from heapq import heapify, heappush, heappop

class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        '''
        greedy, sort by moveTime
        '''

        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[2e9] * m for _ in range(n)]
        dp[0][0] = 0
        heappush(pq, (0, 0, 0))

        vis = set()

        while pq:
            t, i, j = heappop(pq)

            if (i, j) in vis: continue
            vis.add((i, j))

            if i + 1 < n: 
                dp[i + 1][j] = min(dp[i + 1][j], max(dp[i][j] + 1, moveTime[i + 1][j] + 1))
                heappush(pq, (dp[i + 1][j], i + 1, j))
                
            if j + 1 < m: 
                dp[i][j + 1] = min(dp[i][j + 1], max(dp[i][j] + 1, moveTime[i][j + 1] + 1))
                heappush(pq, (dp[i][j + 1], i, j + 1))

            if i - 1 >= 0: 
                dp[i - 1][j] = min(dp[i - 1][j], max(dp[i][j] + 1, moveTime[i - 1][j] + 1))
                heappush(pq, (dp[i - 1][j], i - 1, j))

            if j - 1 >= 0: 
                dp[i][j - 1] = min(dp[i][j - 1], max(dp[i][j] + 1, moveTime[i][j - 1] + 1))
                heappush(pq, (dp[i][j - 1], i, j - 1))

            # print(pq)

        # print(dp)

        return dp[n - 1][m - 1]
                ",1441311233
Jaeha Yi,jaehayi1,296,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        pq = []
        heapify(pq)

        n = len(moveTime)
        m = len(moveTime[0])

        dp = [[[2e9] * 2 for _ in range(m)] for _ in range(n)]
        dp[0][0][0] = 0
        heappush(pq, (0, 0, 0, 0))

        vis = set()

        while pq:
            t, i, j, mode = heappop(pq)

            if (i, j, mode) in vis: continue
            vis.add((i, j, mode))
            mode2 = (mode + 1) % 2
            add = (1 if mode == 0 else 2)

            for i2, j2 in [(i + 1, j), (i, j + 1), (i - 1, j), (i, j - 1)]: 
                if i2 < 0 or j2 < 0 or i2 >= n or j2 >= m: continue
                    
                dp[i2][j2][mode2] = min(dp[i2][j2][mode2], max(dp[i][j][mode] + add, moveTime[i2][j2] + add))
                heappush(pq, (dp[i2][j2][mode2], i2, j2, mode2))

        return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]) ",1441324275
Jaeha Yi,jaehayi1,296,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)): 
            x = int(num[i])
            if i % 2 == 0: 
                # print(""even"", x)
                even += x
            else: 
                odd += x

        if even == odd: 
            return True
        return False",1441282985
Jaeha Yi,jaehayi1,296,3637,python3,"import math
from collections import Counter

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        '''
        max sum = 80 * 9 / 2 = ~ 360

        dp[sum1][i] = num ways to achieve sums1 with i numbers used in sum1

        Two options: 
            keep number i in sum1, or throw away (put in sum2)

        Space complexity: 360 * 360 * 80 = 10^7
        '''

        mod = int(1e9 + 7)
        n = len(num)
        sn = sum([int(num[i]) for i in range(n)])
        if sn % 2 != 0: return 0
        
        goal = sn // 2

        dp = [[0] * (n // 2 + 1) for _ in range(goal + 1)]
        dp[0][0] = 1
        if int(num[0]) <= goal: dp[int(num[0])][1] = 1
        
        for i in range(1, n): 
            d = int(num[i])
            for x in range(goal, -1, -1): 
                for j in range(i + 1, -1, -1): 
                    if x - d >= 0 and j - 1 >= 0 and j < (n // 2 + 1): 
                        dp[x][j] = (dp[x][j] + dp[x - d][j - 1]) 
        
        factor = (math.factorial(n // 2) * math.factorial(n - n // 2))
        res = dp[goal][n // 2] * factor
        
        c = Counter(num)
        for d in c: 
            res = res // math.factorial(c[d])
        
        return res % mod
                
                

        ",1441391166
Edwin Chen,echen5503,297,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0] = 0
        while pq:
            time, i, j = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+1
                if dist[x, y] > t:
                    dist[x, y] = t
                    heapq.heappush(pq, (t, x, y))

        return dist[n-1, m-1]
                ",1441293027
Edwin Chen,echen5503,297,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        
        pq = [(0, 0, 0, 0)]
        dist = defaultdict(lambda: 1e10)
        dist[0,0,0] = 0
        while pq:
            time, i, j, state = heapq.heappop(pq)
            

            for (x, y) in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:
                if x < 0 or x >= n or y < 0 or y >= m:
                    continue
                t = max(time, moveTime[x][y])+state+1
                if dist[x, y, state^1] > t:
                    dist[x, y, state^1] = t
                    heapq.heappush(pq, (t, x, y, state^1))

        return min(dist[n-1, m-1, 0], dist[n-1, m-1, 1])
                ",1441295224
Edwin Chen,echen5503,297,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        a = sum(int(x) for x in num[0:n:2])
        b = sum(int(x) for x in num[1:n:2])

        return a == b",1441281001
Edwin Chen,echen5503,297,3637,python3,"M = int(1e9+7)
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        num = list(int(x) for x in num)
        n = len(num)
        cnt = Counter(num)
        tot = sum(num)

        if tot % 2 != 0:
            return 0

        @cache
        def fact(n):
            return 1 if n == 0 else n*fact(n-1)

        def inv(x):
            return pow(x, M-2, M)
            
        @cache
        def dp(i, s, used):
            if i == 10:
                if s == tot//2 and (used == n//2 or used == ceil(n/2)):
                    return (fact(used) * fact(n-used)) % M
                return 0

            if used > ceil(n/2):
                return 0
            if s > tot//2:
                return 0
            if sum(cnt[x] for x in range(i, 10)) + used < n//2:
                return 0
            ans = 0
            for amt in range(0, cnt[i]+1):
                ans += dp(i+1, s+amt*i, used+amt) * inv(fact(amt)) * inv(fact(cnt[i]-amt))
                ans %= M
            return ans
            
        ans = dp(0, 0, 0)
        if n % 2 == 1:
            ans *= inv(2)
            ans %= M
        return ans",1441392050
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3627,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] travelTime) { // Renamed to match the call
        int rows = travelTime.length;
        int cols = travelTime[0].length;
        int[][] minTime = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            Arrays.fill(minTime[i], Integer.MAX_VALUE);
        }

        PriorityQueue<int[]> queue = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));

        queue.offer(new int[]{0, 0, 0});
        minTime[0][0] = 0;

        int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int currentTime = current[0];
            int x = current[1];
            int y = current[2];

            if (currentTime > minTime[x][y]) continue;

            for (int[] dir : directions) {
                int newX = x + dir[0];
                int newY = y + dir[1];

                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {
                    int updatedTime = Math.max(currentTime, travelTime[newX][newY]) + 1;

                    if (updatedTime < minTime[newX][newY]) {
                        minTime[newX][newY] = updatedTime;
                        queue.offer(new int[]{updatedTime, newX, newY});
                    }
                }
            }
        }

        return minTime[rows - 1][cols - 1];
    }
}
",1441324048
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3628,java,"import java.util.*;

class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int rows = moveTime.length;
        int cols = moveTime[0].length;

        // 3D dp table to store minimum time to reach each cell with both parities (0 and 1)
        int[][][] minTime = new int[rows][cols][2];
        for (int[][] row : minTime) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        minTime[0][0][0] = 0;

        // Deque for BFS-like traversal with time-based ordering
        Deque<int[]> deque = new ArrayDeque<>();
        deque.offerFirst(new int[]{0, 0, 0, 0}); // {time, row, col, parity}

        // Directions for moving up, down, left, and right
        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};

        while (!deque.isEmpty()) {
            int[] state = deque.pollFirst();
            int currTime = state[0];
            int row = state[1];
            int col = state[2];
            int parity = state[3];

            if (currTime > minTime[row][col][parity]) continue;

            for (int[] dir : directions) {
                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                    int nextTime = Math.max(currTime, moveTime[newRow][newCol]) + (parity == 1 ? 2 : 1);

                    if (nextTime < minTime[newRow][newCol][1 - parity]) {
                        minTime[newRow][newCol][1 - parity] = nextTime;
                        if (parity == 0) {
                            deque.offerFirst(new int[]{nextTime, newRow, newCol, 1 - parity});
                        } else {
                            deque.offerLast(new int[]{nextTime, newRow, newCol, 1 - parity});
                        }
                    }
                }
            }
        }

        return Math.min(minTime[rows - 1][cols - 1][0], minTime[rows - 1][cols - 1][1]);
    }
}
",1441312124
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int evenSum = 0, oddSum = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int digit = num.charAt(i) - '0';  // Convert character to integer
            
            if (i % 2 == 0) {
                evenSum += digit;
            } else {
                oddSum += digit;
            }
        }
        
        return evenSum == oddSum;
    }
}
",1441283653
sarvan_yaduvanshi_,sarvan_yaduvanshi_,298,3637,java,"import java.util.*;

public class Solution {
    static final int MOD = 1000000007;
    long[] fact;
    long[] invFact;

    private long powerModFunc(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    private void initFact(int n) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        invFact[n] = powerModFunc(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            invFact[i] = invFact[i + 1] * (i + 1) % MOD;
        }
    }

    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long totalSum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            totalSum += d;
        }

        if (totalSum % 2 != 0) return 0;

        long sumHalf = totalSum / 2;
        int k = (n + 1) / 2;
        initFact(n);

        long[][] dp = new long[k + 1][(int) (sumHalf + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sumHalf; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + d * t > sumHalf) break;
                        long comb = fact[freq[d]] * invFact[t] % MOD * invFact[freq[d] - t] % MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MOD;
                    }
                }
            }
        }

        long validAssignments = dp[k][(int) sumHalf];
        if (validAssignments == 0) return 0;

        long prodFactFd = 1;
        for (int d = 0; d <= 9; d++) {
            prodFactFd = prodFactFd * fact[freq[d]] % MOD;
        }

        long fkFnk = fact[k] * fact[n - k] % MOD;
        long invProdFactFd = powerModFunc(prodFactFd, MOD - 2);
        long answer = fkFnk * validAssignments % MOD * invProdFactFd % MOD;

        return (int) answer;
    }
}
",1441391551
choudharykritik,choudharykritik,299,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 1: 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441390056
choudharykritik,choudharykritik,299,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        long long int n = moveTime.size();
long long int m = moveTime[0].size();

vector<vector<vector<long long int>>> dp(n, vector<vector<long long int>>(m, vector<long long int>(2, 1e12)));
dp[0][0][0] = 0;

priority_queue<pair<long long int, vector<long long int>>, vector<pair<long long int, vector<long long int>>>, greater<>> pq;
pq.push({0, {0, 0, 0}});
long long int dirx[5] = {0, -1, 0, 1};
long long int diry[5] = {1, 0, -1, 0};

while (!pq.empty())
{
    auto [t, v] = pq.top();
    long long int i = v[0], j = v[1], p = v[2];
    pq.pop();

    if (t > dp[i][j][p])
        continue;

    for (long long int p2 = 0; p2 < 4; p2++)
    {
        long long int ni = i + dirx[p2];
        long long int nj = j + diry[p2];

        if (ni >= 0 && ni < n && nj >= 0 && nj < m)
        {
            long long int nt = max(t, (long long int)moveTime[ni][nj]) + (p ? 2 : 1);

            if (nt < dp[ni][nj][!p])
            {
                dp[ni][nj][!p] = nt;
                pq.push({nt, {ni, nj, !p}});
            }
        }
    }
}

return min(dp[n - 1][m - 1][0], dp[n - 1][m - 1][1]);
    }
};",1441388976
choudharykritik,choudharykritik,299,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sm1=0,sm2=0;
        for(int i=0;i<num.size();i+=2){
            sm1+=(num[i]-'0');
        }
        for(int i=1;i<num.size();i+=2){
            sm2+=(num[i]-'0');
        }
        if(sm1==sm2){
            return true;
        }
        return false;
    }
};",1441285033
choudharykritik,choudharykritik,299,3637,cpp,"#include <bits/stdc++.h>
using namespace std;

#define MOD 1000000007
typedef long long ll;

vector<ll> fact, inv_fact;

ll mod_pow(ll a, ll b) {
    ll res = 1;
    a %= MOD;
    while (b > 0) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_fact(int n) {
    fact.assign(n + 1, 1);
    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;

    inv_fact.assign(n + 1, 1);
    inv_fact[n] = mod_pow(fact[n], MOD - 2);
    for (int i = n - 1; i >= 0; i--) inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
}

class Solution {
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        vector<int> f(10, 0);
        ll sum = 0;

        for (char c : num) {
            int d = c - '0';
            f[d]++;
            sum += d;
        }

        if (sum % 2 != 0) return 0;
        ll half = sum / 2;
        int k = (n + 1) / 2;

        init_fact(n);

        vector<vector<ll>> dp(k + 1, vector<ll>(half + 1, 0));
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (f[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (ll s = half; s >= 0; s--) {
                    if (dp[c][s] == 0) continue;
                    for (int t = 1; t <= min(f[d], k - c); t++) {
                        if (s + (ll)d * t > half) break;
                        ll comb = (fact[f[d]] * inv_fact[t] % MOD) * inv_fact[f[d] - t] % MOD;
                        dp[c + t][s + d * t] = (dp[c + t][s + d * t] + dp[c][s] * comb) % MOD;
                    }
                }
            }
        }

        ll valid = dp[k][half];
        if (valid == 0) return 0;

        ll fact_prod = 1;
        for (int d = 0; d <= 9; d++) {
            fact_prod = fact_prod * fact[f[d]] % MOD;
        }

        ll fk_fnk = (fact[k] * fact[n - k]) % MOD;
        ll inv_fact_prod = mod_pow(fact_prod, MOD - 2);
        ll ans = (fk_fnk * valid % MOD) * inv_fact_prod % MOD;

        return (int)ans;
    }
};
",1441386306
GoIsTheBestLang,__golang__,300,3627,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    dis[v] = max(d + w, moveTime[i][j] + 1)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441326693
GoIsTheBestLang,__golang__,300,3628,python3,"class Dijkstra:
    def __init__(self, n: int, edges: List[List[int]], directed: bool = False):
        self.graph = [[] for _ in range(n)]
        for u, v, w in edges:
            self.graph[u].append([v, w])
            if not directed:
                self.graph[v].append([u, w])

    def plain_dijkstra(self, start: int, end: int) -> int:
        n = len(self.graph)
        dis = [float(""inf"")] * n
        dis[start] = 0
        vis = [False] * n
        while True:
            u = -1
            for i, (b, d) in enumerate(zip(vis, dis)):
                if not b and (u < 0 or d < dis[u]):
                    u = i
            if u < 0 or dis[u] == inf:
                return -1
            if u == end:
                return dis[u]
            vis[u] = True
            for v, w in self.graph[u]:
                if dis[u] + w < dis[v]:
                    dis[v] = dis[u] + w

    def heap_dijkstra(self, start: int, end: int, moveTime, n) -> int:
        dis = [float(""inf"")] * len(self.graph)
        dis[start] = 0
        h = [(0, start)]
        while h:
            d, u = heappop(h)
            if d > dis[u]:
                continue
            for v, w in self.graph[u]:
                i, j = divmod(v, n)
                if max(d + w, moveTime[i][j] + 1) < dis[v]:
                    if (i + j) & 1:
                        dis[v] = max(d + w, moveTime[i][j] + 1)
                    else:
                        dis[v] = max(d + w + 1, moveTime[i][j] + 2)
                    heappush(h, (dis[v], v))
        return dis


class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m, n = len(moveTime), len(moveTime[0])
        d = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        edges = list()
        for i in range(m):
            for j in range(n):
                for x, y in d:
                    if 0 <= i + x < m and 0 <= j + y < n:
                        edges.append([i * n + j, (i + x) * n + (j + y), 1])
        dij = Dijkstra(m * n, edges, True)
        return dij.heap_dijkstra(0, m * n - 1, moveTime, n)[-1]
            
        
            
        ",1441329752
GoIsTheBestLang,__golang__,300,3637,python3,"MOD = 10 ** 9 + 7

MAX = 100

fac = [0] * MAX
inv = [0] * MAX

fac[0] = 1
inv[0] = 1
for i in range(1, MAX):
    fac[i] = fac[i - 1] * i % MOD
    inv[i] = pow(fac[i], MOD-2, MOD)

def comb(n, k):
    return fac[n] * inv[k] % MOD * inv[n - k] % MOD

class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        cnt = Counter(list(map(int, num)))
        tot = sum(int(ch) for ch in num)
        if tot & 1:
            return 0
        @cache
        def dfs(i, s, c):
            if s > tot // 2:
                return 0
            if i == 10:
                if s != tot // 2:
                    return 0
                if c == len(num) // 2:
                    return fac[len(num) // 2] * fac[(len(num) + 1) // 2] % MOD
                return 0
            ans = 0
            for j in range(cnt[i] + 1):
                ans += dfs(i + 1, s + j * i, c + j) * inv[j] * inv[cnt[i] - j] % MOD
                ans %= MOD
            return ans
        return dfs(0, 0, 0)
            
        
        ",1441302966
forwarding7,forwarding7,301,3627,cpp,"
class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + 1, x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + 1, x, y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + 1, x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + 1, x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441303584
forwarding7,forwarding7,301,3628,cpp,"class Solution {
  public:
    int minTimeToReach(vector<vector<int>> &moveTime) {
        int n = (int)moveTime.size(), m = (int)moveTime[0].size();

        using type = tuple<int, int, int, int>;
        priority_queue<type, vector<type>, std::greater<>> queue;

        queue.emplace(0, 1, 0, 0);
        moveTime[0][0] = -1;

        while (!queue.empty()) {
            auto [time, next, x, y] = queue.top();
            queue.pop();

            if (x == n - 1 && y == m - 1) {
                return time;
            }

            if (x < n - 1 && moveTime[x + 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x + 1][y]) + next, 3 - next,
                              x + 1, y);
                moveTime[x + 1][y] = -1;
            }
            if (y < m - 1 && moveTime[x][y + 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y + 1]) + next, 3 - next, x,
                              y + 1);
                moveTime[x][y + 1] = -1;
            }
            if (x > 0 && moveTime[x - 1][y] >= 0) {
                queue.emplace(max(time, moveTime[x - 1][y]) + +next, 3 - next,
                              x - 1, y);
                moveTime[x - 1][y] = -1;
            }
            if (y > 0 && moveTime[x][y - 1] >= 0) {
                queue.emplace(max(time, moveTime[x][y - 1]) + +next, 3 - next,
                              x, y - 1);
                moveTime[x][y - 1] = -1;
            }
        }
        return 0;
    }
};",1441305751
forwarding7,forwarding7,301,3637,cpp,"class Solution {
  public:
    using ll = long long;
    int countBalancedPermutations(std::string num) {
        constexpr int mod = 1e9 + 7;

        int n = (int)num.size();
        ll res;

        std::vector<int> nums;
        int sum = 0;
        for (auto c : num) {
            nums.emplace_back(c - '0');
            sum += (c - '0');
        }
        if (sum % 2 == 1) {
            return 0;
        }

        int target = sum / 2;
        int target_size = (int)nums.size() / 2;
        std::vector<std::vector<int>> dp(target_size + 1,
                                         std::vector<int>(target + 1, 0));
        dp[0][0] = 1;
        for (auto number : nums) {
            for (int i = target_size; i >= 1; --i) {
                for (int j = target; j >= number; --j) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - number]) % mod;
                }
            }
        }

        auto factorialMod = [](ll n) -> ll {
            ll result = 1;
            for (ll i = 2; i <= n; ++i) {
                result = (result * i) % mod;
            }
            return result;
        };

        // 计算每个数字的频率
        std::unordered_map<int, int> freq;
        for (auto number : nums) {
            freq[number]++;
        }

        // 计算排列数的去重因子
        ll duplicateFactor = 1;
        for (const auto &[key, value] : freq) {
            duplicateFactor = (duplicateFactor * factorialMod(value)) % mod;
        }

        auto f = dp[target_size][target];
        if (nums.size() % 2 == 0) {
            auto a = factorialMod(target_size);
            res = ((a * a) % mod * f) % mod;
        } else {
            auto a = factorialMod(target_size);
            auto b = factorialMod(target_size + 1);
            res = ((a * b) % mod * f) % mod;
        }

        res = (res * modInverse(duplicateFactor, mod)) % mod;
        return (int)(res);
    }

  private:
    // 快速幂求逆元
    ll modInverse(ll a, ll m) {
        ll m0 = m, t, q;
        ll x0 = 0, x1 = 1;
        if (m == 1)
            return 0;
        while (a > 1) {
            q = a / m;
            t = m;
            m = a % m, a = t;
            t = x0;
            x0 = x1 - q * x0;
            x1 = t;
        }
        if (x1 < 0)
            x1 += m0;
        return x1;
    }
};",1441330435
arunkumar saranga,arunkumarsaranga,302,3628,java,"import java.util.PriorityQueue;

class Solution {
    public int minTimeToReach(int[][] a) {
        int x = a.length;
        int y = a[0].length;
        int[][][] b = f(x, y);
        b[0][0][0] = 0;
        PriorityQueue<int[]> c = new PriorityQueue<>((d, e) -> Integer.compare(d[0], e[0]));
        c.offer(new int[]{0, 0, 0, 0});
        int[][] g = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        while (!c.isEmpty()) {
            h(c, b, g, a, x, y);
        }
        
        return Math.min(b[x - 1][y - 1][0], b[x - 1][y - 1][1]);
    }
    
    private int[][][] f(int x, int y) {
        int[][][] b = new int[x][y][2];
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < y; j++) {
                b[i][j][0] = Integer.MAX_VALUE;
                b[i][j][1] = Integer.MAX_VALUE;
            }
        }
        return b;
    }
    
    private void h(PriorityQueue<int[]> c, int[][][] b, int[][] g, int[][] a, int x, int y) {
        int[] i = c.poll();
        int j = i[0];
        int k = i[1];
        int l = i[2];
        int m = i[3];
        
        if (j > b[k][l][m]) return;
        
        for (int[] n : g) {
            int o = k + n[0];
            int p = l + n[1];
            if (o >= 0 && o < x && p >= 0 && p < y) {
                int q = Math.max(j, a[o][p]) + (m == 0 ? 1 : 2);
                int r = 1 - m;
                
                if (q < b[o][p][r]) {
                    b[o][p][r] = q;
                    c.offer(new int[]{q, o, p, r});
                }
            }
        }
    }
}
",1441377032
arunkumar saranga,arunkumarsaranga,302,3636,python3,"class Solution:
    def isBalanced(self, s: str) -> bool:
        l=list(map(int,s))
        x=l[0::2]
        # print(x)
        y=l[1::2]
        # print(y)
        return sum(x)==sum(y)",1441349852
arunkumar saranga,arunkumarsaranga,302,3637,python3,"MOD = 1000000007

def p(x, y):
    z = 1
    x %= MOD
    while y > 0:
        if y & 1:
            z = z * x % MOD
        x = x * x % MOD
        y >>= 1
    return z

a = []
b = []

def b_init(m):
    global a, b
    a = [1] * (m + 1)
    for c in range(1, m + 1):
        a[c] = a[c - 1] * c % MOD
    b = [1] * (m + 1)
    b[m] = p(a[m], MOD - 2)
    for c in range(m - 1, -1, -1):
        b[c] = b[c + 1] * (c + 1) % MOD

class Solution:
    def countBalancedPermutations(self, q: str) -> int:
        m = len(q)
        n = [0] * 10
        r = 0
        for x in q:
            s = int(x)
            n[s] += 1
            r += s

        if r % 2 != 0:
            return 0
        g = r // 2
        h = (m + 1) // 2
        b_init(m)
        
        dp = [[0] * (g + 1) for _ in range(h + 1)]
        dp[0][0] = 1
        
        for s in range(10):
            if n[s] == 0:
                continue
            for t in range(h, -1, -1):
                for u in range(g, -1, -1):
                    if dp[t][u] == 0:
                        continue
                    for v in range(1, min(n[s], h - t) + 1):
                        if u + s * v > g:
                            break
                        w = (a[n[s]] * b[v] % MOD) * b[n[s] - v] % MOD
                        dp[t + v][u + s * v] = (dp[t + v][u + s * v] + dp[t][u] * w) % MOD

        x = dp[h][g]
        if x == 0:
            return 0

        y = 1
        for s in range(10):
            y = y * a[n[s]] % MOD

        z = a[h] * a[m - h] % MOD
        i_y = p(y, MOD - 2)

        result = (z * x % MOD) * i_y % MOD
        return result
",1441386739
klu2200031955,klu2200031955,303,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int n = moveTime.length;
        int m = moveTime[0].length;

        int[][][] d = initializeDistanceMatrix(n, m);
        PriorityQueue<Node> queue = initializeQueue();

        queue.offer(new Node(0, 0, 0, 0));

        return processQueue(queue, d, moveTime, n, m);
    }

    private int[][][] initializeDistanceMatrix(int rows, int cols) {
        int[][][] distanceMatrix = new int[rows][cols][2];
        for (int[][] row : distanceMatrix) {
            for (int[] col : row) {
                Arrays.fill(col, Integer.MAX_VALUE);
            }
        }
        distanceMatrix[0][0][0] = 0;  // Starting point
        return distanceMatrix;
    }

    private PriorityQueue<Node> initializeQueue() {
        return new PriorityQueue<>();
    }

    private int[][] getDirections() {
        return new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    }

    private int processQueue(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, int n, int m) {
        int[][] directions = getDirections();

        while (!queue.isEmpty()) {
            Node node = queue.poll();
            if (node.time > distance[node.x][node.y][node.parity]) continue;

            updateDistances(queue, distance, moveTime, node, directions, n, m);
        }

        return Math.min(distance[n - 1][m - 1][0], distance[n - 1][m - 1][1]);
    }

    private void updateDistances(PriorityQueue<Node> queue, int[][][] distance, int[][] moveTime, Node node, int[][] directions, int n, int m) {
        for (int[] dir : directions) {
            int ni = node.x + dir[0];
            int nj = node.y + dir[1];

            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {
                // Calculate the new time with corrected parity handling
                int newTime = Math.max(node.time, moveTime[ni][nj]) + ((node.parity == 1) ? 2 : 1);

                if (newTime < distance[ni][nj][1 - node.parity]) {
                    distance[ni][nj][1 - node.parity] = newTime;
                    queue.offer(new Node(newTime, ni, nj, 1 - node.parity));
                }
            }
        }
    }

    private static class Node implements Comparable<Node> {
        int time, x, y, parity;

        Node(int time, int x, int y, int parity) {
            this.time = time;
            this.x = x;
            this.y = y;
            this.parity = parity;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.time, other.time);
        }
    }
}
",1441331711
klu2200031955,klu2200031955,303,3636,java,"class SumCalculator {
    public int calculateEvenSum(String num) {
        int evenSum = 0;
        for (int i = 0; i < num.length(); i += 2) {
            evenSum += num.charAt(i) - '0';
        }
        return evenSum;
    }

    public int calculateOddSum(String num) {
        int oddSum = 0;
        for (int i = 1; i < num.length(); i += 2) {
            oddSum += num.charAt(i) - '0';
        }
        return oddSum;
    }
}

class Solution {
    private SumCalculator calculator = new SumCalculator();

    public boolean isBalanced(String num) {
        int evenSum = calculator.calculateEvenSum(num);
        int oddSum = calculator.calculateOddSum(num);
        return evenSum == oddSum;
    }
}
",1441335004
klu2200031955,klu2200031955,303,3637,java,"import java.util.Arrays;

class MathUtils {
    static final int MOD = 1000000007;

    static long power_mod_func(long a, long b) {
        long res = 1;
        a %= MOD;
        while (b > 0) {
            if ((b & 1) == 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    static class FactorialResult {
        long[] fact;
        long[] inv_fact;

        FactorialResult(long[] fact, long[] inv_fact) {
            this.fact = fact;
            this.inv_fact = inv_fact;
        }
    }

    static FactorialResult initializeFactorials(int n) {
        long[] fact = new long[n + 1];
        long[] inv_fact = new long[n + 1];
        Arrays.fill(fact, 1);
        for (int i = 1; i <= n; i++) {
            fact[i] = fact[i - 1] * i % MOD;
        }
        inv_fact[n] = power_mod_func(fact[n], MOD - 2);
        for (int i = n - 1; i >= 0; i--) {
            inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD;
        }
        return new FactorialResult(fact, inv_fact);
    }
}

class Solution {
    public int countBalancedPermutations(String num) {
        int n = num.length();
        int[] freq = new int[10];
        long total_sum = 0;

        for (char c : num.toCharArray()) {
            int d = c - '0';
            freq[d]++;
            total_sum += d;
        }

        if (total_sum % 2 != 0) return 0;
        long sum_half = total_sum / 2;
        int k = (n + 1) / 2;

        MathUtils.FactorialResult factorials = MathUtils.initializeFactorials(n);
        long[] fact = factorials.fact;
        long[] inv_fact = factorials.inv_fact;

        long[][] dp = new long[k + 1][(int) (sum_half + 1)];
        dp[0][0] = 1;

        for (int d = 0; d <= 9; d++) {
            if (freq[d] == 0) continue;
            for (int c = k; c >= 0; c--) {
                for (long s = sum_half; s >= 0; s--) {
                    if (dp[c][(int) s] == 0) continue;
                    for (int t = 1; t <= Math.min(freq[d], k - c); t++) {
                        if (s + (long) d * t > sum_half) break;
                        long comb = (fact[freq[d]] * inv_fact[t] % MathUtils.MOD) * inv_fact[freq[d] - t] % MathUtils.MOD;
                        dp[c + t][(int) (s + d * t)] = (dp[c + t][(int) (s + d * t)] + dp[c][(int) s] * comb) % MathUtils.MOD;
                    }
                }
            }
        }

        long valid_assignments = dp[k][(int) sum_half];
        if (valid_assignments == 0) return 0;

        long prod_fact_fd = 1;
        for (int d = 0; d <= 9; d++) {
            prod_fact_fd = prod_fact_fd * fact[freq[d]] % MathUtils.MOD;
        }

        long fk_fnk = (fact[k] * fact[n - k]) % MathUtils.MOD;
        long inv_prod_fact_fd = MathUtils.power_mod_func(prod_fact_fd, MathUtils.MOD - 2);
        long answer = (fk_fnk * valid_assignments) % MathUtils.MOD;
        answer = (answer * inv_prod_fact_fd) % MathUtils.MOD;

        return (int) answer;
    }
}
",1441380869
Ratnakar Gautam,ratnakarg,304,3627,cpp,"#define ll long long
class Solution {
public:
    vector<vector<int>> dir = {{1,0} , {0,1} , {0,-1} , {-1,0}};
    bool coords(int r, int c, int n, int m){
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool check(int mid , vector<vector<int>>& mvt) {
        int n = mvt.size() , m = mvt[0].size();
        vector<vector<long long>> dis(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        dis[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cst = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cst <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + dir[i][0], ncol = c + dir[i][1];
                if (coords(nrow, ncol, n, m)) {
                    long long tmp = max(cst + 1, 1LL*mvt[nrow][ncol] + 1);
                    if (tmp < dis[nrow][ncol] && tmp <= mid) {
                        dis[nrow][ncol] = tmp;
                        q.push({tmp , nrow , ncol});
                    }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& mvt) {
        int n = mvt.size(), m = mvt[0].size();
        long long low = 0 , high = 1e13;
        long long ans = -1;
        while(low <= high) {
            long long mid = low + (high-low) / 2;

            if(check(mid , mvt)) {
                ans = mid;
                high = mid-1;
            }
            else low = mid+1;
        } 

        return ans;
    }
};",1441369613
Ratnakar Gautam,ratnakarg,304,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441292383
Ratnakar Gautam,ratnakarg,304,3637,cpp,"#define ll long long
const int mod = 1e9+7;

class Solution {
public:
    ll modPow(ll base, ll exp, ll mod) {
        ll res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    ll inv(ll num) {
        return modPow(num, mod - 2, mod);
    }

    // int solve(vector<int>& num, int k){
    //     int n = num.size();
    
    //     vector<int> prev(k + 1, 0);
    
    //     prev[0] = 1;
    
    //     if (num[0] <= k) {
    //         prev[num[0]] = 1;
    //     }
    
    //     for (int ind = 1; ind < n; ind++) {
    //         vector<int> cur(k + 1, 0);
    
    //         cur[0] = 1;
    
    //         for (int target = 1; target <= k; target++) {
    //             int notTaken = prev[target];
    //             int taken = 0;
    //             if (num[ind] <= target) {
    //                 taken = prev[target - num[ind]];
    //             }
    
    //             cur[target] = notTaken + taken;
    //         }
    
    //         prev = cur;
    //     }
    
    //     return prev[k];
    // }

    int countBalancedPermutations(string num){
        vector<int> v;
        int n = num.size();
        map<int,int> freq;
        for(char x:num){
            v.push_back((int)x-'0');
            freq[v.back()]++;
            
        }
        int tot = accumulate(v.begin(),v.end(),0ll);
        int mod = 1e9+7;
        // vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (9*n , vector<int> (n,-1)));
        // function<int(int,int,int)> rec = [&](int i,int sum,int k){
        //     if(i==n)return (int)(k==n/2 && sum*2==tot);
        //     if(dp[i][sum][k]!=-1)return dp[i][sum][k];
        //     ll ans = 0;
        //     ans+=rec(i+1,sum,k);
        //     ans%=mod;
        //     ans+=rec(i+1,sum+v[i],k+1);
        //     ans%=mod;
        //     return dp[i][sum][k]=(int)ans;
        // };
        // ll cnt=rec(0,0,0);

        if (tot % 2 != 0) return 0;
        int halfSum = tot / 2;
         vector<vector<int>> dp(halfSum + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> next = dp;
            for (int sum = 0; sum <= halfSum; sum++){
                for (int k=0;k<=n/2;k++){
                    if(dp[sum][k]>0){
                        // next[sum][k]=(next[sum][k]+dp[sum][k])%mod;
                        if (k + 1 <= n / 2 && sum + v[i] <= halfSum){
                            next[sum + v[i]][k + 1] = (next[sum + v[i]][k + 1] + dp[sum][k]) % mod;
                        }
                    }
                }
            }
            dp = next;
        }

        ll cnt = dp[halfSum][n/2];

        // cout<<cnt<<endl;

        vector<ll> f(100);
        f[0]=1;
        for(int i=1;i<100;i++){
            f[i]=f[i-1]*i;
            f[i]%=mod;
        }
        int a = n/2 , b = n - a;
        ll ans = (((f[a]*f[b])%mod)*cnt)%mod;

        for(int i=0;i<=9;i++){
            ans*=inv(f[freq[i]]);
            ans%=mod;
        }
        return ans;
    }
};",1441357011
Sean,shaun001280,305,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        // Distance matrix to store minimum times
        vector<vector<int>> dist(n, vector<int>(m, INT_MAX));
        
        // Priority queue to store {time, {row, col}}
        priority_queue<pair<int, pair<int, int>>, 
                      vector<pair<int, pair<int, int>>>,
                      greater<pair<int, pair<int, int>>>> pq;
        
        // Directions: right, down, left, up
        vector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        
        // Start from (0,0)
        dist[0][0] = moveTime[0][0];
        pq.push({0, {0, 0}});
        
        while (!pq.empty()) {
            int currTime = pq.top().first;
            int row = pq.top().second.first;
            int col = pq.top().second.second;
            pq.pop();
            
            if (currTime > dist[row][col]) continue;
            
            for (const auto& dir : dirs) {
                int newRow = row + dir.first;
                int newCol = col + dir.second;
                
                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < m) {
                    int newTime = max(currTime + 1, moveTime[newRow][newCol] + 1);
                    
                    if (newTime < dist[newRow][newCol]) {
                        dist[newRow][newCol] = newTime;
                        pq.push({newTime, {newRow, newCol}});
                    }
                }
            }
        }
        
        return dist[n-1][m-1];
    }
};",1441395871
Sean,shaun001280,305,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum0 = 0, sum1 = 0;
        for (int i = 0; i < num.size(); i++) {
            if (i & 1) sum1 += num[i] - '0';
            else sum0 += num[i] - '0';
        }
        return sum0 == sum1;
    }
};",1441371592
Sean,shaun001280,305,3637,cpp,"class Solution {
private:
    static constexpr int MOD = 1000000007;
    vector<vector<int>> C;
    vector<int> cnt;
    int target_sum;
    unordered_map<string, int> memo;
    
    string getKey(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        return to_string(pos) + "","" + to_string(sum_odd) + "","" + 
               to_string(sum_even) + "","" + to_string(odd_spots) + "","" + 
               to_string(even_spots);
    }
    
    int dfs(int pos, int sum_odd, int sum_even, int odd_spots, int even_spots) {
        if (pos == 10) {
            return (sum_odd == target_sum && sum_even == target_sum) ? 1 : 0;
        }
        
        string key = getKey(pos, sum_odd, sum_even, odd_spots, even_spots);
        if (memo.count(key)) {
            return memo[key];
        }
        
        if (sum_odd > target_sum || sum_even > target_sum) {
            return 0;
        }
        
        if (cnt[pos] == 0) {
            int result = dfs(pos + 1, sum_odd, sum_even, odd_spots, even_spots);
            memo[key] = result;
            return result;
        }
        
        int result = 0;
        for (int i = 0; i <= cnt[pos]; i++) {
            if (i <= odd_spots && (cnt[pos] - i) <= even_spots) {
                long long new_sum_odd = sum_odd + (long long)i * pos;
                long long new_sum_even = sum_even + (long long)(cnt[pos] - i) * pos;
                
                if (new_sum_odd <= target_sum && new_sum_even <= target_sum) {
                    long long ways = 1;
                    ways = ((long long)C[odd_spots][i] * C[even_spots][cnt[pos] - i]) % MOD;
                    ways = (ways * dfs(pos + 1, new_sum_odd, new_sum_even, 
                            odd_spots - i, even_spots - (cnt[pos] - i))) % MOD;
                    result = (result + ways) % MOD;
                }
            }
        }
        
        memo[key] = result;
        return result;
    }
    
public:
    int countBalancedPermutations(string num) {
        int n = num.size();
        int n_odd = (n + 1) / 2;
        int n_even = n / 2;
        
        cnt.resize(10);
        int total_sum = 0;
        
        for (char x : num) {
            total_sum += x - '0';
            cnt[x - '0']++;
        }
        
        if (total_sum % 2 == 1) {
            return 0;
        }
        
        target_sum = total_sum / 2;
        
        C.resize(n + 1, vector<int>(n + 1));
        for (int i = 0; i <= n; i++) {
            C[i][0] = 1;
            C[i][i] = 1;
            for (int j = 1; j < i; j++) {
                C[i][j] = (C[i-1][j-1] + C[i-1][j]) % MOD;
            }
        }
        
        memo.clear();
        return dfs(0, 0, 0, n_odd, n_even);
    }
};",1441367965
roush_70700,roush_70700,306,3627,cpp,"class Solution {
public:
    vector <pair<int,int>> rc = {{1,0} , {0,1} , {0,-1} , {-1,0}};

    bool IsValid(int r, int c, int n, int m) {
        return (r >= 0 && c >= 0 && r < n && c < m);
    }
    bool IsPossible(int mid , vector<vector<int>>& moveTime) {
        int n = moveTime.size() , m = moveTime[0].size();
        vector<vector<long long>> minTime(n, vector<long long>(m, 1e13));
        queue<vector<long long>> q;

        q.push({0,0,0});
        minTime[0][0] = 0;
        vector <vector<int>> vis(n , vector <int> (m , 0));
        vis[0][0] = 1;

        while (!q.empty()) {
            long long r = q.front()[1], c = q.front()[2], cost = q.front()[0];
            q.pop();

            if (r == n - 1 && c == m - 1) {
                return cost <= mid;
            }

            for (int i = 0; i < 4; i++) {
                long long nrow = r + rc[i].first, ncol = c + rc[i].second;
                if (IsValid(nrow, ncol, n, m)) {
                    long long newCost = max(cost + 1, 1LL*moveTime[nrow][ncol] + 1);
                    if (newCost < minTime[nrow][ncol] && newCost <= mid) {
                        minTime[nrow][ncol] = newCost;
                        q.push({newCost , nrow , ncol});
                    }

                    // if(newCost <= mid && !vis[nrow][ncol]) {
                    //     vis[nrow][ncol] = 1;
                    //     // minTime[nrow][ncol] = newCost;
                    //     q.push({newCost , nrow , ncol});
                    // }
                }
            }
        }
        return false;
    }
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();

        long long l = 0 , r = 1e13;
        long long ans = -1;
        while(l <= r) {
            long long mid = l + (r-l) / 2;

            if(IsPossible(mid , moveTime)) {
                ans = mid;
                r = mid-1;
            }
            else l = mid+1;
        } 

        return ans;
    }
};
",1441345035
roush_70700,roush_70700,306,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int ev = 0 , od = 0;
        for(int i = 0 ; i < num.size() ; i += 2) ev += (num[i] - '0');

        for(int i = 1 ; i < num.size() ; i += 2) od += (num[i] - '0');

        return ev == od;
    }
};",1441282228
roush_70700,roush_70700,306,3637,cpp,"class Solution {
public:
    const int mod = 1e9 + 7;
    long long modular_power(long long base, long long exp, long long mod) {
        long long res = 1;
        while (exp > 0) {
            if (exp % 2 == 1) {
                res = (res * base) % mod;
            }
            base = (base * base) % mod;
            exp /= 2;
        }
        return res;
    }

    long long fun(long long num) {
        return modular_power(num, mod - 2, mod);
    }

    long long solve(int sum, int n, vector<int>& temp) {
        int req = sum / 2;
        vector<vector<int>> dp(req + 1, vector<int>(n / 2 + 1, 0));
        dp[0][0] = 1;
        for (int i = 0; i < n; i++) {
            vector<vector<int>> dp_next = dp;
            for (int s = 0; s <= req; s++) {
                for (int k = 0; k <= n / 2; k++) {
                    if (dp[s][k] > 0) {
                        if (k + 1 <= n / 2 && s + temp[i] <= req) {
                            dp_next[s + temp[i]][k + 1] = (dp_next[s + temp[i]][k + 1] + dp[s][k]) % mod;
                        }
                    }
                }
            }
            dp = dp_next;
        }
        return dp[req][n / 2];
    }
    int countBalancedPermutations(string num) {
        vector<int> temp;
        int n = num.size();
        unordered_map<int, int> mp;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            temp.push_back(num[i] - '0');
            mp[temp.back()]++;
            sum += temp[i];
        }

        if (sum % 2 != 0)
            return 0;

        long long cnt = solve(sum, n, temp);
        vector<long long> res(100);
        res[0] = 1;
        for (int i = 1; i < 100; i++) {
            res[i] = (res[i - 1] * i) % mod;
        }
        
        int a = n / 2, b = n - a;
        long long ans = (((res[a] * res[b]) % mod) * cnt) % mod;
        for (int i = 0; i <= 9; i++) {
            ans = (ans * fun(res[mp[i]])) % mod;
        }
        return ans;
    }
};
",1441389790
xy-li,xy-li,307,3627,python3,"import heapq
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        # for i in range(len(moveTime)):
        #     for j in range(len(moveTime[0])):
        #         if i!=0 or j!=0:
        #             moveTime[i][j] += 1
        # moveTime[0][0] = 0
        
        n, m = len(moveTime), len(moveTime[0])
        start = (0, 0)
        seen = [[False] * m for _ in range(n)]
        dist = [[float('inf')] * m for _ in range(n)]
        h = [(0, 0, 0)]
        dist[0][0] = 0
        
        while h:
            d, i, j = heapq.heappop(h)
            if d > dist[i][j]:
                continue
            if i == n - 1 and j == m - 1:
                return d
            seen[i][j] = True
            for x, y in ((i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)):
                if 0 <= x < n and 0 <= y < m and not seen[x][y]:
                    new_dist = min(max(d, moveTime[x][y])+1, dist[x][y])
                    if new_dist < dist[x][y]:
                        dist[x][y] = new_dist
                        heapq.heappush(h, (new_dist, x, y))
            
        return dist[n - 1][m - 1]

                ",1441384467
xy-li,xy-li,307,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        digits = [int(x) for x in num]
        odd_sum = sum(digits[::2])
        even_sum = sum(digits[1::2])
        return odd_sum == even_sum
        ",1441281451
xy-li,xy-li,307,3637,python3,"M = 10**9 + 7

fraq = [1]

for i in range(80):
    fraq.append((fraq[-1] * (i+1)) % M)

fraq_inv = [pow(i, M - 2, M) for i in fraq]

# print(fraq_inv[:10])

from collections import Counter
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        nums = [int(i) for i in num]
        cnt = Counter(nums)
        s = sum(nums)
        if s % 2 != 0:
            return 0
        n = len(nums)
        k = n // 2
        target_sum = s // 2
        
        dp = [[0] * (target_sum + 1) for _ in range(k + 1)]
        dp[0][0] = 1  # Base case: one way to get sum 0 with 0 elements

        # Fill the DP table
        for num in nums:
            # Update dp table in reverse to avoid reusing elements in the same iteration
            for j in range(k, 0, -1):
                for s in range(target_sum, num - 1, -1):
                    dp[j][s] = (dp[j][s] + dp[j - 1][s - num]) % M
                    
        res = dp[-1][-1] * fraq[n - k] * fraq[k] % M
        # print(dp[-1][-1], fraq[n - k])
        for num in cnt:
            res = (res * fraq_inv[cnt[num]]) % M
        return res
                
        
        ",1441365474
lucasomee006,lucasomee006,308,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        #dijkstra's?
        distances = [[float('inf') for i in range(len(moveTime[0]))] for j in range(len(moveTime))]
        # distances[0][0] = 0
        queue = [((0, 0), 0)]
        def neighbors(i, j):
            ans = []
            if i < len(moveTime)-1:
                ans.append((i+1, j))
            if j < len(moveTime[0])-1:
                ans.append((i, j+1))
            if i > 0:
                ans.append((i-1, j))
            if j > 0:
                ans.append((i, j-1))
            return ans
            
        while len(queue):
            coords, weight = heapq.heappop(queue)
            i, j = coords
            if weight >= distances[i][j]:
                continue
            distances[i][j] = weight
            for n in neighbors(i, j):
                heapq.heappush(queue, (n, max(weight+1, moveTime[n[0]][n[1]]+1)))
        # print(neighbors(1, 1))
        # print(distances)
        return distances[-1][-1]
            
            ",1441313817
lucasomee006,lucasomee006,308,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(num[i]) for i in range(1, len(num), 2)]) == sum([int(num[i]) for i in range(0, len(num), 2)])",1441281675
lucasomee006,lucasomee006,308,3637,python3,"from collections import defaultdict
class Solution:
    def countBalancedPermutations(self, num: str) -> int:
        #basically we're dividing it into 2 equal sized groups (max diff of 1)
        #and those two groups have to have the same sum
        d = defaultdict(int)
        for char in num:
            d[int(char)] += 1
        x = [factorial(d[y]) for y in d]
        a = 1
        for i in range(len(x)):
            a *= x[i]
        if len(num) % 2 == 1:
            a *= 2
        #so for each number we can put it into one of the two groups
        #so total number of permutations assuming each char is distinct, but divided by num of each char
        #factorial
        mod = 10**9 + 7
        ans = 0
        finalAns = 0
        #dp(i, curSumDif, numOneGroup) returns
        s = sum([int(char) for char in num])
        @cache
        def dp(i, curSumDif, numOneGroup):
            
            if i == len(num) and curSumDif == 0 and abs(numOneGroup) <= 1:
                return 1
            if i == len(num):
                return 0
            if abs(curSumDif) > s//2+2:
                return 0
            if abs(numOneGroup) > len(num)//2+2:
                return 0
            return dp(i+1, curSumDif+int(num[i]), numOneGroup + 1) + dp(i+1, curSumDif-int(num[i]), numOneGroup-1)
        x = dp(0, 0, 0)
        dp.cache_clear()
        perm = factorial(len(num)//2)*factorial(len(num)-len(num)//2)
        return perm * x // a % mod
        
        ",1441385645
bramar2,bramar2,310,3627,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<ll>> dp(n, vector<ll>(m));
        dp[0][0] = 0;
        for(int i = 1; i < n; i++) {
            dp[i][0] = max((ll)moveTime[i][0] + 1, dp[i - 1][0] + 1);
        }
        for(int i = 1; i < m; i++) {
            dp[0][i] = max((ll)moveTime[0][i] + 1, dp[0][i - 1] + 1);
        }

        for(int i = 1; i < n; i++) {
            for(int j = 1; j < m; j++) {
                dp[i][j] = max({
                    (ll)moveTime[i][j] + 1,
                    min(dp[i - 1][j] + 1, dp[i][j - 1] + 1)
                });
            }
        }
        auto cmax = [&](int i, int j, ll val) {
            if(i == 0 && j == 0) return false;
            ll prev = dp[i][j];
            dp[i][j] = min((ll)moveTime[i][j] + 1, val);
            return (dp[i][j] != prev);
        };
        bool change = true;
        while(change) {
            change = false;
            for(int i = 0; i < n; i++) {
                for(int j = 0; j < m; j++) {
                    if(i == 0 && j == 0) continue;
                    ll prev = dp[i][j];
                    ll mn = 1e16;
                    if(i > 0) {
                        mn = min(mn, dp[i-1][j] + 1);
                    }
                    if(j > 0) {
                        mn = min(mn, dp[i][j-1] + 1);
                    }
                    if(i+1 < n) {
                        mn = min(mn, dp[i+1][j] + 1);
                    }
                    if(j+1 < m) {
                        mn = min(mn, dp[i][j+1] + 1);
                    }
                    dp[i][j] = max((ll)moveTime[i][j] + 1, mn);
                    if(prev != dp[i][j]) change = true;
                }
            }
        }
        return dp.back().back();
    }
};

int main1() {
    fastio;
    return 0;
}",1441302783
bramar2,bramar2,310,3636,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

class Solution {
public:
    bool isBalanced(string num) {
        int sum1 = 0, sum2 = 0;
        for(int i = 0; i < num.size(); i++) {
            if(i % 2 == 0) {
                sum1 += num[i]-'0';
            }else {
                sum2 += num[i]-'0';
            }
        }
        return sum1 == sum2;
    }
};

int main1() {
    fastio;
    return 0;
}",1441290674
bramar2,bramar2,310,3637,cpp,"//#pragma GCC optimize(""O3,unroll-loops"")
//#pragma GCC target(""avx2,bmi,bmi2,lzcnt,popcnt"")
#include <bits/stdc++.h>
using namespace std;
// #include <ext/pb_ds/assoc_container.hpp>
// #include <ext/pb_ds/tree_policy.hpp>
// using namespace __gnu_pbds;
// template<typename T>
// using ordered_map = tree<T, T, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
// template<typename T>
// using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

#define all(x) x.begin(), x.end()
#define rall(x) x.rbegin(), x.rend()
#define ll long long
#define fastio ios::sync_with_stdio(false); cin.tie(nullptr);

#define dbg_stream cout
void __print(int x) {dbg_stream << x;}
void __print(long x) {dbg_stream << x;}
void __print(long long x) {dbg_stream << x;}
void __print(unsigned x) {dbg_stream << x;}
void __print(unsigned long x) {dbg_stream << x;}
void __print(unsigned long long x) {dbg_stream << x;}
void __print(float x) {dbg_stream << x;}
void __print(double x) {dbg_stream << x;}
void __print(long double x) {dbg_stream << x;}
void __print(char x) {dbg_stream << '\'' << x << '\'';}
void __print(const char *x) {dbg_stream << '\""' << x << '\""';}
void __print(const string &x) {dbg_stream << '\""' << x << '\""';}
void __print(bool x) {dbg_stream << (x ? ""true"" : ""false"");}

template<typename T, typename V>
void __print(const pair<T, V> &x) {dbg_stream << '{'; __print(x.first); dbg_stream << ','; __print(x.second); dbg_stream << '}';}
template<typename T>
void __print(const T &x) {int f = 0; dbg_stream << '{'; for (auto &i: x) dbg_stream << (f++ ? "","" : """"), __print(i); dbg_stream << ""}"";}
void _print() {dbg_stream << ""]\n"";}
template <typename T, typename... V>
void _print(T t, V... v) {__print(t); if (sizeof...(v)) dbg_stream << "", ""; _print(v...);}
#ifndef ONLINE_JUDGE
#define dbg(x...) dbg_stream << ""["" << #x << ""] = [""; _print(x)
#else
#define dbg(x...)
#endif

template <typename T>
void print(T t) { int f = 0; for(const auto& b : t) cout << (f++ ? "" "" : """") << b; cout << '\n'; }
template <typename T>
void print2d(T t) { for(const auto& b : t) { print(b); } }

inline long long mod_exp(long long base, long long exp, long long modd) { unsigned long long ans = 1; base %= modd; while(exp > 0) { if(exp%2==1) ans = (base*ans)%modd; exp /= 2; base = (base*base)%modd; } return ans; }
inline long long factorial(long long n) { long long ans = 1; for(long long i = 2; i <= n; i++) ans *= n; return ans; }
inline long long memo_factorial(long long n) { static vector<int> memo {1,1,2}; if(static_cast<size_t>(n) >= memo.size()) { memo.resize(n+1); for(long long i = memo.size(); i <= n; i++) memo[i] = i*memo[i-1]; } return memo[n]; }
inline long long nCk(int N, int K) { if(K > N) return 0; if(K > N-K) K = N-K; long long ans = 1; for(long long i = 1; i <= K; i++) ans = (ans * (N - (K-i))) / i; return ans; }

const ll MOD = 1e9 + 7;
const ll MOD99 = 998244353;
const ll BIGMOD = pow(2,31)-1;

vector<ll> memoFactorial {1,1,2};
long long modfactorial(long long n) {
    if(n < (ll)memoFactorial.size()) return memoFactorial[n];
    for(ll i = memoFactorial.size(); i <= n; i++) {
        memoFactorial.push_back((i * memoFactorial[i - 1]) % MOD);
    }
    return memoFactorial[n];
}

bool init() {
    fastio;
    modfactorial(210);
    return true;
}
bool y = init();

ll dp[10][81][801];
class Solution {
public:
    int countBalancedPermutations(const string& numStr) {
        int n = numStr.size();
        int freq[10] {};
        ll targetSum = 0;
        for(char c : numStr) {
            freq[c-'0']++;
            targetSum += (c-'0');
        }
        if(targetSum % 2 == 1) return 0;
        targetSum /= 2;
        
        ll targetLen = n/2;
        ll ways = (memoFactorial[targetLen] * memoFactorial[n-targetLen]) % MOD;

        vector<vector<vector<ll>>> dp(10, vector<vector<ll>>(n+1, vector<ll>(targetSum+1, -1)));
        function<ll(ll,ll,ll)> go = [&](ll i, ll len1, ll sum1) {
            if(i >= 10) {
                if(len1 == targetLen && sum1 == targetSum) {
                    // dbg(len1, sum1);
                    return ways;
                }
                return 0LL;
            }
            if(sum1 > targetSum) {
                return 0LL;
            }
            if(dp[i][len1][sum1] >= 0) return dp[i][len1][sum1];
            ll ans = 0;
            for(ll take = 0; take <= freq[i]; take++) {
                ll w = (go(i + 1, len1 + take, sum1 + take*i) * mod_exp(memoFactorial[take], MOD-2, MOD)) % MOD;
                w = (w * mod_exp(memoFactorial[freq[i]-take], MOD-2, MOD)) % MOD;
                ans = (ans + w) % MOD;
            }
            return dp[i][len1][sum1] = ans;
        };
        return go(0, 0, 0);
    }
};

int main1() {
    fastio;
    return 0;
}",1441380016
Kumar sai,E22CSEU0567,311,3627,python3,"class Solution:
    def minTimeToReach(self, alpha: List[List[int]]) -> int:
        n, m = len(alpha), len(alpha[0])
        beta = [[float('inf')] * m for _ in range(n)]
        beta[0][0] = 0
        import heapq
        gamma = [(0, 0, 0)]
        delta = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while gamma:
            theta, iota, kappa = heapq.heappop(gamma)
            if theta > beta[iota][kappa]:
                continue
            for dx, dy in delta:
                lambda_, mu = iota + dx, kappa + dy
                if 0 <= lambda_ < n and 0 <= mu < m:
                    nu = max(0, alpha[lambda_][mu] - theta)
                    xi = theta + nu + 1
                    if xi < beta[lambda_][mu]:
                        beta[lambda_][mu] = xi
                        heapq.heappush(gamma, (xi, lambda_, mu))
        
        return beta[n-1][m-1]
",1441290681
Kumar sai,E22CSEU0567,311,3628,python3,"class Solution:
    def minTimeToReach(self, sai: List[List[int]]) -> int:
        n, m = len(sai), len(sai[0])
        preksha = [[[float('inf'), 0] for _ in range(m)] for _ in range(n)]
        preksha[0][0] = [0, 0]
        gamma = [row[:] for row in sai]
        import heapq
        delta = [(0, 0, 0, 0)]
        epsilon = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while delta:
            zeta, eta, theta, iota = heapq.heappop(delta)
            if zeta > preksha[theta][iota][0]:
                continue
            for dx, dy in epsilon:
                kappa, lambda_ = theta + dx, iota + dy
                if 0 <= kappa < n and 0 <= lambda_ < m:
                    xi = 1 if eta % 2 == 0 else 2
                    nu = max(0, gamma[kappa][lambda_] - zeta)
                    omicron = zeta + nu + xi
                    rho = eta + 1
                    if omicron < preksha[kappa][lambda_][0]:
                        preksha[kappa][lambda_] = [omicron, rho]
                        heapq.heappush(delta, (omicron, rho, kappa, lambda_))
        
        return preksha[n-1][m-1][0]
",1441293005
Kumar sai,E22CSEU0567,311,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sai = sum(int(num[i]) for i in range(0, len(num), 2))
        preksha = sum(int(num[i]) for i in range(1, len(num), 2))
        
        return sai == preksha
",1441286642
beaaan,beaaan,312,3627,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 3>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + 1;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441291244
beaaan,beaaan,312,3628,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  int minTimeToReach(vector<vector<int>>& moveTime) {
    int n = (int)moveTime.size();
    int m = (int)moveTime[0].size();
    const int dx[] = {1, 0, -1, 0};
    const int dy[] = {0, 1, 0, -1};
    using ar = array<ll, 4>;
    priority_queue<ar, vector<ar>, greater<>> pq;
    pq.push({0, 0, 0, 1});
    vector<vector<ll>> d(n, vector<ll>(m, 1e18));
    d[0][0] = 0;
    while (!pq.empty()) {
      auto [c, x, y, cost_to_move] = pq.top();
      pq.pop();
      if (d[x][y] != c) {
        continue;
      }
      for (int k = 0; k < 4; k++) {
        int nx = x + dx[k];
        int ny = y + dy[k];
        if (nx < 0 || nx >= n) continue;
        if (ny < 0 || ny >= m) continue;
        ll cost = max(d[x][y], 1ll * moveTime[nx][ny]) + cost_to_move;
        if (d[nx][ny] > cost) {
          d[nx][ny] = cost;
          pq.push({d[nx][ny], nx, ny, cost_to_move == 1 ? 2 : 1});
        }
      }
    }
    return d[n - 1][m - 1];
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441293138
beaaan,beaaan,312,3636,cpp,"#include ""bits/stdc++.h""
using namespace std;

using ll = long long;

class Solution {
public:
  bool isBalanced(string num) {
    int n = (int)num.size();
    int sum = 0;
    for (int i = 0; i < n; i++) {
      if (i & 1) {
        sum -= num[i] - '0';
      } else {
        sum += num[i] - '0';
      }
    }
    return sum == 0;
  }
};

#ifdef LOCAL
#include ""debug.h""

void solve() {
  
}

int main() {
  cin.tie(0)->sync_with_stdio(0);

  int tt = 1;
  // cin >> tt;
  
  while (tt--) {
    solve();
  }

  return 0;
}
#else
#define debug(...) 42
#endif",1441281844
Manyu,ManyuD,313,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j

                if not (0 <= x < m and 0 <= y < n) or ((x, y) in vis and vis[(x, y)] <= max(t + 1, 1 + moveTime[x][y])):
                    continue

                vis[(x, y)] = max(t + 1, 1 + moveTime[x][y])
                heapq.heappush(h, (max(t + 1, 1 + moveTime[x][y]), x, y))
            

",1441289870
Manyu,ManyuD,313,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        h = [(0, 0, 0, True)]
        m, n = len(moveTime), len(moveTime[0])
        vis = {(0, 0): 0}

        while h:
            t, i, j, dur = heapq.heappop(h)
            
            if i == m - 1 and j == n - 1:
                return t

            for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
                x, y = di + i, dj + j
                
                if not (0 <= x < m and 0 <= y < n):
                    continue
                    
                next_time = max(t + (1 if dur else 2), (1 if dur else 2) + moveTime[x][y])

                if ((x, y) in vis and vis[(x, y)] <= next_time):
                    continue

                vis[(x, y)] = next_time
                heapq.heappush(h, (next_time, x, y, not dur))
                
            

",1441293154
Manyu,ManyuD,313,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:

        l = r = 0
        bit = False
        
        for i in num:
            if bit:
                l += int(i)
            else:
                r += int(i)
            bit = not bit

        return l == r
            ",1441281031
mmb L,mammothb,314,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0)]
        while h:
            time, i, j = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j))
",1441292192
mmb L,mammothb,314,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        nr = len(moveTime)
        nc = len(moveTime[0])
        costs = [[float(""inf"")] * nc for _ in range(nr)]
        costs[0][0] = 0
        h = [(costs[0][0], 0, 0, 0)]
        while h:
            time, i, j, move = heapq.heappop(h)
            if time > costs[i][j]:
                continue
            if i == nr - 1 and j == nc - 1:
                return time
            for next_i, next_j in ((i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)):
                if not (0 <= next_i < nr and 0 <= next_j < nc):
                    continue
                next_time = max(time, moveTime[next_i][next_j]) + 1 + move
                if next_time < costs[next_i][next_j]:
                    costs[next_i][next_j] = next_time
                    heapq.heappush(h, (costs[next_i][next_j], next_i, next_j, (move + 1) % 2))
",1441294258
mmb L,mammothb,314,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        n = len(num)
        even = 0
        odd = 0
        for i in range(n):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281209
David Yee,yeedaKing,315,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+1
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l))

        return 0",1441293091
David Yee,yeedaKing,315,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        heap = [(0, 0, 0, 1)]
        m = len(moveTime)
        n = len(moveTime[0])
        minTimes = {(0,0):0}
        dir = [(0,1),(1,0),(-1,0),(0,-1)]
        while heap:
            time, i, j, flag = heappop(heap)
            if (i, j) == (m-1, n-1):
                return time

            for dx, dy in dir:
                k, l = i+dx, j+dy
                if not 0 <= k < m or not 0 <= l < n:
                    continue
                    
                penalty = 0 if moveTime[k][l] <= time else moveTime[k][l]-time
                nextTime = time+penalty+flag
                if minTimes.get((k, l), float(""inf"")) > nextTime:
                    minTimes[(k, l)] = nextTime
                    heappush(heap, (nextTime, k, l, 2 if flag == 1 else 1))

        return 0",1441294688
David Yee,yeedaKing,315,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        sum1 = sum2 = 0
        for i in range(len(num)):
            if i%2:
                sum1 += int(num[i])

            else:
                sum2 += int(num[i])

        return sum1 == sum2",1441280847
killer-whale,killer-whale,316,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start)]
        dist = defaultdict(lambda: inf, {start: 0})
        while h:
            cost, node = heappop(h)
            if dist[node] != cost:
                continue
            if node == target:
                return cost
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx] + 1
                    nw = max(w, cost + 1)
                    if dist[ny, nx] > nw:
                        dist[ny, nx] = nw
                        heappush(h, (nw, (ny, nx)))",1441290248
killer-whale,killer-whale,316,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n = len(moveTime)
        m = len(moveTime[0])
        start = (0,0)
        target = (n-1,m-1)
        h = [(0, start, 1)]
        dist = defaultdict(lambda: inf, {(start, 1): 0})
        while h:
            cost, node, cnt = heappop(h)
            if dist[node, cnt] != cost:
                continue
            if node == target:
                return cost
            cnt += 1
            cnt %= 2
            for dy, dx in (0,1), (0, -1), (1, 0), (-1, 0):
                ny, nx = node[0] + dy, node[1] + dx
                if 0 <= ny < n and 0 <= nx < m:
                    w = moveTime[ny][nx]
                    nw = max(w, cost) + cnt + 1
                    #print(cnt, nw)
                    if dist[(ny, nx), cnt] > nw:
                        dist[(ny, nx), cnt] = nw
                        heappush(h, (nw, (ny, nx), cnt))",1441294773
killer-whale,killer-whale,316,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o=e=0
        for i, x in enumerate(num):
            if i % 2:
                o += int(x)
            else:
                e += int(x)
        return o==e",1441290328
SirTechnical,SirTechnical,317,3627,cpp,"struct State {
    int i;
    int j;
    int t;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist(N, vector<int>(M, 0x3f3f3f3f));
        dist[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0});
        while (!pq.empty()) {
            auto [i,j,t] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+1;
                if (tt < dist[ti][tj]) {
                    dist[ti][tj] = tt;
                    pq.push({ti,tj,tt});
                }
            }
        }
        return dist[N-1][M-1];
    }
};",1441291831
SirTechnical,SirTechnical,317,3628,cpp,"struct State {
    int i;
    int j;
    int t;
    int d;
    bool operator<(const State& o) const {
        return t > o.t;
    }
};

const int INF = 0x3f3f3f3f;
const int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

int N;
int M;
inline bool inr(int i, int j) {
    return 0 <= i && i < N && 0 <= j && j < M;
}

inline int alt(int d) {
    if (d == 1) return 2;
    return 1;
}

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        N = moveTime.size();
        M = moveTime[0].size();
        vector<vector<int>> dist1(N, vector<int>(M, 0x3f3f3f3f));
        vector<vector<int>> dist2(N, vector<int>(M, 0x3f3f3f3f));
        dist1[0][0] = 0;
        priority_queue<State> pq;
        pq.push({0,0,0,1});
        while (!pq.empty()) {
            auto [i,j,t,d] = pq.top(); pq.pop();
            for (const auto& [di, dj] : dirs) {
                int ti = i+di;
                int tj = j+dj;
                if (!inr(ti,tj)) continue;
                int tt = max(t,moveTime[ti][tj])+d;
                if (d == 1) {
                    if (tt < dist2[ti][tj]) {
                        dist2[ti][tj] = tt;
                        pq.push({ti,tj,tt,2});
                    }
                } else {
                    if (tt < dist1[ti][tj]) {
                        dist1[ti][tj] = tt;
                        pq.push({ti,tj,tt,1});
                    }
                }
                
            }
        }
        return min(dist1[N-1][M-1], dist2[N-1][M-1]);
    }
};",1441294968
SirTechnical,SirTechnical,317,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sa = 0;
        int sb = 0;
        for (int i = 0; i < num.size(); ++i) {
            if (i%2 == 0) sa += num[i]-'0';
            else sb += num[i]-'0';
        }
        return sa == sb;
    }
};",1441280907
Sanjay Grover,SanjayGrover,318,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0)]
        visited = [[float('inf')] * m for _ in range(n)]
        visited[0][0] = 0
        
        while pq:
            time, x, y = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + 1 + waitTime
                    
                    if newTime < visited[nx][ny]:
                        visited[nx][ny] = newTime
                        heapq.heappush(pq, (newTime, nx, ny))
        
        return -1",1441289381
Sanjay Grover,SanjayGrover,318,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:

        n, m = len(moveTime), len(moveTime[0])
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        pq = [(0, 0, 0, 1)]
        visited = [[[float('inf')] * 2 for _ in range(m)] for _ in range(n)]
        visited[0][0][1] = 0
        
        while pq:
            time, x, y, nextMoveTime = heapq.heappop(pq)
            
            if (x, y) == (n - 1, m - 1):
                return time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                
                if 0 <= nx < n and 0 <= ny < m:
                    waitTime = max(moveTime[nx][ny] - time, 0)
                    newTime = time + nextMoveTime + waitTime
                    
                    alter = 2 if nextMoveTime == 1 else 1
                    
                    if newTime < visited[nx][ny][alter - 1]:
                        visited[nx][ny][alter - 1] = newTime
                        heapq.heappush(pq, (newTime, nx, ny, alter))
        
        return -1",1441295001
Sanjay Grover,SanjayGrover,318,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int even = 0;
        int odd = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i % 2 == 0) even += num.charAt(i) - '0';
            else odd += num.charAt(i) - '0';
        }
        return odd == even;
    }
}",1441283075
Andwerp,Andwerp,319,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        vector<vector<int>> d(n, vector<int>(m, 2e9));
        d[0][0] = 0;
        priority_queue<pair<int, pair<int, int>>> q;
        q.push({0, {0, 0}});
        vector<vector<bool>> v(n, vector<bool>(m, false));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.first;
            int c = q.top().second.second;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c] || d[r][c] != cur_t) {
                continue;
            }
            v[r][c] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int next_t = max(mt[nr][nc] + 1, cur_t + 1);
                if(next_t < d[nr][nc] && !v[nr][nc]) {
                    d[nr][nc] = next_t;
                    q.push({-next_t, {nr, nc}});
                }
            }
        }
        return d[n - 1][m - 1];
    }
};",1441291525
Andwerp,Andwerp,319,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();
        //i, j, move parity
        vector<vector<vector<int>>> d(n, vector<vector<int>>(m, vector<int>(2, 2e9)));
        d[0][0][0] = 0;
        priority_queue<pair<int, pair<int, pair<int, int>>>> q;
        q.push({0, {0, {0, 0}}});
        vector<vector<vector<bool>>> v(n, vector<vector<bool>>(m, vector<bool>(2, false)));
        vector<int> dr = {-1, 1, 0, 0};
        vector<int> dc = {0, 0, -1, 1};
        while(q.size() != 0){
            int r = q.top().second.second.first;
            int c = q.top().second.second.second;
            int p = q.top().second.first;
            int cur_t = -q.top().first;
            q.pop();
            if(v[r][c][p] || d[r][c][p] != cur_t) {
                continue;
            }
            v[r][c][p] = true;
            for(int i = 0; i < 4; i++){
                int nr = r + dr[i];
                int nc = c + dc[i];
                int np = p == 1? 0 : 1;
                if(nr < 0 || nc < 0 || nr >= n || nc >= m){
                    continue;
                }
                int inc = p == 0? 1 : 2;
                int next_t = max(mt[nr][nc] + inc, cur_t + inc);
                if(next_t < d[nr][nc][np] && !v[nr][nc][np]) {
                    d[nr][nc][np] = next_t;
                    q.push({-next_t, {np, {nr, nc}}});
                }
            }
        }
        return min(d[n - 1][m - 1][0], d[n - 1][m - 1][1]);
    }
};",1441295219
Andwerp,Andwerp,319,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0; i < num.size(); i++){
            sum += (num[i] - '0') * (i % 2 == 0? 1 : -1);
        }
        return sum == 0;
    }
};",1441281071
Raymond Jones Jr.,TheRealRaymondJones,320,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    heapq.heappush(heap,(waitTime,nr,nc))
        return -1
            ",1441293065
Raymond Jones Jr.,TheRealRaymondJones,320,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        M = len(moveTime)
        N = len(moveTime[0])
        heap = []
        heapq.heappush(heap, (0,0,0, False))
        DIRECTIONS = [(0,1), (1,0), (-1,0), (0,-1)]
        seen = set()
        while heap:
            steps, r,c, has_extra_step = heapq.heappop(heap)
            if r == M-1 and c == N-1:
                return steps
            if (r,c) in seen:
                continue
            seen.add((r,c))

            for dr,dc in DIRECTIONS:
                nr = r + dr
                nc = c + dc
                if 0 <= nr < M and 0 <= nc < N:
                    waitTime = max(steps, moveTime[nr][nc]) + 1
                    if has_extra_step:
                        waitTime += 1
                    heapq.heappush(heap,(waitTime,nr,nc, not has_extra_step))
        return -1",1441295429
Raymond Jones Jr.,TheRealRaymondJones,320,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        evens = 0
        odds = 0
        for i, digit in enumerate(num):
            if i % 2 == 0:
                evens += int(digit)
            else:
                odds += int(digit)
        return evens == odds",1441281456
IvanHugh,ivanc-e,324,3627,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0)]
        
        while heap:  
            current_time, x, y = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + 1  
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny))  
        
        return -1",1441293828
IvanHugh,ivanc-e,324,3628,python3,"class Solution:  
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:  
        n, m = len(moveTime), len(moveTime[0])  
        
        arrival_time = [[inf] * m for _ in range(n)]  
        arrival_time[0][0] = 0
        
        heap = [(0, 0, 0, 0)]
        
        while heap:  
            current_time, x, y, cnt = heapq.heappop(heap)  
            
            if (x, y) == (n - 1, m - 1):  
                return current_time  
            
            if current_time > arrival_time[x][y]:  
                continue  
            
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  
                nx, ny = x + dx, y + dy  
                
                if 0 <= nx < n and 0 <= ny < m:  
                    start_time = max(current_time, moveTime[nx][ny])  
                    next_time = start_time + (1 if cnt % 2 == 0 else 2)
                    
                    if next_time < arrival_time[nx][ny]:  
                        arrival_time[nx][ny] = next_time  
                        heapq.heappush(heap, (next_time, nx, ny, cnt+1))  
        
        return -1",1441296218
IvanHugh,ivanc-e,324,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum(int(num[i]) for i in range(0, len(num), 2)) == sum(int(num[i]) for i in range(1, len(num), 2))
        ",1441281390
Wilsano,Wilsano,325,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;
        pq.push({0, 0, 0});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441294111
Wilsano,Wilsano,325,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int m = moveTime.size();
        int n = moveTime[0].size();
        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<tuple<int, int, int, int>>> pq;
        pq.push({0, 0, 0, 1});


        vector<pair<int, int>> directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while(!pq.empty()){
            auto [t, r, c, cost] = pq.top();
            pq.pop();
            
            for(const auto& [dr, dc] : directions){
                int nr = r + dr;
                int nc = c + dc;
                if(0 <= nr && nr < m && 0 <= nc && nc < n){
                    int next_t = max(t, moveTime[nr][nc]) + cost;
                    int next_cost = (cost == 1) ? 2 : 1;
                    if(next_t < dp[nr][nc]){
                        dp[nr][nc] = next_t;
                        pq.push({next_t, nr, nc, next_cost});
                    }
                }
            }
        }

        return dp[m - 1][n - 1];
    }
};",1441296324
Wilsano,Wilsano,325,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        int weight = 1;
        for(int i = 0; i < num.length(); ++i){
            sum += (num[i] - '0') * weight;
            weight *= -1;
        }
        return sum == 0;
    }
};",1441281006
Fuad Qarayev,fuad720,326,3627,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, pair<int,int>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m];
        bool vis[n][m];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j] = 2e9;
                vis[i][j] = 0;
            }
        }
        dist[0][0] = 0;
        pq.push({0,{0,0}});
        while(pq.size()) {
            auto [x,y] = pq.top().second;
            pq.pop();
            if(vis[x][y])continue;
            vis[x][y] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny] > max(moveTime[nx][ny]+1, dist[x][y]+1)) {
                        dist[nx][ny] = max(moveTime[nx][ny]+1, dist[x][y]+1);
                        pq.push({-dist[nx][ny], {nx, ny}});
                    }
                }
            }
        }
        return dist[n-1][m-1];
    }
};",1441293590
Fuad Qarayev,fuad720,326,3628,cpp,"class Solution {
public:
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<pair<int, array<int,3>>> pq;
        int n = moveTime.size(), m = moveTime[0].size();
        int dist[n][m][2];
        bool vis[n][m][2];
        for(int i = 0;i<n;i++) {
            for(int j = 0;j<m;j++) {
                dist[i][j][0] = dist[i][j][1] =  2e9;
                vis[i][j][0] = vis[i][j][1] = 0;
            }
        }
        dist[0][0][0] = 0;
        pq.push({0,{0,0,0}});
        while(pq.size()) {
            auto [x,y,w] = pq.top().second;
            pq.pop();
            if(vis[x][y][w])continue;
            vis[x][y][w] = 1;
            for(int d = 0;d<4;d++) {
                int nx = x + dx[d], ny = y + dy[d];
                if(nx >= 0 and nx<n and ny>=0 and ny<m) {
                    // cout << x << "" "" << y << "" "" << nx << "" "" << ny << endl;
                    if(dist[nx][ny][w^1] > max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w)) {
                        dist[nx][ny][w^1] = max(moveTime[nx][ny]+1+w, dist[x][y][w]+1+w);
                        pq.push({-dist[nx][ny][w^1], {nx, ny, w^1}});
                    }
                }
            }
        }
        return min(dist[n-1][m-1][0],dist[n-1][m-1][1]);
    }
};",1441296391
Fuad Qarayev,fuad720,326,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0;
        for(int i = 0;i<num.size();i+=2) {
            sum+=num[i]-'0';
        }
        for(int i = 1;i<num.size();i+=2) {
            sum-=num[i]-'0';
        }
        return (sum==0);
    }
};",1441282333
Roushan Kumar Singh,r-tron19,327,3627,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0)))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1, moveTime[x][y]+1)
                s.add((T, (x, y)))
        
        return -1",1441294937
Roushan Kumar Singh,r-tron19,327,3628,python3,"from sortedcontainers import SortedList
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        s = SortedList()
        s.add((0, (0, 0), 0))
        done = {}
        n, m = len(moveTime), len(moveTime[0])
        dx = [0, 1, 0, -1]
        dy = [1, 0, -1, 0]
        
        while s:
            t, cord, ext = s.pop(0)
            if cord == (n-1, m-1):
                return t
            done[cord] = True
            cx, cy = cord
            for i in range(4):
                x = cx + dx[i]
                y = cy + dy[i]
                if (x,y) in done:
                    continue
                if not (0 <= x < n  and 0 <= y < m):
                    continue
                done[(x, y)] = True
                T = max(t + 1 + ext, moveTime[x][y]+1+ext)
                s.add((T, (x, y), ext ^ 1))
        
        return -1",1441296682
Roushan Kumar Singh,r-tron19,327,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        o, e = 0, 0
        for i,el in enumerate(num):
            if i%2:
                o += int(el)
            else:
                e += int(el)
        return o == e",1441281649
cro_poder,cro_poder,328,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX));
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        
        while (!pq.empty()) {
            auto [curr, i, j] = pq.top();
            pq.pop();
            if (i == n - 1 && j == m - 1) return curr;  
            
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = max(curr + 1, 1+moveTime[ni][nj]);
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj);
                    }
                }
            }
        }
        return -1;
    }
};
",1441292077
cro_poder,cro_poder,328,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size(), m = moveTime[0].size();
        vector<vector<int>> minTime(n, vector<int>(m, INT_MAX)); 
        minTime[0][0] = 0;
         
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0, 1); 
        vector<pair<int, int>> dx = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!pq.empty()) {
            auto [curr, i, j, moveCost] = pq.top();
            pq.pop();
            
            if (i == n - 1 && j == m - 1) return curr;  
            for (auto [di, dj] : dx) {
                int ni = i + di, nj = j + dj;
                if (ni >= 0 && ni < n && nj >= 0 && nj < m) { 
                    int nextTime = moveCost+max(curr, moveTime[ni][nj]);
                    int nextMoveCost = (moveCost == 1) ? 2 : 1;  
                    if (nextTime < minTime[ni][nj]) {
                        minTime[ni][nj] = nextTime;
                        pq.emplace(nextTime, ni, nj, nextMoveCost);
                    }
                }
            }
        }
        
        return -1;   
    }
};
",1441296768
cro_poder,cro_poder,328,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int s1 = 0, s2 = 0;
        
        for (int i = 0; i < num.size(); ++i) {
            if (i % 2 == 0) {
                s1 += num[i] - '0';  
            } else {
                s2 += num[i] - '0';   
            }
        }
        
        return s1 == s2;
    }
};
",1441281358
Leonyhenn,leonyhenn,329,3627,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+1 if moveTime[dx][dy] > time else time+1
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy))
        return
                
                    
            
        
        ",1441294685
Leonyhenn,leonyhenn,329,3628,python3,"from heapq import heappop,heappush,heapify
class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        m,n = len(moveTime),len(moveTime[0])
        heap = [(0,0,0,1),(0,0,0,2)]
        cache = [[float('inf') for j in range(n)] for i in range(m)]
        while heap:
            (time,x,y,step) = heappop(heap)
            if [x,y] == [m-1,n-1]:
                return time
            for [dx,dy] in [[x-1,y],[x+1,y],[x,y-1],[x,y+1],]:
                if 0 <= dx < m and 0 <= dy < n:
                    newTime = moveTime[dx][dy]+step if moveTime[dx][dy] > time else time+step
                    if newTime < cache[dx][dy]:
                        cache[dx][dy] = newTime
                        heappush(heap,(newTime,dx,dy,2 if step == 1 else 1))
        return
                
                    
            
        
        ",1441296987
Leonyhenn,leonyhenn,329,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        odd = 0
        even = 0
        for i in range(len(num)):
            if i % 2 == 0:
                even += int(num[i])
            else:
                odd += int(num[i])
        return even == odd",1441281088
Jeel27,Jeel27,330,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0)]
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        while heap:
            current_time, x, y = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time
            
            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    next_time = arrival_time + 1
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny))
        
        return -1",1441289971
Jeel27,Jeel27,330,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        heap = [(0, 0, 0, 0)]  # (time, x, y, step)
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        while heap:
            current_time, x, y, step = heappop(heap)
            if (x, y) == (n - 1, m - 1):
                return current_time

            for dx, dy in directions:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < m:
                    arrival_time = max(current_time, moveTime[nx][ny])
                    move_cost = 1 if step % 2 == 0 else 2
                    next_time = arrival_time + move_cost
                    if next_time < min_time[nx][ny]:
                        min_time[nx][ny] = next_time
                        heappush(heap, (next_time, nx, ny, step + 1))

        return -1",1441291277
Jeel27,Jeel27,330,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        even_sum = 0
        odd_sum = 0
        
        for i, digit in enumerate(num):
            if i % 2 == 0:
                even_sum += int(digit)
            else:
                odd_sum += int(digit)
        
        return even_sum == odd_sum",1441281450
Burger Monstah,WRWRW,331,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0)]
        v = {}
        while h:
            t, r, c = heapq.heappop(h)
            # print(t, r, c)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + 1, rr, cc))",1441291563
Burger Monstah,WRWRW,331,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        R, C = len(moveTime), len(moveTime[-1])
        h = [(0, 0, 0, 1)]
        v = {}
        while h:
            
            # print(h)
            t, r, c, cost = heapq.heappop(h)
            # print(t, r, c, cost)
            if (r, c) in v:
                continue
            v[r, c] = t
            if r == R - 1 and c == C - 1:
                return v[r, c]
            for dr, dc in [[0, -1], [0, 1], [1, 0], [-1, 0]]:
                rr, cc = dr + r, c + dc
                if 0 <= rr < R and 0 <= cc < C and (rr, cc) not in v:
                    heapq.heappush(h, (max(v[r, c], moveTime[rr][cc]) + cost, rr, cc, 1 if cost == 2 else 2))",1441297068
Burger Monstah,WRWRW,331,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        a = 0
        
        for i, c in enumerate(num):
            if i % 2 == 0:
                a += int(c)
            else:
                a -= int(c)
        return a == 0
                
        ",1441281726
Denis Rozhkov,rozhkov,333,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows = len(moveTime)
        cols = len(moveTime[0])
        H = [(0, 0, 0)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = set([(0, 0)])
        while H:
            tm, r, c = heapq.heappop(H)
            if r == rows - 1 and c == cols - 1:
                return tm
            for dr, dc in dirs:
                new_r, new_c = r + dr, c + dc
                if 0 <= new_r < rows and 0 <= new_c < cols and (new_r, new_c) not in visited:
                    visited.add((new_r, new_c))
                    heapq.heappush(H, (max(tm, moveTime[new_r][new_c]) + 1, new_r, new_c))
        ",1441295774
Denis Rozhkov,rozhkov,333,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        rows = len(moveTime)
        cols = len(moveTime[0])
        H = [(0, 0, 0, 0)]
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = set([(0, 0)])
        while H:
            tm, r, c, inc = heapq.heappop(H)
            if r == rows - 1 and c == cols - 1:
                return tm
            for dr, dc in dirs:
                new_r, new_c = r + dr, c + dc
                if 0 <= new_r < rows and 0 <= new_c < cols and (new_r, new_c) not in visited:
                    visited.add((new_r, new_c))
                    heapq.heappush(H, (max(tm, moveTime[new_r][new_c]) + 1 + inc, new_r, new_c, 1 - inc))
        ",1441297595
Denis Rozhkov,rozhkov,333,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        return sum([int(x) for i, x in enumerate(num) if i % 2]) == sum([int(x) for i, x in enumerate(num) if not i % 2])
        ",1441283906
Hriday03,Hriday03,334,3627,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        pq = [(0, 0, 0)]
        min_time = [[float('inf')] * m for _ in range(n)]
        min_time[0][0] = 0
        
        while pq:
            curr_time, row, col = heapq.heappop(pq)
            
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(curr_time, moveTime[new_row][new_col])
                    arrival_time = wait_time + 1
                    
                    if arrival_time < min_time[new_row][new_col]:
                        min_time[new_row][new_col] = arrival_time
                        heapq.heappush(pq, (arrival_time, new_row, new_col))
        
        return -1",1441291046
Hriday03,Hriday03,334,3628,python3,"class Solution:
    def minTimeToReach(self, moveTime: List[List[int]]) -> int:
        n, m = len(moveTime), len(moveTime[0])
        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
        
        pq = [(0, 0, 0, 1)]
        min_time = {}
        
        while pq:
            curr_time, row, col, next_move_time = heapq.heappop(pq)
            if row == n - 1 and col == m - 1:
                return curr_time
            
            for dr, dc in directions:
                new_row, new_col = row + dr, col + dc
                
                if 0 <= new_row < n and 0 <= new_col < m:
                    wait_time = max(curr_time, moveTime[new_row][new_col])
                    move_duration = 1 if next_move_time == 1 else 2
                    arrival_time = wait_time + move_duration
                    new_move_time = 2 if next_move_time == 1 else 1
                    
                    state = (new_row, new_col, new_move_time)
                    
                    if state not in min_time or arrival_time < min_time[state]:
                        min_time[state] = arrival_time
                        heapq.heappush(pq, (arrival_time, new_row, new_col, new_move_time))
        
        return -1",1441297620
Hriday03,Hriday03,334,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        esum, osum = 0, 0
        
        for i in range(len(num)):
            if i % 2 == 0:
                esum += int(num[i])
            else:
                osum += int(num[i])
                
        return esum == osum",1441282861
Avichal Dubey,dubeyavichal999,335,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        int n=moveTime.size(), m=moveTime[0].size();
        vector<vector<int>> vis(n,vector<int>(m,INT_MAX));
        vis[0][0]=0;
        pq.push({0,0,0});
        int dr[4]={-1,1,0,0};
        int dc[4]={0,0,-1,1};
        while(!pq.empty()){
            int time=pq.top()[0];
            int i=pq.top()[1];
            int j=pq.top()[2];
            pq.pop();
            for(int k=0;k<4;k++){
                int nr=i+dr[k],nc=j+dc[k];
                if(nr>=0 && nr<n && nc>=0 && nc<m){
                    int timeto=max(time,moveTime[nr][nc])+1;
                    if(vis[nr][nc]==INT_MAX || timeto<vis[nr][nc]){
                        pq.push({timeto,nr,nc});
                        vis[nr][nc]=timeto;
                    }
                }
            }
        }
        return vis[n-1][m-1];
    }
};",1441295317
Avichal Dubey,dubeyavichal999,335,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
        int n=moveTime.size(), m=moveTime[0].size();
        vector<vector<int>> vis(n,vector<int>(m,INT_MAX));
        vis[0][0]=0;
        pq.push({0,0,0,1});
        int dr[4]={-1,1,0,0};
        int dc[4]={0,0,-1,1};
        while(!pq.empty()){
            int time=pq.top()[0];
            int i=pq.top()[1];
            int j=pq.top()[2];
            int add=pq.top()[3];
            pq.pop();
            for(int k=0;k<4;k++){
                int nr=i+dr[k],nc=j+dc[k];
                if(nr>=0 && nr<n && nc>=0 && nc<m){
                    int timeto=max(time,moveTime[nr][nc])+add;
                    int nadd=add==1?2:1;
                    if(vis[nr][nc]==INT_MAX || timeto<vis[nr][nc]){
                        pq.push({timeto,nr,nc,nadd});
                        vis[nr][nc]=timeto;
                    }
                }
            }
        }
        return vis[n-1][m-1];
    }
};",1441297859
Avichal Dubey,dubeyavichal999,335,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        bool flag=true;
        int curr=0;
        for(char c:num){
            if(flag) curr+=(c-'0');
            else curr-=(c-'0');
            flag=!flag;
        }
        return curr==0;
    }
};",1441283238
Marmaduke,Marmaduke,336,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        int m = A.size();
        int n = A[0].size();
        const int big = 2e9;
        vector<vector<int>> B(m, vector<int>(n,big));
        typedef array<int,3> a3;
        priority_queue<a3, vector<a3>, std::greater<a3>> pq;
        B[0][0] = 0;
        pq.push({0,0,0});
        vector<pair<int,int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        while(!pq.empty())
        {
            auto v = pq.top();
            pq.pop();
            int t = v[0];
            int i = v[1];
            int j = v[2];
            for(auto &u : dir)
            {
                int a = u.first + i;
                int b = u.second + j;
                if(0 <= a && a < m && 0 <= b && b < n)
                {
                    int e = A[a][b] <= t ? t+1 : A[a][b] + 1;
                    if(e < B[a][b])
                    {
                        B[a][b] = e;
                        pq.push({e,a,b});
                    }
                }
            }
        }
        
        return B[m-1][n-1];
    }
};",1441295894
Marmaduke,Marmaduke,336,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& A) {
        int m = A.size();
        int n = A[0].size();
        const int big = 2e9;
        vector<vector<int>> B(m, vector<int>(n,big));
        typedef array<int,3> a3;
        priority_queue<a3, vector<a3>, std::greater<a3>> pq;
        B[0][0] = 0;
        pq.push({0,0,0});
        vector<pair<int,int>> dir = {{0,1}, {0,-1}, {1,0}, {-1,0}};
        while(!pq.empty())
        {
            auto v = pq.top();
            pq.pop();
            int t = v[0];
            int i = v[1];
            int j = v[2];
            int f = (i+j) % 2 == 0 ? 1 : 2;
            for(auto &u : dir)
            {
                int a = u.first + i;
                int b = u.second + j;
                if(0 <= a && a < m && 0 <= b && b < n)
                {
                    int e = A[a][b] <= t ? t+f : A[a][b] + f;
                    if(e < B[a][b])
                    {
                        B[a][b] = e;
                        pq.push({e,a,b});
                    }
                }
            }
        }
        
        return B[m-1][n-1];
    }
};",1441297936
Marmaduke,Marmaduke,336,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int n = num.length();
        vector<int> c(2,0);
        for(int i = 0; i < n; i++)
        {
            int x = num[i] - '0';
            c[i%2]+=x;
        }
        return c[0] == c[1];
    }
};",1441281297
w0w0,w0w0,337,3627,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        m, n = len(mt), len(mt[0])

        pq = [[0, (0, 0)]]
        time = [[inf] * n for _ in range(m)]
        time[0][0] = 0
        while pq:
            t, (i, j) = heappop(pq)
            if i == m - 1 and j == n - 1:
                return t
            for ii, jj in (
                (i - 1, j),
                (i + 1, j),
                (i, j - 1),
                (i, j + 1)
            ):
                if 0 <= ii < m and 0 <= jj < n:
                    new_t = max(t + 1, mt[ii][jj] + 1)
                    if new_t < time[ii][jj]:
                        time[ii][jj] = new_t
                        heappush(pq, (new_t, (ii, jj)))",1441291761
w0w0,w0w0,337,3628,python3,"class Solution:
    def minTimeToReach(self, mt: List[List[int]]) -> int:
        m, n = len(mt), len(mt[0])

        pq = [[0, 1, (0, 0)]]
        time1 = [[inf] * n for _ in range(m)]
        time2 = [[inf] * n for _ in range(m)]
        time1[0][0] = 0
        while pq:
            t, d, (i, j) = heappop(pq)
            new_d = 3 - d
            if i == m - 1 and j == n - 1:
                return t
            for ii, jj in (
                (i - 1, j),
                (i + 1, j),
                (i, j - 1),
                (i, j + 1)
            ):
                if 0 <= ii < m and 0 <= jj < n:
                    new_t = max(t + d, mt[ii][jj] + d)
                    if new_d == 1:
                        if new_t < time1[ii][jj]:
                            time1[ii][jj] = new_t
                            heappush(pq, (new_t, new_d, (ii, jj)))
                    else:
                        if new_t < time2[ii][jj]:
                            time2[ii][jj] = new_t
                            heappush(pq, (new_t, new_d, (ii, jj)))",1441297986
w0w0,w0w0,337,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        num = str(num)
        n = len(num)
        e = 0
        o = 0
        for i in range(0, n, 2):
            e += int(num[i])
        for i in range(1, n, 2):
            o += int(num[i])

        return e == o",1441281245
Akash Singh ,8081808345akash_singh,338,3627,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
       int n = mt.size();
        int m = mt[0].size();   
        vector<vector<int>> mnt(n, vector<int>(m, INT_MAX));
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0);
        mnt[0][0] = 0;
        
        vector<pair<int, int>> ds = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; 
        while (!pq.empty()) {
            auto [ct, x, y] = pq.top();
            pq.pop();
            
            if (x == n - 1 && y == m - 1) {
                return ct;
            } 
            for (auto [dx, dy] : ds) {
                int nx = x + dx, ny = y + dy;   
                if (nx >= 0 && ny >= 0 && nx < n && ny < m) {
                    int wt = max(mt[nx][ny] - ct, 0);
                    int nt = ct + 1 + wt;
                    
                    if (nt < mnt[nx][ny]) {
                        mnt[nx][ny] = nt;
                        pq.emplace(nt, nx, ny);
                    }
                }
            }
        }
        return -1;  
    }
};",1441292427
Akash Singh ,8081808345akash_singh,338,3628,cpp,"class Solution {
public:
    int minTimeToReach(vector<vector<int>>& mt) {
        int n = mt.size();
        int m = mt[0].size();   
        vector<vector<int>> vz = mt;
        vector<vector<int>> mnt(n, vector<int>(m, INT_MAX)); 
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> pq;
        pq.emplace(0, 0, 0, 1);
        mnt[0][0] = 0;  
        vector<pair<int, int>> ds = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
        while (!pq.empty()) {
            auto [ct, x, y, st] = pq.top();
            pq.pop();
            if (x == n - 1 && y == m - 1) {
                return ct;
            }
            for (auto [dx, dy] : ds) {
                int nx = x + dx, ny = y + dy;
                if (nx >= 0 && ny >= 0 && nx < n && ny < m) {
                    int wt = max(vz[nx][ny] - ct, 0);
                    int nt = ct + st + wt;
                    int nst = (st == 1) ? 2 : 1;
                    
                    if (nt < mnt[nx][ny]) {
                        mnt[nx][ny] = nt;
                        pq.emplace(nt, nx, ny, nst);
                    }
                }
            }
        }
        
        return -1;
    }
};",1441298024
Akash Singh ,8081808345akash_singh,338,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int es = 0, os = 0;
        
        for (int i = 0; i < num.length(); i++) {
            int d = num[i] - '0';
            if (i % 2 == 0) {
                es += d;
            } else {
                os += d;
            }
        }
        
        return es == os;
    }
};",1441284986
Narathip Hongthawee,opalXDnaja123,340,3627,cpp,"#define F first
#define S second

typedef pair<int, int> pii;
typedef pair<int, pii> pipii;

int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int dist[n][m];
        bool visited[n][m];
        priority_queue<pipii, vector<pipii>, greater<pipii>> pq;
        fill_n(dist[0], n * m, 2e9);
        fill_n(visited[0], n * m, false);
        dist[0][0] = 0;
        pq.emplace(dist[0][0], make_pair(0, 0));
        while (!pq.empty()) {
            int nowd = pq.top().F;
            int x = pq.top().S.F;
            int y = pq.top().S.S;
            pq.pop();
            if (visited[x][y]) {
                continue;
            }
            if (x == n - 1 && y == m - 1) {
                return nowd;
            }
            visited[x][y] = true;
            for (int i = 0; i < 4; i++) {
                int tox = x + dx[i];
                int toy = y + dy[i];
                if (tox < 0 || toy < 0 || tox > n - 1 || toy > m - 1) {
                    continue;
                }
                int tod = max(nowd, moveTime[tox][toy]) + 1;
                if (dist[tox][toy] > tod && !visited[tox][toy]) {
                    dist[tox][toy] = tod;
                    pq.emplace(dist[tox][toy], make_pair(tox, toy));
                }
            }
            
        }
        return -1;
    }
};",1441294261
Narathip Hongthawee,opalXDnaja123,340,3628,cpp,"#define F first
#define S second

typedef pair<int, int> pii;
typedef pair<int, pii> pipii;
typedef pair<bool, pipii> pbpipii;

int dx[4] = {0, 0, -1, 1}, dy[4] = {-1, 1, 0, 0};

class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = moveTime.size();
        int m = moveTime[0].size();
        
        int dist[2][n][m];
        bool visited[2][n][m];
        priority_queue<pbpipii, vector<pbpipii>, greater<pbpipii>> pq;
        fill_n(dist[0][0], 2 * n * m, 2e9);
        fill_n(visited[0][0], 2 * n * m, false);
        dist[0][0][0] = 0;
        pq.emplace(false, make_pair(dist[0][0][0], make_pair(0, 0)));
        while (!pq.empty()) {
            bool cur = pq.top().F;
            int nowd = pq.top().S.F;
            int x = pq.top().S.S.F;
            int y = pq.top().S.S.S;
            pq.pop();
            if (visited[cur][x][y]) {
                continue;
            }
            if (x == n - 1 && y == m - 1) {
                return nowd;
            }
            visited[cur][x][y] = true;
            for (int i = 0; i < 4; i++) {
                int tox = x + dx[i];
                int toy = y + dy[i];
                if (tox < 0 || toy < 0 || tox > n - 1 || toy > m - 1) {
                    continue;
                }
                int tod = max(nowd, moveTime[tox][toy]) + ((cur) + 1);
                if (dist[cur][tox][toy] > tod && !visited[cur][tox][toy]) {
                    dist[cur][tox][toy] = tod;
                    pq.emplace(cur ^ 1, make_pair(dist[cur][tox][toy], make_pair(tox, toy)));
                }
            }
            
        }
        return -1;
    }
};",1441298112
Narathip Hongthawee,opalXDnaja123,340,3636,cpp,"class Solution {
public:
    bool isBalanced(string num) {
        int sum = 0, sum2 = 0;
        bool flg = 0;
        for (auto e : num) {
            if (flg) {
                sum += (e - '0');
                flg = 0;
                continue;
            }
            sum2 += (e - '0');
            flg = 1;
        }
        return (sum == sum2);
    }
};",1441281258
zeningc,zeningc,344,3627,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dir = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        
        pq.offer(new int[] {0, 0, 0});
        Set<String> set = new HashSet<>();
        while (!pq.isEmpty())   {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            int t = cur[2];
            String key = x + ""_"" + y;
            if (set.contains(key))
                continue;
            set.add(key);
            if (x == m - 1 && y == n - 1)
                return t;
            
            for (int[] d : dir) {
                int nx = x + d[0];
                int ny = y + d[1];
                String nKey = nx + ""_"" + ny;
                if (nx < 0 || nx >= m || ny < 0 || ny >= n || set.contains(nKey))
                    continue;
                pq.offer(new int[] {nx, ny, Math.max(t + 1, moveTime[nx][ny] + 1)});
            }
        }
        
        return -1;
    }
}",1441290938
zeningc,zeningc,344,3628,java,"class Solution {
    public int minTimeToReach(int[][] moveTime) {
        int m = moveTime.length;
        int n = moveTime[0].length;
        int[][] dir = new int[][] {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        
        pq.offer(new int[] {0, 0, 0, 1});
        Set<String> set = new HashSet<>();
        while (!pq.isEmpty())   {
            int[] cur = pq.poll();
            int x = cur[0];
            int y = cur[1];
            int t = cur[2];
            int curTurn = cur[3];
            String key = x + ""_"" + y + ""_"" + curTurn;
            if (set.contains(key))
                continue;
            set.add(key);
            
            
            if (x == m - 1 && y == n - 1)
                return t;
            for (int[] d : dir) {
                int nx = x + d[0];
                int ny = y + d[1];
                int nxtTurn = curTurn == 1 ? 2 : 1;
                String nKey = nx + ""_"" + ny + ""_"" + nxtTurn;
                if (nx < 0 || nx >= m || ny < 0 || ny >= n || set.contains(nKey))
                    continue;
                pq.offer(new int[] {nx, ny, Math.max(t + curTurn, moveTime[nx][ny] + curTurn), nxtTurn});
            }
        }
        
        return -1;
    }
}",1441298372
zeningc,zeningc,344,3636,java,"class Solution {
    public boolean isBalanced(String num) {
        int a = 0;
        int b = 0;
        for (int i = 0; i < num.length(); i++) {
            if (i % 2 == 0)
                a += num.charAt(i) - '0';
            else
                b += num.charAt(i) - '0';
        }
        return a == b;
    }
}",1441281004
gan14008,gan14008,345,3627,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        m, n = len(g), len(g[0])
        visited = [[float('inf')] * n for _ in range(m)]
        q = [(0, 0, 0)]
        visited[0][0] = 0
        
        while q:
            t, i, j = heapq.heappop(q)
            if i == m - 1 and j == n - 1:
                break
            
            for x, y in (i, j + 1), (i + 1, j), (i, j - 1), (i - 1, j):
                if 0 <= x < m and 0 <= y < n:
                    arrived = max(t, g[x][y])
                    if arrived + 1 < visited[x][y]:
                        visited[x][y] = arrived + 1
                        heapq.heappush(q, (visited[x][y], x, y))

        return visited[m - 1][n - 1]
",1441296476
gan14008,gan14008,345,3628,python3,"class Solution:
    def minTimeToReach(self, g: List[List[int]]) -> int:
        m, n = len(g), len(g[0])
        visited = [[float('inf')] * n for _ in range(m)]
        q = [(0, 0, 0, 0)]
        visited[0][0] = 0
        
        while q:
            t, s, i, j = heapq.heappop(q)
            if i == m - 1 and j == n - 1:
                break
            
            for x, y in (i, j + 1), (i + 1, j), (i, j - 1), (i - 1, j):
                if 0 <= x < m and 0 <= y < n:
                    arrived = max(t, g[x][y]) + (s & 1) + 1
                    if arrived < visited[x][y]:
                        visited[x][y] = arrived
                        heapq.heappush(q, (visited[x][y], s ^ 1, x, y))

        return visited[m - 1][n - 1]
",1441298401
gan14008,gan14008,345,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        q = [0, 0]
        
        for i, x in enumerate(num):
            q[i & 1] += int(x)
        
        return q[0] == q[1]",1441280915
domick,dominic89231,348,3627,python3,"class Solution:
    def minTimeToReach(self, M: List[List[int]]) -> int:
        m,n = len(M), len(M[0])
        Q = []
        heappush(Q, (0, 0, 0))
        seen = set()
        D = [(0,1),(0,-1),(1,0),(-1,0)]
        while Q:
            t, i, j = heappop(Q)
            print(t, i, j)
            if i == (m-1) and j == (n-1):
                return t
            if (i, j) not in seen:
                seen.add((i, j))
                for d in D:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < m and 0 <= nj < n:
                        new_t = max(t, M[ni][nj]) + 1
                        heappush(Q, (new_t, ni, nj))
        return -1
            ",1441296433
domick,dominic89231,348,3628,python3,"class Solution:
    def minTimeToReach(self, M: List[List[int]]) -> int:
        m,n = len(M), len(M[0])
        Q = []
        heappush(Q, (0, 1, 0, 0))
        seen = set()
        D = [(0,1),(0,-1),(1,0),(-1,0)]
        while Q:
            t, s, i, j = heappop(Q)
            if i == (m-1) and j == (n-1):
                return t
            if (s, i, j) not in seen:
                seen.add((s, i, j))
                for d in D:
                    ni, nj = i + d[0], j + d[1]
                    if 0 <= ni < m and 0 <= nj < n:
                        new_t = max(t, M[ni][nj]) + s
                        new_s = 1 if s == 2 else 2
                        heappush(Q, (new_t, new_s, ni, nj))
        return -1",1441298709
domick,dominic89231,348,3636,python3,"class Solution:
    def isBalanced(self, num: str) -> bool:
        s1 = s2 = 0
        for i in range(len(num)):
            if i % 2 == 0:
                s1 += int(num[i])
            else:
                s2 += int(num[i])
        return s1 == s2",1441282368
Jose Coves,jcoves,350,3627,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = sz(g), m = sz(g[0]);
        auto dp = vv(n, m, oo);
        min_pq<array<int, 3>> pq;
        dp[0][0] = 0;
        pq.push({dp[0][0], 0, 0});
        while(!pq.empty()){
            auto [d, x, y] = pq.top(); pq.pop();
            // if(dp[i][j] < d) continue;
            if(dp[x][y] != d) continue;
            forn(k, 4){
                int nx = x + DX[k], ny = y + DY[k];
                if(nx < 0 or nx >= n or ny < 0 or ny >= m) continue;
                int nd = max(d, g[nx][ny]) + 1;
                if(nd >= dp[nx][ny]) continue;
                dp[nx][ny] = nd;
                pq.push({nd, nx, ny});
            }
        }
        return dp[n-1][m-1];
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vvi g; cin >> g;
    out(sol.minTimeToReach(g));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1441294903
Jose Coves,jcoves,350,3628,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& g) {
        int n = sz(g), m = sz(g[0]);
        auto dp = vv(2, n, m, oo);
        min_pq<array<int, 4>> pq;
        dp[0][0][0] = 0;
        pq.push({dp[0][0][0], 0, 0, 0});
        while(!pq.empty()){
            auto [d, c, x, y] = pq.top(); pq.pop();
            // if(dp[i][j] < d) continue;
            if(dp[c][x][y] != d) continue;
            forn(k, 4){
                int nx = x + DX[k], ny = y + DY[k];
                if(nx < 0 or nx >= n or ny < 0 or ny >= m) continue;
                int nd = max(d, g[nx][ny]) + 1 + c;
                int nc = 1 - c;
                if(nd >= dp[nc][nx][ny]) continue;
                dp[nc][nx][ny] = nd;
                pq.push({nd, nc, nx, ny});
            }
        }
        return min(dp[0][n-1][m-1], dp[1][n-1][m-1]);
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;
    vvi g; cin >> g;
    out(sol.minTimeToReach(g));
}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1441298971
Jose Coves,jcoves,350,3636,cpp,"
#ifdef LOCAL_RUN
#include ""debug_leet.h""
    #else
    #define trace(...) ;
    #define dbg(...) ;
    #define dbgc(...) ;
    #define debug(x) ;
    #define debuga(a, n) ;
    #define debug2(x, y) ;
    #define debug3(x, y, z) ;
    #define debug4(x, y, z, w) ;
    #define debug5(a,b,c,d,e) ;
    #define lassert(x) ;
    #define dassert(x, ...) ;
    int recur_depth = 0; bool rec_indent = true;
    const bool isLocal = false;
    template <typename Arg, typename... Args>
    void display(TreeNode* root) {}
    #endif

    #define pb push_back
    #define eb emplace_back
    #define popb pop_back
    #define all(v) begin(v), end(v)
    #define rall(v) (v).rbegin(),(v).rend()
    #define make_unique(v) (v).erase(unique(all(v)), (v).end())
    #define sz(c) ((int) c.size())
    #define forn(i,n) for(auto i=(n)-(n);i<(n);i++)
    #define fornn(i,s,n) for(auto i=(n)-(n)+(s);i<(n);i++)
    #define forb(i,n) for(auto i=(n)-1;i>=0;i--)
    #define forbn(i,s,n) for(auto i=(n)-1;i>=(s);i--)
    #define forit(it, c) for(auto it = (c).begin(); it != (c).end(); ++it)
    #define mem(a,b) memset(a,b,sizeof(a))
    #define abs(x) (((x) < 0) ? -(x) : (x))
    #define sqr(x) ((x) * (x))
    #define sqrt(x) sqrt(abs(x))
    #define has(c,x) (c.find(x) != c.end())
    #define pw(x) (1LL << (x))
    #define ibit(x,i) (((x) >> (i)) & 1)
    #define data(v) v.data(), sz(v) // vi -> vai
    #define gtime() ((double(clock()) - 0)/CLOCKS_PER_SEC)

    typedef stringstream sstr;
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<ll,ll> pll;
    typedef pair<ld,ld> pdd;
    typedef vector<int> vi;
    typedef vector<ll> vll;
    typedef vector<pii> vpii;
    typedef vector<vi> vvi;
    typedef vector<vll> vvll;
    typedef valarray<int> vai;
    template <class T>
    using min_pq = priority_queue<T, vector<T>, greater<T>>;
    template <class T>
    using vc = vector<T>;
    template <class T>
    using vvc = vector<vc<T>>;
    template <class T>
    using vvvc = vector<vvc<T>>;
    template <class T>
    using vvvvc = vector<vvvc<T>>;
    template <class T>
    using vvvvvc = vector<vvvvc<T>>;

    template<class F>
    struct y_comb{
        F f;
        template<class T> explicit y_comb(T &&f_in): f(forward<T>(f_in)){ }
        template<class ...Args> decltype(auto) operator()(Args &&...args){ return f(ref(*this), forward<Args>(args)...); }
    };
    template<class F>
    decltype(auto) yf(F &&f){
        return y_comb<decay_t<F>>(forward<F>(f));
    }

    inline int ni(){ int x; cin >> x;   return x; }
    inline ll  nl() { ll  x; cin >> x; return x; }

    template <class T> void mmin(T& a, const T& b) {
        a = (a) < (b) ? (a) : (b);
    }
    template <class T> void mmax(T& a, const T& b) {
        a = (a) > (b) ? (a) : (b);
    }
    template <class T> int LB(vc<T> &a, T x){
        return int(lower_bound(all(a), x) - a.begin());
    }
    template <class T> int UB(vc<T> &a, T x){
        return int(upper_bound(all(a), x) - a.begin());
    }
    template <class T> T MAX(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *max_element(a.begin()+l, a.begin()+r);
    }
    template <class T> T MIN(vc<T> &a, int l=0, int r=-1){
        if(r < 0) r = sz(a);
        return *min_element(a.begin()+l, a.begin()+r);
    }
    template <class T> auto vv(int d1, T x){
        return vc<T>(d1, x);
    }
    template <class T> auto vv(int d1, int d2, T x){
        return vc<vc<T>>(d1, vc<T>(d2, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, T x){
        return vc<vc<vc<T>>>(d1, vv(d2, d3, x));
    }
    template <class T> auto vv(int d1, int d2, int d3, int d4, T x){
        return vc<vc<vc<vc<T>>>>(d1, vv(d2, d3, d4, x));
    }
    void outv(auto &v){
        for(auto &x: v) {cout<< x <<"" "";} cout<<endl;
    }
    void rvec(int &n, auto &v){
        cin >> n; v.resize(n); for(auto &x: v) cin >> (x);
    }
    template <typename Arg, typename... Args>
    void read(Arg&& arg, Args&&... args){
        cin >> std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cin >> std::forward<Args>(args)),0)...};
    }
    template <typename Arg, typename... Args>
    void out(Arg&& arg, Args&&... args){
        cout << std::forward<Arg>(arg); using expander = int[];
        (void)expander{0, (void(cout << "" "" << std::forward<Args>(args)),0)...};
        cout << endl;
    }
    template <class Integer, class F>
    Integer find_first_false(Integer l, Integer r, F&& f) {
        --l; // ++r;
        while (r - l > 1) {
            Integer m = midpoint(l, r);
            if (f(m)) l = m;
            else r = m;
        }
        return r;
    }
    template <class Integer, class F>
    Integer find_last_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return f(i); }) - 1;
    }
    template <class Integer, class F>
    Integer find_first_true(Integer l, Integer r, F &&f) {
        return find_first_false(l, r, [&f](Integer i) { return !f(i); });
    }
    auto init = []() {
        ios::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL); return 'c';
    }();

    ll pwr(ll base, ll p, ll mod){
        ll ans=1; while(p) {if(p&1) ans=(ans*base)%mod;
            base=(base*base)%mod; p/=2;}
        return ans;
    }
    ll gcd(ll a, ll b) {  return b == 0 ? a : gcd(b,a%b); }
    ll lcm(ll a, ll b) {  return a*(b/gcd(a,b)); }

    const long double PI = (long double)(3.1415926535897932384626433832795);
    const ll  mx_ll   = numeric_limits<ll> :: max();
    const int mx_int  = numeric_limits<int> :: max();

    const int oo = 0x3f3f3f3f;
    const ll  OO = 0x3f3f3f3f3f3f3f3fll;
    const double eps = 1e-9;
    const int DX[8]={0,1, 0,-1,-1,1,-1, 1};
    const int DY[8]={1,0,-1, 0,-1,1, 1,-1};

const int maxn = 1e5 + 3;
const int mod = 1e9+7;
class Solution {
public:
    bool isBalanced(string s) {
        vi a(2);
        int n = sz(s);
        forn(i, n){
            int x = s[i] - '0';
            a[i%2] += x;
        }
        return a[0] == a[1];
    }
};

#ifdef LOCAL_RUN
void _solve(){
    Solution sol;

}


/*************************************************************************/
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    //cout.precision(15);
    // return 0;
    while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    while(cin.peek() != EOF){
        _solve();
        while(cin.peek() == 32 or cin.peek() == 10) cin.get();
    }
}
#endif
",1441282077
